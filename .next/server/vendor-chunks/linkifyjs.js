"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/linkifyjs";
exports.ids = ["vendor-chunks/linkifyjs"];
exports.modules = {

/***/ "(ssr)/./node_modules/linkifyjs/dist/linkify.mjs":
/*!*************************************************!*\
  !*** ./node_modules/linkifyjs/dist/linkify.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MultiToken: () => (/* binding */ MultiToken),\n/* harmony export */   Options: () => (/* binding */ Options),\n/* harmony export */   State: () => (/* binding */ State),\n/* harmony export */   createTokenClass: () => (/* binding */ createTokenClass),\n/* harmony export */   find: () => (/* binding */ find),\n/* harmony export */   init: () => (/* binding */ init),\n/* harmony export */   multi: () => (/* binding */ multi),\n/* harmony export */   options: () => (/* binding */ options),\n/* harmony export */   regexp: () => (/* binding */ regexp),\n/* harmony export */   registerCustomProtocol: () => (/* binding */ registerCustomProtocol),\n/* harmony export */   registerPlugin: () => (/* binding */ registerPlugin),\n/* harmony export */   registerTokenPlugin: () => (/* binding */ registerTokenPlugin),\n/* harmony export */   reset: () => (/* binding */ reset),\n/* harmony export */   stringToArray: () => (/* binding */ stringToArray),\n/* harmony export */   test: () => (/* binding */ test),\n/* harmony export */   text: () => (/* binding */ multi),\n/* harmony export */   tokenize: () => (/* binding */ tokenize)\n/* harmony export */ });\n// THIS FILE IS AUTOMATICALLY GENERATED DO NOT EDIT DIRECTLY\n// See update-tlds.js for encoding/decoding format\n// https://data.iana.org/TLD/tlds-alpha-by-domain.txt\nconst encodedTlds = \"aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4w0s2x0a2z0ure5ba0by2idu3namex4d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dad1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3nd0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0axi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp3ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5m\\xf6gensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2\";\n// Internationalized domain names containing non-ASCII\nconst encodedUtlds = \"ελ1υ2бг1ел3дети4ею2католик6ом3мкд2он1сква6онлайн5рг3рус2ф2сайт3рб3укр3қаз3հայ3ישראל5קום3ابوظبي5رامكو5لاردن4بحرين5جزائر5سعودية6عليان5مغرب5مارات5یران5بارت2زار4يتك3ھارت5تونس4سودان3رية5شبكة4عراق2ب2مان4فلسطين6قطر3كاثوليك6وم3مصر2ليسيا5وريتانيا7قع4همراه5پاکستان7ڀارت4कॉम3नेट3भारत0म्3ोत5संगठन5বাংলা5ভারত2ৰত4ਭਾਰਤ4ભારત4ଭାରତ4இந்தியா6லங்கை6சிங்கப்பூர்11భారత్5ಭಾರತ4ഭാരതം5ලංකා4คอม3ไทย3ລາວ3გე2みんな3アマゾン4クラウド4グーグル4コム2ストア3セール3ファッション6ポイント4世界2中信1国1國1文网3亚马逊3企业2佛山2信息2健康2八卦2公司1益2台湾1灣2商城1店1标2嘉里0大酒店5在线2大拿2天主教3娱乐2家電2广东2微博2慈善2我爱你3手机2招聘2政务1府2新加坡2闻2时尚2書籍2机构2淡马锡3游戏2澳門2点看2移动2组织机构4网址1店1站1络2联通2谷歌2购物2通販2集团2電訊盈科4飞利浦3食品2餐厅2香格里拉3港2닷넷1컴2삼성2한국2\";\n/**\n * Finite State Machine generation utilities\n */ /**\n * @template T\n * @typedef {{ [group: string]: T[] }} Collections\n */ /**\n * @typedef {{ [group: string]: true }} Flags\n */ // Keys in scanner Collections instances\nconst numeric = \"numeric\";\nconst ascii = \"ascii\";\nconst alpha = \"alpha\";\nconst asciinumeric = \"asciinumeric\";\nconst alphanumeric = \"alphanumeric\";\nconst domain = \"domain\";\nconst emoji = \"emoji\";\nconst scheme = \"scheme\";\nconst slashscheme = \"slashscheme\";\nconst whitespace = \"whitespace\";\n/**\n * @template T\n * @param {string} name\n * @param {Collections<T>} groups to register in\n * @returns {T[]} Current list of tokens in the given collection\n */ function registerGroup(name, groups) {\n    if (!(name in groups)) {\n        groups[name] = [];\n    }\n    return groups[name];\n}\n/**\n * @template T\n * @param {T} t token to add\n * @param {Collections<T>} groups\n * @param {Flags} flags\n */ function addToGroups(t, flags, groups) {\n    if (flags[numeric]) {\n        flags[asciinumeric] = true;\n        flags[alphanumeric] = true;\n    }\n    if (flags[ascii]) {\n        flags[asciinumeric] = true;\n        flags[alpha] = true;\n    }\n    if (flags[asciinumeric]) {\n        flags[alphanumeric] = true;\n    }\n    if (flags[alpha]) {\n        flags[alphanumeric] = true;\n    }\n    if (flags[alphanumeric]) {\n        flags[domain] = true;\n    }\n    if (flags[emoji]) {\n        flags[domain] = true;\n    }\n    for(const k in flags){\n        const group = registerGroup(k, groups);\n        if (group.indexOf(t) < 0) {\n            group.push(t);\n        }\n    }\n}\n/**\n * @template T\n * @param {T} t token to check\n * @param {Collections<T>} groups\n * @returns {Flags} group flags that contain this token\n */ function flagsForToken(t, groups) {\n    const result = {};\n    for(const c in groups){\n        if (groups[c].indexOf(t) >= 0) {\n            result[c] = true;\n        }\n    }\n    return result;\n}\n/**\n * @template T\n * @typedef {null | T } Transition\n */ /**\n * Define a basic state machine state. j is the list of character transitions,\n * jr is the list of regex-match transitions, jd is the default state to\n * transition to t is the accepting token type, if any. If this is the terminal\n * state, then it does not emit a token.\n *\n * The template type T represents the type of the token this state accepts. This\n * should be a string (such as of the token exports in `text.js`) or a\n * MultiToken subclass (from `multi.js`)\n *\n * @template T\n * @param {T} [token] Token that this state emits\n */ function State(token = null) {\n    // this.n = null; // DEBUG: State name\n    /** @type {{ [input: string]: State<T> }} j */ this.j = {}; // IMPLEMENTATION 1\n    // this.j = []; // IMPLEMENTATION 2\n    /** @type {[RegExp, State<T>][]} jr */ this.jr = [];\n    /** @type {?State<T>} jd */ this.jd = null;\n    /** @type {?T} t */ this.t = token;\n}\n/**\n * Scanner token groups\n * @type Collections<string>\n */ State.groups = {};\nState.prototype = {\n    accepts () {\n        return !!this.t;\n    },\n    /**\n   * Follow an existing transition from the given input to the next state.\n   * Does not mutate.\n   * @param {string} input character or token type to transition on\n   * @returns {?State<T>} the next state, if any\n   */ go (input) {\n        const state = this;\n        const nextState = state.j[input];\n        if (nextState) {\n            return nextState;\n        }\n        for(let i = 0; i < state.jr.length; i++){\n            const regex = state.jr[i][0];\n            const nextState = state.jr[i][1]; // note: might be empty to prevent default jump\n            if (nextState && regex.test(input)) {\n                return nextState;\n            }\n        }\n        // Nowhere left to jump! Return default, if any\n        return state.jd;\n    },\n    /**\n   * Whether the state has a transition for the given input. Set the second\n   * argument to true to only look for an exact match (and not a default or\n   * regular-expression-based transition)\n   * @param {string} input\n   * @param {boolean} exactOnly\n   */ has (input, exactOnly = false) {\n        return exactOnly ? input in this.j : !!this.go(input);\n    },\n    /**\n   * Short for \"transition all\"; create a transition from the array of items\n   * in the given list to the same final resulting state.\n   * @param {string | string[]} inputs Group of inputs to transition on\n   * @param {Transition<T> | State<T>} [next] Transition options\n   * @param {Flags} [flags] Collections flags to add token to\n   * @param {Collections<T>} [groups] Master list of token groups\n   */ ta (inputs, next, flags, groups) {\n        for(let i = 0; i < inputs.length; i++){\n            this.tt(inputs[i], next, flags, groups);\n        }\n    },\n    /**\n   * Short for \"take regexp transition\"; defines a transition for this state\n   * when it encounters a token which matches the given regular expression\n   * @param {RegExp} regexp Regular expression transition (populate first)\n   * @param {T | State<T>} [next] Transition options\n   * @param {Flags} [flags] Collections flags to add token to\n   * @param {Collections<T>} [groups] Master list of token groups\n   * @returns {State<T>} taken after the given input\n   */ tr (regexp, next, flags, groups) {\n        groups = groups || State.groups;\n        let nextState;\n        if (next && next.j) {\n            nextState = next;\n        } else {\n            // Token with maybe token groups\n            nextState = new State(next);\n            if (flags && groups) {\n                addToGroups(next, flags, groups);\n            }\n        }\n        this.jr.push([\n            regexp,\n            nextState\n        ]);\n        return nextState;\n    },\n    /**\n   * Short for \"take transitions\", will take as many sequential transitions as\n   * the length of the given input and returns the\n   * resulting final state.\n   * @param {string | string[]} input\n   * @param {T | State<T>} [next] Transition options\n   * @param {Flags} [flags] Collections flags to add token to\n   * @param {Collections<T>} [groups] Master list of token groups\n   * @returns {State<T>} taken after the given input\n   */ ts (input, next, flags, groups) {\n        let state = this;\n        const len = input.length;\n        if (!len) {\n            return state;\n        }\n        for(let i = 0; i < len - 1; i++){\n            state = state.tt(input[i]);\n        }\n        return state.tt(input[len - 1], next, flags, groups);\n    },\n    /**\n   * Short for \"take transition\", this is a method for building/working with\n   * state machines.\n   *\n   * If a state already exists for the given input, returns it.\n   *\n   * If a token is specified, that state will emit that token when reached by\n   * the linkify engine.\n   *\n   * If no state exists, it will be initialized with some default transitions\n   * that resemble existing default transitions.\n   *\n   * If a state is given for the second argument, that state will be\n   * transitioned to on the given input regardless of what that input\n   * previously did.\n   *\n   * Specify a token group flags to define groups that this token belongs to.\n   * The token will be added to corresponding entires in the given groups\n   * object.\n   *\n   * @param {string} input character, token type to transition on\n   * @param {T | State<T>} [next] Transition options\n   * @param {Flags} [flags] Collections flags to add token to\n   * @param {Collections<T>} [groups] Master list of groups\n   * @returns {State<T>} taken after the given input\n   */ tt (input, next, flags, groups) {\n        groups = groups || State.groups;\n        const state = this;\n        // Check if existing state given, just a basic transition\n        if (next && next.j) {\n            state.j[input] = next;\n            return next;\n        }\n        const t = next;\n        // Take the transition with the usual default mechanisms and use that as\n        // a template for creating the next state\n        let nextState, templateState = state.go(input);\n        if (templateState) {\n            nextState = new State();\n            Object.assign(nextState.j, templateState.j);\n            nextState.jr.push.apply(nextState.jr, templateState.jr);\n            nextState.jd = templateState.jd;\n            nextState.t = templateState.t;\n        } else {\n            nextState = new State();\n        }\n        if (t) {\n            // Ensure newly token is in the same groups as the old token\n            if (groups) {\n                if (nextState.t && typeof nextState.t === \"string\") {\n                    const allFlags = Object.assign(flagsForToken(nextState.t, groups), flags);\n                    addToGroups(t, allFlags, groups);\n                } else if (flags) {\n                    addToGroups(t, flags, groups);\n                }\n            }\n            nextState.t = t; // overwrite anything that was previously there\n        }\n        state.j[input] = nextState;\n        return nextState;\n    }\n};\n// Helper functions to improve minification (not exported outside linkifyjs module)\n/**\n * @template T\n * @param {State<T>} state\n * @param {string | string[]} input\n * @param {Flags} [flags]\n * @param {Collections<T>} [groups]\n */ const ta = (state, input, next, flags, groups)=>state.ta(input, next, flags, groups);\n/**\n * @template T\n * @param {State<T>} state\n * @param {RegExp} regexp\n * @param {T | State<T>} [next]\n * @param {Flags} [flags]\n * @param {Collections<T>} [groups]\n */ const tr = (state, regexp, next, flags, groups)=>state.tr(regexp, next, flags, groups);\n/**\n * @template T\n * @param {State<T>} state\n * @param {string | string[]} input\n * @param {T | State<T>} [next]\n * @param {Flags} [flags]\n * @param {Collections<T>} [groups]\n */ const ts = (state, input, next, flags, groups)=>state.ts(input, next, flags, groups);\n/**\n * @template T\n * @param {State<T>} state\n * @param {string} input\n * @param {T | State<T>} [next]\n * @param {Collections<T>} [groups]\n * @param {Flags} [flags]\n */ const tt = (state, input, next, flags, groups)=>state.tt(input, next, flags, groups);\n/******************************************************************************\nText Tokens\nIdentifiers for token outputs from the regexp scanner\n******************************************************************************/ // A valid web domain token\nconst WORD = \"WORD\"; // only contains a-z\nconst UWORD = \"UWORD\"; // contains letters other than a-z, used for IDN\nconst ASCIINUMERICAL = \"ASCIINUMERICAL\"; // contains a-z, 0-9\nconst ALPHANUMERICAL = \"ALPHANUMERICAL\"; // contains numbers and letters other than a-z, used for IDN\n// Special case of word\nconst LOCALHOST = \"LOCALHOST\";\n// Valid top-level domain, special case of WORD (see tlds.js)\nconst TLD = \"TLD\";\n// Valid IDN TLD, special case of UWORD (see tlds.js)\nconst UTLD = \"UTLD\";\n// The scheme portion of a web URI protocol. Supported types include: `mailto`,\n// `file`, and user-defined custom protocols. Limited to schemes that contain\n// only letters\nconst SCHEME = \"SCHEME\";\n// Similar to SCHEME, except makes distinction for schemes that must always be\n// followed by `://`, not just `:`. Supported types include `http`, `https`,\n// `ftp`, `ftps`\nconst SLASH_SCHEME = \"SLASH_SCHEME\";\n// Any sequence of digits 0-9\nconst NUM = \"NUM\";\n// Any number of consecutive whitespace characters that are not newline\nconst WS = \"WS\";\n// New line (unix style)\nconst NL = \"NL\"; // \\n\n// Opening/closing bracket classes\n// TODO: Rename OPEN -> LEFT and CLOSE -> RIGHT in v5 to fit with Unicode names\n// Also rename angle brackes to LESSTHAN and GREATER THAN\nconst OPENBRACE = \"OPENBRACE\"; // {\nconst CLOSEBRACE = \"CLOSEBRACE\"; // }\nconst OPENBRACKET = \"OPENBRACKET\"; // [\nconst CLOSEBRACKET = \"CLOSEBRACKET\"; // ]\nconst OPENPAREN = \"OPENPAREN\"; // (\nconst CLOSEPAREN = \"CLOSEPAREN\"; // )\nconst OPENANGLEBRACKET = \"OPENANGLEBRACKET\"; // <\nconst CLOSEANGLEBRACKET = \"CLOSEANGLEBRACKET\"; // >\nconst FULLWIDTHLEFTPAREN = \"FULLWIDTHLEFTPAREN\"; // （\nconst FULLWIDTHRIGHTPAREN = \"FULLWIDTHRIGHTPAREN\"; // ）\nconst LEFTCORNERBRACKET = \"LEFTCORNERBRACKET\"; // 「\nconst RIGHTCORNERBRACKET = \"RIGHTCORNERBRACKET\"; // 」\nconst LEFTWHITECORNERBRACKET = \"LEFTWHITECORNERBRACKET\"; // 『\nconst RIGHTWHITECORNERBRACKET = \"RIGHTWHITECORNERBRACKET\"; // 』\nconst FULLWIDTHLESSTHAN = \"FULLWIDTHLESSTHAN\"; // ＜\nconst FULLWIDTHGREATERTHAN = \"FULLWIDTHGREATERTHAN\"; // ＞\n// Various symbols\nconst AMPERSAND = \"AMPERSAND\"; // &\nconst APOSTROPHE = \"APOSTROPHE\"; // '\nconst ASTERISK = \"ASTERISK\"; // *\nconst AT = \"AT\"; // @\nconst BACKSLASH = \"BACKSLASH\"; // \\\nconst BACKTICK = \"BACKTICK\"; // `\nconst CARET = \"CARET\"; // ^\nconst COLON = \"COLON\"; // :\nconst COMMA = \"COMMA\"; // ,\nconst DOLLAR = \"DOLLAR\"; // $\nconst DOT = \"DOT\"; // .\nconst EQUALS = \"EQUALS\"; // =\nconst EXCLAMATION = \"EXCLAMATION\"; // !\nconst HYPHEN = \"HYPHEN\"; // -\nconst PERCENT = \"PERCENT\"; // %\nconst PIPE = \"PIPE\"; // |\nconst PLUS = \"PLUS\"; // +\nconst POUND = \"POUND\"; // #\nconst QUERY = \"QUERY\"; // ?\nconst QUOTE = \"QUOTE\"; // \"\nconst FULLWIDTHMIDDLEDOT = \"FULLWIDTHMIDDLEDOT\"; // ・\nconst SEMI = \"SEMI\"; // ;\nconst SLASH = \"SLASH\"; // /\nconst TILDE = \"TILDE\"; // ~\nconst UNDERSCORE = \"UNDERSCORE\"; // _\n// Emoji symbol\nconst EMOJI$1 = \"EMOJI\";\n// Default token - anything that is not one of the above\nconst SYM = \"SYM\";\nvar tk = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    ALPHANUMERICAL: ALPHANUMERICAL,\n    AMPERSAND: AMPERSAND,\n    APOSTROPHE: APOSTROPHE,\n    ASCIINUMERICAL: ASCIINUMERICAL,\n    ASTERISK: ASTERISK,\n    AT: AT,\n    BACKSLASH: BACKSLASH,\n    BACKTICK: BACKTICK,\n    CARET: CARET,\n    CLOSEANGLEBRACKET: CLOSEANGLEBRACKET,\n    CLOSEBRACE: CLOSEBRACE,\n    CLOSEBRACKET: CLOSEBRACKET,\n    CLOSEPAREN: CLOSEPAREN,\n    COLON: COLON,\n    COMMA: COMMA,\n    DOLLAR: DOLLAR,\n    DOT: DOT,\n    EMOJI: EMOJI$1,\n    EQUALS: EQUALS,\n    EXCLAMATION: EXCLAMATION,\n    FULLWIDTHGREATERTHAN: FULLWIDTHGREATERTHAN,\n    FULLWIDTHLEFTPAREN: FULLWIDTHLEFTPAREN,\n    FULLWIDTHLESSTHAN: FULLWIDTHLESSTHAN,\n    FULLWIDTHMIDDLEDOT: FULLWIDTHMIDDLEDOT,\n    FULLWIDTHRIGHTPAREN: FULLWIDTHRIGHTPAREN,\n    HYPHEN: HYPHEN,\n    LEFTCORNERBRACKET: LEFTCORNERBRACKET,\n    LEFTWHITECORNERBRACKET: LEFTWHITECORNERBRACKET,\n    LOCALHOST: LOCALHOST,\n    NL: NL,\n    NUM: NUM,\n    OPENANGLEBRACKET: OPENANGLEBRACKET,\n    OPENBRACE: OPENBRACE,\n    OPENBRACKET: OPENBRACKET,\n    OPENPAREN: OPENPAREN,\n    PERCENT: PERCENT,\n    PIPE: PIPE,\n    PLUS: PLUS,\n    POUND: POUND,\n    QUERY: QUERY,\n    QUOTE: QUOTE,\n    RIGHTCORNERBRACKET: RIGHTCORNERBRACKET,\n    RIGHTWHITECORNERBRACKET: RIGHTWHITECORNERBRACKET,\n    SCHEME: SCHEME,\n    SEMI: SEMI,\n    SLASH: SLASH,\n    SLASH_SCHEME: SLASH_SCHEME,\n    SYM: SYM,\n    TILDE: TILDE,\n    TLD: TLD,\n    UNDERSCORE: UNDERSCORE,\n    UTLD: UTLD,\n    UWORD: UWORD,\n    WORD: WORD,\n    WS: WS\n});\n// Note that these two Unicode ones expand into a really big one with Babel\nconst ASCII_LETTER = /[a-z]/;\nconst LETTER = /\\p{L}/u; // Any Unicode character with letter data type\nconst EMOJI = /\\p{Emoji}/u; // Any Unicode emoji character\nconst EMOJI_VARIATION$1 = /\\ufe0f/;\nconst DIGIT = /\\d/;\nconst SPACE = /\\s/;\nvar regexp = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    ASCII_LETTER: ASCII_LETTER,\n    DIGIT: DIGIT,\n    EMOJI: EMOJI,\n    EMOJI_VARIATION: EMOJI_VARIATION$1,\n    LETTER: LETTER,\n    SPACE: SPACE\n});\n/**\n\tThe scanner provides an interface that takes a string of text as input, and\n\toutputs an array of tokens instances that can be used for easy URL parsing.\n*/ const CR = \"\\r\"; // carriage-return character\nconst LF = \"\\n\"; // line-feed character\nconst EMOJI_VARIATION = \"️\"; // Variation selector, follows heart and others\nconst EMOJI_JOINER = \"‍\"; // zero-width joiner\nconst OBJECT_REPLACEMENT = \"￼\"; // whitespace placeholder that sometimes appears in rich text editors\nlet tlds = null, utlds = null; // don't change so only have to be computed once\n/**\n * Scanner output token:\n * - `t` is the token name (e.g., 'NUM', 'EMOJI', 'TLD')\n * - `v` is the value of the token (e.g., '123', '❤️', 'com')\n * - `s` is the start index of the token in the original string\n * - `e` is the end index of the token in the original string\n * @typedef {{t: string, v: string, s: number, e: number}} Token\n */ /**\n * @template T\n * @typedef {{ [collection: string]: T[] }} Collections\n */ /**\n * Initialize the scanner character-based state machine for the given start\n * state\n * @param {[string, boolean][]} customSchemes List of custom schemes, where each\n * item is a length-2 tuple with the first element set to the string scheme, and\n * the second element set to `true` if the `://` after the scheme is optional\n */ function init$2(customSchemes = []) {\n    // Frequently used states (name argument removed during minification)\n    /** @type Collections<string> */ const groups = {}; // of tokens\n    State.groups = groups;\n    /** @type State<string> */ const Start = new State();\n    if (tlds == null) {\n        tlds = decodeTlds(encodedTlds);\n    }\n    if (utlds == null) {\n        utlds = decodeTlds(encodedUtlds);\n    }\n    // States for special URL symbols that accept immediately after start\n    tt(Start, \"'\", APOSTROPHE);\n    tt(Start, \"{\", OPENBRACE);\n    tt(Start, \"}\", CLOSEBRACE);\n    tt(Start, \"[\", OPENBRACKET);\n    tt(Start, \"]\", CLOSEBRACKET);\n    tt(Start, \"(\", OPENPAREN);\n    tt(Start, \")\", CLOSEPAREN);\n    tt(Start, \"<\", OPENANGLEBRACKET);\n    tt(Start, \">\", CLOSEANGLEBRACKET);\n    tt(Start, \"（\", FULLWIDTHLEFTPAREN);\n    tt(Start, \"）\", FULLWIDTHRIGHTPAREN);\n    tt(Start, \"「\", LEFTCORNERBRACKET);\n    tt(Start, \"」\", RIGHTCORNERBRACKET);\n    tt(Start, \"『\", LEFTWHITECORNERBRACKET);\n    tt(Start, \"』\", RIGHTWHITECORNERBRACKET);\n    tt(Start, \"＜\", FULLWIDTHLESSTHAN);\n    tt(Start, \"＞\", FULLWIDTHGREATERTHAN);\n    tt(Start, \"&\", AMPERSAND);\n    tt(Start, \"*\", ASTERISK);\n    tt(Start, \"@\", AT);\n    tt(Start, \"`\", BACKTICK);\n    tt(Start, \"^\", CARET);\n    tt(Start, \":\", COLON);\n    tt(Start, \",\", COMMA);\n    tt(Start, \"$\", DOLLAR);\n    tt(Start, \".\", DOT);\n    tt(Start, \"=\", EQUALS);\n    tt(Start, \"!\", EXCLAMATION);\n    tt(Start, \"-\", HYPHEN);\n    tt(Start, \"%\", PERCENT);\n    tt(Start, \"|\", PIPE);\n    tt(Start, \"+\", PLUS);\n    tt(Start, \"#\", POUND);\n    tt(Start, \"?\", QUERY);\n    tt(Start, '\"', QUOTE);\n    tt(Start, \"/\", SLASH);\n    tt(Start, \";\", SEMI);\n    tt(Start, \"~\", TILDE);\n    tt(Start, \"_\", UNDERSCORE);\n    tt(Start, \"\\\\\", BACKSLASH);\n    tt(Start, \"・\", FULLWIDTHMIDDLEDOT);\n    const Num = tr(Start, DIGIT, NUM, {\n        [numeric]: true\n    });\n    tr(Num, DIGIT, Num);\n    const Asciinumeric = tr(Num, ASCII_LETTER, ASCIINUMERICAL, {\n        [asciinumeric]: true\n    });\n    const Alphanumeric = tr(Num, LETTER, ALPHANUMERICAL, {\n        [alphanumeric]: true\n    });\n    // State which emits a word token\n    const Word = tr(Start, ASCII_LETTER, WORD, {\n        [ascii]: true\n    });\n    tr(Word, DIGIT, Asciinumeric);\n    tr(Word, ASCII_LETTER, Word);\n    tr(Asciinumeric, DIGIT, Asciinumeric);\n    tr(Asciinumeric, ASCII_LETTER, Asciinumeric);\n    // Same as previous, but specific to non-fsm.ascii alphabet words\n    const UWord = tr(Start, LETTER, UWORD, {\n        [alpha]: true\n    });\n    tr(UWord, ASCII_LETTER); // Non-accepting\n    tr(UWord, DIGIT, Alphanumeric);\n    tr(UWord, LETTER, UWord);\n    tr(Alphanumeric, DIGIT, Alphanumeric);\n    tr(Alphanumeric, ASCII_LETTER); // Non-accepting\n    tr(Alphanumeric, LETTER, Alphanumeric); // Non-accepting\n    // Whitespace jumps\n    // Tokens of only non-newline whitespace are arbitrarily long\n    // If any whitespace except newline, more whitespace!\n    const Nl = tt(Start, LF, NL, {\n        [whitespace]: true\n    });\n    const Cr = tt(Start, CR, WS, {\n        [whitespace]: true\n    });\n    const Ws = tr(Start, SPACE, WS, {\n        [whitespace]: true\n    });\n    tt(Start, OBJECT_REPLACEMENT, Ws);\n    tt(Cr, LF, Nl); // \\r\\n\n    tt(Cr, OBJECT_REPLACEMENT, Ws);\n    tr(Cr, SPACE, Ws);\n    tt(Ws, CR); // non-accepting state to avoid mixing whitespaces\n    tt(Ws, LF); // non-accepting state to avoid mixing whitespaces\n    tr(Ws, SPACE, Ws);\n    tt(Ws, OBJECT_REPLACEMENT, Ws);\n    // Emoji tokens. They are not grouped by the scanner except in cases where a\n    // zero-width joiner is present\n    const Emoji = tr(Start, EMOJI, EMOJI$1, {\n        [emoji]: true\n    });\n    tt(Emoji, \"#\"); // no transition, emoji regex seems to match #\n    tr(Emoji, EMOJI, Emoji);\n    tt(Emoji, EMOJI_VARIATION, Emoji);\n    // tt(Start, EMOJI_VARIATION, Emoji); // This one is sketchy\n    const EmojiJoiner = tt(Emoji, EMOJI_JOINER);\n    tt(EmojiJoiner, \"#\");\n    tr(EmojiJoiner, EMOJI, Emoji);\n    // tt(EmojiJoiner, EMOJI_VARIATION, Emoji); // also sketchy\n    // Generates states for top-level domains\n    // Note that this is most accurate when tlds are in alphabetical order\n    const wordjr = [\n        [\n            ASCII_LETTER,\n            Word\n        ],\n        [\n            DIGIT,\n            Asciinumeric\n        ]\n    ];\n    const uwordjr = [\n        [\n            ASCII_LETTER,\n            null\n        ],\n        [\n            LETTER,\n            UWord\n        ],\n        [\n            DIGIT,\n            Alphanumeric\n        ]\n    ];\n    for(let i = 0; i < tlds.length; i++){\n        fastts(Start, tlds[i], TLD, WORD, wordjr);\n    }\n    for(let i = 0; i < utlds.length; i++){\n        fastts(Start, utlds[i], UTLD, UWORD, uwordjr);\n    }\n    addToGroups(TLD, {\n        tld: true,\n        ascii: true\n    }, groups);\n    addToGroups(UTLD, {\n        utld: true,\n        alpha: true\n    }, groups);\n    // Collect the states generated by different protocols. NOTE: If any new TLDs\n    // get added that are also protocols, set the token to be the same as the\n    // protocol to ensure parsing works as expected.\n    fastts(Start, \"file\", SCHEME, WORD, wordjr);\n    fastts(Start, \"mailto\", SCHEME, WORD, wordjr);\n    fastts(Start, \"http\", SLASH_SCHEME, WORD, wordjr);\n    fastts(Start, \"https\", SLASH_SCHEME, WORD, wordjr);\n    fastts(Start, \"ftp\", SLASH_SCHEME, WORD, wordjr);\n    fastts(Start, \"ftps\", SLASH_SCHEME, WORD, wordjr);\n    addToGroups(SCHEME, {\n        scheme: true,\n        ascii: true\n    }, groups);\n    addToGroups(SLASH_SCHEME, {\n        slashscheme: true,\n        ascii: true\n    }, groups);\n    // Register custom schemes. Assumes each scheme is asciinumeric with hyphens\n    customSchemes = customSchemes.sort((a, b)=>a[0] > b[0] ? 1 : -1);\n    for(let i = 0; i < customSchemes.length; i++){\n        const sch = customSchemes[i][0];\n        const optionalSlashSlash = customSchemes[i][1];\n        const flags = optionalSlashSlash ? {\n            [scheme]: true\n        } : {\n            [slashscheme]: true\n        };\n        if (sch.indexOf(\"-\") >= 0) {\n            flags[domain] = true;\n        } else if (!ASCII_LETTER.test(sch)) {\n            flags[numeric] = true; // numbers only\n        } else if (DIGIT.test(sch)) {\n            flags[asciinumeric] = true;\n        } else {\n            flags[ascii] = true;\n        }\n        ts(Start, sch, sch, flags);\n    }\n    // Localhost token\n    ts(Start, \"localhost\", LOCALHOST, {\n        ascii: true\n    });\n    // Set default transition for start state (some symbol)\n    Start.jd = new State(SYM);\n    return {\n        start: Start,\n        tokens: Object.assign({\n            groups\n        }, tk)\n    };\n}\n/**\n\tGiven a string, returns an array of TOKEN instances representing the\n\tcomposition of that string.\n\n\t@method run\n\t@param {State<string>} start scanner starting state\n\t@param {string} str input string to scan\n\t@return {Token[]} list of tokens, each with a type and value\n*/ function run$1(start, str) {\n    // State machine is not case sensitive, so input is tokenized in lowercased\n    // form (still returns regular case). Uses selective `toLowerCase` because\n    // lowercasing the entire string causes the length and character position to\n    // vary in some non-English strings with V8-based runtimes.\n    const iterable = stringToArray(str.replace(/[A-Z]/g, (c)=>c.toLowerCase()));\n    const charCount = iterable.length; // <= len if there are emojis, etc\n    const tokens = []; // return value\n    // cursor through the string itself, accounting for characters that have\n    // width with length 2 such as emojis\n    let cursor = 0;\n    // Cursor through the array-representation of the string\n    let charCursor = 0;\n    // Tokenize the string\n    while(charCursor < charCount){\n        let state = start;\n        let nextState = null;\n        let tokenLength = 0;\n        let latestAccepting = null;\n        let sinceAccepts = -1;\n        let charsSinceAccepts = -1;\n        while(charCursor < charCount && (nextState = state.go(iterable[charCursor]))){\n            state = nextState;\n            // Keep track of the latest accepting state\n            if (state.accepts()) {\n                sinceAccepts = 0;\n                charsSinceAccepts = 0;\n                latestAccepting = state;\n            } else if (sinceAccepts >= 0) {\n                sinceAccepts += iterable[charCursor].length;\n                charsSinceAccepts++;\n            }\n            tokenLength += iterable[charCursor].length;\n            cursor += iterable[charCursor].length;\n            charCursor++;\n        }\n        // Roll back to the latest accepting state\n        cursor -= sinceAccepts;\n        charCursor -= charsSinceAccepts;\n        tokenLength -= sinceAccepts;\n        // No more jumps, just make a new token from the last accepting one\n        tokens.push({\n            t: latestAccepting.t,\n            // token type/name\n            v: str.slice(cursor - tokenLength, cursor),\n            // string value\n            s: cursor - tokenLength,\n            // start index\n            e: cursor // end index (excluding)\n        });\n    }\n    return tokens;\n}\n/**\n * Convert a String to an Array of characters, taking into account that some\n * characters like emojis take up two string indexes.\n *\n * Adapted from core-js (MIT license)\n * https://github.com/zloirock/core-js/blob/2d69cf5f99ab3ea3463c395df81e5a15b68f49d9/packages/core-js/internals/string-multibyte.js\n *\n * @function stringToArray\n * @param {string} str\n * @returns {string[]}\n */ function stringToArray(str) {\n    const result = [];\n    const len = str.length;\n    let index = 0;\n    while(index < len){\n        let first = str.charCodeAt(index);\n        let second;\n        let char = first < 0xd800 || first > 0xdbff || index + 1 === len || (second = str.charCodeAt(index + 1)) < 0xdc00 || second > 0xdfff ? str[index] // single character\n         : str.slice(index, index + 2); // two-index characters\n        result.push(char);\n        index += char.length;\n    }\n    return result;\n}\n/**\n * Fast version of ts function for when transition defaults are well known\n * @param {State<string>} state\n * @param {string} input\n * @param {string} t\n * @param {string} defaultt\n * @param {[RegExp, State<string>][]} jr\n * @returns {State<string>}\n */ function fastts(state, input, t, defaultt, jr) {\n    let next;\n    const len = input.length;\n    for(let i = 0; i < len - 1; i++){\n        const char = input[i];\n        if (state.j[char]) {\n            next = state.j[char];\n        } else {\n            next = new State(defaultt);\n            next.jr = jr.slice();\n            state.j[char] = next;\n        }\n        state = next;\n    }\n    next = new State(t);\n    next.jr = jr.slice();\n    state.j[input[len - 1]] = next;\n    return next;\n}\n/**\n * Converts a string of Top-Level Domain names encoded in update-tlds.js back\n * into a list of strings.\n * @param {str} encoded encoded TLDs string\n * @returns {str[]} original TLDs list\n */ function decodeTlds(encoded) {\n    const words = [];\n    const stack = [];\n    let i = 0;\n    let digits = \"0123456789\";\n    while(i < encoded.length){\n        let popDigitCount = 0;\n        while(digits.indexOf(encoded[i + popDigitCount]) >= 0){\n            popDigitCount++; // encountered some digits, have to pop to go one level up trie\n        }\n        if (popDigitCount > 0) {\n            words.push(stack.join(\"\")); // whatever preceded the pop digits must be a word\n            for(let popCount = parseInt(encoded.substring(i, i + popDigitCount), 10); popCount > 0; popCount--){\n                stack.pop();\n            }\n            i += popDigitCount;\n        } else {\n            stack.push(encoded[i]); // drop down a level into the trie\n            i++;\n        }\n    }\n    return words;\n}\n/**\n * An object where each key is a valid DOM Event Name such as `click` or `focus`\n * and each value is an event handler function.\n *\n * https://developer.mozilla.org/en-US/docs/Web/API/Element#events\n * @typedef {?{ [event: string]: Function }} EventListeners\n */ /**\n * All formatted properties required to render a link, including `tagName`,\n * `attributes`, `content` and `eventListeners`.\n * @typedef {{ tagName: any, attributes: {[attr: string]: any}, content: string,\n * eventListeners: EventListeners }} IntermediateRepresentation\n */ /**\n * Specify either an object described by the template type `O` or a function.\n *\n * The function takes a string value (usually the link's href attribute), the\n * link type (`'url'`, `'hashtag`', etc.) and an internal token representation\n * of the link. It should return an object of the template type `O`\n * @template O\n * @typedef {O | ((value: string, type: string, token: MultiToken) => O)} OptObj\n */ /**\n * Specify either a function described by template type `F` or an object.\n *\n * Each key in the object should be a link type (`'url'`, `'hashtag`', etc.). Each\n * value should be a function with template type `F` that is called when the\n * corresponding link type is encountered.\n * @template F\n * @typedef {F | { [type: string]: F}} OptFn\n */ /**\n * Specify either a value with template type `V`, a function that returns `V` or\n * an object where each value resolves to `V`.\n *\n * The function takes a string value (usually the link's href attribute), the\n * link type (`'url'`, `'hashtag`', etc.) and an internal token representation\n * of the link. It should return an object of the template type `V`\n *\n * For the object, each key should be a link type (`'url'`, `'hashtag`', etc.).\n * Each value should either have type `V` or a function that returns V. This\n * function similarly takes a string value and a token.\n *\n * Example valid types for `Opt<string>`:\n *\n * ```js\n * 'hello'\n * (value, type, token) => 'world'\n * { url: 'hello', email: (value, token) => 'world'}\n * ```\n * @template V\n * @typedef {V | ((value: string, type: string, token: MultiToken) => V) | { [type: string]: V | ((value: string, token: MultiToken) => V) }} Opt\n */ /**\n * See available options: https://linkify.js.org/docs/options.html\n * @typedef {{\n * \tdefaultProtocol?: string,\n *  events?: OptObj<EventListeners>,\n * \tformat?: Opt<string>,\n * \tformatHref?: Opt<string>,\n * \tnl2br?: boolean,\n * \ttagName?: Opt<any>,\n * \ttarget?: Opt<string>,\n * \trel?: Opt<string>,\n * \tvalidate?: Opt<boolean>,\n * \ttruncate?: Opt<number>,\n * \tclassName?: Opt<string>,\n * \tattributes?: OptObj<({ [attr: string]: any })>,\n *  ignoreTags?: string[],\n * \trender?: OptFn<((ir: IntermediateRepresentation) => any)>\n * }} Opts\n */ /**\n * @type Required<Opts>\n */ const defaults = {\n    defaultProtocol: \"http\",\n    events: null,\n    format: noop,\n    formatHref: noop,\n    nl2br: false,\n    tagName: \"a\",\n    target: null,\n    rel: null,\n    validate: true,\n    truncate: Infinity,\n    className: null,\n    attributes: null,\n    ignoreTags: [],\n    render: null\n};\n/**\n * Utility class for linkify interfaces to apply specified\n * {@link Opts formatting and rendering options}.\n *\n * @param {Opts | Options} [opts] Option value overrides.\n * @param {(ir: IntermediateRepresentation) => any} [defaultRender] (For\n *   internal use) default render function that determines how to generate an\n *   HTML element based on a link token's derived tagName, attributes and HTML.\n *   Similar to render option\n */ function Options(opts, defaultRender = null) {\n    let o = Object.assign({}, defaults);\n    if (opts) {\n        o = Object.assign(o, opts instanceof Options ? opts.o : opts);\n    }\n    // Ensure all ignored tags are uppercase\n    const ignoredTags = o.ignoreTags;\n    const uppercaseIgnoredTags = [];\n    for(let i = 0; i < ignoredTags.length; i++){\n        uppercaseIgnoredTags.push(ignoredTags[i].toUpperCase());\n    }\n    /** @protected */ this.o = o;\n    if (defaultRender) {\n        this.defaultRender = defaultRender;\n    }\n    this.ignoreTags = uppercaseIgnoredTags;\n}\nOptions.prototype = {\n    o: defaults,\n    /**\n   * @type string[]\n   */ ignoreTags: [],\n    /**\n   * @param {IntermediateRepresentation} ir\n   * @returns {any}\n   */ defaultRender (ir) {\n        return ir;\n    },\n    /**\n   * Returns true or false based on whether a token should be displayed as a\n   * link based on the user options.\n   * @param {MultiToken} token\n   * @returns {boolean}\n   */ check (token) {\n        return this.get(\"validate\", token.toString(), token);\n    },\n    // Private methods\n    /**\n   * Resolve an option's value based on the value of the option and the given\n   * params. If operator and token are specified and the target option is\n   * callable, automatically calls the function with the given argument.\n   * @template {keyof Opts} K\n   * @param {K} key Name of option to use\n   * @param {string} [operator] will be passed to the target option if it's a\n   * function. If not specified, RAW function value gets returned\n   * @param {MultiToken} [token] The token from linkify.tokenize\n   * @returns {Opts[K] | any}\n   */ get (key, operator, token) {\n        const isCallable = operator != null;\n        let option = this.o[key];\n        if (!option) {\n            return option;\n        }\n        if (typeof option === \"object\") {\n            option = token.t in option ? option[token.t] : defaults[key];\n            if (typeof option === \"function\" && isCallable) {\n                option = option(operator, token);\n            }\n        } else if (typeof option === \"function\" && isCallable) {\n            option = option(operator, token.t, token);\n        }\n        return option;\n    },\n    /**\n   * @template {keyof Opts} L\n   * @param {L} key Name of options object to use\n   * @param {string} [operator]\n   * @param {MultiToken} [token]\n   * @returns {Opts[L] | any}\n   */ getObj (key, operator, token) {\n        let obj = this.o[key];\n        if (typeof obj === \"function\" && operator != null) {\n            obj = obj(operator, token.t, token);\n        }\n        return obj;\n    },\n    /**\n   * Convert the given token to a rendered element that may be added to the\n   * calling-interface's DOM\n   * @param {MultiToken} token Token to render to an HTML element\n   * @returns {any} Render result; e.g., HTML string, DOM element, React\n   *   Component, etc.\n   */ render (token) {\n        const ir = token.render(this); // intermediate representation\n        const renderFn = this.get(\"render\", null, token) || this.defaultRender;\n        return renderFn(ir, token.t, token);\n    }\n};\nfunction noop(val) {\n    return val;\n}\nvar options = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    Options: Options,\n    defaults: defaults\n});\n/******************************************************************************\n\tMulti-Tokens\n\tTokens composed of arrays of TextTokens\n******************************************************************************/ /**\n * @param {string} value\n * @param {Token[]} tokens\n */ function MultiToken(value, tokens) {\n    this.t = \"token\";\n    this.v = value;\n    this.tk = tokens;\n}\n/**\n * Abstract class used for manufacturing tokens of text tokens. That is rather\n * than the value for a token being a small string of text, it's value an array\n * of text tokens.\n *\n * Used for grouping together URLs, emails, hashtags, and other potential\n * creations.\n * @class MultiToken\n * @property {string} t\n * @property {string} v\n * @property {Token[]} tk\n * @abstract\n */ MultiToken.prototype = {\n    isLink: false,\n    /**\n   * Return the string this token represents.\n   * @return {string}\n   */ toString () {\n        return this.v;\n    },\n    /**\n   * What should the value for this token be in the `href` HTML attribute?\n   * Returns the `.toString` value by default.\n   * @param {string} [scheme]\n   * @return {string}\n   */ toHref (scheme) {\n        return this.toString();\n    },\n    /**\n   * @param {Options} options Formatting options\n   * @returns {string}\n   */ toFormattedString (options) {\n        const val = this.toString();\n        const truncate = options.get(\"truncate\", val, this);\n        const formatted = options.get(\"format\", val, this);\n        return truncate && formatted.length > truncate ? formatted.substring(0, truncate) + \"…\" : formatted;\n    },\n    /**\n   *\n   * @param {Options} options\n   * @returns {string}\n   */ toFormattedHref (options) {\n        return options.get(\"formatHref\", this.toHref(options.get(\"defaultProtocol\")), this);\n    },\n    /**\n   * The start index of this token in the original input string\n   * @returns {number}\n   */ startIndex () {\n        return this.tk[0].s;\n    },\n    /**\n   * The end index of this token in the original input string (up to this\n   * index but not including it)\n   * @returns {number}\n   */ endIndex () {\n        return this.tk[this.tk.length - 1].e;\n    },\n    /**\n  \tReturns an object  of relevant values for this token, which includes keys\n  \t* type - Kind of token ('url', 'email', etc.)\n  \t* value - Original text\n  \t* href - The value that should be added to the anchor tag's href\n  \t\tattribute\n  \t\t@method toObject\n  \t@param {string} [protocol] `'http'` by default\n  */ toObject (protocol = defaults.defaultProtocol) {\n        return {\n            type: this.t,\n            value: this.toString(),\n            isLink: this.isLink,\n            href: this.toHref(protocol),\n            start: this.startIndex(),\n            end: this.endIndex()\n        };\n    },\n    /**\n   *\n   * @param {Options} options Formatting option\n   */ toFormattedObject (options) {\n        return {\n            type: this.t,\n            value: this.toFormattedString(options),\n            isLink: this.isLink,\n            href: this.toFormattedHref(options),\n            start: this.startIndex(),\n            end: this.endIndex()\n        };\n    },\n    /**\n   * Whether this token should be rendered as a link according to the given options\n   * @param {Options} options\n   * @returns {boolean}\n   */ validate (options) {\n        return options.get(\"validate\", this.toString(), this);\n    },\n    /**\n   * Return an object that represents how this link should be rendered.\n   * @param {Options} options Formattinng options\n   */ render (options) {\n        const token = this;\n        const href = this.toHref(options.get(\"defaultProtocol\"));\n        const formattedHref = options.get(\"formatHref\", href, this);\n        const tagName = options.get(\"tagName\", href, token);\n        const content = this.toFormattedString(options);\n        const attributes = {};\n        const className = options.get(\"className\", href, token);\n        const target = options.get(\"target\", href, token);\n        const rel = options.get(\"rel\", href, token);\n        const attrs = options.getObj(\"attributes\", href, token);\n        const eventListeners = options.getObj(\"events\", href, token);\n        attributes.href = formattedHref;\n        if (className) {\n            attributes.class = className;\n        }\n        if (target) {\n            attributes.target = target;\n        }\n        if (rel) {\n            attributes.rel = rel;\n        }\n        if (attrs) {\n            Object.assign(attributes, attrs);\n        }\n        return {\n            tagName,\n            attributes,\n            content,\n            eventListeners\n        };\n    }\n};\n/**\n * Create a new token that can be emitted by the parser state machine\n * @param {string} type readable type of the token\n * @param {object} props properties to assign or override, including isLink = true or false\n * @returns {new (value: string, tokens: Token[]) => MultiToken} new token class\n */ function createTokenClass(type, props) {\n    class Token extends MultiToken {\n        constructor(value, tokens){\n            super(value, tokens);\n            this.t = type;\n        }\n    }\n    for(const p in props){\n        Token.prototype[p] = props[p];\n    }\n    Token.t = type;\n    return Token;\n}\n/**\n\tRepresents a list of tokens making up a valid email address\n*/ const Email = createTokenClass(\"email\", {\n    isLink: true,\n    toHref () {\n        return \"mailto:\" + this.toString();\n    }\n});\n/**\n\tRepresents some plain text\n*/ const Text = createTokenClass(\"text\");\n/**\n\tMulti-linebreak token - represents a line break\n\t@class Nl\n*/ const Nl = createTokenClass(\"nl\");\n/**\n\tRepresents a list of text tokens making up a valid URL\n\t@class Url\n*/ const Url = createTokenClass(\"url\", {\n    isLink: true,\n    /**\n  \tLowercases relevant parts of the domain and adds the protocol if\n  \trequired. Note that this will not escape unsafe HTML characters in the\n  \tURL.\n  \t\t@param {string} [scheme] default scheme (e.g., 'https')\n  \t@return {string} the full href\n  */ toHref (scheme = defaults.defaultProtocol) {\n        // Check if already has a prefix scheme\n        return this.hasProtocol() ? this.v : `${scheme}://${this.v}`;\n    },\n    /**\n   * Check whether this URL token has a protocol\n   * @return {boolean}\n   */ hasProtocol () {\n        const tokens = this.tk;\n        return tokens.length >= 2 && tokens[0].t !== LOCALHOST && tokens[1].t === COLON;\n    }\n});\nvar multi = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    Base: MultiToken,\n    Email: Email,\n    MultiToken: MultiToken,\n    Nl: Nl,\n    Text: Text,\n    Url: Url,\n    createTokenClass: createTokenClass\n});\n/**\n\tNot exactly parser, more like the second-stage scanner (although we can\n\ttheoretically hotswap the code here with a real parser in the future... but\n\tfor a little URL-finding utility abstract syntax trees may be a little\n\toverkill).\n\n\tURL format: http://en.wikipedia.org/wiki/URI_scheme\n\tEmail format: http://en.wikipedia.org/wiki/EmailAddress (links to RFC in\n\treference)\n\n\t@module linkify\n\t@submodule parser\n\t@main run\n*/ const makeState = (arg)=>new State(arg);\n/**\n * Generate the parser multi token-based state machine\n * @param {{ groups: Collections<string> }} tokens\n */ function init$1({ groups }) {\n    // Types of characters the URL can definitely end in\n    const qsAccepting = groups.domain.concat([\n        AMPERSAND,\n        ASTERISK,\n        AT,\n        BACKSLASH,\n        BACKTICK,\n        CARET,\n        DOLLAR,\n        EQUALS,\n        HYPHEN,\n        NUM,\n        PERCENT,\n        PIPE,\n        PLUS,\n        POUND,\n        SLASH,\n        SYM,\n        TILDE,\n        UNDERSCORE\n    ]);\n    // Types of tokens that can follow a URL and be part of the query string\n    // but cannot be the very last characters\n    // Characters that cannot appear in the URL at all should be excluded\n    const qsNonAccepting = [\n        APOSTROPHE,\n        COLON,\n        COMMA,\n        DOT,\n        EXCLAMATION,\n        PERCENT,\n        QUERY,\n        QUOTE,\n        SEMI,\n        OPENANGLEBRACKET,\n        CLOSEANGLEBRACKET,\n        OPENBRACE,\n        CLOSEBRACE,\n        CLOSEBRACKET,\n        OPENBRACKET,\n        OPENPAREN,\n        CLOSEPAREN,\n        FULLWIDTHLEFTPAREN,\n        FULLWIDTHRIGHTPAREN,\n        LEFTCORNERBRACKET,\n        RIGHTCORNERBRACKET,\n        LEFTWHITECORNERBRACKET,\n        RIGHTWHITECORNERBRACKET,\n        FULLWIDTHLESSTHAN,\n        FULLWIDTHGREATERTHAN\n    ];\n    // For addresses without the mailto prefix\n    // Tokens allowed in the localpart of the email\n    const localpartAccepting = [\n        AMPERSAND,\n        APOSTROPHE,\n        ASTERISK,\n        BACKSLASH,\n        BACKTICK,\n        CARET,\n        DOLLAR,\n        EQUALS,\n        HYPHEN,\n        OPENBRACE,\n        CLOSEBRACE,\n        PERCENT,\n        PIPE,\n        PLUS,\n        POUND,\n        QUERY,\n        SLASH,\n        SYM,\n        TILDE,\n        UNDERSCORE\n    ];\n    // The universal starting state.\n    /**\n   * @type State<Token>\n   */ const Start = makeState();\n    const Localpart = tt(Start, TILDE); // Local part of the email address\n    ta(Localpart, localpartAccepting, Localpart);\n    ta(Localpart, groups.domain, Localpart);\n    const Domain = makeState(), Scheme = makeState(), SlashScheme = makeState();\n    ta(Start, groups.domain, Domain); // parsed string ends with a potential domain name (A)\n    ta(Start, groups.scheme, Scheme); // e.g., 'mailto'\n    ta(Start, groups.slashscheme, SlashScheme); // e.g., 'http'\n    ta(Domain, localpartAccepting, Localpart);\n    ta(Domain, groups.domain, Domain);\n    const LocalpartAt = tt(Domain, AT); // Local part of the email address plus @\n    tt(Localpart, AT, LocalpartAt); // close to an email address now\n    // Local part of an email address can be e.g. 'http' or 'mailto'\n    tt(Scheme, AT, LocalpartAt);\n    tt(SlashScheme, AT, LocalpartAt);\n    const LocalpartDot = tt(Localpart, DOT); // Local part of the email address plus '.' (localpart cannot end in .)\n    ta(LocalpartDot, localpartAccepting, Localpart);\n    ta(LocalpartDot, groups.domain, Localpart);\n    const EmailDomain = makeState();\n    ta(LocalpartAt, groups.domain, EmailDomain); // parsed string starts with local email info + @ with a potential domain name\n    ta(EmailDomain, groups.domain, EmailDomain);\n    const EmailDomainDot = tt(EmailDomain, DOT); // domain followed by DOT\n    ta(EmailDomainDot, groups.domain, EmailDomain);\n    const Email$1 = makeState(Email); // Possible email address (could have more tlds)\n    ta(EmailDomainDot, groups.tld, Email$1);\n    ta(EmailDomainDot, groups.utld, Email$1);\n    tt(LocalpartAt, LOCALHOST, Email$1);\n    // Hyphen can jump back to a domain name\n    const EmailDomainHyphen = tt(EmailDomain, HYPHEN); // parsed string starts with local email info + @ with a potential domain name\n    tt(EmailDomainHyphen, HYPHEN, EmailDomainHyphen);\n    ta(EmailDomainHyphen, groups.domain, EmailDomain);\n    ta(Email$1, groups.domain, EmailDomain);\n    tt(Email$1, DOT, EmailDomainDot);\n    tt(Email$1, HYPHEN, EmailDomainHyphen);\n    // Final possible email states\n    const EmailColon = tt(Email$1, COLON); // URL followed by colon (potential port number here)\n    /*const EmailColonPort = */ ta(EmailColon, groups.numeric, Email); // URL followed by colon and port number\n    // Account for dots and hyphens. Hyphens are usually parts of domain names\n    // (but not TLDs)\n    const DomainHyphen = tt(Domain, HYPHEN); // domain followed by hyphen\n    const DomainDot = tt(Domain, DOT); // domain followed by DOT\n    tt(DomainHyphen, HYPHEN, DomainHyphen);\n    ta(DomainHyphen, groups.domain, Domain);\n    ta(DomainDot, localpartAccepting, Localpart);\n    ta(DomainDot, groups.domain, Domain);\n    const DomainDotTld = makeState(Url); // Simplest possible URL with no query string\n    ta(DomainDot, groups.tld, DomainDotTld);\n    ta(DomainDot, groups.utld, DomainDotTld);\n    ta(DomainDotTld, groups.domain, Domain);\n    ta(DomainDotTld, localpartAccepting, Localpart);\n    tt(DomainDotTld, DOT, DomainDot);\n    tt(DomainDotTld, HYPHEN, DomainHyphen);\n    tt(DomainDotTld, AT, LocalpartAt);\n    const DomainDotTldColon = tt(DomainDotTld, COLON); // URL followed by colon (potential port number here)\n    const DomainDotTldColonPort = makeState(Url); // TLD followed by a port number\n    ta(DomainDotTldColon, groups.numeric, DomainDotTldColonPort);\n    // Long URL with optional port and maybe query string\n    const Url$1 = makeState(Url);\n    // URL with extra symbols at the end, followed by an opening bracket\n    const UrlNonaccept = makeState(); // URL followed by some symbols (will not be part of the final URL)\n    // Query strings\n    ta(Url$1, qsAccepting, Url$1);\n    ta(Url$1, qsNonAccepting, UrlNonaccept);\n    ta(UrlNonaccept, qsAccepting, Url$1);\n    ta(UrlNonaccept, qsNonAccepting, UrlNonaccept);\n    // Become real URLs after `SLASH` or `COLON NUM SLASH`\n    // Here works with or without scheme:// prefix\n    tt(DomainDotTld, SLASH, Url$1);\n    tt(DomainDotTldColonPort, SLASH, Url$1);\n    // Note that domains that begin with schemes are treated slighly differently\n    const SchemeColon = tt(Scheme, COLON); // e.g., 'mailto:'\n    const SlashSchemeColon = tt(SlashScheme, COLON); // e.g., 'http:'\n    const SlashSchemeColonSlash = tt(SlashSchemeColon, SLASH); // e.g., 'http:/'\n    const UriPrefix = tt(SlashSchemeColonSlash, SLASH); // e.g., 'http://'\n    // Scheme states can transition to domain states\n    ta(Scheme, groups.domain, Domain);\n    tt(Scheme, DOT, DomainDot);\n    tt(Scheme, HYPHEN, DomainHyphen);\n    ta(SlashScheme, groups.domain, Domain);\n    tt(SlashScheme, DOT, DomainDot);\n    tt(SlashScheme, HYPHEN, DomainHyphen);\n    // Force URL with scheme prefix followed by anything sane\n    ta(SchemeColon, groups.domain, Url$1);\n    tt(SchemeColon, SLASH, Url$1);\n    tt(SchemeColon, QUERY, Url$1);\n    ta(UriPrefix, groups.domain, Url$1);\n    ta(UriPrefix, qsAccepting, Url$1);\n    tt(UriPrefix, SLASH, Url$1);\n    const bracketPairs = [\n        [\n            OPENBRACE,\n            CLOSEBRACE\n        ],\n        // {}\n        [\n            OPENBRACKET,\n            CLOSEBRACKET\n        ],\n        // []\n        [\n            OPENPAREN,\n            CLOSEPAREN\n        ],\n        // ()\n        [\n            OPENANGLEBRACKET,\n            CLOSEANGLEBRACKET\n        ],\n        // <>\n        [\n            FULLWIDTHLEFTPAREN,\n            FULLWIDTHRIGHTPAREN\n        ],\n        // （）\n        [\n            LEFTCORNERBRACKET,\n            RIGHTCORNERBRACKET\n        ],\n        // 「」\n        [\n            LEFTWHITECORNERBRACKET,\n            RIGHTWHITECORNERBRACKET\n        ],\n        // 『』\n        [\n            FULLWIDTHLESSTHAN,\n            FULLWIDTHGREATERTHAN\n        ] // ＜＞\n    ];\n    for(let i = 0; i < bracketPairs.length; i++){\n        const [OPEN, CLOSE] = bracketPairs[i];\n        const UrlOpen = tt(Url$1, OPEN); // URL followed by open bracket\n        // Continue not accepting for open brackets\n        tt(UrlNonaccept, OPEN, UrlOpen);\n        // Closing bracket component. This character WILL be included in the URL\n        tt(UrlOpen, CLOSE, Url$1);\n        // URL that beings with an opening bracket, followed by a symbols.\n        // Note that the final state can still be `UrlOpen` (if the URL has a\n        // single opening bracket for some reason).\n        const UrlOpenQ = makeState(Url);\n        ta(UrlOpen, qsAccepting, UrlOpenQ);\n        const UrlOpenSyms = makeState(); // UrlOpen followed by some symbols it cannot end it\n        ta(UrlOpen, qsNonAccepting);\n        // URL that begins with an opening bracket, followed by some symbols\n        ta(UrlOpenQ, qsAccepting, UrlOpenQ);\n        ta(UrlOpenQ, qsNonAccepting, UrlOpenSyms);\n        ta(UrlOpenSyms, qsAccepting, UrlOpenQ);\n        ta(UrlOpenSyms, qsNonAccepting, UrlOpenSyms);\n        // Close brace/bracket to become regular URL\n        tt(UrlOpenQ, CLOSE, Url$1);\n        tt(UrlOpenSyms, CLOSE, Url$1);\n    }\n    tt(Start, LOCALHOST, DomainDotTld); // localhost is a valid URL state\n    tt(Start, NL, Nl); // single new line\n    return {\n        start: Start,\n        tokens: tk\n    };\n}\n/**\n * Run the parser state machine on a list of scanned string-based tokens to\n * create a list of multi tokens, each of which represents a URL, email address,\n * plain text, etc.\n *\n * @param {State<MultiToken>} start parser start state\n * @param {string} input the original input used to generate the given tokens\n * @param {Token[]} tokens list of scanned tokens\n * @returns {MultiToken[]}\n */ function run(start, input, tokens) {\n    let len = tokens.length;\n    let cursor = 0;\n    let multis = [];\n    let textTokens = [];\n    while(cursor < len){\n        let state = start;\n        let secondState = null;\n        let nextState = null;\n        let multiLength = 0;\n        let latestAccepting = null;\n        let sinceAccepts = -1;\n        while(cursor < len && !(secondState = state.go(tokens[cursor].t))){\n            // Starting tokens with nowhere to jump to.\n            // Consider these to be just plain text\n            textTokens.push(tokens[cursor++]);\n        }\n        while(cursor < len && (nextState = secondState || state.go(tokens[cursor].t))){\n            // Get the next state\n            secondState = null;\n            state = nextState;\n            // Keep track of the latest accepting state\n            if (state.accepts()) {\n                sinceAccepts = 0;\n                latestAccepting = state;\n            } else if (sinceAccepts >= 0) {\n                sinceAccepts++;\n            }\n            cursor++;\n            multiLength++;\n        }\n        if (sinceAccepts < 0) {\n            // No accepting state was found, part of a regular text token add\n            // the first text token to the text tokens array and try again from\n            // the next\n            cursor -= multiLength;\n            if (cursor < len) {\n                textTokens.push(tokens[cursor]);\n                cursor++;\n            }\n        } else {\n            // Accepting state!\n            // First close off the textTokens (if available)\n            if (textTokens.length > 0) {\n                multis.push(initMultiToken(Text, input, textTokens));\n                textTokens = [];\n            }\n            // Roll back to the latest accepting state\n            cursor -= sinceAccepts;\n            multiLength -= sinceAccepts;\n            // Create a new multitoken\n            const Multi = latestAccepting.t;\n            const subtokens = tokens.slice(cursor - multiLength, cursor);\n            multis.push(initMultiToken(Multi, input, subtokens));\n        }\n    }\n    // Finally close off the textTokens (if available)\n    if (textTokens.length > 0) {\n        multis.push(initMultiToken(Text, input, textTokens));\n    }\n    return multis;\n}\n/**\n * Utility function for instantiating a new multitoken with all the relevant\n * fields during parsing.\n * @param {new (value: string, tokens: Token[]) => MultiToken} Multi class to instantiate\n * @param {string} input original input string\n * @param {Token[]} tokens consecutive tokens scanned from input string\n * @returns {MultiToken}\n */ function initMultiToken(Multi, input, tokens) {\n    const startIdx = tokens[0].s;\n    const endIdx = tokens[tokens.length - 1].e;\n    const value = input.slice(startIdx, endIdx);\n    return new Multi(value, tokens);\n}\nconst warn = typeof console !== \"undefined\" && console && console.warn || (()=>{});\nconst warnAdvice = \"until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.\";\n// Side-effect initialization state\nconst INIT = {\n    scanner: null,\n    parser: null,\n    tokenQueue: [],\n    pluginQueue: [],\n    customSchemes: [],\n    initialized: false\n};\n/**\n * @typedef {{\n * \tstart: State<string>,\n * \ttokens: { groups: Collections<string> } & typeof tk\n * }} ScannerInit\n */ /**\n * @typedef {{\n * \tstart: State<MultiToken>,\n * \ttokens: typeof multi\n * }} ParserInit\n */ /**\n * @typedef {(arg: { scanner: ScannerInit }) => void} TokenPlugin\n */ /**\n * @typedef {(arg: { scanner: ScannerInit, parser: ParserInit }) => void} Plugin\n */ /**\n * De-register all plugins and reset the internal state-machine. Used for\n * testing; not required in practice.\n * @private\n */ function reset() {\n    State.groups = {};\n    INIT.scanner = null;\n    INIT.parser = null;\n    INIT.tokenQueue = [];\n    INIT.pluginQueue = [];\n    INIT.customSchemes = [];\n    INIT.initialized = false;\n    return INIT;\n}\n/**\n * Register a token plugin to allow the scanner to recognize additional token\n * types before the parser state machine is constructed from the results.\n * @param {string} name of plugin to register\n * @param {TokenPlugin} plugin function that accepts the scanner state machine\n * and available scanner tokens and collections and extends the state machine to\n * recognize additional tokens or groups.\n */ function registerTokenPlugin(name, plugin) {\n    if (typeof plugin !== \"function\") {\n        throw new Error(`linkifyjs: Invalid token plugin ${plugin} (expects function)`);\n    }\n    for(let i = 0; i < INIT.tokenQueue.length; i++){\n        if (name === INIT.tokenQueue[i][0]) {\n            warn(`linkifyjs: token plugin \"${name}\" already registered - will be overwritten`);\n            INIT.tokenQueue[i] = [\n                name,\n                plugin\n            ];\n            return;\n        }\n    }\n    INIT.tokenQueue.push([\n        name,\n        plugin\n    ]);\n    if (INIT.initialized) {\n        warn(`linkifyjs: already initialized - will not register token plugin \"${name}\" ${warnAdvice}`);\n    }\n}\n/**\n * Register a linkify plugin\n * @param {string} name of plugin to register\n * @param {Plugin} plugin function that accepts the parser state machine and\n * extends the parser to recognize additional link types\n */ function registerPlugin(name, plugin) {\n    if (typeof plugin !== \"function\") {\n        throw new Error(`linkifyjs: Invalid plugin ${plugin} (expects function)`);\n    }\n    for(let i = 0; i < INIT.pluginQueue.length; i++){\n        if (name === INIT.pluginQueue[i][0]) {\n            warn(`linkifyjs: plugin \"${name}\" already registered - will be overwritten`);\n            INIT.pluginQueue[i] = [\n                name,\n                plugin\n            ];\n            return;\n        }\n    }\n    INIT.pluginQueue.push([\n        name,\n        plugin\n    ]);\n    if (INIT.initialized) {\n        warn(`linkifyjs: already initialized - will not register plugin \"${name}\" ${warnAdvice}`);\n    }\n}\n/**\n * Detect URLs with the following additional protocol. Anything with format\n * \"protocol://...\" will be considered a link. If `optionalSlashSlash` is set to\n * `true`, anything with format \"protocol:...\" will be considered a link.\n * @param {string} scheme\n * @param {boolean} [optionalSlashSlash]\n */ function registerCustomProtocol(scheme, optionalSlashSlash = false) {\n    if (INIT.initialized) {\n        warn(`linkifyjs: already initialized - will not register custom scheme \"${scheme}\" ${warnAdvice}`);\n    }\n    if (!/^[0-9a-z]+(-[0-9a-z]+)*$/.test(scheme)) {\n        throw new Error(`linkifyjs: incorrect scheme format.\n1. Must only contain digits, lowercase ASCII letters or \"-\"\n2. Cannot start or end with \"-\"\n3. \"-\" cannot repeat`);\n    }\n    INIT.customSchemes.push([\n        scheme,\n        optionalSlashSlash\n    ]);\n}\n/**\n * Initialize the linkify state machine. Called automatically the first time\n * linkify is called on a string, but may be called manually as well.\n */ function init() {\n    // Initialize scanner state machine and plugins\n    INIT.scanner = init$2(INIT.customSchemes);\n    for(let i = 0; i < INIT.tokenQueue.length; i++){\n        INIT.tokenQueue[i][1]({\n            scanner: INIT.scanner\n        });\n    }\n    // Initialize parser state machine and plugins\n    INIT.parser = init$1(INIT.scanner.tokens);\n    for(let i = 0; i < INIT.pluginQueue.length; i++){\n        INIT.pluginQueue[i][1]({\n            scanner: INIT.scanner,\n            parser: INIT.parser\n        });\n    }\n    INIT.initialized = true;\n    return INIT;\n}\n/**\n * Parse a string into tokens that represent linkable and non-linkable sub-components\n * @param {string} str\n * @return {MultiToken[]} tokens\n */ function tokenize(str) {\n    if (!INIT.initialized) {\n        init();\n    }\n    return run(INIT.parser.start, str, run$1(INIT.scanner.start, str));\n}\ntokenize.scan = run$1; // for testing\n/**\n * Find a list of linkable items in the given string.\n * @param {string} str string to find links in\n * @param {string | Opts} [type] either formatting options or specific type of\n * links to find, e.g., 'url' or 'email'\n * @param {Opts} [opts] formatting options for final output. Cannot be specified\n * if opts already provided in `type` argument\n */ function find(str, type = null, opts = null) {\n    if (type && typeof type === \"object\") {\n        if (opts) {\n            throw Error(`linkifyjs: Invalid link type ${type}; must be a string`);\n        }\n        opts = type;\n        type = null;\n    }\n    const options = new Options(opts);\n    const tokens = tokenize(str);\n    const filtered = [];\n    for(let i = 0; i < tokens.length; i++){\n        const token = tokens[i];\n        if (token.isLink && (!type || token.t === type) && options.check(token)) {\n            filtered.push(token.toFormattedObject(options));\n        }\n    }\n    return filtered;\n}\n/**\n * Is the given string valid linkable text of some sort. Note that this does not\n * trim the text for you.\n *\n * Optionally pass in a second `type` param, which is the type of link to test\n * for.\n *\n * For example,\n *\n *     linkify.test(str, 'email');\n *\n * Returns `true` if str is a valid email.\n * @param {string} str string to test for links\n * @param {string} [type] optional specific link type to look for\n * @returns boolean true/false\n */ function test(str, type = null) {\n    const tokens = tokenize(str);\n    return tokens.length === 1 && tokens[0].isLink && (!type || tokens[0].t === type);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGlua2lmeWpzL2Rpc3QvbGlua2lmeS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSw0REFBNEQ7QUFDNUQsa0RBQWtEO0FBQ2xELHFEQUFxRDtBQUNyRCxNQUFNQSxjQUFjO0FBQ3BCLHNEQUFzRDtBQUN0RCxNQUFNQyxlQUFlO0FBRXJCOztDQUVDLEdBRUQ7OztDQUdDLEdBRUQ7O0NBRUMsR0FFRCx3Q0FBd0M7QUFDeEMsTUFBTUMsVUFBVTtBQUNoQixNQUFNQyxRQUFRO0FBQ2QsTUFBTUMsUUFBUTtBQUNkLE1BQU1DLGVBQWU7QUFDckIsTUFBTUMsZUFBZTtBQUNyQixNQUFNQyxTQUFTO0FBQ2YsTUFBTUMsUUFBUTtBQUNkLE1BQU1DLFNBQVM7QUFDZixNQUFNQyxjQUFjO0FBQ3BCLE1BQU1DLGFBQWE7QUFFbkI7Ozs7O0NBS0MsR0FDRCxTQUFTQyxjQUFjQyxJQUFJLEVBQUVDLE1BQU07SUFDakMsSUFBSSxDQUFFRCxDQUFBQSxRQUFRQyxNQUFLLEdBQUk7UUFDckJBLE1BQU0sQ0FBQ0QsS0FBSyxHQUFHLEVBQUU7SUFDbkI7SUFDQSxPQUFPQyxNQUFNLENBQUNELEtBQUs7QUFDckI7QUFFQTs7Ozs7Q0FLQyxHQUNELFNBQVNFLFlBQVlDLENBQUMsRUFBRUMsS0FBSyxFQUFFSCxNQUFNO0lBQ25DLElBQUlHLEtBQUssQ0FBQ2YsUUFBUSxFQUFFO1FBQ2xCZSxLQUFLLENBQUNaLGFBQWEsR0FBRztRQUN0QlksS0FBSyxDQUFDWCxhQUFhLEdBQUc7SUFDeEI7SUFDQSxJQUFJVyxLQUFLLENBQUNkLE1BQU0sRUFBRTtRQUNoQmMsS0FBSyxDQUFDWixhQUFhLEdBQUc7UUFDdEJZLEtBQUssQ0FBQ2IsTUFBTSxHQUFHO0lBQ2pCO0lBQ0EsSUFBSWEsS0FBSyxDQUFDWixhQUFhLEVBQUU7UUFDdkJZLEtBQUssQ0FBQ1gsYUFBYSxHQUFHO0lBQ3hCO0lBQ0EsSUFBSVcsS0FBSyxDQUFDYixNQUFNLEVB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Q0QsU0FBU3RSLEtBQUtrSCxHQUFHLEVBQUVnRixPQUFPLElBQUk7SUFDNUIsTUFBTWxGLFNBQVNtSyxTQUFTaks7SUFDeEIsT0FBT0YsT0FBT2xILE1BQU0sS0FBSyxLQUFLa0gsTUFBTSxDQUFDLEVBQUUsQ0FBQ3lFLE1BQU0sSUFBSyxFQUFDUyxRQUFRbEYsTUFBTSxDQUFDLEVBQUUsQ0FBQ3ZJLENBQUMsS0FBS3lOLElBQUc7QUFDakY7QUFFOE0iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcmFzb2JwYWktd2ViLy4vbm9kZV9tb2R1bGVzL2xpbmtpZnlqcy9kaXN0L2xpbmtpZnkubWpzPzZmNzYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVEhJUyBGSUxFIElTIEFVVE9NQVRJQ0FMTFkgR0VORVJBVEVEIERPIE5PVCBFRElUIERJUkVDVExZXG4vLyBTZWUgdXBkYXRlLXRsZHMuanMgZm9yIGVuY29kaW5nL2RlY29kaW5nIGZvcm1hdFxuLy8gaHR0cHM6Ly9kYXRhLmlhbmEub3JnL1RMRC90bGRzLWFscGhhLWJ5LWRvbWFpbi50eHRcbmNvbnN0IGVuY29kZWRUbGRzID0gJ2FhYTFycDNiYjBvdHQzdmllNGMxbGUyb2dhZG81dWRoYWJpN2MwYWRlbXk1Y2VudHVyZTZvdW50YW50MHM5bzF0b3I0ZDBzMXVsdDRlMGcxcm8ydG5hNGYwbDFyaWNhNWcwYWtoYW41ZW5jeTVpMGcxcmJ1czNmb3JjZTV0ZWw1a2RuM2wwaWJhYmE0cGF5NGxmaW5hbno2c3RhdGU1eTJzYWNlM3RvbTVtMGF6b240ZXJpY2FuZXhwcmVzczdmYW1pbHkxMXgyZmFtM2ljYTNzdGVyZGFtOG5hbHl0aWNzN2Ryb2lkNXF1YW40ejJvMGwycGFydG1lbnRzOHAwbGU0cTB1YXJlbGxlOHIwYWIxbWNvNGNoaTNteTJwYTJ0MGUzczBkYTJpYTJzb2NpYXRlczl0MGhsZXRhNXRvcm5leTd1MGN0aW9uNWRpMGJsZTNvM3Nwb3N0NXRob3IzbzBzNHcwczJ4MGEyejB1cmU1YmEwYnkyaWR1M25hbWV4NGQxazJyMGNlbG9uYTVsYXljYXJkNHM1ZWZvb3Q1Z2FpbnM2c2ViYWxsNWtldGJhbGw4dWhhdXM1eWVybjViMGMxdDF2YTNjZzFuMmQxZTBhdHMydXR5NGVyMnJsaW40c3QwYnV5NXQyZjFnMWgwYXJ0aTVpMGJsZTNkMWtlMm5nMG8zbzF6MmoxbGFjazBmcmlkYXk5b2NrYnVzdGVyOGcxb21iZXJnN3VlM20wczF3Mm4wcHBhcmliYXM5bzBhdHMzZWhyaW5nZXI4ZmEybTFuZDJvMGswaW5nNXNjaDJ0aWsyb240dDF1dGlxdWU2eDJyMGFkZXNjbzZpZGdlc3RvbmU5b2Fkd2F5NWtlcjN0aGVyNXVzc2VsczdzMXQxdWlsZDBlcnM2c2luZXNzNnkxenozdjF3MXkxejBoM2NhMGIxZmUybDBsMXZpbmtsZWluOW0wZXJhM3Aybm9uM3BldG93bjVpdGFsMG9uZThyMGF2YW40ZHMyZTBlcjBzNHMyc2ExZTFoMWlubzR0MGVyaW5nNWhvbGljN2JhMW4xcmUzYzFkMWVudGVyNG8xcm4zZjBhMWQyZzFoMGFuZWwybmVsNHJpdHk0c2UydDJlYXAzaW50YWk1cmlzdG1hczZvbWU0dXJjaDVpMHByaWFuaTZyY2xlNHNjbzN0YWRlbDRpMGMyeTNrMWwwYWltczRlYW5pbmc2aWNrMm5pYzFxdWU2b3RoaW5nNXVkM3ViMG1lZDZtMW4xbzBhY2gzZGVzM2ZmZWU0bGxlZ2U0b2duZTVtMG1iYW5rNHVuaXR5NnBhbnkycmUzdXRlcjVzZWM0bmRvczNzdHJ1Y3Rpb244dWx0aW5nN3RhY3QzcmFjdG9yczlva2luZzRsMXAycnNpY2E1dW50cnk0cG9uMHM0cnNlczZwYTJyMGVkaXQwY2FyZDR1bmlvbjlpY2tldDVvd24zczF1aXNlMHM2dTBpc2luZWxsYTl2MXcxeDF5MG1ydTNvdTN6MmRhZDFuY2UzdGExZTFpbmczc3VuNHkyY2xrM2RzMmUwYWwwZXIyczNncmVlNGxpdmVyeTVsMW9pdHRlNXRhM21vY3JhdDZudGFsMmlzdDVzaTBnbjR2MmhsMmlhbW9uZHM2ZXQyZ2l0YWw1cmVjdDBvcnk3c2NvdW50M3ZlcjVoMnkyajFrMW0xbnAybzBjczF0b3I0ZzFtYWluczV0MXdubG9hZDdyaXZlNHR2MnViYWkzbmxvcDRwb250NHJiYW41dmFnMnIyejJlYXJ0aDN0MmMwbzJkZWthM3UwY2F0aW9uOGUxZzFtYWlsM2VyY2s1bmVyZ3k0Z2luZWVyMGluZzl0ZXJwcmlzZXMxMHBzb240cXVpcG1lbnQ4cjBpY3Nzb242bmkzczBxMXRhdGU1dDF1MHJvdmlzaW9uOHMydmVudHM1eGNoYW5nZTZwZXJ0M29zZWQ0cmVzczV0cmFzcGFjZTEwZmFnZTJpbDFyd2luZHM2dGgzbWlseTRuMHMycm0wZXJzNXNoaW9uNHQzZWRleDNlZGJhY2s2cnJhcmkzZXJvNmkwZGVsaXR5NW8ybG0ybmFsMW5jZTFpYWw3cmUwc3RvbmU2bWRhbGU2c2gwaW5nNXQwbmVzczZqMWsxbGlja3IzZ2h0czRyMm9yaXN0NHdlcnM1eTJtMW8wbzBkMXRiYWxsNnJkMWV4MnNhbGU0dW0zdW5kYXRpb244eDJyMGVlMXNlbml1czdsMW9nYW5zNG50aWVyN3RyMnVqaXRzdTVuMGQycm5pdHVyZTd0Ym9sNXlpM2dhMGwwbGVyeTNvMXVwNG1lMHMzcDFyZGVuNHkyYjBpejNkMG4yZTBhMW50MGluZzVvcmdlNWYxZzBlZTNoMWkwZnQwczN2ZXMyaW5nNWwwYXNzM2Uxb2JhbDJvNG0wYWlsM2JoMm8xeDJuMW9kYWRkeTVsZDBwb2ludDZmMm8wZHllYXI1ZzBsZTRwMXQxdjJwMXExcjBhaW5nZXI1cGhpY3M1dGlzNGVlbjNpcGUzb2Nlcnk0dXA0czF0MXUwY2NpM2dlMmlkZTJ0YXJzNXJ1M3cxeTJoYWlyMm1idXJnNW5nb3V0NXVzM2JvMmRmYzBiYW5rN2VhbHRoMGNhcmU4bHAxc2lua2k2cmUxbWVzNWlwaG9wNHNhbWl0c3U3dGFjaGk1djJrMHQybTFuMW9ja2V5NGxkaW5nczVpZGF5NW1lZGVwb3Q1Z29vZHM1czBlbnNlN25kYTNyc2Uzc3BpdGFsNXQwaW5nNXQwZWxzM21haWw1dXNlM3cycjFzYmMzdDF1MGdoZXM1eWF0dDN1bmRhaTdpYm0yY2JjMmUxdTJkMWUwZWUzZm0ya2FubzRsMW0wYW1hdDRkYjJtbzBiaWxpZW45bjBjMWR1c3RyaWVzOGZpbml0aTVvMmcxazFzdGl0dXRlNnVyYW5jZTRlNHQwZXJuYXRpb25hbDEwdWl0NHZlc3RtZW50czEwbzFwaXJhbmdhN3ExcjBpc2g0czBtYWlsaTV0MGFuYnVsN3QwYXUydjNqYWd1YXI0dmEzY2IyZTBlcDJ0enQzd2Vscnk2aW8ybGwybTBwMm5qMm8wYnMxdXJnNHQxeTJwMG1vcmdhbjZyczN1ZWdvczRuaXBlcjdrYXVmZW41ZGRpM2UwcnJ5aG90ZWxzNnByb3BlcnRpZXMxNGZoMmcxaDFpMGExZHMybTFuZGxlNHRjaGVuNXdpM20xbjFvZWxuM21hdHN1NXNoZXI1cDBtZzJuMnIwZDFlZDN1b2tncm91cDh3MXkwb3RvNHoybGEwY2FpeGE1bWJvcmdoaW5pOGVyM25kMHJvdmVyNnhlc3M1c2FsbGU1dDBpbm8zcm9iZTV3MHllcjViMWMxZHMyZWFzZTNjbGVyYzVmcmFrNGdhbDJvMnh1czRnYnQzaTBkbDJmZTBpbnN1cmFuY2U5c3R5bGU3Z2h0aW5nNmtlMmxseTNtaXRlZDRvMm5jb2xuNGsydmUxaW5nNWsxbGMxcDJvYW4wczNja2VyM3VzM2wxbmRvbjR0dGUxbzN2ZTNwbDBmaW5hbmNpYWwxMXIxczF0MGQwYTN1MG5kYmVjazZ4ZTF1cnk1djF5Mm1hMGRyaWQ0aWYxc29uNGtldXA0bjBhZ2VtZW50N2dvM3AxcmtldDBpbmczczRyaW90dDVzaGFsbHM3dHRlbDViYTJjMGtpbnNleTdkMWUwZDBpYTNldDJsYm91cm5lN21lMW9yaWFsNm4wdTJyY2ttc2Q3ZzFoMWlhbWkzY3Jvc29mdDdsMW5pMXQydDBzdWJpc2hpOWsxbDBiMXMybTBhMm4xbzBiaTBsZTRkYTJlMWkxbTFuYXNoM2V5MnN0ZXI1cm1vbjN0Z2FnZTZzY293NHRvMHJjeWNsZXM5djBpZTRwMXExcjFzMGQydDBuMXIydTBzZXVtM2ljNHYxdzF4MXkxejJuYTBiMWdveWE0bWUydnkzYmEyYzFlMGMxdDBiYW5rNGZsaXg0d29yazV1c3RhcjV3MHMyeHQwZGlyZWN0N3VzNGYwbDJnMG8yaGsyaTBjbzJrZTFvbjNuamEzc3NhbjF5NWwxbzBraWEzcnRvbjR3MHJ1ejN0djRwMXIwYTF3MnR0MnUxeWMyejJvYmkxc2VydmVyN2ZmaWNlNWtpbmF3YTZsYXlhbjBncm91cDlsbzNtMGVnYTRuZTFnMWwwaW5lNW9vMnBlbjNyYWNsZTNuZ2U0ZzBhbmljNWlnaW5zNnNha2E0dHN1a2E0dDJ2aDNwYTBnZTJuYXNvbmljN3JpczJzMXRuZXJzNHMxeTN5MmNjdzNlMHQyZjBpemVyNWcxaDBhcm1hY3k2ZDFpbGlwczVvbmUydG8wZ3JhcGh5NnM0eXNpbzVpY3MxdGV0MnVyZXM2ZDFuMGcxazJvbmVlcjV6emE0azFsMGFjZTJ5MHN0YXRpb245dW1iaW5nNXMzbTFuMGMyb2hsMmtlcjNsaXRpZTVybjJzdDNyMGF4aTNlc3MzaW1lM28wZDB1Y3Rpb25zOGYxZ3Jlc3NpdmU4bW8ycGVydGllczN5NXRlY3Rpb244dTBkZW50aWFsOXMxdDF1YjJ3MGMyeTJxYTFwb24zdWViZWMzc3Q1cmFjaW5nNGRpbzRlMGFkMWxlc3RhdGU2dG9yMnk0Y2lwZXM1ZDBzdG9uZTV1bWJyZWxsYTloYWIzaXNlMG4zdDJsaWFuY2U2bjB0MGFsczVwYWlyM29ydDN1YmxpY2FuOHN0MGF1cmFudDh2aWV3MHM1eHJvdGg2aWNoMGFyZGxpNm9oM2wxbzFwMm8wY2tzM2RlbzNnZXJzNG9tM3MwdnAzdTBnYnkzaHIybjJ3MGUyeXVreXU2c2EwYXJsYW5kNmZlMHR5NGt1cmE0bGUxb24zbXNjbHViNHVuZzVuZHZpazBjb3JvbWFudDEyb2ZpNHAxcmwyczF2ZTJ4bzNiMGkxczJjMGIxaGFlZmZsZXI3bWlkdDRvbGFyc2hpcHM4b2wzdWxlM3dhcno1aWVuY2U1b3QzZDFlMGFyY2gzdDJjdXJlMWl0eTZlazJsZWN0NG5lcjNydmljZXM2dmVuM3cxeDB5M2ZyMmcxaDBhbmdyaWxhNnJwM2VsbDNpYTFrc2hhNW9lczJwMHBpbmc1dWppM3czaTBsazJuYTFnbGVzNXRlM2oxazBpMG4yeTBwZTRsMGluZzRtMGFydDNpbGU0bjBjZjNvMGNjZXIzaWFsNGZ0YmFuazR3YXJlNmh1MmxhcjJ1dGlvbnM3bmcxeTJ5MnBhMGNlM29ydDJ0M3IwbDJzMXQwYWRhMnBsZXM0cjF0ZWJhbms0ZmFybTdjMGdyb3VwNm9ja2hvbG02cmFnZTNlM3JlYW00dWRpbzJ5M3lsZTR1MGNrczNwcGxpZXMzeTJvcnQ1cmYxZ2VyeTV6dWtpNXYxd2F0Y2g0aXNzNHgxeTBkbmV5NHN0ZW1zNnoydGFiMWlwZWk0bGsyb2JhbzRyZ2V0NHRhbW90b3JzNnIydG9vNHgwaTNjMGkyZDBrMmVhbTJjaDBub2xvZ3k4bDFtYXNlazVubmlzNHZhM2YxZzFoMGQxZWF0ZXIycmU2aWFhMmNrZXRzNWVuZGE0cHMycmVzMm9sNGowbWF4eDR4MmswbWF4eDVsMW0wYWxsNG4xbzBkYXkza3lvM29sczNwMXJheTNzaGliYTV0YWwzdXJzM3duMnlvdGEzczNyMGFkZTFpbmc0aW5pbmc1dmVsMGVyczBpbnN1cmFuY2UxNnVzdDN2MnQxdWJlMmkxbmVzM3NodTR2MHMydzF6MnVhMWJhbmszczJnMWsxbmljb20zdmVyc2l0eThvMm9sMnBzMnMxeTF6MnZhMGNhdGlvbnM3bmExZ3VhcmQ3YzFlMGdhczNudHVyZXM2cmlzaWduNW3DtmdlbnNiZXJhdGVyMnVuZzE0c2ljaGVydW5nMTB0MmcxaTBhamVzNGRlbzNnMWtpbmc0bGxhczRuMXAxcmdpbjRzYTFpb240dmExbzNsYWFuZGVyZW45bjFvZGthM2x2bzN0ZTFpbmczbzJ5YWdlNXUyd2FsZXMybWFydDR0ZXI0bmcwZ291NXRjaDBlczZlYXRoZXIwY2hhbm5lbDEyYmNhbTNlcjJzaXRlNWQwZGluZzVpYm8ycjNmMWhvc3dobzZpZW4ya2kybGxpYW1oaWxsOW4wZG93czRlMW5lcnM2bWUyb2x0ZXJza2x1d2VyMTFvZHNpZGU2cmswczJsZDN3MnMxdGMxZjN4Ym94M2Vyb3g0aWh1YW40bjJ4eDJ5ejN5YWNodHM0aG9vM21heHVuNW5kZXg1ZTFvZG9iYXNoaTdnYTJrb2hhbWE2dTB0dWJlNnQxdW4zemEwcHBvczRyYTNlcm8zaXAybTFvbmUzdWVyaWNoNncyJztcbi8vIEludGVybmF0aW9uYWxpemVkIGRvbWFpbiBuYW1lcyBjb250YWluaW5nIG5vbi1BU0NJSVxuY29uc3QgZW5jb2RlZFV0bGRzID0gJ861zrsxz4Uy0LHQszHQtdC7M9C00LXRgtC4NNC10Y4y0LrQsNGC0L7Qu9C40Lo20L7QvDPQvNC60LQy0L7QvTHRgdC60LLQsDbQvtC90LvQsNC50L010YDQszPRgNGD0YEy0YQy0YHQsNC50YIz0YDQsTPRg9C60YAz0pvQsNC3M9Ww1aHVtTPXmdep16jXkNecNden15XXnTPYp9io2YjYuNio2Yo12LHYp9mF2YPZiDXZhNin2LHYr9mGNNio2K3YsdmK2YY12KzYstin2KbYsTXYs9i52YjYr9mK2Kk22LnZhNmK2KfZhjXZhdi62LHYqDXZhdin2LHYp9iqNduM2LHYp9mGNdio2KfYsdiqMtiy2KfYsTTZitiq2YMz2r7Yp9ix2Ko12KrZiNmG2LM02LPZiNiv2KfZhjPYsdmK2Kk12LTYqNmD2Kk02LnYsdin2YIy2Kgy2YXYp9mGNNmB2YTYs9i32YrZhjbZgti32LEz2YPYp9ir2YjZhNmK2YM22YjZhTPZhdi12LEy2YTZitiz2YrYpzXZiNix2YrYqtin2YbZitinN9mC2Lk02YfZhdix2KfZhzXZvtin2qnYs9iq2KfZhjfagNin2LHYqjTgpJXgpYngpK4z4KSo4KWH4KSfM+CkreCkvuCksOCkpDDgpK7gpY0z4KWL4KSkNeCkuOCkguCkl+CkoOCkqDXgpqzgpr7gpoLgprLgpr414Kat4Ka+4Kaw4KakMuCnsOCmpDTgqK3gqL7gqLDgqKQ04Kqt4Kq+4Kqw4KqkNOCsreCsvuCssOCspDTgrofgrqjgr43grqTgrr/grq/grr424K6y4K6Z4K+N4K6V4K+INuCumuCuv+CumeCvjeCuleCuquCvjeCuquCvguCusOCvjTEx4LCt4LC+4LCw4LCk4LGNNeCyreCyvuCysOCypDTgtK3gtL7gtLDgtKTgtII14La94LaC4Laa4LePNOC4hOC4reC4oTPguYTguJfguKIz4Lql4Lqy4LqnM+GDkuGDlDLjgb/jgpPjgaoz44Ki44Oe44K+44OzNOOCr+ODqeOCpuODiTTjgrDjg7zjgrDjg6s044Kz44OgMuOCueODiOOCojPjgrvjg7zjg6sz44OV44Kh44OD44K344On44OzNuODneOCpOODs+ODiDTkuJbnlYwy5Lit5L+hMeWbvTHlnIsx5paH572RM+S6mumprOmAijPkvIHkuJoy5L2b5bGxMuS/oeaBrzLlgaXlurcy5YWr5Y2mMuWFrOWPuDHnm4oy5Y+w5rm+MeeBozLllYbln44x5bqXMeaghzLlmInph4ww5aSn6YWS5bqXNeWcqOe6vzLlpKfmi78y5aSp5Li75pWZM+WoseS5kDLlrrbpm7sy5bm/5LicMuW+ruWNmjLmhYjlloQy5oiR54ix5L2gM+aJi+acujLmi5vogZgy5pS/5YqhMeW6nDLmlrDliqDlnaEy6Ze7MuaXtuWwmjLmm7jnsY0y5py65p6EMua3oemprOmUoTPmuLjmiI8y5r6z6ZaAMueCueecizLnp7vliqgy57uE57uH5py65p6ENOe9keWdgDHlupcx56uZMee7nDLogZTpgJoy6LC35q2MMui0reeJqTLpgJrosqky6ZuG5ZuiMumbu+ioiuebiOenkTTpo57liKnmtaYz6aOf5ZOBMumkkOWOhTLpppnmoLzph4zmi4kz5rivMuuLt+uEtzHsu7Qy7IK87ISxMu2VnOq1rTInO1xuXG4vKipcbiAqIEZpbml0ZSBTdGF0ZSBNYWNoaW5lIGdlbmVyYXRpb24gdXRpbGl0aWVzXG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHR5cGVkZWYge3sgW2dyb3VwOiBzdHJpbmddOiBUW10gfX0gQ29sbGVjdGlvbnNcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7IFtncm91cDogc3RyaW5nXTogdHJ1ZSB9fSBGbGFnc1xuICovXG5cbi8vIEtleXMgaW4gc2Nhbm5lciBDb2xsZWN0aW9ucyBpbnN0YW5jZXNcbmNvbnN0IG51bWVyaWMgPSAnbnVtZXJpYyc7XG5jb25zdCBhc2NpaSA9ICdhc2NpaSc7XG5jb25zdCBhbHBoYSA9ICdhbHBoYSc7XG5jb25zdCBhc2NpaW51bWVyaWMgPSAnYXNjaWludW1lcmljJztcbmNvbnN0IGFscGhhbnVtZXJpYyA9ICdhbHBoYW51bWVyaWMnO1xuY29uc3QgZG9tYWluID0gJ2RvbWFpbic7XG5jb25zdCBlbW9qaSA9ICdlbW9qaSc7XG5jb25zdCBzY2hlbWUgPSAnc2NoZW1lJztcbmNvbnN0IHNsYXNoc2NoZW1lID0gJ3NsYXNoc2NoZW1lJztcbmNvbnN0IHdoaXRlc3BhY2UgPSAnd2hpdGVzcGFjZSc7XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge0NvbGxlY3Rpb25zPFQ+fSBncm91cHMgdG8gcmVnaXN0ZXIgaW5cbiAqIEByZXR1cm5zIHtUW119IEN1cnJlbnQgbGlzdCBvZiB0b2tlbnMgaW4gdGhlIGdpdmVuIGNvbGxlY3Rpb25cbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJHcm91cChuYW1lLCBncm91cHMpIHtcbiAgaWYgKCEobmFtZSBpbiBncm91cHMpKSB7XG4gICAgZ3JvdXBzW25hbWVdID0gW107XG4gIH1cbiAgcmV0dXJuIGdyb3Vwc1tuYW1lXTtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtUfSB0IHRva2VuIHRvIGFkZFxuICogQHBhcmFtIHtDb2xsZWN0aW9uczxUPn0gZ3JvdXBzXG4gKiBAcGFyYW0ge0ZsYWdzfSBmbGFnc1xuICovXG5mdW5jdGlvbiBhZGRUb0dyb3Vwcyh0LCBmbGFncywgZ3JvdXBzKSB7XG4gIGlmIChmbGFnc1tudW1lcmljXSkge1xuICAgIGZsYWdzW2FzY2lpbnVtZXJpY10gPSB0cnVlO1xuICAgIGZsYWdzW2FscGhhbnVtZXJpY10gPSB0cnVlO1xuICB9XG4gIGlmIChmbGFnc1thc2NpaV0pIHtcbiAgICBmbGFnc1thc2NpaW51bWVyaWNdID0gdHJ1ZTtcbiAgICBmbGFnc1thbHBoYV0gPSB0cnVlO1xuICB9XG4gIGlmIChmbGFnc1thc2NpaW51bWVyaWNdKSB7XG4gICAgZmxhZ3NbYWxwaGFudW1lcmljXSA9IHRydWU7XG4gIH1cbiAgaWYgKGZsYWdzW2FscGhhXSkge1xuICAgIGZsYWdzW2FscGhhbnVtZXJpY10gPSB0cnVlO1xuICB9XG4gIGlmIChmbGFnc1thbHBoYW51bWVyaWNdKSB7XG4gICAgZmxhZ3NbZG9tYWluXSA9IHRydWU7XG4gIH1cbiAgaWYgKGZsYWdzW2Vtb2ppXSkge1xuICAgIGZsYWdzW2RvbWFpbl0gPSB0cnVlO1xuICB9XG4gIGZvciAoY29uc3QgayBpbiBmbGFncykge1xuICAgIGNvbnN0IGdyb3VwID0gcmVnaXN0ZXJHcm91cChrLCBncm91cHMpO1xuICAgIGlmIChncm91cC5pbmRleE9mKHQpIDwgMCkge1xuICAgICAgZ3JvdXAucHVzaCh0KTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtUfSB0IHRva2VuIHRvIGNoZWNrXG4gKiBAcGFyYW0ge0NvbGxlY3Rpb25zPFQ+fSBncm91cHNcbiAqIEByZXR1cm5zIHtGbGFnc30gZ3JvdXAgZmxhZ3MgdGhhdCBjb250YWluIHRoaXMgdG9rZW5cbiAqL1xuZnVuY3Rpb24gZmxhZ3NGb3JUb2tlbih0LCBncm91cHMpIHtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGZvciAoY29uc3QgYyBpbiBncm91cHMpIHtcbiAgICBpZiAoZ3JvdXBzW2NdLmluZGV4T2YodCkgPj0gMCkge1xuICAgICAgcmVzdWx0W2NdID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHR5cGVkZWYge251bGwgfCBUIH0gVHJhbnNpdGlvblxuICovXG5cbi8qKlxuICogRGVmaW5lIGEgYmFzaWMgc3RhdGUgbWFjaGluZSBzdGF0ZS4gaiBpcyB0aGUgbGlzdCBvZiBjaGFyYWN0ZXIgdHJhbnNpdGlvbnMsXG4gKiBqciBpcyB0aGUgbGlzdCBvZiByZWdleC1tYXRjaCB0cmFuc2l0aW9ucywgamQgaXMgdGhlIGRlZmF1bHQgc3RhdGUgdG9cbiAqIHRyYW5zaXRpb24gdG8gdCBpcyB0aGUgYWNjZXB0aW5nIHRva2VuIHR5cGUsIGlmIGFueS4gSWYgdGhpcyBpcyB0aGUgdGVybWluYWxcbiAqIHN0YXRlLCB0aGVuIGl0IGRvZXMgbm90IGVtaXQgYSB0b2tlbi5cbiAqXG4gKiBUaGUgdGVtcGxhdGUgdHlwZSBUIHJlcHJlc2VudHMgdGhlIHR5cGUgb2YgdGhlIHRva2VuIHRoaXMgc3RhdGUgYWNjZXB0cy4gVGhpc1xuICogc2hvdWxkIGJlIGEgc3RyaW5nIChzdWNoIGFzIG9mIHRoZSB0b2tlbiBleHBvcnRzIGluIGB0ZXh0LmpzYCkgb3IgYVxuICogTXVsdGlUb2tlbiBzdWJjbGFzcyAoZnJvbSBgbXVsdGkuanNgKVxuICpcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1R9IFt0b2tlbl0gVG9rZW4gdGhhdCB0aGlzIHN0YXRlIGVtaXRzXG4gKi9cbmZ1bmN0aW9uIFN0YXRlKHRva2VuID0gbnVsbCkge1xuICAvLyB0aGlzLm4gPSBudWxsOyAvLyBERUJVRzogU3RhdGUgbmFtZVxuICAvKiogQHR5cGUge3sgW2lucHV0OiBzdHJpbmddOiBTdGF0ZTxUPiB9fSBqICovXG4gIHRoaXMuaiA9IHt9OyAvLyBJTVBMRU1FTlRBVElPTiAxXG4gIC8vIHRoaXMuaiA9IFtdOyAvLyBJTVBMRU1FTlRBVElPTiAyXG4gIC8qKiBAdHlwZSB7W1JlZ0V4cCwgU3RhdGU8VD5dW119IGpyICovXG4gIHRoaXMuanIgPSBbXTtcbiAgLyoqIEB0eXBlIHs/U3RhdGU8VD59IGpkICovXG4gIHRoaXMuamQgPSBudWxsO1xuICAvKiogQHR5cGUgez9UfSB0ICovXG4gIHRoaXMudCA9IHRva2VuO1xufVxuXG4vKipcbiAqIFNjYW5uZXIgdG9rZW4gZ3JvdXBzXG4gKiBAdHlwZSBDb2xsZWN0aW9uczxzdHJpbmc+XG4gKi9cblN0YXRlLmdyb3VwcyA9IHt9O1xuU3RhdGUucHJvdG90eXBlID0ge1xuICBhY2NlcHRzKCkge1xuICAgIHJldHVybiAhIXRoaXMudDtcbiAgfSxcbiAgLyoqXG4gICAqIEZvbGxvdyBhbiBleGlzdGluZyB0cmFuc2l0aW9uIGZyb20gdGhlIGdpdmVuIGlucHV0IHRvIHRoZSBuZXh0IHN0YXRlLlxuICAgKiBEb2VzIG5vdCBtdXRhdGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dCBjaGFyYWN0ZXIgb3IgdG9rZW4gdHlwZSB0byB0cmFuc2l0aW9uIG9uXG4gICAqIEByZXR1cm5zIHs/U3RhdGU8VD59IHRoZSBuZXh0IHN0YXRlLCBpZiBhbnlcbiAgICovXG4gIGdvKGlucHV0KSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzO1xuICAgIGNvbnN0IG5leHRTdGF0ZSA9IHN0YXRlLmpbaW5wdXRdO1xuICAgIGlmIChuZXh0U3RhdGUpIHtcbiAgICAgIHJldHVybiBuZXh0U3RhdGU7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdGUuanIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHJlZ2V4ID0gc3RhdGUuanJbaV1bMF07XG4gICAgICBjb25zdCBuZXh0U3RhdGUgPSBzdGF0ZS5qcltpXVsxXTsgLy8gbm90ZTogbWlnaHQgYmUgZW1wdHkgdG8gcHJldmVudCBkZWZhdWx0IGp1bXBcbiAgICAgIGlmIChuZXh0U3RhdGUgJiYgcmVnZXgudGVzdChpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIG5leHRTdGF0ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gTm93aGVyZSBsZWZ0IHRvIGp1bXAhIFJldHVybiBkZWZhdWx0LCBpZiBhbnlcbiAgICByZXR1cm4gc3RhdGUuamQ7XG4gIH0sXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBzdGF0ZSBoYXMgYSB0cmFuc2l0aW9uIGZvciB0aGUgZ2l2ZW4gaW5wdXQuIFNldCB0aGUgc2Vjb25kXG4gICAqIGFyZ3VtZW50IHRvIHRydWUgdG8gb25seSBsb29rIGZvciBhbiBleGFjdCBtYXRjaCAoYW5kIG5vdCBhIGRlZmF1bHQgb3JcbiAgICogcmVndWxhci1leHByZXNzaW9uLWJhc2VkIHRyYW5zaXRpb24pXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGV4YWN0T25seVxuICAgKi9cbiAgaGFzKGlucHV0LCBleGFjdE9ubHkgPSBmYWxzZSkge1xuICAgIHJldHVybiBleGFjdE9ubHkgPyBpbnB1dCBpbiB0aGlzLmogOiAhIXRoaXMuZ28oaW5wdXQpO1xuICB9LFxuICAvKipcbiAgICogU2hvcnQgZm9yIFwidHJhbnNpdGlvbiBhbGxcIjsgY3JlYXRlIGEgdHJhbnNpdGlvbiBmcm9tIHRoZSBhcnJheSBvZiBpdGVtc1xuICAgKiBpbiB0aGUgZ2l2ZW4gbGlzdCB0byB0aGUgc2FtZSBmaW5hbCByZXN1bHRpbmcgc3RhdGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgc3RyaW5nW119IGlucHV0cyBHcm91cCBvZiBpbnB1dHMgdG8gdHJhbnNpdGlvbiBvblxuICAgKiBAcGFyYW0ge1RyYW5zaXRpb248VD4gfCBTdGF0ZTxUPn0gW25leHRdIFRyYW5zaXRpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0ge0ZsYWdzfSBbZmxhZ3NdIENvbGxlY3Rpb25zIGZsYWdzIHRvIGFkZCB0b2tlbiB0b1xuICAgKiBAcGFyYW0ge0NvbGxlY3Rpb25zPFQ+fSBbZ3JvdXBzXSBNYXN0ZXIgbGlzdCBvZiB0b2tlbiBncm91cHNcbiAgICovXG4gIHRhKGlucHV0cywgbmV4dCwgZmxhZ3MsIGdyb3Vwcykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLnR0KGlucHV0c1tpXSwgbmV4dCwgZmxhZ3MsIGdyb3Vwcyk7XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogU2hvcnQgZm9yIFwidGFrZSByZWdleHAgdHJhbnNpdGlvblwiOyBkZWZpbmVzIGEgdHJhbnNpdGlvbiBmb3IgdGhpcyBzdGF0ZVxuICAgKiB3aGVuIGl0IGVuY291bnRlcnMgYSB0b2tlbiB3aGljaCBtYXRjaGVzIHRoZSBnaXZlbiByZWd1bGFyIGV4cHJlc3Npb25cbiAgICogQHBhcmFtIHtSZWdFeHB9IHJlZ2V4cCBSZWd1bGFyIGV4cHJlc3Npb24gdHJhbnNpdGlvbiAocG9wdWxhdGUgZmlyc3QpXG4gICAqIEBwYXJhbSB7VCB8IFN0YXRlPFQ+fSBbbmV4dF0gVHJhbnNpdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSB7RmxhZ3N9IFtmbGFnc10gQ29sbGVjdGlvbnMgZmxhZ3MgdG8gYWRkIHRva2VuIHRvXG4gICAqIEBwYXJhbSB7Q29sbGVjdGlvbnM8VD59IFtncm91cHNdIE1hc3RlciBsaXN0IG9mIHRva2VuIGdyb3Vwc1xuICAgKiBAcmV0dXJucyB7U3RhdGU8VD59IHRha2VuIGFmdGVyIHRoZSBnaXZlbiBpbnB1dFxuICAgKi9cbiAgdHIocmVnZXhwLCBuZXh0LCBmbGFncywgZ3JvdXBzKSB7XG4gICAgZ3JvdXBzID0gZ3JvdXBzIHx8IFN0YXRlLmdyb3VwcztcbiAgICBsZXQgbmV4dFN0YXRlO1xuICAgIGlmIChuZXh0ICYmIG5leHQuaikge1xuICAgICAgbmV4dFN0YXRlID0gbmV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVG9rZW4gd2l0aCBtYXliZSB0b2tlbiBncm91cHNcbiAgICAgIG5leHRTdGF0ZSA9IG5ldyBTdGF0ZShuZXh0KTtcbiAgICAgIGlmIChmbGFncyAmJiBncm91cHMpIHtcbiAgICAgICAgYWRkVG9Hcm91cHMobmV4dCwgZmxhZ3MsIGdyb3Vwcyk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuanIucHVzaChbcmVnZXhwLCBuZXh0U3RhdGVdKTtcbiAgICByZXR1cm4gbmV4dFN0YXRlO1xuICB9LFxuICAvKipcbiAgICogU2hvcnQgZm9yIFwidGFrZSB0cmFuc2l0aW9uc1wiLCB3aWxsIHRha2UgYXMgbWFueSBzZXF1ZW50aWFsIHRyYW5zaXRpb25zIGFzXG4gICAqIHRoZSBsZW5ndGggb2YgdGhlIGdpdmVuIGlucHV0IGFuZCByZXR1cm5zIHRoZVxuICAgKiByZXN1bHRpbmcgZmluYWwgc3RhdGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgc3RyaW5nW119IGlucHV0XG4gICAqIEBwYXJhbSB7VCB8IFN0YXRlPFQ+fSBbbmV4dF0gVHJhbnNpdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSB7RmxhZ3N9IFtmbGFnc10gQ29sbGVjdGlvbnMgZmxhZ3MgdG8gYWRkIHRva2VuIHRvXG4gICAqIEBwYXJhbSB7Q29sbGVjdGlvbnM8VD59IFtncm91cHNdIE1hc3RlciBsaXN0IG9mIHRva2VuIGdyb3Vwc1xuICAgKiBAcmV0dXJucyB7U3RhdGU8VD59IHRha2VuIGFmdGVyIHRoZSBnaXZlbiBpbnB1dFxuICAgKi9cbiAgdHMoaW5wdXQsIG5leHQsIGZsYWdzLCBncm91cHMpIHtcbiAgICBsZXQgc3RhdGUgPSB0aGlzO1xuICAgIGNvbnN0IGxlbiA9IGlucHV0Lmxlbmd0aDtcbiAgICBpZiAoIWxlbikge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbiAtIDE7IGkrKykge1xuICAgICAgc3RhdGUgPSBzdGF0ZS50dChpbnB1dFtpXSk7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZS50dChpbnB1dFtsZW4gLSAxXSwgbmV4dCwgZmxhZ3MsIGdyb3Vwcyk7XG4gIH0sXG4gIC8qKlxuICAgKiBTaG9ydCBmb3IgXCJ0YWtlIHRyYW5zaXRpb25cIiwgdGhpcyBpcyBhIG1ldGhvZCBmb3IgYnVpbGRpbmcvd29ya2luZyB3aXRoXG4gICAqIHN0YXRlIG1hY2hpbmVzLlxuICAgKlxuICAgKiBJZiBhIHN0YXRlIGFscmVhZHkgZXhpc3RzIGZvciB0aGUgZ2l2ZW4gaW5wdXQsIHJldHVybnMgaXQuXG4gICAqXG4gICAqIElmIGEgdG9rZW4gaXMgc3BlY2lmaWVkLCB0aGF0IHN0YXRlIHdpbGwgZW1pdCB0aGF0IHRva2VuIHdoZW4gcmVhY2hlZCBieVxuICAgKiB0aGUgbGlua2lmeSBlbmdpbmUuXG4gICAqXG4gICAqIElmIG5vIHN0YXRlIGV4aXN0cywgaXQgd2lsbCBiZSBpbml0aWFsaXplZCB3aXRoIHNvbWUgZGVmYXVsdCB0cmFuc2l0aW9uc1xuICAgKiB0aGF0IHJlc2VtYmxlIGV4aXN0aW5nIGRlZmF1bHQgdHJhbnNpdGlvbnMuXG4gICAqXG4gICAqIElmIGEgc3RhdGUgaXMgZ2l2ZW4gZm9yIHRoZSBzZWNvbmQgYXJndW1lbnQsIHRoYXQgc3RhdGUgd2lsbCBiZVxuICAgKiB0cmFuc2l0aW9uZWQgdG8gb24gdGhlIGdpdmVuIGlucHV0IHJlZ2FyZGxlc3Mgb2Ygd2hhdCB0aGF0IGlucHV0XG4gICAqIHByZXZpb3VzbHkgZGlkLlxuICAgKlxuICAgKiBTcGVjaWZ5IGEgdG9rZW4gZ3JvdXAgZmxhZ3MgdG8gZGVmaW5lIGdyb3VwcyB0aGF0IHRoaXMgdG9rZW4gYmVsb25ncyB0by5cbiAgICogVGhlIHRva2VuIHdpbGwgYmUgYWRkZWQgdG8gY29ycmVzcG9uZGluZyBlbnRpcmVzIGluIHRoZSBnaXZlbiBncm91cHNcbiAgICogb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaW5wdXQgY2hhcmFjdGVyLCB0b2tlbiB0eXBlIHRvIHRyYW5zaXRpb24gb25cbiAgICogQHBhcmFtIHtUIHwgU3RhdGU8VD59IFtuZXh0XSBUcmFuc2l0aW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIHtGbGFnc30gW2ZsYWdzXSBDb2xsZWN0aW9ucyBmbGFncyB0byBhZGQgdG9rZW4gdG9cbiAgICogQHBhcmFtIHtDb2xsZWN0aW9uczxUPn0gW2dyb3Vwc10gTWFzdGVyIGxpc3Qgb2YgZ3JvdXBzXG4gICAqIEByZXR1cm5zIHtTdGF0ZTxUPn0gdGFrZW4gYWZ0ZXIgdGhlIGdpdmVuIGlucHV0XG4gICAqL1xuICB0dChpbnB1dCwgbmV4dCwgZmxhZ3MsIGdyb3Vwcykge1xuICAgIGdyb3VwcyA9IGdyb3VwcyB8fCBTdGF0ZS5ncm91cHM7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzO1xuXG4gICAgLy8gQ2hlY2sgaWYgZXhpc3Rpbmcgc3RhdGUgZ2l2ZW4sIGp1c3QgYSBiYXNpYyB0cmFuc2l0aW9uXG4gICAgaWYgKG5leHQgJiYgbmV4dC5qKSB7XG4gICAgICBzdGF0ZS5qW2lucHV0XSA9IG5leHQ7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9XG4gICAgY29uc3QgdCA9IG5leHQ7XG5cbiAgICAvLyBUYWtlIHRoZSB0cmFuc2l0aW9uIHdpdGggdGhlIHVzdWFsIGRlZmF1bHQgbWVjaGFuaXNtcyBhbmQgdXNlIHRoYXQgYXNcbiAgICAvLyBhIHRlbXBsYXRlIGZvciBjcmVhdGluZyB0aGUgbmV4dCBzdGF0ZVxuICAgIGxldCBuZXh0U3RhdGUsXG4gICAgICB0ZW1wbGF0ZVN0YXRlID0gc3RhdGUuZ28oaW5wdXQpO1xuICAgIGlmICh0ZW1wbGF0ZVN0YXRlKSB7XG4gICAgICBuZXh0U3RhdGUgPSBuZXcgU3RhdGUoKTtcbiAgICAgIE9iamVjdC5hc3NpZ24obmV4dFN0YXRlLmosIHRlbXBsYXRlU3RhdGUuaik7XG4gICAgICBuZXh0U3RhdGUuanIucHVzaC5hcHBseShuZXh0U3RhdGUuanIsIHRlbXBsYXRlU3RhdGUuanIpO1xuICAgICAgbmV4dFN0YXRlLmpkID0gdGVtcGxhdGVTdGF0ZS5qZDtcbiAgICAgIG5leHRTdGF0ZS50ID0gdGVtcGxhdGVTdGF0ZS50O1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0U3RhdGUgPSBuZXcgU3RhdGUoKTtcbiAgICB9XG4gICAgaWYgKHQpIHtcbiAgICAgIC8vIEVuc3VyZSBuZXdseSB0b2tlbiBpcyBpbiB0aGUgc2FtZSBncm91cHMgYXMgdGhlIG9sZCB0b2tlblxuICAgICAgaWYgKGdyb3Vwcykge1xuICAgICAgICBpZiAobmV4dFN0YXRlLnQgJiYgdHlwZW9mIG5leHRTdGF0ZS50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGNvbnN0IGFsbEZsYWdzID0gT2JqZWN0LmFzc2lnbihmbGFnc0ZvclRva2VuKG5leHRTdGF0ZS50LCBncm91cHMpLCBmbGFncyk7XG4gICAgICAgICAgYWRkVG9Hcm91cHModCwgYWxsRmxhZ3MsIGdyb3Vwcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoZmxhZ3MpIHtcbiAgICAgICAgICBhZGRUb0dyb3Vwcyh0LCBmbGFncywgZ3JvdXBzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbmV4dFN0YXRlLnQgPSB0OyAvLyBvdmVyd3JpdGUgYW55dGhpbmcgdGhhdCB3YXMgcHJldmlvdXNseSB0aGVyZVxuICAgIH1cbiAgICBzdGF0ZS5qW2lucHV0XSA9IG5leHRTdGF0ZTtcbiAgICByZXR1cm4gbmV4dFN0YXRlO1xuICB9XG59O1xuXG4vLyBIZWxwZXIgZnVuY3Rpb25zIHRvIGltcHJvdmUgbWluaWZpY2F0aW9uIChub3QgZXhwb3J0ZWQgb3V0c2lkZSBsaW5raWZ5anMgbW9kdWxlKVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1N0YXRlPFQ+fSBzdGF0ZVxuICogQHBhcmFtIHtzdHJpbmcgfCBzdHJpbmdbXX0gaW5wdXRcbiAqIEBwYXJhbSB7RmxhZ3N9IFtmbGFnc11cbiAqIEBwYXJhbSB7Q29sbGVjdGlvbnM8VD59IFtncm91cHNdXG4gKi9cbmNvbnN0IHRhID0gKHN0YXRlLCBpbnB1dCwgbmV4dCwgZmxhZ3MsIGdyb3VwcykgPT4gc3RhdGUudGEoaW5wdXQsIG5leHQsIGZsYWdzLCBncm91cHMpO1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1N0YXRlPFQ+fSBzdGF0ZVxuICogQHBhcmFtIHtSZWdFeHB9IHJlZ2V4cFxuICogQHBhcmFtIHtUIHwgU3RhdGU8VD59IFtuZXh0XVxuICogQHBhcmFtIHtGbGFnc30gW2ZsYWdzXVxuICogQHBhcmFtIHtDb2xsZWN0aW9uczxUPn0gW2dyb3Vwc11cbiAqL1xuY29uc3QgdHIgPSAoc3RhdGUsIHJlZ2V4cCwgbmV4dCwgZmxhZ3MsIGdyb3VwcykgPT4gc3RhdGUudHIocmVnZXhwLCBuZXh0LCBmbGFncywgZ3JvdXBzKTtcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtTdGF0ZTxUPn0gc3RhdGVcbiAqIEBwYXJhbSB7c3RyaW5nIHwgc3RyaW5nW119IGlucHV0XG4gKiBAcGFyYW0ge1QgfCBTdGF0ZTxUPn0gW25leHRdXG4gKiBAcGFyYW0ge0ZsYWdzfSBbZmxhZ3NdXG4gKiBAcGFyYW0ge0NvbGxlY3Rpb25zPFQ+fSBbZ3JvdXBzXVxuICovXG5jb25zdCB0cyA9IChzdGF0ZSwgaW5wdXQsIG5leHQsIGZsYWdzLCBncm91cHMpID0+IHN0YXRlLnRzKGlucHV0LCBuZXh0LCBmbGFncywgZ3JvdXBzKTtcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtTdGF0ZTxUPn0gc3RhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dFxuICogQHBhcmFtIHtUIHwgU3RhdGU8VD59IFtuZXh0XVxuICogQHBhcmFtIHtDb2xsZWN0aW9uczxUPn0gW2dyb3Vwc11cbiAqIEBwYXJhbSB7RmxhZ3N9IFtmbGFnc11cbiAqL1xuY29uc3QgdHQgPSAoc3RhdGUsIGlucHV0LCBuZXh0LCBmbGFncywgZ3JvdXBzKSA9PiBzdGF0ZS50dChpbnB1dCwgbmV4dCwgZmxhZ3MsIGdyb3Vwcyk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblRleHQgVG9rZW5zXG5JZGVudGlmaWVycyBmb3IgdG9rZW4gb3V0cHV0cyBmcm9tIHRoZSByZWdleHAgc2Nhbm5lclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vLyBBIHZhbGlkIHdlYiBkb21haW4gdG9rZW5cbmNvbnN0IFdPUkQgPSAnV09SRCc7IC8vIG9ubHkgY29udGFpbnMgYS16XG5jb25zdCBVV09SRCA9ICdVV09SRCc7IC8vIGNvbnRhaW5zIGxldHRlcnMgb3RoZXIgdGhhbiBhLXosIHVzZWQgZm9yIElETlxuY29uc3QgQVNDSUlOVU1FUklDQUwgPSAnQVNDSUlOVU1FUklDQUwnOyAvLyBjb250YWlucyBhLXosIDAtOVxuY29uc3QgQUxQSEFOVU1FUklDQUwgPSAnQUxQSEFOVU1FUklDQUwnOyAvLyBjb250YWlucyBudW1iZXJzIGFuZCBsZXR0ZXJzIG90aGVyIHRoYW4gYS16LCB1c2VkIGZvciBJRE5cblxuLy8gU3BlY2lhbCBjYXNlIG9mIHdvcmRcbmNvbnN0IExPQ0FMSE9TVCA9ICdMT0NBTEhPU1QnO1xuXG4vLyBWYWxpZCB0b3AtbGV2ZWwgZG9tYWluLCBzcGVjaWFsIGNhc2Ugb2YgV09SRCAoc2VlIHRsZHMuanMpXG5jb25zdCBUTEQgPSAnVExEJztcblxuLy8gVmFsaWQgSUROIFRMRCwgc3BlY2lhbCBjYXNlIG9mIFVXT1JEIChzZWUgdGxkcy5qcylcbmNvbnN0IFVUTEQgPSAnVVRMRCc7XG5cbi8vIFRoZSBzY2hlbWUgcG9ydGlvbiBvZiBhIHdlYiBVUkkgcHJvdG9jb2wuIFN1cHBvcnRlZCB0eXBlcyBpbmNsdWRlOiBgbWFpbHRvYCxcbi8vIGBmaWxlYCwgYW5kIHVzZXItZGVmaW5lZCBjdXN0b20gcHJvdG9jb2xzLiBMaW1pdGVkIHRvIHNjaGVtZXMgdGhhdCBjb250YWluXG4vLyBvbmx5IGxldHRlcnNcbmNvbnN0IFNDSEVNRSA9ICdTQ0hFTUUnO1xuXG4vLyBTaW1pbGFyIHRvIFNDSEVNRSwgZXhjZXB0IG1ha2VzIGRpc3RpbmN0aW9uIGZvciBzY2hlbWVzIHRoYXQgbXVzdCBhbHdheXMgYmVcbi8vIGZvbGxvd2VkIGJ5IGA6Ly9gLCBub3QganVzdCBgOmAuIFN1cHBvcnRlZCB0eXBlcyBpbmNsdWRlIGBodHRwYCwgYGh0dHBzYCxcbi8vIGBmdHBgLCBgZnRwc2BcbmNvbnN0IFNMQVNIX1NDSEVNRSA9ICdTTEFTSF9TQ0hFTUUnO1xuXG4vLyBBbnkgc2VxdWVuY2Ugb2YgZGlnaXRzIDAtOVxuY29uc3QgTlVNID0gJ05VTSc7XG5cbi8vIEFueSBudW1iZXIgb2YgY29uc2VjdXRpdmUgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzIHRoYXQgYXJlIG5vdCBuZXdsaW5lXG5jb25zdCBXUyA9ICdXUyc7XG5cbi8vIE5ldyBsaW5lICh1bml4IHN0eWxlKVxuY29uc3QgTkwgPSAnTkwnOyAvLyBcXG5cblxuLy8gT3BlbmluZy9jbG9zaW5nIGJyYWNrZXQgY2xhc3Nlc1xuLy8gVE9ETzogUmVuYW1lIE9QRU4gLT4gTEVGVCBhbmQgQ0xPU0UgLT4gUklHSFQgaW4gdjUgdG8gZml0IHdpdGggVW5pY29kZSBuYW1lc1xuLy8gQWxzbyByZW5hbWUgYW5nbGUgYnJhY2tlcyB0byBMRVNTVEhBTiBhbmQgR1JFQVRFUiBUSEFOXG5jb25zdCBPUEVOQlJBQ0UgPSAnT1BFTkJSQUNFJzsgLy8ge1xuY29uc3QgQ0xPU0VCUkFDRSA9ICdDTE9TRUJSQUNFJzsgLy8gfVxuY29uc3QgT1BFTkJSQUNLRVQgPSAnT1BFTkJSQUNLRVQnOyAvLyBbXG5jb25zdCBDTE9TRUJSQUNLRVQgPSAnQ0xPU0VCUkFDS0VUJzsgLy8gXVxuY29uc3QgT1BFTlBBUkVOID0gJ09QRU5QQVJFTic7IC8vIChcbmNvbnN0IENMT1NFUEFSRU4gPSAnQ0xPU0VQQVJFTic7IC8vIClcbmNvbnN0IE9QRU5BTkdMRUJSQUNLRVQgPSAnT1BFTkFOR0xFQlJBQ0tFVCc7IC8vIDxcbmNvbnN0IENMT1NFQU5HTEVCUkFDS0VUID0gJ0NMT1NFQU5HTEVCUkFDS0VUJzsgLy8gPlxuY29uc3QgRlVMTFdJRFRITEVGVFBBUkVOID0gJ0ZVTExXSURUSExFRlRQQVJFTic7IC8vIO+8iFxuY29uc3QgRlVMTFdJRFRIUklHSFRQQVJFTiA9ICdGVUxMV0lEVEhSSUdIVFBBUkVOJzsgLy8g77yJXG5jb25zdCBMRUZUQ09STkVSQlJBQ0tFVCA9ICdMRUZUQ09STkVSQlJBQ0tFVCc7IC8vIOOAjFxuY29uc3QgUklHSFRDT1JORVJCUkFDS0VUID0gJ1JJR0hUQ09STkVSQlJBQ0tFVCc7IC8vIOOAjVxuY29uc3QgTEVGVFdISVRFQ09STkVSQlJBQ0tFVCA9ICdMRUZUV0hJVEVDT1JORVJCUkFDS0VUJzsgLy8g44COXG5jb25zdCBSSUdIVFdISVRFQ09STkVSQlJBQ0tFVCA9ICdSSUdIVFdISVRFQ09STkVSQlJBQ0tFVCc7IC8vIOOAj1xuY29uc3QgRlVMTFdJRFRITEVTU1RIQU4gPSAnRlVMTFdJRFRITEVTU1RIQU4nOyAvLyDvvJxcbmNvbnN0IEZVTExXSURUSEdSRUFURVJUSEFOID0gJ0ZVTExXSURUSEdSRUFURVJUSEFOJzsgLy8g77yeXG5cbi8vIFZhcmlvdXMgc3ltYm9sc1xuY29uc3QgQU1QRVJTQU5EID0gJ0FNUEVSU0FORCc7IC8vICZcbmNvbnN0IEFQT1NUUk9QSEUgPSAnQVBPU1RST1BIRSc7IC8vICdcbmNvbnN0IEFTVEVSSVNLID0gJ0FTVEVSSVNLJzsgLy8gKlxuY29uc3QgQVQgPSAnQVQnOyAvLyBAXG5jb25zdCBCQUNLU0xBU0ggPSAnQkFDS1NMQVNIJzsgLy8gXFxcbmNvbnN0IEJBQ0tUSUNLID0gJ0JBQ0tUSUNLJzsgLy8gYFxuY29uc3QgQ0FSRVQgPSAnQ0FSRVQnOyAvLyBeXG5jb25zdCBDT0xPTiA9ICdDT0xPTic7IC8vIDpcbmNvbnN0IENPTU1BID0gJ0NPTU1BJzsgLy8gLFxuY29uc3QgRE9MTEFSID0gJ0RPTExBUic7IC8vICRcbmNvbnN0IERPVCA9ICdET1QnOyAvLyAuXG5jb25zdCBFUVVBTFMgPSAnRVFVQUxTJzsgLy8gPVxuY29uc3QgRVhDTEFNQVRJT04gPSAnRVhDTEFNQVRJT04nOyAvLyAhXG5jb25zdCBIWVBIRU4gPSAnSFlQSEVOJzsgLy8gLVxuY29uc3QgUEVSQ0VOVCA9ICdQRVJDRU5UJzsgLy8gJVxuY29uc3QgUElQRSA9ICdQSVBFJzsgLy8gfFxuY29uc3QgUExVUyA9ICdQTFVTJzsgLy8gK1xuY29uc3QgUE9VTkQgPSAnUE9VTkQnOyAvLyAjXG5jb25zdCBRVUVSWSA9ICdRVUVSWSc7IC8vID9cbmNvbnN0IFFVT1RFID0gJ1FVT1RFJzsgLy8gXCJcbmNvbnN0IEZVTExXSURUSE1JRERMRURPVCA9ICdGVUxMV0lEVEhNSURETEVET1QnOyAvLyDjg7tcblxuY29uc3QgU0VNSSA9ICdTRU1JJzsgLy8gO1xuY29uc3QgU0xBU0ggPSAnU0xBU0gnOyAvLyAvXG5jb25zdCBUSUxERSA9ICdUSUxERSc7IC8vIH5cbmNvbnN0IFVOREVSU0NPUkUgPSAnVU5ERVJTQ09SRSc7IC8vIF9cblxuLy8gRW1vamkgc3ltYm9sXG5jb25zdCBFTU9KSSQxID0gJ0VNT0pJJztcblxuLy8gRGVmYXVsdCB0b2tlbiAtIGFueXRoaW5nIHRoYXQgaXMgbm90IG9uZSBvZiB0aGUgYWJvdmVcbmNvbnN0IFNZTSA9ICdTWU0nO1xuXG52YXIgdGsgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5cdF9fcHJvdG9fXzogbnVsbCxcblx0QUxQSEFOVU1FUklDQUw6IEFMUEhBTlVNRVJJQ0FMLFxuXHRBTVBFUlNBTkQ6IEFNUEVSU0FORCxcblx0QVBPU1RST1BIRTogQVBPU1RST1BIRSxcblx0QVNDSUlOVU1FUklDQUw6IEFTQ0lJTlVNRVJJQ0FMLFxuXHRBU1RFUklTSzogQVNURVJJU0ssXG5cdEFUOiBBVCxcblx0QkFDS1NMQVNIOiBCQUNLU0xBU0gsXG5cdEJBQ0tUSUNLOiBCQUNLVElDSyxcblx0Q0FSRVQ6IENBUkVULFxuXHRDTE9TRUFOR0xFQlJBQ0tFVDogQ0xPU0VBTkdMRUJSQUNLRVQsXG5cdENMT1NFQlJBQ0U6IENMT1NFQlJBQ0UsXG5cdENMT1NFQlJBQ0tFVDogQ0xPU0VCUkFDS0VULFxuXHRDTE9TRVBBUkVOOiBDTE9TRVBBUkVOLFxuXHRDT0xPTjogQ09MT04sXG5cdENPTU1BOiBDT01NQSxcblx0RE9MTEFSOiBET0xMQVIsXG5cdERPVDogRE9ULFxuXHRFTU9KSTogRU1PSkkkMSxcblx0RVFVQUxTOiBFUVVBTFMsXG5cdEVYQ0xBTUFUSU9OOiBFWENMQU1BVElPTixcblx0RlVMTFdJRFRIR1JFQVRFUlRIQU46IEZVTExXSURUSEdSRUFURVJUSEFOLFxuXHRGVUxMV0lEVEhMRUZUUEFSRU46IEZVTExXSURUSExFRlRQQVJFTixcblx0RlVMTFdJRFRITEVTU1RIQU46IEZVTExXSURUSExFU1NUSEFOLFxuXHRGVUxMV0lEVEhNSURETEVET1Q6IEZVTExXSURUSE1JRERMRURPVCxcblx0RlVMTFdJRFRIUklHSFRQQVJFTjogRlVMTFdJRFRIUklHSFRQQVJFTixcblx0SFlQSEVOOiBIWVBIRU4sXG5cdExFRlRDT1JORVJCUkFDS0VUOiBMRUZUQ09STkVSQlJBQ0tFVCxcblx0TEVGVFdISVRFQ09STkVSQlJBQ0tFVDogTEVGVFdISVRFQ09STkVSQlJBQ0tFVCxcblx0TE9DQUxIT1NUOiBMT0NBTEhPU1QsXG5cdE5MOiBOTCxcblx0TlVNOiBOVU0sXG5cdE9QRU5BTkdMRUJSQUNLRVQ6IE9QRU5BTkdMRUJSQUNLRVQsXG5cdE9QRU5CUkFDRTogT1BFTkJSQUNFLFxuXHRPUEVOQlJBQ0tFVDogT1BFTkJSQUNLRVQsXG5cdE9QRU5QQVJFTjogT1BFTlBBUkVOLFxuXHRQRVJDRU5UOiBQRVJDRU5ULFxuXHRQSVBFOiBQSVBFLFxuXHRQTFVTOiBQTFVTLFxuXHRQT1VORDogUE9VTkQsXG5cdFFVRVJZOiBRVUVSWSxcblx0UVVPVEU6IFFVT1RFLFxuXHRSSUdIVENPUk5FUkJSQUNLRVQ6IFJJR0hUQ09STkVSQlJBQ0tFVCxcblx0UklHSFRXSElURUNPUk5FUkJSQUNLRVQ6IFJJR0hUV0hJVEVDT1JORVJCUkFDS0VULFxuXHRTQ0hFTUU6IFNDSEVNRSxcblx0U0VNSTogU0VNSSxcblx0U0xBU0g6IFNMQVNILFxuXHRTTEFTSF9TQ0hFTUU6IFNMQVNIX1NDSEVNRSxcblx0U1lNOiBTWU0sXG5cdFRJTERFOiBUSUxERSxcblx0VExEOiBUTEQsXG5cdFVOREVSU0NPUkU6IFVOREVSU0NPUkUsXG5cdFVUTEQ6IFVUTEQsXG5cdFVXT1JEOiBVV09SRCxcblx0V09SRDogV09SRCxcblx0V1M6IFdTXG59KTtcblxuLy8gTm90ZSB0aGF0IHRoZXNlIHR3byBVbmljb2RlIG9uZXMgZXhwYW5kIGludG8gYSByZWFsbHkgYmlnIG9uZSB3aXRoIEJhYmVsXG5jb25zdCBBU0NJSV9MRVRURVIgPSAvW2Etel0vO1xuY29uc3QgTEVUVEVSID0gL1xccHtMfS91OyAvLyBBbnkgVW5pY29kZSBjaGFyYWN0ZXIgd2l0aCBsZXR0ZXIgZGF0YSB0eXBlXG5jb25zdCBFTU9KSSA9IC9cXHB7RW1vaml9L3U7IC8vIEFueSBVbmljb2RlIGVtb2ppIGNoYXJhY3RlclxuY29uc3QgRU1PSklfVkFSSUFUSU9OJDEgPSAvXFx1ZmUwZi87XG5jb25zdCBESUdJVCA9IC9cXGQvO1xuY29uc3QgU1BBQ0UgPSAvXFxzLztcblxudmFyIHJlZ2V4cCA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcblx0X19wcm90b19fOiBudWxsLFxuXHRBU0NJSV9MRVRURVI6IEFTQ0lJX0xFVFRFUixcblx0RElHSVQ6IERJR0lULFxuXHRFTU9KSTogRU1PSkksXG5cdEVNT0pJX1ZBUklBVElPTjogRU1PSklfVkFSSUFUSU9OJDEsXG5cdExFVFRFUjogTEVUVEVSLFxuXHRTUEFDRTogU1BBQ0Vcbn0pO1xuXG4vKipcblx0VGhlIHNjYW5uZXIgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIHRoYXQgdGFrZXMgYSBzdHJpbmcgb2YgdGV4dCBhcyBpbnB1dCwgYW5kXG5cdG91dHB1dHMgYW4gYXJyYXkgb2YgdG9rZW5zIGluc3RhbmNlcyB0aGF0IGNhbiBiZSB1c2VkIGZvciBlYXN5IFVSTCBwYXJzaW5nLlxuKi9cblxuY29uc3QgQ1IgPSAnXFxyJzsgLy8gY2FycmlhZ2UtcmV0dXJuIGNoYXJhY3RlclxuY29uc3QgTEYgPSAnXFxuJzsgLy8gbGluZS1mZWVkIGNoYXJhY3RlclxuY29uc3QgRU1PSklfVkFSSUFUSU9OID0gJ1xcdWZlMGYnOyAvLyBWYXJpYXRpb24gc2VsZWN0b3IsIGZvbGxvd3MgaGVhcnQgYW5kIG90aGVyc1xuY29uc3QgRU1PSklfSk9JTkVSID0gJ1xcdTIwMGQnOyAvLyB6ZXJvLXdpZHRoIGpvaW5lclxuY29uc3QgT0JKRUNUX1JFUExBQ0VNRU5UID0gJ1xcdWZmZmMnOyAvLyB3aGl0ZXNwYWNlIHBsYWNlaG9sZGVyIHRoYXQgc29tZXRpbWVzIGFwcGVhcnMgaW4gcmljaCB0ZXh0IGVkaXRvcnNcblxubGV0IHRsZHMgPSBudWxsLFxuICB1dGxkcyA9IG51bGw7IC8vIGRvbid0IGNoYW5nZSBzbyBvbmx5IGhhdmUgdG8gYmUgY29tcHV0ZWQgb25jZVxuXG4vKipcbiAqIFNjYW5uZXIgb3V0cHV0IHRva2VuOlxuICogLSBgdGAgaXMgdGhlIHRva2VuIG5hbWUgKGUuZy4sICdOVU0nLCAnRU1PSkknLCAnVExEJylcbiAqIC0gYHZgIGlzIHRoZSB2YWx1ZSBvZiB0aGUgdG9rZW4gKGUuZy4sICcxMjMnLCAn4p2k77iPJywgJ2NvbScpXG4gKiAtIGBzYCBpcyB0aGUgc3RhcnQgaW5kZXggb2YgdGhlIHRva2VuIGluIHRoZSBvcmlnaW5hbCBzdHJpbmdcbiAqIC0gYGVgIGlzIHRoZSBlbmQgaW5kZXggb2YgdGhlIHRva2VuIGluIHRoZSBvcmlnaW5hbCBzdHJpbmdcbiAqIEB0eXBlZGVmIHt7dDogc3RyaW5nLCB2OiBzdHJpbmcsIHM6IG51bWJlciwgZTogbnVtYmVyfX0gVG9rZW5cbiAqL1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAdHlwZWRlZiB7eyBbY29sbGVjdGlvbjogc3RyaW5nXTogVFtdIH19IENvbGxlY3Rpb25zXG4gKi9cblxuLyoqXG4gKiBJbml0aWFsaXplIHRoZSBzY2FubmVyIGNoYXJhY3Rlci1iYXNlZCBzdGF0ZSBtYWNoaW5lIGZvciB0aGUgZ2l2ZW4gc3RhcnRcbiAqIHN0YXRlXG4gKiBAcGFyYW0ge1tzdHJpbmcsIGJvb2xlYW5dW119IGN1c3RvbVNjaGVtZXMgTGlzdCBvZiBjdXN0b20gc2NoZW1lcywgd2hlcmUgZWFjaFxuICogaXRlbSBpcyBhIGxlbmd0aC0yIHR1cGxlIHdpdGggdGhlIGZpcnN0IGVsZW1lbnQgc2V0IHRvIHRoZSBzdHJpbmcgc2NoZW1lLCBhbmRcbiAqIHRoZSBzZWNvbmQgZWxlbWVudCBzZXQgdG8gYHRydWVgIGlmIHRoZSBgOi8vYCBhZnRlciB0aGUgc2NoZW1lIGlzIG9wdGlvbmFsXG4gKi9cbmZ1bmN0aW9uIGluaXQkMihjdXN0b21TY2hlbWVzID0gW10pIHtcbiAgLy8gRnJlcXVlbnRseSB1c2VkIHN0YXRlcyAobmFtZSBhcmd1bWVudCByZW1vdmVkIGR1cmluZyBtaW5pZmljYXRpb24pXG4gIC8qKiBAdHlwZSBDb2xsZWN0aW9uczxzdHJpbmc+ICovXG4gIGNvbnN0IGdyb3VwcyA9IHt9OyAvLyBvZiB0b2tlbnNcbiAgU3RhdGUuZ3JvdXBzID0gZ3JvdXBzO1xuICAvKiogQHR5cGUgU3RhdGU8c3RyaW5nPiAqL1xuICBjb25zdCBTdGFydCA9IG5ldyBTdGF0ZSgpO1xuICBpZiAodGxkcyA9PSBudWxsKSB7XG4gICAgdGxkcyA9IGRlY29kZVRsZHMoZW5jb2RlZFRsZHMpO1xuICB9XG4gIGlmICh1dGxkcyA9PSBudWxsKSB7XG4gICAgdXRsZHMgPSBkZWNvZGVUbGRzKGVuY29kZWRVdGxkcyk7XG4gIH1cblxuICAvLyBTdGF0ZXMgZm9yIHNwZWNpYWwgVVJMIHN5bWJvbHMgdGhhdCBhY2NlcHQgaW1tZWRpYXRlbHkgYWZ0ZXIgc3RhcnRcbiAgdHQoU3RhcnQsIFwiJ1wiLCBBUE9TVFJPUEhFKTtcbiAgdHQoU3RhcnQsICd7JywgT1BFTkJSQUNFKTtcbiAgdHQoU3RhcnQsICd9JywgQ0xPU0VCUkFDRSk7XG4gIHR0KFN0YXJ0LCAnWycsIE9QRU5CUkFDS0VUKTtcbiAgdHQoU3RhcnQsICddJywgQ0xPU0VCUkFDS0VUKTtcbiAgdHQoU3RhcnQsICcoJywgT1BFTlBBUkVOKTtcbiAgdHQoU3RhcnQsICcpJywgQ0xPU0VQQVJFTik7XG4gIHR0KFN0YXJ0LCAnPCcsIE9QRU5BTkdMRUJSQUNLRVQpO1xuICB0dChTdGFydCwgJz4nLCBDTE9TRUFOR0xFQlJBQ0tFVCk7XG4gIHR0KFN0YXJ0LCAn77yIJywgRlVMTFdJRFRITEVGVFBBUkVOKTtcbiAgdHQoU3RhcnQsICfvvIknLCBGVUxMV0lEVEhSSUdIVFBBUkVOKTtcbiAgdHQoU3RhcnQsICfjgIwnLCBMRUZUQ09STkVSQlJBQ0tFVCk7XG4gIHR0KFN0YXJ0LCAn44CNJywgUklHSFRDT1JORVJCUkFDS0VUKTtcbiAgdHQoU3RhcnQsICfjgI4nLCBMRUZUV0hJVEVDT1JORVJCUkFDS0VUKTtcbiAgdHQoU3RhcnQsICfjgI8nLCBSSUdIVFdISVRFQ09STkVSQlJBQ0tFVCk7XG4gIHR0KFN0YXJ0LCAn77ycJywgRlVMTFdJRFRITEVTU1RIQU4pO1xuICB0dChTdGFydCwgJ++8nicsIEZVTExXSURUSEdSRUFURVJUSEFOKTtcbiAgdHQoU3RhcnQsICcmJywgQU1QRVJTQU5EKTtcbiAgdHQoU3RhcnQsICcqJywgQVNURVJJU0spO1xuICB0dChTdGFydCwgJ0AnLCBBVCk7XG4gIHR0KFN0YXJ0LCAnYCcsIEJBQ0tUSUNLKTtcbiAgdHQoU3RhcnQsICdeJywgQ0FSRVQpO1xuICB0dChTdGFydCwgJzonLCBDT0xPTik7XG4gIHR0KFN0YXJ0LCAnLCcsIENPTU1BKTtcbiAgdHQoU3RhcnQsICckJywgRE9MTEFSKTtcbiAgdHQoU3RhcnQsICcuJywgRE9UKTtcbiAgdHQoU3RhcnQsICc9JywgRVFVQUxTKTtcbiAgdHQoU3RhcnQsICchJywgRVhDTEFNQVRJT04pO1xuICB0dChTdGFydCwgJy0nLCBIWVBIRU4pO1xuICB0dChTdGFydCwgJyUnLCBQRVJDRU5UKTtcbiAgdHQoU3RhcnQsICd8JywgUElQRSk7XG4gIHR0KFN0YXJ0LCAnKycsIFBMVVMpO1xuICB0dChTdGFydCwgJyMnLCBQT1VORCk7XG4gIHR0KFN0YXJ0LCAnPycsIFFVRVJZKTtcbiAgdHQoU3RhcnQsICdcIicsIFFVT1RFKTtcbiAgdHQoU3RhcnQsICcvJywgU0xBU0gpO1xuICB0dChTdGFydCwgJzsnLCBTRU1JKTtcbiAgdHQoU3RhcnQsICd+JywgVElMREUpO1xuICB0dChTdGFydCwgJ18nLCBVTkRFUlNDT1JFKTtcbiAgdHQoU3RhcnQsICdcXFxcJywgQkFDS1NMQVNIKTtcbiAgdHQoU3RhcnQsICfjg7snLCBGVUxMV0lEVEhNSURETEVET1QpO1xuICBjb25zdCBOdW0gPSB0cihTdGFydCwgRElHSVQsIE5VTSwge1xuICAgIFtudW1lcmljXTogdHJ1ZVxuICB9KTtcbiAgdHIoTnVtLCBESUdJVCwgTnVtKTtcbiAgY29uc3QgQXNjaWludW1lcmljID0gdHIoTnVtLCBBU0NJSV9MRVRURVIsIEFTQ0lJTlVNRVJJQ0FMLCB7XG4gICAgW2FzY2lpbnVtZXJpY106IHRydWVcbiAgfSk7XG4gIGNvbnN0IEFscGhhbnVtZXJpYyA9IHRyKE51bSwgTEVUVEVSLCBBTFBIQU5VTUVSSUNBTCwge1xuICAgIFthbHBoYW51bWVyaWNdOiB0cnVlXG4gIH0pO1xuXG4gIC8vIFN0YXRlIHdoaWNoIGVtaXRzIGEgd29yZCB0b2tlblxuICBjb25zdCBXb3JkID0gdHIoU3RhcnQsIEFTQ0lJX0xFVFRFUiwgV09SRCwge1xuICAgIFthc2NpaV06IHRydWVcbiAgfSk7XG4gIHRyKFdvcmQsIERJR0lULCBBc2NpaW51bWVyaWMpO1xuICB0cihXb3JkLCBBU0NJSV9MRVRURVIsIFdvcmQpO1xuICB0cihBc2NpaW51bWVyaWMsIERJR0lULCBBc2NpaW51bWVyaWMpO1xuICB0cihBc2NpaW51bWVyaWMsIEFTQ0lJX0xFVFRFUiwgQXNjaWludW1lcmljKTtcblxuICAvLyBTYW1lIGFzIHByZXZpb3VzLCBidXQgc3BlY2lmaWMgdG8gbm9uLWZzbS5hc2NpaSBhbHBoYWJldCB3b3Jkc1xuICBjb25zdCBVV29yZCA9IHRyKFN0YXJ0LCBMRVRURVIsIFVXT1JELCB7XG4gICAgW2FscGhhXTogdHJ1ZVxuICB9KTtcbiAgdHIoVVdvcmQsIEFTQ0lJX0xFVFRFUik7IC8vIE5vbi1hY2NlcHRpbmdcbiAgdHIoVVdvcmQsIERJR0lULCBBbHBoYW51bWVyaWMpO1xuICB0cihVV29yZCwgTEVUVEVSLCBVV29yZCk7XG4gIHRyKEFscGhhbnVtZXJpYywgRElHSVQsIEFscGhhbnVtZXJpYyk7XG4gIHRyKEFscGhhbnVtZXJpYywgQVNDSUlfTEVUVEVSKTsgLy8gTm9uLWFjY2VwdGluZ1xuICB0cihBbHBoYW51bWVyaWMsIExFVFRFUiwgQWxwaGFudW1lcmljKTsgLy8gTm9uLWFjY2VwdGluZ1xuXG4gIC8vIFdoaXRlc3BhY2UganVtcHNcbiAgLy8gVG9rZW5zIG9mIG9ubHkgbm9uLW5ld2xpbmUgd2hpdGVzcGFjZSBhcmUgYXJiaXRyYXJpbHkgbG9uZ1xuICAvLyBJZiBhbnkgd2hpdGVzcGFjZSBleGNlcHQgbmV3bGluZSwgbW9yZSB3aGl0ZXNwYWNlIVxuICBjb25zdCBObCA9IHR0KFN0YXJ0LCBMRiwgTkwsIHtcbiAgICBbd2hpdGVzcGFjZV06IHRydWVcbiAgfSk7XG4gIGNvbnN0IENyID0gdHQoU3RhcnQsIENSLCBXUywge1xuICAgIFt3aGl0ZXNwYWNlXTogdHJ1ZVxuICB9KTtcbiAgY29uc3QgV3MgPSB0cihTdGFydCwgU1BBQ0UsIFdTLCB7XG4gICAgW3doaXRlc3BhY2VdOiB0cnVlXG4gIH0pO1xuICB0dChTdGFydCwgT0JKRUNUX1JFUExBQ0VNRU5ULCBXcyk7XG4gIHR0KENyLCBMRiwgTmwpOyAvLyBcXHJcXG5cbiAgdHQoQ3IsIE9CSkVDVF9SRVBMQUNFTUVOVCwgV3MpO1xuICB0cihDciwgU1BBQ0UsIFdzKTtcbiAgdHQoV3MsIENSKTsgLy8gbm9uLWFjY2VwdGluZyBzdGF0ZSB0byBhdm9pZCBtaXhpbmcgd2hpdGVzcGFjZXNcbiAgdHQoV3MsIExGKTsgLy8gbm9uLWFjY2VwdGluZyBzdGF0ZSB0byBhdm9pZCBtaXhpbmcgd2hpdGVzcGFjZXNcbiAgdHIoV3MsIFNQQUNFLCBXcyk7XG4gIHR0KFdzLCBPQkpFQ1RfUkVQTEFDRU1FTlQsIFdzKTtcblxuICAvLyBFbW9qaSB0b2tlbnMuIFRoZXkgYXJlIG5vdCBncm91cGVkIGJ5IHRoZSBzY2FubmVyIGV4Y2VwdCBpbiBjYXNlcyB3aGVyZSBhXG4gIC8vIHplcm8td2lkdGggam9pbmVyIGlzIHByZXNlbnRcbiAgY29uc3QgRW1vamkgPSB0cihTdGFydCwgRU1PSkksIEVNT0pJJDEsIHtcbiAgICBbZW1vamldOiB0cnVlXG4gIH0pO1xuICB0dChFbW9qaSwgJyMnKTsgLy8gbm8gdHJhbnNpdGlvbiwgZW1vamkgcmVnZXggc2VlbXMgdG8gbWF0Y2ggI1xuICB0cihFbW9qaSwgRU1PSkksIEVtb2ppKTtcbiAgdHQoRW1vamksIEVNT0pJX1ZBUklBVElPTiwgRW1vamkpO1xuICAvLyB0dChTdGFydCwgRU1PSklfVkFSSUFUSU9OLCBFbW9qaSk7IC8vIFRoaXMgb25lIGlzIHNrZXRjaHlcblxuICBjb25zdCBFbW9qaUpvaW5lciA9IHR0KEVtb2ppLCBFTU9KSV9KT0lORVIpO1xuICB0dChFbW9qaUpvaW5lciwgJyMnKTtcbiAgdHIoRW1vamlKb2luZXIsIEVNT0pJLCBFbW9qaSk7XG4gIC8vIHR0KEVtb2ppSm9pbmVyLCBFTU9KSV9WQVJJQVRJT04sIEVtb2ppKTsgLy8gYWxzbyBza2V0Y2h5XG5cbiAgLy8gR2VuZXJhdGVzIHN0YXRlcyBmb3IgdG9wLWxldmVsIGRvbWFpbnNcbiAgLy8gTm90ZSB0aGF0IHRoaXMgaXMgbW9zdCBhY2N1cmF0ZSB3aGVuIHRsZHMgYXJlIGluIGFscGhhYmV0aWNhbCBvcmRlclxuICBjb25zdCB3b3JkanIgPSBbW0FTQ0lJX0xFVFRFUiwgV29yZF0sIFtESUdJVCwgQXNjaWludW1lcmljXV07XG4gIGNvbnN0IHV3b3JkanIgPSBbW0FTQ0lJX0xFVFRFUiwgbnVsbF0sIFtMRVRURVIsIFVXb3JkXSwgW0RJR0lULCBBbHBoYW51bWVyaWNdXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0bGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgZmFzdHRzKFN0YXJ0LCB0bGRzW2ldLCBUTEQsIFdPUkQsIHdvcmRqcik7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB1dGxkcy5sZW5ndGg7IGkrKykge1xuICAgIGZhc3R0cyhTdGFydCwgdXRsZHNbaV0sIFVUTEQsIFVXT1JELCB1d29yZGpyKTtcbiAgfVxuICBhZGRUb0dyb3VwcyhUTEQsIHtcbiAgICB0bGQ6IHRydWUsXG4gICAgYXNjaWk6IHRydWVcbiAgfSwgZ3JvdXBzKTtcbiAgYWRkVG9Hcm91cHMoVVRMRCwge1xuICAgIHV0bGQ6IHRydWUsXG4gICAgYWxwaGE6IHRydWVcbiAgfSwgZ3JvdXBzKTtcblxuICAvLyBDb2xsZWN0IHRoZSBzdGF0ZXMgZ2VuZXJhdGVkIGJ5IGRpZmZlcmVudCBwcm90b2NvbHMuIE5PVEU6IElmIGFueSBuZXcgVExEc1xuICAvLyBnZXQgYWRkZWQgdGhhdCBhcmUgYWxzbyBwcm90b2NvbHMsIHNldCB0aGUgdG9rZW4gdG8gYmUgdGhlIHNhbWUgYXMgdGhlXG4gIC8vIHByb3RvY29sIHRvIGVuc3VyZSBwYXJzaW5nIHdvcmtzIGFzIGV4cGVjdGVkLlxuICBmYXN0dHMoU3RhcnQsICdmaWxlJywgU0NIRU1FLCBXT1JELCB3b3JkanIpO1xuICBmYXN0dHMoU3RhcnQsICdtYWlsdG8nLCBTQ0hFTUUsIFdPUkQsIHdvcmRqcik7XG4gIGZhc3R0cyhTdGFydCwgJ2h0dHAnLCBTTEFTSF9TQ0hFTUUsIFdPUkQsIHdvcmRqcik7XG4gIGZhc3R0cyhTdGFydCwgJ2h0dHBzJywgU0xBU0hfU0NIRU1FLCBXT1JELCB3b3JkanIpO1xuICBmYXN0dHMoU3RhcnQsICdmdHAnLCBTTEFTSF9TQ0hFTUUsIFdPUkQsIHdvcmRqcik7XG4gIGZhc3R0cyhTdGFydCwgJ2Z0cHMnLCBTTEFTSF9TQ0hFTUUsIFdPUkQsIHdvcmRqcik7XG4gIGFkZFRvR3JvdXBzKFNDSEVNRSwge1xuICAgIHNjaGVtZTogdHJ1ZSxcbiAgICBhc2NpaTogdHJ1ZVxuICB9LCBncm91cHMpO1xuICBhZGRUb0dyb3VwcyhTTEFTSF9TQ0hFTUUsIHtcbiAgICBzbGFzaHNjaGVtZTogdHJ1ZSxcbiAgICBhc2NpaTogdHJ1ZVxuICB9LCBncm91cHMpO1xuXG4gIC8vIFJlZ2lzdGVyIGN1c3RvbSBzY2hlbWVzLiBBc3N1bWVzIGVhY2ggc2NoZW1lIGlzIGFzY2lpbnVtZXJpYyB3aXRoIGh5cGhlbnNcbiAgY3VzdG9tU2NoZW1lcyA9IGN1c3RvbVNjaGVtZXMuc29ydCgoYSwgYikgPT4gYVswXSA+IGJbMF0gPyAxIDogLTEpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGN1c3RvbVNjaGVtZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzY2ggPSBjdXN0b21TY2hlbWVzW2ldWzBdO1xuICAgIGNvbnN0IG9wdGlvbmFsU2xhc2hTbGFzaCA9IGN1c3RvbVNjaGVtZXNbaV1bMV07XG4gICAgY29uc3QgZmxhZ3MgPSBvcHRpb25hbFNsYXNoU2xhc2ggPyB7XG4gICAgICBbc2NoZW1lXTogdHJ1ZVxuICAgIH0gOiB7XG4gICAgICBbc2xhc2hzY2hlbWVdOiB0cnVlXG4gICAgfTtcbiAgICBpZiAoc2NoLmluZGV4T2YoJy0nKSA+PSAwKSB7XG4gICAgICBmbGFnc1tkb21haW5dID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKCFBU0NJSV9MRVRURVIudGVzdChzY2gpKSB7XG4gICAgICBmbGFnc1tudW1lcmljXSA9IHRydWU7IC8vIG51bWJlcnMgb25seVxuICAgIH0gZWxzZSBpZiAoRElHSVQudGVzdChzY2gpKSB7XG4gICAgICBmbGFnc1thc2NpaW51bWVyaWNdID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmxhZ3NbYXNjaWldID0gdHJ1ZTtcbiAgICB9XG4gICAgdHMoU3RhcnQsIHNjaCwgc2NoLCBmbGFncyk7XG4gIH1cblxuICAvLyBMb2NhbGhvc3QgdG9rZW5cbiAgdHMoU3RhcnQsICdsb2NhbGhvc3QnLCBMT0NBTEhPU1QsIHtcbiAgICBhc2NpaTogdHJ1ZVxuICB9KTtcblxuICAvLyBTZXQgZGVmYXVsdCB0cmFuc2l0aW9uIGZvciBzdGFydCBzdGF0ZSAoc29tZSBzeW1ib2wpXG4gIFN0YXJ0LmpkID0gbmV3IFN0YXRlKFNZTSk7XG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IFN0YXJ0LFxuICAgIHRva2VuczogT2JqZWN0LmFzc2lnbih7XG4gICAgICBncm91cHNcbiAgICB9LCB0aylcbiAgfTtcbn1cblxuLyoqXG5cdEdpdmVuIGEgc3RyaW5nLCByZXR1cm5zIGFuIGFycmF5IG9mIFRPS0VOIGluc3RhbmNlcyByZXByZXNlbnRpbmcgdGhlXG5cdGNvbXBvc2l0aW9uIG9mIHRoYXQgc3RyaW5nLlxuXG5cdEBtZXRob2QgcnVuXG5cdEBwYXJhbSB7U3RhdGU8c3RyaW5nPn0gc3RhcnQgc2Nhbm5lciBzdGFydGluZyBzdGF0ZVxuXHRAcGFyYW0ge3N0cmluZ30gc3RyIGlucHV0IHN0cmluZyB0byBzY2FuXG5cdEByZXR1cm4ge1Rva2VuW119IGxpc3Qgb2YgdG9rZW5zLCBlYWNoIHdpdGggYSB0eXBlIGFuZCB2YWx1ZVxuKi9cbmZ1bmN0aW9uIHJ1biQxKHN0YXJ0LCBzdHIpIHtcbiAgLy8gU3RhdGUgbWFjaGluZSBpcyBub3QgY2FzZSBzZW5zaXRpdmUsIHNvIGlucHV0IGlzIHRva2VuaXplZCBpbiBsb3dlcmNhc2VkXG4gIC8vIGZvcm0gKHN0aWxsIHJldHVybnMgcmVndWxhciBjYXNlKS4gVXNlcyBzZWxlY3RpdmUgYHRvTG93ZXJDYXNlYCBiZWNhdXNlXG4gIC8vIGxvd2VyY2FzaW5nIHRoZSBlbnRpcmUgc3RyaW5nIGNhdXNlcyB0aGUgbGVuZ3RoIGFuZCBjaGFyYWN0ZXIgcG9zaXRpb24gdG9cbiAgLy8gdmFyeSBpbiBzb21lIG5vbi1FbmdsaXNoIHN0cmluZ3Mgd2l0aCBWOC1iYXNlZCBydW50aW1lcy5cbiAgY29uc3QgaXRlcmFibGUgPSBzdHJpbmdUb0FycmF5KHN0ci5yZXBsYWNlKC9bQS1aXS9nLCBjID0+IGMudG9Mb3dlckNhc2UoKSkpO1xuICBjb25zdCBjaGFyQ291bnQgPSBpdGVyYWJsZS5sZW5ndGg7IC8vIDw9IGxlbiBpZiB0aGVyZSBhcmUgZW1vamlzLCBldGNcbiAgY29uc3QgdG9rZW5zID0gW107IC8vIHJldHVybiB2YWx1ZVxuXG4gIC8vIGN1cnNvciB0aHJvdWdoIHRoZSBzdHJpbmcgaXRzZWxmLCBhY2NvdW50aW5nIGZvciBjaGFyYWN0ZXJzIHRoYXQgaGF2ZVxuICAvLyB3aWR0aCB3aXRoIGxlbmd0aCAyIHN1Y2ggYXMgZW1vamlzXG4gIGxldCBjdXJzb3IgPSAwO1xuXG4gIC8vIEN1cnNvciB0aHJvdWdoIHRoZSBhcnJheS1yZXByZXNlbnRhdGlvbiBvZiB0aGUgc3RyaW5nXG4gIGxldCBjaGFyQ3Vyc29yID0gMDtcblxuICAvLyBUb2tlbml6ZSB0aGUgc3RyaW5nXG4gIHdoaWxlIChjaGFyQ3Vyc29yIDwgY2hhckNvdW50KSB7XG4gICAgbGV0IHN0YXRlID0gc3RhcnQ7XG4gICAgbGV0IG5leHRTdGF0ZSA9IG51bGw7XG4gICAgbGV0IHRva2VuTGVuZ3RoID0gMDtcbiAgICBsZXQgbGF0ZXN0QWNjZXB0aW5nID0gbnVsbDtcbiAgICBsZXQgc2luY2VBY2NlcHRzID0gLTE7XG4gICAgbGV0IGNoYXJzU2luY2VBY2NlcHRzID0gLTE7XG4gICAgd2hpbGUgKGNoYXJDdXJzb3IgPCBjaGFyQ291bnQgJiYgKG5leHRTdGF0ZSA9IHN0YXRlLmdvKGl0ZXJhYmxlW2NoYXJDdXJzb3JdKSkpIHtcbiAgICAgIHN0YXRlID0gbmV4dFN0YXRlO1xuXG4gICAgICAvLyBLZWVwIHRyYWNrIG9mIHRoZSBsYXRlc3QgYWNjZXB0aW5nIHN0YXRlXG4gICAgICBpZiAoc3RhdGUuYWNjZXB0cygpKSB7XG4gICAgICAgIHNpbmNlQWNjZXB0cyA9IDA7XG4gICAgICAgIGNoYXJzU2luY2VBY2NlcHRzID0gMDtcbiAgICAgICAgbGF0ZXN0QWNjZXB0aW5nID0gc3RhdGU7XG4gICAgICB9IGVsc2UgaWYgKHNpbmNlQWNjZXB0cyA+PSAwKSB7XG4gICAgICAgIHNpbmNlQWNjZXB0cyArPSBpdGVyYWJsZVtjaGFyQ3Vyc29yXS5sZW5ndGg7XG4gICAgICAgIGNoYXJzU2luY2VBY2NlcHRzKys7XG4gICAgICB9XG4gICAgICB0b2tlbkxlbmd0aCArPSBpdGVyYWJsZVtjaGFyQ3Vyc29yXS5sZW5ndGg7XG4gICAgICBjdXJzb3IgKz0gaXRlcmFibGVbY2hhckN1cnNvcl0ubGVuZ3RoO1xuICAgICAgY2hhckN1cnNvcisrO1xuICAgIH1cblxuICAgIC8vIFJvbGwgYmFjayB0byB0aGUgbGF0ZXN0IGFjY2VwdGluZyBzdGF0ZVxuICAgIGN1cnNvciAtPSBzaW5jZUFjY2VwdHM7XG4gICAgY2hhckN1cnNvciAtPSBjaGFyc1NpbmNlQWNjZXB0cztcbiAgICB0b2tlbkxlbmd0aCAtPSBzaW5jZUFjY2VwdHM7XG5cbiAgICAvLyBObyBtb3JlIGp1bXBzLCBqdXN0IG1ha2UgYSBuZXcgdG9rZW4gZnJvbSB0aGUgbGFzdCBhY2NlcHRpbmcgb25lXG4gICAgdG9rZW5zLnB1c2goe1xuICAgICAgdDogbGF0ZXN0QWNjZXB0aW5nLnQsXG4gICAgICAvLyB0b2tlbiB0eXBlL25hbWVcbiAgICAgIHY6IHN0ci5zbGljZShjdXJzb3IgLSB0b2tlbkxlbmd0aCwgY3Vyc29yKSxcbiAgICAgIC8vIHN0cmluZyB2YWx1ZVxuICAgICAgczogY3Vyc29yIC0gdG9rZW5MZW5ndGgsXG4gICAgICAvLyBzdGFydCBpbmRleFxuICAgICAgZTogY3Vyc29yIC8vIGVuZCBpbmRleCAoZXhjbHVkaW5nKVxuICAgIH0pO1xuICB9XG4gIHJldHVybiB0b2tlbnM7XG59XG5cbi8qKlxuICogQ29udmVydCBhIFN0cmluZyB0byBhbiBBcnJheSBvZiBjaGFyYWN0ZXJzLCB0YWtpbmcgaW50byBhY2NvdW50IHRoYXQgc29tZVxuICogY2hhcmFjdGVycyBsaWtlIGVtb2ppcyB0YWtlIHVwIHR3byBzdHJpbmcgaW5kZXhlcy5cbiAqXG4gKiBBZGFwdGVkIGZyb20gY29yZS1qcyAoTUlUIGxpY2Vuc2UpXG4gKiBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9ibG9iLzJkNjljZjVmOTlhYjNlYTM0NjNjMzk1ZGY4MWU1YTE1YjY4ZjQ5ZDkvcGFja2FnZXMvY29yZS1qcy9pbnRlcm5hbHMvc3RyaW5nLW11bHRpYnl0ZS5qc1xuICpcbiAqIEBmdW5jdGlvbiBzdHJpbmdUb0FycmF5XG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7c3RyaW5nW119XG4gKi9cbmZ1bmN0aW9uIHN0cmluZ1RvQXJyYXkoc3RyKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBjb25zdCBsZW4gPSBzdHIubGVuZ3RoO1xuICBsZXQgaW5kZXggPSAwO1xuICB3aGlsZSAoaW5kZXggPCBsZW4pIHtcbiAgICBsZXQgZmlyc3QgPSBzdHIuY2hhckNvZGVBdChpbmRleCk7XG4gICAgbGV0IHNlY29uZDtcbiAgICBsZXQgY2hhciA9IGZpcnN0IDwgMHhkODAwIHx8IGZpcnN0ID4gMHhkYmZmIHx8IGluZGV4ICsgMSA9PT0gbGVuIHx8IChzZWNvbmQgPSBzdHIuY2hhckNvZGVBdChpbmRleCArIDEpKSA8IDB4ZGMwMCB8fCBzZWNvbmQgPiAweGRmZmYgPyBzdHJbaW5kZXhdIC8vIHNpbmdsZSBjaGFyYWN0ZXJcbiAgICA6IHN0ci5zbGljZShpbmRleCwgaW5kZXggKyAyKTsgLy8gdHdvLWluZGV4IGNoYXJhY3RlcnNcbiAgICByZXN1bHQucHVzaChjaGFyKTtcbiAgICBpbmRleCArPSBjaGFyLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEZhc3QgdmVyc2lvbiBvZiB0cyBmdW5jdGlvbiBmb3Igd2hlbiB0cmFuc2l0aW9uIGRlZmF1bHRzIGFyZSB3ZWxsIGtub3duXG4gKiBAcGFyYW0ge1N0YXRlPHN0cmluZz59IHN0YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5wdXRcbiAqIEBwYXJhbSB7c3RyaW5nfSB0XG4gKiBAcGFyYW0ge3N0cmluZ30gZGVmYXVsdHRcbiAqIEBwYXJhbSB7W1JlZ0V4cCwgU3RhdGU8c3RyaW5nPl1bXX0ganJcbiAqIEByZXR1cm5zIHtTdGF0ZTxzdHJpbmc+fVxuICovXG5mdW5jdGlvbiBmYXN0dHMoc3RhdGUsIGlucHV0LCB0LCBkZWZhdWx0dCwganIpIHtcbiAgbGV0IG5leHQ7XG4gIGNvbnN0IGxlbiA9IGlucHV0Lmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW4gLSAxOyBpKyspIHtcbiAgICBjb25zdCBjaGFyID0gaW5wdXRbaV07XG4gICAgaWYgKHN0YXRlLmpbY2hhcl0pIHtcbiAgICAgIG5leHQgPSBzdGF0ZS5qW2NoYXJdO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0ID0gbmV3IFN0YXRlKGRlZmF1bHR0KTtcbiAgICAgIG5leHQuanIgPSBqci5zbGljZSgpO1xuICAgICAgc3RhdGUualtjaGFyXSA9IG5leHQ7XG4gICAgfVxuICAgIHN0YXRlID0gbmV4dDtcbiAgfVxuICBuZXh0ID0gbmV3IFN0YXRlKHQpO1xuICBuZXh0LmpyID0ganIuc2xpY2UoKTtcbiAgc3RhdGUualtpbnB1dFtsZW4gLSAxXV0gPSBuZXh0O1xuICByZXR1cm4gbmV4dDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIHN0cmluZyBvZiBUb3AtTGV2ZWwgRG9tYWluIG5hbWVzIGVuY29kZWQgaW4gdXBkYXRlLXRsZHMuanMgYmFja1xuICogaW50byBhIGxpc3Qgb2Ygc3RyaW5ncy5cbiAqIEBwYXJhbSB7c3RyfSBlbmNvZGVkIGVuY29kZWQgVExEcyBzdHJpbmdcbiAqIEByZXR1cm5zIHtzdHJbXX0gb3JpZ2luYWwgVExEcyBsaXN0XG4gKi9cbmZ1bmN0aW9uIGRlY29kZVRsZHMoZW5jb2RlZCkge1xuICBjb25zdCB3b3JkcyA9IFtdO1xuICBjb25zdCBzdGFjayA9IFtdO1xuICBsZXQgaSA9IDA7XG4gIGxldCBkaWdpdHMgPSAnMDEyMzQ1Njc4OSc7XG4gIHdoaWxlIChpIDwgZW5jb2RlZC5sZW5ndGgpIHtcbiAgICBsZXQgcG9wRGlnaXRDb3VudCA9IDA7XG4gICAgd2hpbGUgKGRpZ2l0cy5pbmRleE9mKGVuY29kZWRbaSArIHBvcERpZ2l0Q291bnRdKSA+PSAwKSB7XG4gICAgICBwb3BEaWdpdENvdW50Kys7IC8vIGVuY291bnRlcmVkIHNvbWUgZGlnaXRzLCBoYXZlIHRvIHBvcCB0byBnbyBvbmUgbGV2ZWwgdXAgdHJpZVxuICAgIH1cbiAgICBpZiAocG9wRGlnaXRDb3VudCA+IDApIHtcbiAgICAgIHdvcmRzLnB1c2goc3RhY2suam9pbignJykpOyAvLyB3aGF0ZXZlciBwcmVjZWRlZCB0aGUgcG9wIGRpZ2l0cyBtdXN0IGJlIGEgd29yZFxuICAgICAgZm9yIChsZXQgcG9wQ291bnQgPSBwYXJzZUludChlbmNvZGVkLnN1YnN0cmluZyhpLCBpICsgcG9wRGlnaXRDb3VudCksIDEwKTsgcG9wQ291bnQgPiAwOyBwb3BDb3VudC0tKSB7XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgfVxuICAgICAgaSArPSBwb3BEaWdpdENvdW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFjay5wdXNoKGVuY29kZWRbaV0pOyAvLyBkcm9wIGRvd24gYSBsZXZlbCBpbnRvIHRoZSB0cmllXG4gICAgICBpKys7XG4gICAgfVxuICB9XG4gIHJldHVybiB3b3Jkcztcbn1cblxuLyoqXG4gKiBBbiBvYmplY3Qgd2hlcmUgZWFjaCBrZXkgaXMgYSB2YWxpZCBET00gRXZlbnQgTmFtZSBzdWNoIGFzIGBjbGlja2Agb3IgYGZvY3VzYFxuICogYW5kIGVhY2ggdmFsdWUgaXMgYW4gZXZlbnQgaGFuZGxlciBmdW5jdGlvbi5cbiAqXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudCNldmVudHNcbiAqIEB0eXBlZGVmIHs/eyBbZXZlbnQ6IHN0cmluZ106IEZ1bmN0aW9uIH19IEV2ZW50TGlzdGVuZXJzXG4gKi9cblxuLyoqXG4gKiBBbGwgZm9ybWF0dGVkIHByb3BlcnRpZXMgcmVxdWlyZWQgdG8gcmVuZGVyIGEgbGluaywgaW5jbHVkaW5nIGB0YWdOYW1lYCxcbiAqIGBhdHRyaWJ1dGVzYCwgYGNvbnRlbnRgIGFuZCBgZXZlbnRMaXN0ZW5lcnNgLlxuICogQHR5cGVkZWYge3sgdGFnTmFtZTogYW55LCBhdHRyaWJ1dGVzOiB7W2F0dHI6IHN0cmluZ106IGFueX0sIGNvbnRlbnQ6IHN0cmluZyxcbiAqIGV2ZW50TGlzdGVuZXJzOiBFdmVudExpc3RlbmVycyB9fSBJbnRlcm1lZGlhdGVSZXByZXNlbnRhdGlvblxuICovXG5cbi8qKlxuICogU3BlY2lmeSBlaXRoZXIgYW4gb2JqZWN0IGRlc2NyaWJlZCBieSB0aGUgdGVtcGxhdGUgdHlwZSBgT2Agb3IgYSBmdW5jdGlvbi5cbiAqXG4gKiBUaGUgZnVuY3Rpb24gdGFrZXMgYSBzdHJpbmcgdmFsdWUgKHVzdWFsbHkgdGhlIGxpbmsncyBocmVmIGF0dHJpYnV0ZSksIHRoZVxuICogbGluayB0eXBlIChgJ3VybCdgLCBgJ2hhc2h0YWdgJywgZXRjLikgYW5kIGFuIGludGVybmFsIHRva2VuIHJlcHJlc2VudGF0aW9uXG4gKiBvZiB0aGUgbGluay4gSXQgc2hvdWxkIHJldHVybiBhbiBvYmplY3Qgb2YgdGhlIHRlbXBsYXRlIHR5cGUgYE9gXG4gKiBAdGVtcGxhdGUgT1xuICogQHR5cGVkZWYge08gfCAoKHZhbHVlOiBzdHJpbmcsIHR5cGU6IHN0cmluZywgdG9rZW46IE11bHRpVG9rZW4pID0+IE8pfSBPcHRPYmpcbiAqL1xuXG4vKipcbiAqIFNwZWNpZnkgZWl0aGVyIGEgZnVuY3Rpb24gZGVzY3JpYmVkIGJ5IHRlbXBsYXRlIHR5cGUgYEZgIG9yIGFuIG9iamVjdC5cbiAqXG4gKiBFYWNoIGtleSBpbiB0aGUgb2JqZWN0IHNob3VsZCBiZSBhIGxpbmsgdHlwZSAoYCd1cmwnYCwgYCdoYXNodGFnYCcsIGV0Yy4pLiBFYWNoXG4gKiB2YWx1ZSBzaG91bGQgYmUgYSBmdW5jdGlvbiB3aXRoIHRlbXBsYXRlIHR5cGUgYEZgIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlXG4gKiBjb3JyZXNwb25kaW5nIGxpbmsgdHlwZSBpcyBlbmNvdW50ZXJlZC5cbiAqIEB0ZW1wbGF0ZSBGXG4gKiBAdHlwZWRlZiB7RiB8IHsgW3R5cGU6IHN0cmluZ106IEZ9fSBPcHRGblxuICovXG5cbi8qKlxuICogU3BlY2lmeSBlaXRoZXIgYSB2YWx1ZSB3aXRoIHRlbXBsYXRlIHR5cGUgYFZgLCBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBgVmAgb3JcbiAqIGFuIG9iamVjdCB3aGVyZSBlYWNoIHZhbHVlIHJlc29sdmVzIHRvIGBWYC5cbiAqXG4gKiBUaGUgZnVuY3Rpb24gdGFrZXMgYSBzdHJpbmcgdmFsdWUgKHVzdWFsbHkgdGhlIGxpbmsncyBocmVmIGF0dHJpYnV0ZSksIHRoZVxuICogbGluayB0eXBlIChgJ3VybCdgLCBgJ2hhc2h0YWdgJywgZXRjLikgYW5kIGFuIGludGVybmFsIHRva2VuIHJlcHJlc2VudGF0aW9uXG4gKiBvZiB0aGUgbGluay4gSXQgc2hvdWxkIHJldHVybiBhbiBvYmplY3Qgb2YgdGhlIHRlbXBsYXRlIHR5cGUgYFZgXG4gKlxuICogRm9yIHRoZSBvYmplY3QsIGVhY2gga2V5IHNob3VsZCBiZSBhIGxpbmsgdHlwZSAoYCd1cmwnYCwgYCdoYXNodGFnYCcsIGV0Yy4pLlxuICogRWFjaCB2YWx1ZSBzaG91bGQgZWl0aGVyIGhhdmUgdHlwZSBgVmAgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgVi4gVGhpc1xuICogZnVuY3Rpb24gc2ltaWxhcmx5IHRha2VzIGEgc3RyaW5nIHZhbHVlIGFuZCBhIHRva2VuLlxuICpcbiAqIEV4YW1wbGUgdmFsaWQgdHlwZXMgZm9yIGBPcHQ8c3RyaW5nPmA6XG4gKlxuICogYGBganNcbiAqICdoZWxsbydcbiAqICh2YWx1ZSwgdHlwZSwgdG9rZW4pID0+ICd3b3JsZCdcbiAqIHsgdXJsOiAnaGVsbG8nLCBlbWFpbDogKHZhbHVlLCB0b2tlbikgPT4gJ3dvcmxkJ31cbiAqIGBgYFxuICogQHRlbXBsYXRlIFZcbiAqIEB0eXBlZGVmIHtWIHwgKCh2YWx1ZTogc3RyaW5nLCB0eXBlOiBzdHJpbmcsIHRva2VuOiBNdWx0aVRva2VuKSA9PiBWKSB8IHsgW3R5cGU6IHN0cmluZ106IFYgfCAoKHZhbHVlOiBzdHJpbmcsIHRva2VuOiBNdWx0aVRva2VuKSA9PiBWKSB9fSBPcHRcbiAqL1xuXG4vKipcbiAqIFNlZSBhdmFpbGFibGUgb3B0aW9uczogaHR0cHM6Ly9saW5raWZ5LmpzLm9yZy9kb2NzL29wdGlvbnMuaHRtbFxuICogQHR5cGVkZWYge3tcbiAqIFx0ZGVmYXVsdFByb3RvY29sPzogc3RyaW5nLFxuICogIGV2ZW50cz86IE9wdE9iajxFdmVudExpc3RlbmVycz4sXG4gKiBcdGZvcm1hdD86IE9wdDxzdHJpbmc+LFxuICogXHRmb3JtYXRIcmVmPzogT3B0PHN0cmluZz4sXG4gKiBcdG5sMmJyPzogYm9vbGVhbixcbiAqIFx0dGFnTmFtZT86IE9wdDxhbnk+LFxuICogXHR0YXJnZXQ/OiBPcHQ8c3RyaW5nPixcbiAqIFx0cmVsPzogT3B0PHN0cmluZz4sXG4gKiBcdHZhbGlkYXRlPzogT3B0PGJvb2xlYW4+LFxuICogXHR0cnVuY2F0ZT86IE9wdDxudW1iZXI+LFxuICogXHRjbGFzc05hbWU/OiBPcHQ8c3RyaW5nPixcbiAqIFx0YXR0cmlidXRlcz86IE9wdE9iajwoeyBbYXR0cjogc3RyaW5nXTogYW55IH0pPixcbiAqICBpZ25vcmVUYWdzPzogc3RyaW5nW10sXG4gKiBcdHJlbmRlcj86IE9wdEZuPCgoaXI6IEludGVybWVkaWF0ZVJlcHJlc2VudGF0aW9uKSA9PiBhbnkpPlxuICogfX0gT3B0c1xuICovXG5cbi8qKlxuICogQHR5cGUgUmVxdWlyZWQ8T3B0cz5cbiAqL1xuY29uc3QgZGVmYXVsdHMgPSB7XG4gIGRlZmF1bHRQcm90b2NvbDogJ2h0dHAnLFxuICBldmVudHM6IG51bGwsXG4gIGZvcm1hdDogbm9vcCxcbiAgZm9ybWF0SHJlZjogbm9vcCxcbiAgbmwyYnI6IGZhbHNlLFxuICB0YWdOYW1lOiAnYScsXG4gIHRhcmdldDogbnVsbCxcbiAgcmVsOiBudWxsLFxuICB2YWxpZGF0ZTogdHJ1ZSxcbiAgdHJ1bmNhdGU6IEluZmluaXR5LFxuICBjbGFzc05hbWU6IG51bGwsXG4gIGF0dHJpYnV0ZXM6IG51bGwsXG4gIGlnbm9yZVRhZ3M6IFtdLFxuICByZW5kZXI6IG51bGxcbn07XG5cbi8qKlxuICogVXRpbGl0eSBjbGFzcyBmb3IgbGlua2lmeSBpbnRlcmZhY2VzIHRvIGFwcGx5IHNwZWNpZmllZFxuICoge0BsaW5rIE9wdHMgZm9ybWF0dGluZyBhbmQgcmVuZGVyaW5nIG9wdGlvbnN9LlxuICpcbiAqIEBwYXJhbSB7T3B0cyB8IE9wdGlvbnN9IFtvcHRzXSBPcHRpb24gdmFsdWUgb3ZlcnJpZGVzLlxuICogQHBhcmFtIHsoaXI6IEludGVybWVkaWF0ZVJlcHJlc2VudGF0aW9uKSA9PiBhbnl9IFtkZWZhdWx0UmVuZGVyXSAoRm9yXG4gKiAgIGludGVybmFsIHVzZSkgZGVmYXVsdCByZW5kZXIgZnVuY3Rpb24gdGhhdCBkZXRlcm1pbmVzIGhvdyB0byBnZW5lcmF0ZSBhblxuICogICBIVE1MIGVsZW1lbnQgYmFzZWQgb24gYSBsaW5rIHRva2VuJ3MgZGVyaXZlZCB0YWdOYW1lLCBhdHRyaWJ1dGVzIGFuZCBIVE1MLlxuICogICBTaW1pbGFyIHRvIHJlbmRlciBvcHRpb25cbiAqL1xuZnVuY3Rpb24gT3B0aW9ucyhvcHRzLCBkZWZhdWx0UmVuZGVyID0gbnVsbCkge1xuICBsZXQgbyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRzKTtcbiAgaWYgKG9wdHMpIHtcbiAgICBvID0gT2JqZWN0LmFzc2lnbihvLCBvcHRzIGluc3RhbmNlb2YgT3B0aW9ucyA/IG9wdHMubyA6IG9wdHMpO1xuICB9XG5cbiAgLy8gRW5zdXJlIGFsbCBpZ25vcmVkIHRhZ3MgYXJlIHVwcGVyY2FzZVxuICBjb25zdCBpZ25vcmVkVGFncyA9IG8uaWdub3JlVGFncztcbiAgY29uc3QgdXBwZXJjYXNlSWdub3JlZFRhZ3MgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpZ25vcmVkVGFncy5sZW5ndGg7IGkrKykge1xuICAgIHVwcGVyY2FzZUlnbm9yZWRUYWdzLnB1c2goaWdub3JlZFRhZ3NbaV0udG9VcHBlckNhc2UoKSk7XG4gIH1cbiAgLyoqIEBwcm90ZWN0ZWQgKi9cbiAgdGhpcy5vID0gbztcbiAgaWYgKGRlZmF1bHRSZW5kZXIpIHtcbiAgICB0aGlzLmRlZmF1bHRSZW5kZXIgPSBkZWZhdWx0UmVuZGVyO1xuICB9XG4gIHRoaXMuaWdub3JlVGFncyA9IHVwcGVyY2FzZUlnbm9yZWRUYWdzO1xufVxuT3B0aW9ucy5wcm90b3R5cGUgPSB7XG4gIG86IGRlZmF1bHRzLFxuICAvKipcbiAgICogQHR5cGUgc3RyaW5nW11cbiAgICovXG4gIGlnbm9yZVRhZ3M6IFtdLFxuICAvKipcbiAgICogQHBhcmFtIHtJbnRlcm1lZGlhdGVSZXByZXNlbnRhdGlvbn0gaXJcbiAgICogQHJldHVybnMge2FueX1cbiAgICovXG4gIGRlZmF1bHRSZW5kZXIoaXIpIHtcbiAgICByZXR1cm4gaXI7XG4gIH0sXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgb3IgZmFsc2UgYmFzZWQgb24gd2hldGhlciBhIHRva2VuIHNob3VsZCBiZSBkaXNwbGF5ZWQgYXMgYVxuICAgKiBsaW5rIGJhc2VkIG9uIHRoZSB1c2VyIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7TXVsdGlUb2tlbn0gdG9rZW5cbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBjaGVjayh0b2tlbikge1xuICAgIHJldHVybiB0aGlzLmdldCgndmFsaWRhdGUnLCB0b2tlbi50b1N0cmluZygpLCB0b2tlbik7XG4gIH0sXG4gIC8vIFByaXZhdGUgbWV0aG9kc1xuXG4gIC8qKlxuICAgKiBSZXNvbHZlIGFuIG9wdGlvbidzIHZhbHVlIGJhc2VkIG9uIHRoZSB2YWx1ZSBvZiB0aGUgb3B0aW9uIGFuZCB0aGUgZ2l2ZW5cbiAgICogcGFyYW1zLiBJZiBvcGVyYXRvciBhbmQgdG9rZW4gYXJlIHNwZWNpZmllZCBhbmQgdGhlIHRhcmdldCBvcHRpb24gaXNcbiAgICogY2FsbGFibGUsIGF1dG9tYXRpY2FsbHkgY2FsbHMgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIGdpdmVuIGFyZ3VtZW50LlxuICAgKiBAdGVtcGxhdGUge2tleW9mIE9wdHN9IEtcbiAgICogQHBhcmFtIHtLfSBrZXkgTmFtZSBvZiBvcHRpb24gdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3BlcmF0b3JdIHdpbGwgYmUgcGFzc2VkIHRvIHRoZSB0YXJnZXQgb3B0aW9uIGlmIGl0J3MgYVxuICAgKiBmdW5jdGlvbi4gSWYgbm90IHNwZWNpZmllZCwgUkFXIGZ1bmN0aW9uIHZhbHVlIGdldHMgcmV0dXJuZWRcbiAgICogQHBhcmFtIHtNdWx0aVRva2VufSBbdG9rZW5dIFRoZSB0b2tlbiBmcm9tIGxpbmtpZnkudG9rZW5pemVcbiAgICogQHJldHVybnMge09wdHNbS10gfCBhbnl9XG4gICAqL1xuICBnZXQoa2V5LCBvcGVyYXRvciwgdG9rZW4pIHtcbiAgICBjb25zdCBpc0NhbGxhYmxlID0gb3BlcmF0b3IgIT0gbnVsbDtcbiAgICBsZXQgb3B0aW9uID0gdGhpcy5vW2tleV07XG4gICAgaWYgKCFvcHRpb24pIHtcbiAgICAgIHJldHVybiBvcHRpb247XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9uID09PSAnb2JqZWN0Jykge1xuICAgICAgb3B0aW9uID0gdG9rZW4udCBpbiBvcHRpb24gPyBvcHRpb25bdG9rZW4udF0gOiBkZWZhdWx0c1trZXldO1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb24gPT09ICdmdW5jdGlvbicgJiYgaXNDYWxsYWJsZSkge1xuICAgICAgICBvcHRpb24gPSBvcHRpb24ob3BlcmF0b3IsIHRva2VuKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb24gPT09ICdmdW5jdGlvbicgJiYgaXNDYWxsYWJsZSkge1xuICAgICAgb3B0aW9uID0gb3B0aW9uKG9wZXJhdG9yLCB0b2tlbi50LCB0b2tlbik7XG4gICAgfVxuICAgIHJldHVybiBvcHRpb247XG4gIH0sXG4gIC8qKlxuICAgKiBAdGVtcGxhdGUge2tleW9mIE9wdHN9IExcbiAgICogQHBhcmFtIHtMfSBrZXkgTmFtZSBvZiBvcHRpb25zIG9iamVjdCB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcGVyYXRvcl1cbiAgICogQHBhcmFtIHtNdWx0aVRva2VufSBbdG9rZW5dXG4gICAqIEByZXR1cm5zIHtPcHRzW0xdIHwgYW55fVxuICAgKi9cbiAgZ2V0T2JqKGtleSwgb3BlcmF0b3IsIHRva2VuKSB7XG4gICAgbGV0IG9iaiA9IHRoaXMub1trZXldO1xuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nICYmIG9wZXJhdG9yICE9IG51bGwpIHtcbiAgICAgIG9iaiA9IG9iaihvcGVyYXRvciwgdG9rZW4udCwgdG9rZW4pO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9LFxuICAvKipcbiAgICogQ29udmVydCB0aGUgZ2l2ZW4gdG9rZW4gdG8gYSByZW5kZXJlZCBlbGVtZW50IHRoYXQgbWF5IGJlIGFkZGVkIHRvIHRoZVxuICAgKiBjYWxsaW5nLWludGVyZmFjZSdzIERPTVxuICAgKiBAcGFyYW0ge011bHRpVG9rZW59IHRva2VuIFRva2VuIHRvIHJlbmRlciB0byBhbiBIVE1MIGVsZW1lbnRcbiAgICogQHJldHVybnMge2FueX0gUmVuZGVyIHJlc3VsdDsgZS5nLiwgSFRNTCBzdHJpbmcsIERPTSBlbGVtZW50LCBSZWFjdFxuICAgKiAgIENvbXBvbmVudCwgZXRjLlxuICAgKi9cbiAgcmVuZGVyKHRva2VuKSB7XG4gICAgY29uc3QgaXIgPSB0b2tlbi5yZW5kZXIodGhpcyk7IC8vIGludGVybWVkaWF0ZSByZXByZXNlbnRhdGlvblxuICAgIGNvbnN0IHJlbmRlckZuID0gdGhpcy5nZXQoJ3JlbmRlcicsIG51bGwsIHRva2VuKSB8fCB0aGlzLmRlZmF1bHRSZW5kZXI7XG4gICAgcmV0dXJuIHJlbmRlckZuKGlyLCB0b2tlbi50LCB0b2tlbik7XG4gIH1cbn07XG5mdW5jdGlvbiBub29wKHZhbCkge1xuICByZXR1cm4gdmFsO1xufVxuXG52YXIgb3B0aW9ucyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcblx0X19wcm90b19fOiBudWxsLFxuXHRPcHRpb25zOiBPcHRpb25zLFxuXHRkZWZhdWx0czogZGVmYXVsdHNcbn0pO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdE11bHRpLVRva2Vuc1xuXHRUb2tlbnMgY29tcG9zZWQgb2YgYXJyYXlzIG9mIFRleHRUb2tlbnNcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEBwYXJhbSB7VG9rZW5bXX0gdG9rZW5zXG4gKi9cbmZ1bmN0aW9uIE11bHRpVG9rZW4odmFsdWUsIHRva2Vucykge1xuICB0aGlzLnQgPSAndG9rZW4nO1xuICB0aGlzLnYgPSB2YWx1ZTtcbiAgdGhpcy50ayA9IHRva2Vucztcbn1cblxuLyoqXG4gKiBBYnN0cmFjdCBjbGFzcyB1c2VkIGZvciBtYW51ZmFjdHVyaW5nIHRva2VucyBvZiB0ZXh0IHRva2Vucy4gVGhhdCBpcyByYXRoZXJcbiAqIHRoYW4gdGhlIHZhbHVlIGZvciBhIHRva2VuIGJlaW5nIGEgc21hbGwgc3RyaW5nIG9mIHRleHQsIGl0J3MgdmFsdWUgYW4gYXJyYXlcbiAqIG9mIHRleHQgdG9rZW5zLlxuICpcbiAqIFVzZWQgZm9yIGdyb3VwaW5nIHRvZ2V0aGVyIFVSTHMsIGVtYWlscywgaGFzaHRhZ3MsIGFuZCBvdGhlciBwb3RlbnRpYWxcbiAqIGNyZWF0aW9ucy5cbiAqIEBjbGFzcyBNdWx0aVRva2VuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdFxuICogQHByb3BlcnR5IHtzdHJpbmd9IHZcbiAqIEBwcm9wZXJ0eSB7VG9rZW5bXX0gdGtcbiAqIEBhYnN0cmFjdFxuICovXG5NdWx0aVRva2VuLnByb3RvdHlwZSA9IHtcbiAgaXNMaW5rOiBmYWxzZSxcbiAgLyoqXG4gICAqIFJldHVybiB0aGUgc3RyaW5nIHRoaXMgdG9rZW4gcmVwcmVzZW50cy5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMudjtcbiAgfSxcbiAgLyoqXG4gICAqIFdoYXQgc2hvdWxkIHRoZSB2YWx1ZSBmb3IgdGhpcyB0b2tlbiBiZSBpbiB0aGUgYGhyZWZgIEhUTUwgYXR0cmlidXRlP1xuICAgKiBSZXR1cm5zIHRoZSBgLnRvU3RyaW5nYCB2YWx1ZSBieSBkZWZhdWx0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3NjaGVtZV1cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9IcmVmKHNjaGVtZSkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gIH0sXG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnMgRm9ybWF0dGluZyBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICB0b0Zvcm1hdHRlZFN0cmluZyhvcHRpb25zKSB7XG4gICAgY29uc3QgdmFsID0gdGhpcy50b1N0cmluZygpO1xuICAgIGNvbnN0IHRydW5jYXRlID0gb3B0aW9ucy5nZXQoJ3RydW5jYXRlJywgdmFsLCB0aGlzKTtcbiAgICBjb25zdCBmb3JtYXR0ZWQgPSBvcHRpb25zLmdldCgnZm9ybWF0JywgdmFsLCB0aGlzKTtcbiAgICByZXR1cm4gdHJ1bmNhdGUgJiYgZm9ybWF0dGVkLmxlbmd0aCA+IHRydW5jYXRlID8gZm9ybWF0dGVkLnN1YnN0cmluZygwLCB0cnVuY2F0ZSkgKyAn4oCmJyA6IGZvcm1hdHRlZDtcbiAgfSxcbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gb3B0aW9uc1xuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgdG9Gb3JtYXR0ZWRIcmVmKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5nZXQoJ2Zvcm1hdEhyZWYnLCB0aGlzLnRvSHJlZihvcHRpb25zLmdldCgnZGVmYXVsdFByb3RvY29sJykpLCB0aGlzKTtcbiAgfSxcbiAgLyoqXG4gICAqIFRoZSBzdGFydCBpbmRleCBvZiB0aGlzIHRva2VuIGluIHRoZSBvcmlnaW5hbCBpbnB1dCBzdHJpbmdcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIHN0YXJ0SW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMudGtbMF0ucztcbiAgfSxcbiAgLyoqXG4gICAqIFRoZSBlbmQgaW5kZXggb2YgdGhpcyB0b2tlbiBpbiB0aGUgb3JpZ2luYWwgaW5wdXQgc3RyaW5nICh1cCB0byB0aGlzXG4gICAqIGluZGV4IGJ1dCBub3QgaW5jbHVkaW5nIGl0KVxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgZW5kSW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMudGtbdGhpcy50ay5sZW5ndGggLSAxXS5lO1xuICB9LFxuICAvKipcbiAgXHRSZXR1cm5zIGFuIG9iamVjdCAgb2YgcmVsZXZhbnQgdmFsdWVzIGZvciB0aGlzIHRva2VuLCB3aGljaCBpbmNsdWRlcyBrZXlzXG4gIFx0KiB0eXBlIC0gS2luZCBvZiB0b2tlbiAoJ3VybCcsICdlbWFpbCcsIGV0Yy4pXG4gIFx0KiB2YWx1ZSAtIE9yaWdpbmFsIHRleHRcbiAgXHQqIGhyZWYgLSBUaGUgdmFsdWUgdGhhdCBzaG91bGQgYmUgYWRkZWQgdG8gdGhlIGFuY2hvciB0YWcncyBocmVmXG4gIFx0XHRhdHRyaWJ1dGVcbiAgXHRcdEBtZXRob2QgdG9PYmplY3RcbiAgXHRAcGFyYW0ge3N0cmluZ30gW3Byb3RvY29sXSBgJ2h0dHAnYCBieSBkZWZhdWx0XG4gICovXG4gIHRvT2JqZWN0KHByb3RvY29sID0gZGVmYXVsdHMuZGVmYXVsdFByb3RvY29sKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IHRoaXMudCxcbiAgICAgIHZhbHVlOiB0aGlzLnRvU3RyaW5nKCksXG4gICAgICBpc0xpbms6IHRoaXMuaXNMaW5rLFxuICAgICAgaHJlZjogdGhpcy50b0hyZWYocHJvdG9jb2wpLFxuICAgICAgc3RhcnQ6IHRoaXMuc3RhcnRJbmRleCgpLFxuICAgICAgZW5kOiB0aGlzLmVuZEluZGV4KClcbiAgICB9O1xuICB9LFxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtPcHRpb25zfSBvcHRpb25zIEZvcm1hdHRpbmcgb3B0aW9uXG4gICAqL1xuICB0b0Zvcm1hdHRlZE9iamVjdChvcHRpb25zKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IHRoaXMudCxcbiAgICAgIHZhbHVlOiB0aGlzLnRvRm9ybWF0dGVkU3RyaW5nKG9wdGlvbnMpLFxuICAgICAgaXNMaW5rOiB0aGlzLmlzTGluayxcbiAgICAgIGhyZWY6IHRoaXMudG9Gb3JtYXR0ZWRIcmVmKG9wdGlvbnMpLFxuICAgICAgc3RhcnQ6IHRoaXMuc3RhcnRJbmRleCgpLFxuICAgICAgZW5kOiB0aGlzLmVuZEluZGV4KClcbiAgICB9O1xuICB9LFxuICAvKipcbiAgICogV2hldGhlciB0aGlzIHRva2VuIHNob3VsZCBiZSByZW5kZXJlZCBhcyBhIGxpbmsgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiBvcHRpb25zXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gb3B0aW9uc1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHZhbGlkYXRlKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5nZXQoJ3ZhbGlkYXRlJywgdGhpcy50b1N0cmluZygpLCB0aGlzKTtcbiAgfSxcbiAgLyoqXG4gICAqIFJldHVybiBhbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIGhvdyB0aGlzIGxpbmsgc2hvdWxkIGJlIHJlbmRlcmVkLlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnMgRm9ybWF0dGlubmcgb3B0aW9uc1xuICAgKi9cbiAgcmVuZGVyKG9wdGlvbnMpIHtcbiAgICBjb25zdCB0b2tlbiA9IHRoaXM7XG4gICAgY29uc3QgaHJlZiA9IHRoaXMudG9IcmVmKG9wdGlvbnMuZ2V0KCdkZWZhdWx0UHJvdG9jb2wnKSk7XG4gICAgY29uc3QgZm9ybWF0dGVkSHJlZiA9IG9wdGlvbnMuZ2V0KCdmb3JtYXRIcmVmJywgaHJlZiwgdGhpcyk7XG4gICAgY29uc3QgdGFnTmFtZSA9IG9wdGlvbnMuZ2V0KCd0YWdOYW1lJywgaHJlZiwgdG9rZW4pO1xuICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzLnRvRm9ybWF0dGVkU3RyaW5nKG9wdGlvbnMpO1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB7fTtcbiAgICBjb25zdCBjbGFzc05hbWUgPSBvcHRpb25zLmdldCgnY2xhc3NOYW1lJywgaHJlZiwgdG9rZW4pO1xuICAgIGNvbnN0IHRhcmdldCA9IG9wdGlvbnMuZ2V0KCd0YXJnZXQnLCBocmVmLCB0b2tlbik7XG4gICAgY29uc3QgcmVsID0gb3B0aW9ucy5nZXQoJ3JlbCcsIGhyZWYsIHRva2VuKTtcbiAgICBjb25zdCBhdHRycyA9IG9wdGlvbnMuZ2V0T2JqKCdhdHRyaWJ1dGVzJywgaHJlZiwgdG9rZW4pO1xuICAgIGNvbnN0IGV2ZW50TGlzdGVuZXJzID0gb3B0aW9ucy5nZXRPYmooJ2V2ZW50cycsIGhyZWYsIHRva2VuKTtcbiAgICBhdHRyaWJ1dGVzLmhyZWYgPSBmb3JtYXR0ZWRIcmVmO1xuICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgIGF0dHJpYnV0ZXMuY2xhc3MgPSBjbGFzc05hbWU7XG4gICAgfVxuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgIGF0dHJpYnV0ZXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgIH1cbiAgICBpZiAocmVsKSB7XG4gICAgICBhdHRyaWJ1dGVzLnJlbCA9IHJlbDtcbiAgICB9XG4gICAgaWYgKGF0dHJzKSB7XG4gICAgICBPYmplY3QuYXNzaWduKGF0dHJpYnV0ZXMsIGF0dHJzKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHRhZ05hbWUsXG4gICAgICBhdHRyaWJ1dGVzLFxuICAgICAgY29udGVudCxcbiAgICAgIGV2ZW50TGlzdGVuZXJzXG4gICAgfTtcbiAgfVxufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgdG9rZW4gdGhhdCBjYW4gYmUgZW1pdHRlZCBieSB0aGUgcGFyc2VyIHN0YXRlIG1hY2hpbmVcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIHJlYWRhYmxlIHR5cGUgb2YgdGhlIHRva2VuXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHMgcHJvcGVydGllcyB0byBhc3NpZ24gb3Igb3ZlcnJpZGUsIGluY2x1ZGluZyBpc0xpbmsgPSB0cnVlIG9yIGZhbHNlXG4gKiBAcmV0dXJucyB7bmV3ICh2YWx1ZTogc3RyaW5nLCB0b2tlbnM6IFRva2VuW10pID0+IE11bHRpVG9rZW59IG5ldyB0b2tlbiBjbGFzc1xuICovXG5mdW5jdGlvbiBjcmVhdGVUb2tlbkNsYXNzKHR5cGUsIHByb3BzKSB7XG4gIGNsYXNzIFRva2VuIGV4dGVuZHMgTXVsdGlUb2tlbiB7XG4gICAgY29uc3RydWN0b3IodmFsdWUsIHRva2Vucykge1xuICAgICAgc3VwZXIodmFsdWUsIHRva2Vucyk7XG4gICAgICB0aGlzLnQgPSB0eXBlO1xuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IHAgaW4gcHJvcHMpIHtcbiAgICBUb2tlbi5wcm90b3R5cGVbcF0gPSBwcm9wc1twXTtcbiAgfVxuICBUb2tlbi50ID0gdHlwZTtcbiAgcmV0dXJuIFRva2VuO1xufVxuXG4vKipcblx0UmVwcmVzZW50cyBhIGxpc3Qgb2YgdG9rZW5zIG1ha2luZyB1cCBhIHZhbGlkIGVtYWlsIGFkZHJlc3NcbiovXG5jb25zdCBFbWFpbCA9IGNyZWF0ZVRva2VuQ2xhc3MoJ2VtYWlsJywge1xuICBpc0xpbms6IHRydWUsXG4gIHRvSHJlZigpIHtcbiAgICByZXR1cm4gJ21haWx0bzonICsgdGhpcy50b1N0cmluZygpO1xuICB9XG59KTtcblxuLyoqXG5cdFJlcHJlc2VudHMgc29tZSBwbGFpbiB0ZXh0XG4qL1xuY29uc3QgVGV4dCA9IGNyZWF0ZVRva2VuQ2xhc3MoJ3RleHQnKTtcblxuLyoqXG5cdE11bHRpLWxpbmVicmVhayB0b2tlbiAtIHJlcHJlc2VudHMgYSBsaW5lIGJyZWFrXG5cdEBjbGFzcyBObFxuKi9cbmNvbnN0IE5sID0gY3JlYXRlVG9rZW5DbGFzcygnbmwnKTtcblxuLyoqXG5cdFJlcHJlc2VudHMgYSBsaXN0IG9mIHRleHQgdG9rZW5zIG1ha2luZyB1cCBhIHZhbGlkIFVSTFxuXHRAY2xhc3MgVXJsXG4qL1xuY29uc3QgVXJsID0gY3JlYXRlVG9rZW5DbGFzcygndXJsJywge1xuICBpc0xpbms6IHRydWUsXG4gIC8qKlxuICBcdExvd2VyY2FzZXMgcmVsZXZhbnQgcGFydHMgb2YgdGhlIGRvbWFpbiBhbmQgYWRkcyB0aGUgcHJvdG9jb2wgaWZcbiAgXHRyZXF1aXJlZC4gTm90ZSB0aGF0IHRoaXMgd2lsbCBub3QgZXNjYXBlIHVuc2FmZSBIVE1MIGNoYXJhY3RlcnMgaW4gdGhlXG4gIFx0VVJMLlxuICBcdFx0QHBhcmFtIHtzdHJpbmd9IFtzY2hlbWVdIGRlZmF1bHQgc2NoZW1lIChlLmcuLCAnaHR0cHMnKVxuICBcdEByZXR1cm4ge3N0cmluZ30gdGhlIGZ1bGwgaHJlZlxuICAqL1xuICB0b0hyZWYoc2NoZW1lID0gZGVmYXVsdHMuZGVmYXVsdFByb3RvY29sKSB7XG4gICAgLy8gQ2hlY2sgaWYgYWxyZWFkeSBoYXMgYSBwcmVmaXggc2NoZW1lXG4gICAgcmV0dXJuIHRoaXMuaGFzUHJvdG9jb2woKSA/IHRoaXMudiA6IGAke3NjaGVtZX06Ly8ke3RoaXMudn1gO1xuICB9LFxuICAvKipcbiAgICogQ2hlY2sgd2hldGhlciB0aGlzIFVSTCB0b2tlbiBoYXMgYSBwcm90b2NvbFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaGFzUHJvdG9jb2woKSB7XG4gICAgY29uc3QgdG9rZW5zID0gdGhpcy50aztcbiAgICByZXR1cm4gdG9rZW5zLmxlbmd0aCA+PSAyICYmIHRva2Vuc1swXS50ICE9PSBMT0NBTEhPU1QgJiYgdG9rZW5zWzFdLnQgPT09IENPTE9OO1xuICB9XG59KTtcblxudmFyIG11bHRpID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuXHRfX3Byb3RvX186IG51bGwsXG5cdEJhc2U6IE11bHRpVG9rZW4sXG5cdEVtYWlsOiBFbWFpbCxcblx0TXVsdGlUb2tlbjogTXVsdGlUb2tlbixcblx0Tmw6IE5sLFxuXHRUZXh0OiBUZXh0LFxuXHRVcmw6IFVybCxcblx0Y3JlYXRlVG9rZW5DbGFzczogY3JlYXRlVG9rZW5DbGFzc1xufSk7XG5cbi8qKlxuXHROb3QgZXhhY3RseSBwYXJzZXIsIG1vcmUgbGlrZSB0aGUgc2Vjb25kLXN0YWdlIHNjYW5uZXIgKGFsdGhvdWdoIHdlIGNhblxuXHR0aGVvcmV0aWNhbGx5IGhvdHN3YXAgdGhlIGNvZGUgaGVyZSB3aXRoIGEgcmVhbCBwYXJzZXIgaW4gdGhlIGZ1dHVyZS4uLiBidXRcblx0Zm9yIGEgbGl0dGxlIFVSTC1maW5kaW5nIHV0aWxpdHkgYWJzdHJhY3Qgc3ludGF4IHRyZWVzIG1heSBiZSBhIGxpdHRsZVxuXHRvdmVya2lsbCkuXG5cblx0VVJMIGZvcm1hdDogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9VUklfc2NoZW1lXG5cdEVtYWlsIGZvcm1hdDogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FbWFpbEFkZHJlc3MgKGxpbmtzIHRvIFJGQyBpblxuXHRyZWZlcmVuY2UpXG5cblx0QG1vZHVsZSBsaW5raWZ5XG5cdEBzdWJtb2R1bGUgcGFyc2VyXG5cdEBtYWluIHJ1blxuKi9cblxuY29uc3QgbWFrZVN0YXRlID0gYXJnID0+IG5ldyBTdGF0ZShhcmcpO1xuXG4vKipcbiAqIEdlbmVyYXRlIHRoZSBwYXJzZXIgbXVsdGkgdG9rZW4tYmFzZWQgc3RhdGUgbWFjaGluZVxuICogQHBhcmFtIHt7IGdyb3VwczogQ29sbGVjdGlvbnM8c3RyaW5nPiB9fSB0b2tlbnNcbiAqL1xuZnVuY3Rpb24gaW5pdCQxKHtcbiAgZ3JvdXBzXG59KSB7XG4gIC8vIFR5cGVzIG9mIGNoYXJhY3RlcnMgdGhlIFVSTCBjYW4gZGVmaW5pdGVseSBlbmQgaW5cbiAgY29uc3QgcXNBY2NlcHRpbmcgPSBncm91cHMuZG9tYWluLmNvbmNhdChbQU1QRVJTQU5ELCBBU1RFUklTSywgQVQsIEJBQ0tTTEFTSCwgQkFDS1RJQ0ssIENBUkVULCBET0xMQVIsIEVRVUFMUywgSFlQSEVOLCBOVU0sIFBFUkNFTlQsIFBJUEUsIFBMVVMsIFBPVU5ELCBTTEFTSCwgU1lNLCBUSUxERSwgVU5ERVJTQ09SRV0pO1xuXG4gIC8vIFR5cGVzIG9mIHRva2VucyB0aGF0IGNhbiBmb2xsb3cgYSBVUkwgYW5kIGJlIHBhcnQgb2YgdGhlIHF1ZXJ5IHN0cmluZ1xuICAvLyBidXQgY2Fubm90IGJlIHRoZSB2ZXJ5IGxhc3QgY2hhcmFjdGVyc1xuICAvLyBDaGFyYWN0ZXJzIHRoYXQgY2Fubm90IGFwcGVhciBpbiB0aGUgVVJMIGF0IGFsbCBzaG91bGQgYmUgZXhjbHVkZWRcbiAgY29uc3QgcXNOb25BY2NlcHRpbmcgPSBbQVBPU1RST1BIRSwgQ09MT04sIENPTU1BLCBET1QsIEVYQ0xBTUFUSU9OLCBQRVJDRU5ULCBRVUVSWSwgUVVPVEUsIFNFTUksIE9QRU5BTkdMRUJSQUNLRVQsIENMT1NFQU5HTEVCUkFDS0VULCBPUEVOQlJBQ0UsIENMT1NFQlJBQ0UsIENMT1NFQlJBQ0tFVCwgT1BFTkJSQUNLRVQsIE9QRU5QQVJFTiwgQ0xPU0VQQVJFTiwgRlVMTFdJRFRITEVGVFBBUkVOLCBGVUxMV0lEVEhSSUdIVFBBUkVOLCBMRUZUQ09STkVSQlJBQ0tFVCwgUklHSFRDT1JORVJCUkFDS0VULCBMRUZUV0hJVEVDT1JORVJCUkFDS0VULCBSSUdIVFdISVRFQ09STkVSQlJBQ0tFVCwgRlVMTFdJRFRITEVTU1RIQU4sIEZVTExXSURUSEdSRUFURVJUSEFOXTtcblxuICAvLyBGb3IgYWRkcmVzc2VzIHdpdGhvdXQgdGhlIG1haWx0byBwcmVmaXhcbiAgLy8gVG9rZW5zIGFsbG93ZWQgaW4gdGhlIGxvY2FscGFydCBvZiB0aGUgZW1haWxcbiAgY29uc3QgbG9jYWxwYXJ0QWNjZXB0aW5nID0gW0FNUEVSU0FORCwgQVBPU1RST1BIRSwgQVNURVJJU0ssIEJBQ0tTTEFTSCwgQkFDS1RJQ0ssIENBUkVULCBET0xMQVIsIEVRVUFMUywgSFlQSEVOLCBPUEVOQlJBQ0UsIENMT1NFQlJBQ0UsIFBFUkNFTlQsIFBJUEUsIFBMVVMsIFBPVU5ELCBRVUVSWSwgU0xBU0gsIFNZTSwgVElMREUsIFVOREVSU0NPUkVdO1xuXG4gIC8vIFRoZSB1bml2ZXJzYWwgc3RhcnRpbmcgc3RhdGUuXG4gIC8qKlxuICAgKiBAdHlwZSBTdGF0ZTxUb2tlbj5cbiAgICovXG4gIGNvbnN0IFN0YXJ0ID0gbWFrZVN0YXRlKCk7XG4gIGNvbnN0IExvY2FscGFydCA9IHR0KFN0YXJ0LCBUSUxERSk7IC8vIExvY2FsIHBhcnQgb2YgdGhlIGVtYWlsIGFkZHJlc3NcbiAgdGEoTG9jYWxwYXJ0LCBsb2NhbHBhcnRBY2NlcHRpbmcsIExvY2FscGFydCk7XG4gIHRhKExvY2FscGFydCwgZ3JvdXBzLmRvbWFpbiwgTG9jYWxwYXJ0KTtcbiAgY29uc3QgRG9tYWluID0gbWFrZVN0YXRlKCksXG4gICAgU2NoZW1lID0gbWFrZVN0YXRlKCksXG4gICAgU2xhc2hTY2hlbWUgPSBtYWtlU3RhdGUoKTtcbiAgdGEoU3RhcnQsIGdyb3Vwcy5kb21haW4sIERvbWFpbik7IC8vIHBhcnNlZCBzdHJpbmcgZW5kcyB3aXRoIGEgcG90ZW50aWFsIGRvbWFpbiBuYW1lIChBKVxuICB0YShTdGFydCwgZ3JvdXBzLnNjaGVtZSwgU2NoZW1lKTsgLy8gZS5nLiwgJ21haWx0bydcbiAgdGEoU3RhcnQsIGdyb3Vwcy5zbGFzaHNjaGVtZSwgU2xhc2hTY2hlbWUpOyAvLyBlLmcuLCAnaHR0cCdcblxuICB0YShEb21haW4sIGxvY2FscGFydEFjY2VwdGluZywgTG9jYWxwYXJ0KTtcbiAgdGEoRG9tYWluLCBncm91cHMuZG9tYWluLCBEb21haW4pO1xuICBjb25zdCBMb2NhbHBhcnRBdCA9IHR0KERvbWFpbiwgQVQpOyAvLyBMb2NhbCBwYXJ0IG9mIHRoZSBlbWFpbCBhZGRyZXNzIHBsdXMgQFxuXG4gIHR0KExvY2FscGFydCwgQVQsIExvY2FscGFydEF0KTsgLy8gY2xvc2UgdG8gYW4gZW1haWwgYWRkcmVzcyBub3dcblxuICAvLyBMb2NhbCBwYXJ0IG9mIGFuIGVtYWlsIGFkZHJlc3MgY2FuIGJlIGUuZy4gJ2h0dHAnIG9yICdtYWlsdG8nXG4gIHR0KFNjaGVtZSwgQVQsIExvY2FscGFydEF0KTtcbiAgdHQoU2xhc2hTY2hlbWUsIEFULCBMb2NhbHBhcnRBdCk7XG4gIGNvbnN0IExvY2FscGFydERvdCA9IHR0KExvY2FscGFydCwgRE9UKTsgLy8gTG9jYWwgcGFydCBvZiB0aGUgZW1haWwgYWRkcmVzcyBwbHVzICcuJyAobG9jYWxwYXJ0IGNhbm5vdCBlbmQgaW4gLilcbiAgdGEoTG9jYWxwYXJ0RG90LCBsb2NhbHBhcnRBY2NlcHRpbmcsIExvY2FscGFydCk7XG4gIHRhKExvY2FscGFydERvdCwgZ3JvdXBzLmRvbWFpbiwgTG9jYWxwYXJ0KTtcbiAgY29uc3QgRW1haWxEb21haW4gPSBtYWtlU3RhdGUoKTtcbiAgdGEoTG9jYWxwYXJ0QXQsIGdyb3Vwcy5kb21haW4sIEVtYWlsRG9tYWluKTsgLy8gcGFyc2VkIHN0cmluZyBzdGFydHMgd2l0aCBsb2NhbCBlbWFpbCBpbmZvICsgQCB3aXRoIGEgcG90ZW50aWFsIGRvbWFpbiBuYW1lXG4gIHRhKEVtYWlsRG9tYWluLCBncm91cHMuZG9tYWluLCBFbWFpbERvbWFpbik7XG4gIGNvbnN0IEVtYWlsRG9tYWluRG90ID0gdHQoRW1haWxEb21haW4sIERPVCk7IC8vIGRvbWFpbiBmb2xsb3dlZCBieSBET1RcbiAgdGEoRW1haWxEb21haW5Eb3QsIGdyb3Vwcy5kb21haW4sIEVtYWlsRG9tYWluKTtcbiAgY29uc3QgRW1haWwkMSA9IG1ha2VTdGF0ZShFbWFpbCk7IC8vIFBvc3NpYmxlIGVtYWlsIGFkZHJlc3MgKGNvdWxkIGhhdmUgbW9yZSB0bGRzKVxuICB0YShFbWFpbERvbWFpbkRvdCwgZ3JvdXBzLnRsZCwgRW1haWwkMSk7XG4gIHRhKEVtYWlsRG9tYWluRG90LCBncm91cHMudXRsZCwgRW1haWwkMSk7XG4gIHR0KExvY2FscGFydEF0LCBMT0NBTEhPU1QsIEVtYWlsJDEpO1xuXG4gIC8vIEh5cGhlbiBjYW4ganVtcCBiYWNrIHRvIGEgZG9tYWluIG5hbWVcbiAgY29uc3QgRW1haWxEb21haW5IeXBoZW4gPSB0dChFbWFpbERvbWFpbiwgSFlQSEVOKTsgLy8gcGFyc2VkIHN0cmluZyBzdGFydHMgd2l0aCBsb2NhbCBlbWFpbCBpbmZvICsgQCB3aXRoIGEgcG90ZW50aWFsIGRvbWFpbiBuYW1lXG4gIHR0KEVtYWlsRG9tYWluSHlwaGVuLCBIWVBIRU4sIEVtYWlsRG9tYWluSHlwaGVuKTtcbiAgdGEoRW1haWxEb21haW5IeXBoZW4sIGdyb3Vwcy5kb21haW4sIEVtYWlsRG9tYWluKTtcbiAgdGEoRW1haWwkMSwgZ3JvdXBzLmRvbWFpbiwgRW1haWxEb21haW4pO1xuICB0dChFbWFpbCQxLCBET1QsIEVtYWlsRG9tYWluRG90KTtcbiAgdHQoRW1haWwkMSwgSFlQSEVOLCBFbWFpbERvbWFpbkh5cGhlbik7XG5cbiAgLy8gRmluYWwgcG9zc2libGUgZW1haWwgc3RhdGVzXG4gIGNvbnN0IEVtYWlsQ29sb24gPSB0dChFbWFpbCQxLCBDT0xPTik7IC8vIFVSTCBmb2xsb3dlZCBieSBjb2xvbiAocG90ZW50aWFsIHBvcnQgbnVtYmVyIGhlcmUpXG4gIC8qY29uc3QgRW1haWxDb2xvblBvcnQgPSAqL1xuICB0YShFbWFpbENvbG9uLCBncm91cHMubnVtZXJpYywgRW1haWwpOyAvLyBVUkwgZm9sbG93ZWQgYnkgY29sb24gYW5kIHBvcnQgbnVtYmVyXG5cbiAgLy8gQWNjb3VudCBmb3IgZG90cyBhbmQgaHlwaGVucy4gSHlwaGVucyBhcmUgdXN1YWxseSBwYXJ0cyBvZiBkb21haW4gbmFtZXNcbiAgLy8gKGJ1dCBub3QgVExEcylcbiAgY29uc3QgRG9tYWluSHlwaGVuID0gdHQoRG9tYWluLCBIWVBIRU4pOyAvLyBkb21haW4gZm9sbG93ZWQgYnkgaHlwaGVuXG4gIGNvbnN0IERvbWFpbkRvdCA9IHR0KERvbWFpbiwgRE9UKTsgLy8gZG9tYWluIGZvbGxvd2VkIGJ5IERPVFxuICB0dChEb21haW5IeXBoZW4sIEhZUEhFTiwgRG9tYWluSHlwaGVuKTtcbiAgdGEoRG9tYWluSHlwaGVuLCBncm91cHMuZG9tYWluLCBEb21haW4pO1xuICB0YShEb21haW5Eb3QsIGxvY2FscGFydEFjY2VwdGluZywgTG9jYWxwYXJ0KTtcbiAgdGEoRG9tYWluRG90LCBncm91cHMuZG9tYWluLCBEb21haW4pO1xuICBjb25zdCBEb21haW5Eb3RUbGQgPSBtYWtlU3RhdGUoVXJsKTsgLy8gU2ltcGxlc3QgcG9zc2libGUgVVJMIHdpdGggbm8gcXVlcnkgc3RyaW5nXG4gIHRhKERvbWFpbkRvdCwgZ3JvdXBzLnRsZCwgRG9tYWluRG90VGxkKTtcbiAgdGEoRG9tYWluRG90LCBncm91cHMudXRsZCwgRG9tYWluRG90VGxkKTtcbiAgdGEoRG9tYWluRG90VGxkLCBncm91cHMuZG9tYWluLCBEb21haW4pO1xuICB0YShEb21haW5Eb3RUbGQsIGxvY2FscGFydEFjY2VwdGluZywgTG9jYWxwYXJ0KTtcbiAgdHQoRG9tYWluRG90VGxkLCBET1QsIERvbWFpbkRvdCk7XG4gIHR0KERvbWFpbkRvdFRsZCwgSFlQSEVOLCBEb21haW5IeXBoZW4pO1xuICB0dChEb21haW5Eb3RUbGQsIEFULCBMb2NhbHBhcnRBdCk7XG4gIGNvbnN0IERvbWFpbkRvdFRsZENvbG9uID0gdHQoRG9tYWluRG90VGxkLCBDT0xPTik7IC8vIFVSTCBmb2xsb3dlZCBieSBjb2xvbiAocG90ZW50aWFsIHBvcnQgbnVtYmVyIGhlcmUpXG4gIGNvbnN0IERvbWFpbkRvdFRsZENvbG9uUG9ydCA9IG1ha2VTdGF0ZShVcmwpOyAvLyBUTEQgZm9sbG93ZWQgYnkgYSBwb3J0IG51bWJlclxuICB0YShEb21haW5Eb3RUbGRDb2xvbiwgZ3JvdXBzLm51bWVyaWMsIERvbWFpbkRvdFRsZENvbG9uUG9ydCk7XG5cbiAgLy8gTG9uZyBVUkwgd2l0aCBvcHRpb25hbCBwb3J0IGFuZCBtYXliZSBxdWVyeSBzdHJpbmdcbiAgY29uc3QgVXJsJDEgPSBtYWtlU3RhdGUoVXJsKTtcblxuICAvLyBVUkwgd2l0aCBleHRyYSBzeW1ib2xzIGF0IHRoZSBlbmQsIGZvbGxvd2VkIGJ5IGFuIG9wZW5pbmcgYnJhY2tldFxuICBjb25zdCBVcmxOb25hY2NlcHQgPSBtYWtlU3RhdGUoKTsgLy8gVVJMIGZvbGxvd2VkIGJ5IHNvbWUgc3ltYm9scyAod2lsbCBub3QgYmUgcGFydCBvZiB0aGUgZmluYWwgVVJMKVxuXG4gIC8vIFF1ZXJ5IHN0cmluZ3NcbiAgdGEoVXJsJDEsIHFzQWNjZXB0aW5nLCBVcmwkMSk7XG4gIHRhKFVybCQxLCBxc05vbkFjY2VwdGluZywgVXJsTm9uYWNjZXB0KTtcbiAgdGEoVXJsTm9uYWNjZXB0LCBxc0FjY2VwdGluZywgVXJsJDEpO1xuICB0YShVcmxOb25hY2NlcHQsIHFzTm9uQWNjZXB0aW5nLCBVcmxOb25hY2NlcHQpO1xuXG4gIC8vIEJlY29tZSByZWFsIFVSTHMgYWZ0ZXIgYFNMQVNIYCBvciBgQ09MT04gTlVNIFNMQVNIYFxuICAvLyBIZXJlIHdvcmtzIHdpdGggb3Igd2l0aG91dCBzY2hlbWU6Ly8gcHJlZml4XG4gIHR0KERvbWFpbkRvdFRsZCwgU0xBU0gsIFVybCQxKTtcbiAgdHQoRG9tYWluRG90VGxkQ29sb25Qb3J0LCBTTEFTSCwgVXJsJDEpO1xuXG4gIC8vIE5vdGUgdGhhdCBkb21haW5zIHRoYXQgYmVnaW4gd2l0aCBzY2hlbWVzIGFyZSB0cmVhdGVkIHNsaWdobHkgZGlmZmVyZW50bHlcbiAgY29uc3QgU2NoZW1lQ29sb24gPSB0dChTY2hlbWUsIENPTE9OKTsgLy8gZS5nLiwgJ21haWx0bzonXG4gIGNvbnN0IFNsYXNoU2NoZW1lQ29sb24gPSB0dChTbGFzaFNjaGVtZSwgQ09MT04pOyAvLyBlLmcuLCAnaHR0cDonXG4gIGNvbnN0IFNsYXNoU2NoZW1lQ29sb25TbGFzaCA9IHR0KFNsYXNoU2NoZW1lQ29sb24sIFNMQVNIKTsgLy8gZS5nLiwgJ2h0dHA6LydcblxuICBjb25zdCBVcmlQcmVmaXggPSB0dChTbGFzaFNjaGVtZUNvbG9uU2xhc2gsIFNMQVNIKTsgLy8gZS5nLiwgJ2h0dHA6Ly8nXG5cbiAgLy8gU2NoZW1lIHN0YXRlcyBjYW4gdHJhbnNpdGlvbiB0byBkb21haW4gc3RhdGVzXG4gIHRhKFNjaGVtZSwgZ3JvdXBzLmRvbWFpbiwgRG9tYWluKTtcbiAgdHQoU2NoZW1lLCBET1QsIERvbWFpbkRvdCk7XG4gIHR0KFNjaGVtZSwgSFlQSEVOLCBEb21haW5IeXBoZW4pO1xuICB0YShTbGFzaFNjaGVtZSwgZ3JvdXBzLmRvbWFpbiwgRG9tYWluKTtcbiAgdHQoU2xhc2hTY2hlbWUsIERPVCwgRG9tYWluRG90KTtcbiAgdHQoU2xhc2hTY2hlbWUsIEhZUEhFTiwgRG9tYWluSHlwaGVuKTtcblxuICAvLyBGb3JjZSBVUkwgd2l0aCBzY2hlbWUgcHJlZml4IGZvbGxvd2VkIGJ5IGFueXRoaW5nIHNhbmVcbiAgdGEoU2NoZW1lQ29sb24sIGdyb3Vwcy5kb21haW4sIFVybCQxKTtcbiAgdHQoU2NoZW1lQ29sb24sIFNMQVNILCBVcmwkMSk7XG4gIHR0KFNjaGVtZUNvbG9uLCBRVUVSWSwgVXJsJDEpO1xuICB0YShVcmlQcmVmaXgsIGdyb3Vwcy5kb21haW4sIFVybCQxKTtcbiAgdGEoVXJpUHJlZml4LCBxc0FjY2VwdGluZywgVXJsJDEpO1xuICB0dChVcmlQcmVmaXgsIFNMQVNILCBVcmwkMSk7XG4gIGNvbnN0IGJyYWNrZXRQYWlycyA9IFtbT1BFTkJSQUNFLCBDTE9TRUJSQUNFXSxcbiAgLy8ge31cbiAgW09QRU5CUkFDS0VULCBDTE9TRUJSQUNLRVRdLFxuICAvLyBbXVxuICBbT1BFTlBBUkVOLCBDTE9TRVBBUkVOXSxcbiAgLy8gKClcbiAgW09QRU5BTkdMRUJSQUNLRVQsIENMT1NFQU5HTEVCUkFDS0VUXSxcbiAgLy8gPD5cbiAgW0ZVTExXSURUSExFRlRQQVJFTiwgRlVMTFdJRFRIUklHSFRQQVJFTl0sXG4gIC8vIO+8iO+8iVxuICBbTEVGVENPUk5FUkJSQUNLRVQsIFJJR0hUQ09STkVSQlJBQ0tFVF0sXG4gIC8vIOOAjOOAjVxuICBbTEVGVFdISVRFQ09STkVSQlJBQ0tFVCwgUklHSFRXSElURUNPUk5FUkJSQUNLRVRdLFxuICAvLyDjgI7jgI9cbiAgW0ZVTExXSURUSExFU1NUSEFOLCBGVUxMV0lEVEhHUkVBVEVSVEhBTl0gLy8g77yc77yeXG4gIF07XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnJhY2tldFBhaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgW09QRU4sIENMT1NFXSA9IGJyYWNrZXRQYWlyc1tpXTtcbiAgICBjb25zdCBVcmxPcGVuID0gdHQoVXJsJDEsIE9QRU4pOyAvLyBVUkwgZm9sbG93ZWQgYnkgb3BlbiBicmFja2V0XG5cbiAgICAvLyBDb250aW51ZSBub3QgYWNjZXB0aW5nIGZvciBvcGVuIGJyYWNrZXRzXG4gICAgdHQoVXJsTm9uYWNjZXB0LCBPUEVOLCBVcmxPcGVuKTtcblxuICAgIC8vIENsb3NpbmcgYnJhY2tldCBjb21wb25lbnQuIFRoaXMgY2hhcmFjdGVyIFdJTEwgYmUgaW5jbHVkZWQgaW4gdGhlIFVSTFxuICAgIHR0KFVybE9wZW4sIENMT1NFLCBVcmwkMSk7XG5cbiAgICAvLyBVUkwgdGhhdCBiZWluZ3Mgd2l0aCBhbiBvcGVuaW5nIGJyYWNrZXQsIGZvbGxvd2VkIGJ5IGEgc3ltYm9scy5cbiAgICAvLyBOb3RlIHRoYXQgdGhlIGZpbmFsIHN0YXRlIGNhbiBzdGlsbCBiZSBgVXJsT3BlbmAgKGlmIHRoZSBVUkwgaGFzIGFcbiAgICAvLyBzaW5nbGUgb3BlbmluZyBicmFja2V0IGZvciBzb21lIHJlYXNvbikuXG4gICAgY29uc3QgVXJsT3BlblEgPSBtYWtlU3RhdGUoVXJsKTtcbiAgICB0YShVcmxPcGVuLCBxc0FjY2VwdGluZywgVXJsT3BlblEpO1xuICAgIGNvbnN0IFVybE9wZW5TeW1zID0gbWFrZVN0YXRlKCk7IC8vIFVybE9wZW4gZm9sbG93ZWQgYnkgc29tZSBzeW1ib2xzIGl0IGNhbm5vdCBlbmQgaXRcbiAgICB0YShVcmxPcGVuLCBxc05vbkFjY2VwdGluZyk7XG5cbiAgICAvLyBVUkwgdGhhdCBiZWdpbnMgd2l0aCBhbiBvcGVuaW5nIGJyYWNrZXQsIGZvbGxvd2VkIGJ5IHNvbWUgc3ltYm9sc1xuICAgIHRhKFVybE9wZW5RLCBxc0FjY2VwdGluZywgVXJsT3BlblEpO1xuICAgIHRhKFVybE9wZW5RLCBxc05vbkFjY2VwdGluZywgVXJsT3BlblN5bXMpO1xuICAgIHRhKFVybE9wZW5TeW1zLCBxc0FjY2VwdGluZywgVXJsT3BlblEpO1xuICAgIHRhKFVybE9wZW5TeW1zLCBxc05vbkFjY2VwdGluZywgVXJsT3BlblN5bXMpO1xuXG4gICAgLy8gQ2xvc2UgYnJhY2UvYnJhY2tldCB0byBiZWNvbWUgcmVndWxhciBVUkxcbiAgICB0dChVcmxPcGVuUSwgQ0xPU0UsIFVybCQxKTtcbiAgICB0dChVcmxPcGVuU3ltcywgQ0xPU0UsIFVybCQxKTtcbiAgfVxuICB0dChTdGFydCwgTE9DQUxIT1NULCBEb21haW5Eb3RUbGQpOyAvLyBsb2NhbGhvc3QgaXMgYSB2YWxpZCBVUkwgc3RhdGVcbiAgdHQoU3RhcnQsIE5MLCBObCk7IC8vIHNpbmdsZSBuZXcgbGluZVxuXG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IFN0YXJ0LFxuICAgIHRva2VuczogdGtcbiAgfTtcbn1cblxuLyoqXG4gKiBSdW4gdGhlIHBhcnNlciBzdGF0ZSBtYWNoaW5lIG9uIGEgbGlzdCBvZiBzY2FubmVkIHN0cmluZy1iYXNlZCB0b2tlbnMgdG9cbiAqIGNyZWF0ZSBhIGxpc3Qgb2YgbXVsdGkgdG9rZW5zLCBlYWNoIG9mIHdoaWNoIHJlcHJlc2VudHMgYSBVUkwsIGVtYWlsIGFkZHJlc3MsXG4gKiBwbGFpbiB0ZXh0LCBldGMuXG4gKlxuICogQHBhcmFtIHtTdGF0ZTxNdWx0aVRva2VuPn0gc3RhcnQgcGFyc2VyIHN0YXJ0IHN0YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5wdXQgdGhlIG9yaWdpbmFsIGlucHV0IHVzZWQgdG8gZ2VuZXJhdGUgdGhlIGdpdmVuIHRva2Vuc1xuICogQHBhcmFtIHtUb2tlbltdfSB0b2tlbnMgbGlzdCBvZiBzY2FubmVkIHRva2Vuc1xuICogQHJldHVybnMge011bHRpVG9rZW5bXX1cbiAqL1xuZnVuY3Rpb24gcnVuKHN0YXJ0LCBpbnB1dCwgdG9rZW5zKSB7XG4gIGxldCBsZW4gPSB0b2tlbnMubGVuZ3RoO1xuICBsZXQgY3Vyc29yID0gMDtcbiAgbGV0IG11bHRpcyA9IFtdO1xuICBsZXQgdGV4dFRva2VucyA9IFtdO1xuICB3aGlsZSAoY3Vyc29yIDwgbGVuKSB7XG4gICAgbGV0IHN0YXRlID0gc3RhcnQ7XG4gICAgbGV0IHNlY29uZFN0YXRlID0gbnVsbDtcbiAgICBsZXQgbmV4dFN0YXRlID0gbnVsbDtcbiAgICBsZXQgbXVsdGlMZW5ndGggPSAwO1xuICAgIGxldCBsYXRlc3RBY2NlcHRpbmcgPSBudWxsO1xuICAgIGxldCBzaW5jZUFjY2VwdHMgPSAtMTtcbiAgICB3aGlsZSAoY3Vyc29yIDwgbGVuICYmICEoc2Vjb25kU3RhdGUgPSBzdGF0ZS5nbyh0b2tlbnNbY3Vyc29yXS50KSkpIHtcbiAgICAgIC8vIFN0YXJ0aW5nIHRva2VucyB3aXRoIG5vd2hlcmUgdG8ganVtcCB0by5cbiAgICAgIC8vIENvbnNpZGVyIHRoZXNlIHRvIGJlIGp1c3QgcGxhaW4gdGV4dFxuICAgICAgdGV4dFRva2Vucy5wdXNoKHRva2Vuc1tjdXJzb3IrK10pO1xuICAgIH1cbiAgICB3aGlsZSAoY3Vyc29yIDwgbGVuICYmIChuZXh0U3RhdGUgPSBzZWNvbmRTdGF0ZSB8fCBzdGF0ZS5nbyh0b2tlbnNbY3Vyc29yXS50KSkpIHtcbiAgICAgIC8vIEdldCB0aGUgbmV4dCBzdGF0ZVxuICAgICAgc2Vjb25kU3RhdGUgPSBudWxsO1xuICAgICAgc3RhdGUgPSBuZXh0U3RhdGU7XG5cbiAgICAgIC8vIEtlZXAgdHJhY2sgb2YgdGhlIGxhdGVzdCBhY2NlcHRpbmcgc3RhdGVcbiAgICAgIGlmIChzdGF0ZS5hY2NlcHRzKCkpIHtcbiAgICAgICAgc2luY2VBY2NlcHRzID0gMDtcbiAgICAgICAgbGF0ZXN0QWNjZXB0aW5nID0gc3RhdGU7XG4gICAgICB9IGVsc2UgaWYgKHNpbmNlQWNjZXB0cyA+PSAwKSB7XG4gICAgICAgIHNpbmNlQWNjZXB0cysrO1xuICAgICAgfVxuICAgICAgY3Vyc29yKys7XG4gICAgICBtdWx0aUxlbmd0aCsrO1xuICAgIH1cbiAgICBpZiAoc2luY2VBY2NlcHRzIDwgMCkge1xuICAgICAgLy8gTm8gYWNjZXB0aW5nIHN0YXRlIHdhcyBmb3VuZCwgcGFydCBvZiBhIHJlZ3VsYXIgdGV4dCB0b2tlbiBhZGRcbiAgICAgIC8vIHRoZSBmaXJzdCB0ZXh0IHRva2VuIHRvIHRoZSB0ZXh0IHRva2VucyBhcnJheSBhbmQgdHJ5IGFnYWluIGZyb21cbiAgICAgIC8vIHRoZSBuZXh0XG4gICAgICBjdXJzb3IgLT0gbXVsdGlMZW5ndGg7XG4gICAgICBpZiAoY3Vyc29yIDwgbGVuKSB7XG4gICAgICAgIHRleHRUb2tlbnMucHVzaCh0b2tlbnNbY3Vyc29yXSk7XG4gICAgICAgIGN1cnNvcisrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBBY2NlcHRpbmcgc3RhdGUhXG4gICAgICAvLyBGaXJzdCBjbG9zZSBvZmYgdGhlIHRleHRUb2tlbnMgKGlmIGF2YWlsYWJsZSlcbiAgICAgIGlmICh0ZXh0VG9rZW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbXVsdGlzLnB1c2goaW5pdE11bHRpVG9rZW4oVGV4dCwgaW5wdXQsIHRleHRUb2tlbnMpKTtcbiAgICAgICAgdGV4dFRva2VucyA9IFtdO1xuICAgICAgfVxuXG4gICAgICAvLyBSb2xsIGJhY2sgdG8gdGhlIGxhdGVzdCBhY2NlcHRpbmcgc3RhdGVcbiAgICAgIGN1cnNvciAtPSBzaW5jZUFjY2VwdHM7XG4gICAgICBtdWx0aUxlbmd0aCAtPSBzaW5jZUFjY2VwdHM7XG5cbiAgICAgIC8vIENyZWF0ZSBhIG5ldyBtdWx0aXRva2VuXG4gICAgICBjb25zdCBNdWx0aSA9IGxhdGVzdEFjY2VwdGluZy50O1xuICAgICAgY29uc3Qgc3VidG9rZW5zID0gdG9rZW5zLnNsaWNlKGN1cnNvciAtIG11bHRpTGVuZ3RoLCBjdXJzb3IpO1xuICAgICAgbXVsdGlzLnB1c2goaW5pdE11bHRpVG9rZW4oTXVsdGksIGlucHV0LCBzdWJ0b2tlbnMpKTtcbiAgICB9XG4gIH1cblxuICAvLyBGaW5hbGx5IGNsb3NlIG9mZiB0aGUgdGV4dFRva2VucyAoaWYgYXZhaWxhYmxlKVxuICBpZiAodGV4dFRva2Vucy5sZW5ndGggPiAwKSB7XG4gICAgbXVsdGlzLnB1c2goaW5pdE11bHRpVG9rZW4oVGV4dCwgaW5wdXQsIHRleHRUb2tlbnMpKTtcbiAgfVxuICByZXR1cm4gbXVsdGlzO1xufVxuXG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gZm9yIGluc3RhbnRpYXRpbmcgYSBuZXcgbXVsdGl0b2tlbiB3aXRoIGFsbCB0aGUgcmVsZXZhbnRcbiAqIGZpZWxkcyBkdXJpbmcgcGFyc2luZy5cbiAqIEBwYXJhbSB7bmV3ICh2YWx1ZTogc3RyaW5nLCB0b2tlbnM6IFRva2VuW10pID0+IE11bHRpVG9rZW59IE11bHRpIGNsYXNzIHRvIGluc3RhbnRpYXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5wdXQgb3JpZ2luYWwgaW5wdXQgc3RyaW5nXG4gKiBAcGFyYW0ge1Rva2VuW119IHRva2VucyBjb25zZWN1dGl2ZSB0b2tlbnMgc2Nhbm5lZCBmcm9tIGlucHV0IHN0cmluZ1xuICogQHJldHVybnMge011bHRpVG9rZW59XG4gKi9cbmZ1bmN0aW9uIGluaXRNdWx0aVRva2VuKE11bHRpLCBpbnB1dCwgdG9rZW5zKSB7XG4gIGNvbnN0IHN0YXJ0SWR4ID0gdG9rZW5zWzBdLnM7XG4gIGNvbnN0IGVuZElkeCA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV0uZTtcbiAgY29uc3QgdmFsdWUgPSBpbnB1dC5zbGljZShzdGFydElkeCwgZW5kSWR4KTtcbiAgcmV0dXJuIG5ldyBNdWx0aSh2YWx1ZSwgdG9rZW5zKTtcbn1cblxuY29uc3Qgd2FybiA9IHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiBjb25zb2xlICYmIGNvbnNvbGUud2FybiB8fCAoKCkgPT4ge30pO1xuY29uc3Qgd2FybkFkdmljZSA9ICd1bnRpbCBtYW51YWwgY2FsbCBvZiBsaW5raWZ5LmluaXQoKS4gUmVnaXN0ZXIgYWxsIHNjaGVtZXMgYW5kIHBsdWdpbnMgYmVmb3JlIGludm9raW5nIGxpbmtpZnkgdGhlIGZpcnN0IHRpbWUuJztcblxuLy8gU2lkZS1lZmZlY3QgaW5pdGlhbGl6YXRpb24gc3RhdGVcbmNvbnN0IElOSVQgPSB7XG4gIHNjYW5uZXI6IG51bGwsXG4gIHBhcnNlcjogbnVsbCxcbiAgdG9rZW5RdWV1ZTogW10sXG4gIHBsdWdpblF1ZXVlOiBbXSxcbiAgY3VzdG9tU2NoZW1lczogW10sXG4gIGluaXRpYWxpemVkOiBmYWxzZVxufTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7e1xuICogXHRzdGFydDogU3RhdGU8c3RyaW5nPixcbiAqIFx0dG9rZW5zOiB7IGdyb3VwczogQ29sbGVjdGlvbnM8c3RyaW5nPiB9ICYgdHlwZW9mIHRrXG4gKiB9fSBTY2FubmVySW5pdFxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge3tcbiAqIFx0c3RhcnQ6IFN0YXRlPE11bHRpVG9rZW4+LFxuICogXHR0b2tlbnM6IHR5cGVvZiBtdWx0aVxuICogfX0gUGFyc2VySW5pdFxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgeyhhcmc6IHsgc2Nhbm5lcjogU2Nhbm5lckluaXQgfSkgPT4gdm9pZH0gVG9rZW5QbHVnaW5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHsoYXJnOiB7IHNjYW5uZXI6IFNjYW5uZXJJbml0LCBwYXJzZXI6IFBhcnNlckluaXQgfSkgPT4gdm9pZH0gUGx1Z2luXG4gKi9cblxuLyoqXG4gKiBEZS1yZWdpc3RlciBhbGwgcGx1Z2lucyBhbmQgcmVzZXQgdGhlIGludGVybmFsIHN0YXRlLW1hY2hpbmUuIFVzZWQgZm9yXG4gKiB0ZXN0aW5nOyBub3QgcmVxdWlyZWQgaW4gcHJhY3RpY2UuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZXNldCgpIHtcbiAgU3RhdGUuZ3JvdXBzID0ge307XG4gIElOSVQuc2Nhbm5lciA9IG51bGw7XG4gIElOSVQucGFyc2VyID0gbnVsbDtcbiAgSU5JVC50b2tlblF1ZXVlID0gW107XG4gIElOSVQucGx1Z2luUXVldWUgPSBbXTtcbiAgSU5JVC5jdXN0b21TY2hlbWVzID0gW107XG4gIElOSVQuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgcmV0dXJuIElOSVQ7XG59XG5cbi8qKlxuICogUmVnaXN0ZXIgYSB0b2tlbiBwbHVnaW4gdG8gYWxsb3cgdGhlIHNjYW5uZXIgdG8gcmVjb2duaXplIGFkZGl0aW9uYWwgdG9rZW5cbiAqIHR5cGVzIGJlZm9yZSB0aGUgcGFyc2VyIHN0YXRlIG1hY2hpbmUgaXMgY29uc3RydWN0ZWQgZnJvbSB0aGUgcmVzdWx0cy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIG9mIHBsdWdpbiB0byByZWdpc3RlclxuICogQHBhcmFtIHtUb2tlblBsdWdpbn0gcGx1Z2luIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyB0aGUgc2Nhbm5lciBzdGF0ZSBtYWNoaW5lXG4gKiBhbmQgYXZhaWxhYmxlIHNjYW5uZXIgdG9rZW5zIGFuZCBjb2xsZWN0aW9ucyBhbmQgZXh0ZW5kcyB0aGUgc3RhdGUgbWFjaGluZSB0b1xuICogcmVjb2duaXplIGFkZGl0aW9uYWwgdG9rZW5zIG9yIGdyb3Vwcy5cbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJUb2tlblBsdWdpbihuYW1lLCBwbHVnaW4pIHtcbiAgaWYgKHR5cGVvZiBwbHVnaW4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGxpbmtpZnlqczogSW52YWxpZCB0b2tlbiBwbHVnaW4gJHtwbHVnaW59IChleHBlY3RzIGZ1bmN0aW9uKWApO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgSU5JVC50b2tlblF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG5hbWUgPT09IElOSVQudG9rZW5RdWV1ZVtpXVswXSkge1xuICAgICAgd2FybihgbGlua2lmeWpzOiB0b2tlbiBwbHVnaW4gXCIke25hbWV9XCIgYWxyZWFkeSByZWdpc3RlcmVkIC0gd2lsbCBiZSBvdmVyd3JpdHRlbmApO1xuICAgICAgSU5JVC50b2tlblF1ZXVlW2ldID0gW25hbWUsIHBsdWdpbl07XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIElOSVQudG9rZW5RdWV1ZS5wdXNoKFtuYW1lLCBwbHVnaW5dKTtcbiAgaWYgKElOSVQuaW5pdGlhbGl6ZWQpIHtcbiAgICB3YXJuKGBsaW5raWZ5anM6IGFscmVhZHkgaW5pdGlhbGl6ZWQgLSB3aWxsIG5vdCByZWdpc3RlciB0b2tlbiBwbHVnaW4gXCIke25hbWV9XCIgJHt3YXJuQWR2aWNlfWApO1xuICB9XG59XG5cbi8qKlxuICogUmVnaXN0ZXIgYSBsaW5raWZ5IHBsdWdpblxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgb2YgcGx1Z2luIHRvIHJlZ2lzdGVyXG4gKiBAcGFyYW0ge1BsdWdpbn0gcGx1Z2luIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyB0aGUgcGFyc2VyIHN0YXRlIG1hY2hpbmUgYW5kXG4gKiBleHRlbmRzIHRoZSBwYXJzZXIgdG8gcmVjb2duaXplIGFkZGl0aW9uYWwgbGluayB0eXBlc1xuICovXG5mdW5jdGlvbiByZWdpc3RlclBsdWdpbihuYW1lLCBwbHVnaW4pIHtcbiAgaWYgKHR5cGVvZiBwbHVnaW4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGxpbmtpZnlqczogSW52YWxpZCBwbHVnaW4gJHtwbHVnaW59IChleHBlY3RzIGZ1bmN0aW9uKWApO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgSU5JVC5wbHVnaW5RdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChuYW1lID09PSBJTklULnBsdWdpblF1ZXVlW2ldWzBdKSB7XG4gICAgICB3YXJuKGBsaW5raWZ5anM6IHBsdWdpbiBcIiR7bmFtZX1cIiBhbHJlYWR5IHJlZ2lzdGVyZWQgLSB3aWxsIGJlIG92ZXJ3cml0dGVuYCk7XG4gICAgICBJTklULnBsdWdpblF1ZXVlW2ldID0gW25hbWUsIHBsdWdpbl07XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIElOSVQucGx1Z2luUXVldWUucHVzaChbbmFtZSwgcGx1Z2luXSk7XG4gIGlmIChJTklULmluaXRpYWxpemVkKSB7XG4gICAgd2FybihgbGlua2lmeWpzOiBhbHJlYWR5IGluaXRpYWxpemVkIC0gd2lsbCBub3QgcmVnaXN0ZXIgcGx1Z2luIFwiJHtuYW1lfVwiICR7d2FybkFkdmljZX1gKTtcbiAgfVxufVxuXG4vKipcbiAqIERldGVjdCBVUkxzIHdpdGggdGhlIGZvbGxvd2luZyBhZGRpdGlvbmFsIHByb3RvY29sLiBBbnl0aGluZyB3aXRoIGZvcm1hdFxuICogXCJwcm90b2NvbDovLy4uLlwiIHdpbGwgYmUgY29uc2lkZXJlZCBhIGxpbmsuIElmIGBvcHRpb25hbFNsYXNoU2xhc2hgIGlzIHNldCB0b1xuICogYHRydWVgLCBhbnl0aGluZyB3aXRoIGZvcm1hdCBcInByb3RvY29sOi4uLlwiIHdpbGwgYmUgY29uc2lkZXJlZCBhIGxpbmsuXG4gKiBAcGFyYW0ge3N0cmluZ30gc2NoZW1lXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25hbFNsYXNoU2xhc2hdXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyQ3VzdG9tUHJvdG9jb2woc2NoZW1lLCBvcHRpb25hbFNsYXNoU2xhc2ggPSBmYWxzZSkge1xuICBpZiAoSU5JVC5pbml0aWFsaXplZCkge1xuICAgIHdhcm4oYGxpbmtpZnlqczogYWxyZWFkeSBpbml0aWFsaXplZCAtIHdpbGwgbm90IHJlZ2lzdGVyIGN1c3RvbSBzY2hlbWUgXCIke3NjaGVtZX1cIiAke3dhcm5BZHZpY2V9YCk7XG4gIH1cbiAgaWYgKCEvXlswLTlhLXpdKygtWzAtOWEtel0rKSokLy50ZXN0KHNjaGVtZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGxpbmtpZnlqczogaW5jb3JyZWN0IHNjaGVtZSBmb3JtYXQuXG4xLiBNdXN0IG9ubHkgY29udGFpbiBkaWdpdHMsIGxvd2VyY2FzZSBBU0NJSSBsZXR0ZXJzIG9yIFwiLVwiXG4yLiBDYW5ub3Qgc3RhcnQgb3IgZW5kIHdpdGggXCItXCJcbjMuIFwiLVwiIGNhbm5vdCByZXBlYXRgKTtcbiAgfVxuICBJTklULmN1c3RvbVNjaGVtZXMucHVzaChbc2NoZW1lLCBvcHRpb25hbFNsYXNoU2xhc2hdKTtcbn1cblxuLyoqXG4gKiBJbml0aWFsaXplIHRoZSBsaW5raWZ5IHN0YXRlIG1hY2hpbmUuIENhbGxlZCBhdXRvbWF0aWNhbGx5IHRoZSBmaXJzdCB0aW1lXG4gKiBsaW5raWZ5IGlzIGNhbGxlZCBvbiBhIHN0cmluZywgYnV0IG1heSBiZSBjYWxsZWQgbWFudWFsbHkgYXMgd2VsbC5cbiAqL1xuZnVuY3Rpb24gaW5pdCgpIHtcbiAgLy8gSW5pdGlhbGl6ZSBzY2FubmVyIHN0YXRlIG1hY2hpbmUgYW5kIHBsdWdpbnNcbiAgSU5JVC5zY2FubmVyID0gaW5pdCQyKElOSVQuY3VzdG9tU2NoZW1lcyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgSU5JVC50b2tlblF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgSU5JVC50b2tlblF1ZXVlW2ldWzFdKHtcbiAgICAgIHNjYW5uZXI6IElOSVQuc2Nhbm5lclxuICAgIH0pO1xuICB9XG5cbiAgLy8gSW5pdGlhbGl6ZSBwYXJzZXIgc3RhdGUgbWFjaGluZSBhbmQgcGx1Z2luc1xuICBJTklULnBhcnNlciA9IGluaXQkMShJTklULnNjYW5uZXIudG9rZW5zKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBJTklULnBsdWdpblF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgSU5JVC5wbHVnaW5RdWV1ZVtpXVsxXSh7XG4gICAgICBzY2FubmVyOiBJTklULnNjYW5uZXIsXG4gICAgICBwYXJzZXI6IElOSVQucGFyc2VyXG4gICAgfSk7XG4gIH1cbiAgSU5JVC5pbml0aWFsaXplZCA9IHRydWU7XG4gIHJldHVybiBJTklUO1xufVxuXG4vKipcbiAqIFBhcnNlIGEgc3RyaW5nIGludG8gdG9rZW5zIHRoYXQgcmVwcmVzZW50IGxpbmthYmxlIGFuZCBub24tbGlua2FibGUgc3ViLWNvbXBvbmVudHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge011bHRpVG9rZW5bXX0gdG9rZW5zXG4gKi9cbmZ1bmN0aW9uIHRva2VuaXplKHN0cikge1xuICBpZiAoIUlOSVQuaW5pdGlhbGl6ZWQpIHtcbiAgICBpbml0KCk7XG4gIH1cbiAgcmV0dXJuIHJ1bihJTklULnBhcnNlci5zdGFydCwgc3RyLCBydW4kMShJTklULnNjYW5uZXIuc3RhcnQsIHN0cikpO1xufVxudG9rZW5pemUuc2NhbiA9IHJ1biQxOyAvLyBmb3IgdGVzdGluZ1xuXG4vKipcbiAqIEZpbmQgYSBsaXN0IG9mIGxpbmthYmxlIGl0ZW1zIGluIHRoZSBnaXZlbiBzdHJpbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIHN0cmluZyB0byBmaW5kIGxpbmtzIGluXG4gKiBAcGFyYW0ge3N0cmluZyB8IE9wdHN9IFt0eXBlXSBlaXRoZXIgZm9ybWF0dGluZyBvcHRpb25zIG9yIHNwZWNpZmljIHR5cGUgb2ZcbiAqIGxpbmtzIHRvIGZpbmQsIGUuZy4sICd1cmwnIG9yICdlbWFpbCdcbiAqIEBwYXJhbSB7T3B0c30gW29wdHNdIGZvcm1hdHRpbmcgb3B0aW9ucyBmb3IgZmluYWwgb3V0cHV0LiBDYW5ub3QgYmUgc3BlY2lmaWVkXG4gKiBpZiBvcHRzIGFscmVhZHkgcHJvdmlkZWQgaW4gYHR5cGVgIGFyZ3VtZW50XG4gKi9cbmZ1bmN0aW9uIGZpbmQoc3RyLCB0eXBlID0gbnVsbCwgb3B0cyA9IG51bGwpIHtcbiAgaWYgKHR5cGUgJiYgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgaWYgKG9wdHMpIHtcbiAgICAgIHRocm93IEVycm9yKGBsaW5raWZ5anM6IEludmFsaWQgbGluayB0eXBlICR7dHlwZX07IG11c3QgYmUgYSBzdHJpbmdgKTtcbiAgICB9XG4gICAgb3B0cyA9IHR5cGU7XG4gICAgdHlwZSA9IG51bGw7XG4gIH1cbiAgY29uc3Qgb3B0aW9ucyA9IG5ldyBPcHRpb25zKG9wdHMpO1xuICBjb25zdCB0b2tlbnMgPSB0b2tlbml6ZShzdHIpO1xuICBjb25zdCBmaWx0ZXJlZCA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHRva2VuID0gdG9rZW5zW2ldO1xuICAgIGlmICh0b2tlbi5pc0xpbmsgJiYgKCF0eXBlIHx8IHRva2VuLnQgPT09IHR5cGUpICYmIG9wdGlvbnMuY2hlY2sodG9rZW4pKSB7XG4gICAgICBmaWx0ZXJlZC5wdXNoKHRva2VuLnRvRm9ybWF0dGVkT2JqZWN0KG9wdGlvbnMpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZpbHRlcmVkO1xufVxuXG4vKipcbiAqIElzIHRoZSBnaXZlbiBzdHJpbmcgdmFsaWQgbGlua2FibGUgdGV4dCBvZiBzb21lIHNvcnQuIE5vdGUgdGhhdCB0aGlzIGRvZXMgbm90XG4gKiB0cmltIHRoZSB0ZXh0IGZvciB5b3UuXG4gKlxuICogT3B0aW9uYWxseSBwYXNzIGluIGEgc2Vjb25kIGB0eXBlYCBwYXJhbSwgd2hpY2ggaXMgdGhlIHR5cGUgb2YgbGluayB0byB0ZXN0XG4gKiBmb3IuXG4gKlxuICogRm9yIGV4YW1wbGUsXG4gKlxuICogICAgIGxpbmtpZnkudGVzdChzdHIsICdlbWFpbCcpO1xuICpcbiAqIFJldHVybnMgYHRydWVgIGlmIHN0ciBpcyBhIHZhbGlkIGVtYWlsLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBzdHJpbmcgdG8gdGVzdCBmb3IgbGlua3NcbiAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZV0gb3B0aW9uYWwgc3BlY2lmaWMgbGluayB0eXBlIHRvIGxvb2sgZm9yXG4gKiBAcmV0dXJucyBib29sZWFuIHRydWUvZmFsc2VcbiAqL1xuZnVuY3Rpb24gdGVzdChzdHIsIHR5cGUgPSBudWxsKSB7XG4gIGNvbnN0IHRva2VucyA9IHRva2VuaXplKHN0cik7XG4gIHJldHVybiB0b2tlbnMubGVuZ3RoID09PSAxICYmIHRva2Vuc1swXS5pc0xpbmsgJiYgKCF0eXBlIHx8IHRva2Vuc1swXS50ID09PSB0eXBlKTtcbn1cblxuZXhwb3J0IHsgTXVsdGlUb2tlbiwgT3B0aW9ucywgU3RhdGUsIGNyZWF0ZVRva2VuQ2xhc3MsIGZpbmQsIGluaXQsIG11bHRpLCBvcHRpb25zLCByZWdleHAsIHJlZ2lzdGVyQ3VzdG9tUHJvdG9jb2wsIHJlZ2lzdGVyUGx1Z2luLCByZWdpc3RlclRva2VuUGx1Z2luLCByZXNldCwgc3RyaW5nVG9BcnJheSwgdGVzdCwgbXVsdGkgYXMgdGV4dCwgdG9rZW5pemUgfTtcbiJdLCJuYW1lcyI6WyJlbmNvZGVkVGxkcyIsImVuY29kZWRVdGxkcyIsIm51bWVyaWMiLCJhc2NpaSIsImFscGhhIiwiYXNjaWludW1lcmljIiwiYWxwaGFudW1lcmljIiwiZG9tYWluIiwiZW1vamkiLCJzY2hlbWUiLCJzbGFzaHNjaGVtZSIsIndoaXRlc3BhY2UiLCJyZWdpc3Rlckdyb3VwIiwibmFtZSIsImdyb3VwcyIsImFkZFRvR3JvdXBzIiwidCIsImZsYWdzIiwiayIsImdyb3VwIiwiaW5kZXhPZiIsInB1c2giLCJmbGFnc0ZvclRva2VuIiwicmVzdWx0IiwiYyIsIlN0YXRlIiwidG9rZW4iLCJqIiwianIiLCJqZCIsInByb3RvdHlwZSIsImFjY2VwdHMiLCJnbyIsImlucHV0Iiwic3RhdGUiLCJuZXh0U3RhdGUiLCJpIiwibGVuZ3RoIiwicmVnZXgiLCJ0ZXN0IiwiaGFzIiwiZXhhY3RPbmx5IiwidGEiLCJpbnB1dHMiLCJuZXh0IiwidHQiLCJ0ciIsInJlZ2V4cCIsInRzIiwibGVuIiwidGVtcGxhdGVTdGF0ZSIsIk9iamVjdCIsImFzc2lnbiIsImFwcGx5IiwiYWxsRmxhZ3MiLCJXT1JEIiwiVVdPUkQiLCJBU0NJSU5VTUVSSUNBTCIsIkFMUEhBTlVNRVJJQ0FMIiwiTE9DQUxIT1NUIiwiVExEIiwiVVRMRCIsIlNDSEVNRSIsIlNMQVNIX1NDSEVNRSIsIk5VTSIsIldTIiwiTkwiLCJPUEVOQlJBQ0UiLCJDTE9TRUJSQUNFIiwiT1BFTkJSQUNLRVQiLCJDTE9TRUJSQUNLRVQiLCJPUEVOUEFSRU4iLCJDTE9TRVBBUkVOIiwiT1BFTkFOR0xFQlJBQ0tFVCIsIkNMT1NFQU5HTEVCUkFDS0VUIiwiRlVMTFdJRFRITEVGVFBBUkVOIiwiRlVMTFdJRFRIUklHSFRQQVJFTiIsIkxFRlRDT1JORVJCUkFDS0VUIiwiUklHSFRDT1JORVJCUkFDS0VUIiwiTEVGVFdISVRFQ09STkVSQlJBQ0tFVCIsIlJJR0hUV0hJVEVDT1JORVJCUkFDS0VUIiwiRlVMTFdJRFRITEVTU1RIQU4iLCJGVUxMV0lEVEhHUkVBVEVSVEhBTiIsIkFNUEVSU0FORCIsIkFQT1NUUk9QSEUiLCJBU1RFUklTSyIsIkFUIiwiQkFDS1NMQVNIIiwiQkFDS1RJQ0siLCJDQVJFVCIsIkNPTE9OIiwiQ09NTUEiLCJET0xMQVIiLCJET1QiLCJFUVVBTFMiLCJFWENMQU1BVElPTiIsIkhZUEhFTiIsIlBFUkNFTlQiLCJQSVBFIiwiUExVUyIsIlBPVU5EIiwiUVVFUlkiLCJRVU9URSIsIkZVTExXSURUSE1JRERMRURPVCIsIlNFTUkiLCJTTEFTSCIsIlRJTERFIiwiVU5ERVJTQ09SRSIsIkVNT0pJJDEiLCJTWU0iLCJ0ayIsImZyZWV6ZSIsIl9fcHJvdG9fXyIsIkVNT0pJIiwiQVNDSUlfTEVUVEVSIiwiTEVUVEVSIiwiRU1PSklfVkFSSUFUSU9OJDEiLCJESUdJVCIsIlNQQUNFIiwiRU1PSklfVkFSSUFUSU9OIiwiQ1IiLCJMRiIsIkVNT0pJX0pPSU5FUiIsIk9CSkVDVF9SRVBMQUNFTUVOVCIsInRsZHMiLCJ1dGxkcyIsImluaXQkMiIsImN1c3RvbVNjaGVtZXMiLCJTdGFydCIsImRlY29kZVRsZHMiLCJOdW0iLCJBc2NpaW51bWVyaWMiLCJBbHBoYW51bWVyaWMiLCJXb3JkIiwiVVdvcmQiLCJObCIsIkNyIiwiV3MiLCJFbW9qaSIsIkVtb2ppSm9pbmVyIiwid29yZGpyIiwidXdvcmRqciIsImZhc3R0cyIsInRsZCIsInV0bGQiLCJzb3J0IiwiYSIsImIiLCJzY2giLCJvcHRpb25hbFNsYXNoU2xhc2giLCJzdGFydCIsInRva2VucyIsInJ1biQxIiwic3RyIiwiaXRlcmFibGUiLCJzdHJpbmdUb0FycmF5IiwicmVwbGFjZSIsInRvTG93ZXJDYXNlIiwiY2hhckNvdW50IiwiY3Vyc29yIiwiY2hhckN1cnNvciIsInRva2VuTGVuZ3RoIiwibGF0ZXN0QWNjZXB0aW5nIiwic2luY2VBY2NlcHRzIiwiY2hhcnNTaW5jZUFjY2VwdHMiLCJ2Iiwic2xpY2UiLCJzIiwiZSIsImluZGV4IiwiZmlyc3QiLCJjaGFyQ29kZUF0Iiwic2Vjb25kIiwiY2hhciIsImRlZmF1bHR0IiwiZW5jb2RlZCIsIndvcmRzIiwic3RhY2siLCJkaWdpdHMiLCJwb3BEaWdpdENvdW50Iiwiam9pbiIsInBvcENvdW50IiwicGFyc2VJbnQiLCJzdWJzdHJpbmciLCJwb3AiLCJkZWZhdWx0cyIsImRlZmF1bHRQcm90b2NvbCIsImV2ZW50cyIsImZvcm1hdCIsIm5vb3AiLCJmb3JtYXRIcmVmIiwibmwyYnIiLCJ0YWdOYW1lIiwidGFyZ2V0IiwicmVsIiwidmFsaWRhdGUiLCJ0cnVuY2F0ZSIsIkluZmluaXR5IiwiY2xhc3NOYW1lIiwiYXR0cmlidXRlcyIsImlnbm9yZVRhZ3MiLCJyZW5kZXIiLCJPcHRpb25zIiwib3B0cyIsImRlZmF1bHRSZW5kZXIiLCJvIiwiaWdub3JlZFRhZ3MiLCJ1cHBlcmNhc2VJZ25vcmVkVGFncyIsInRvVXBwZXJDYXNlIiwiaXIiLCJjaGVjayIsImdldCIsInRvU3RyaW5nIiwia2V5Iiwib3BlcmF0b3IiLCJpc0NhbGxhYmxlIiwib3B0aW9uIiwiZ2V0T2JqIiwib2JqIiwicmVuZGVyRm4iLCJ2YWwiLCJvcHRpb25zIiwiTXVsdGlUb2tlbiIsInZhbHVlIiwiaXNMaW5rIiwidG9IcmVmIiwidG9Gb3JtYXR0ZWRTdHJpbmciLCJmb3JtYXR0ZWQiLCJ0b0Zvcm1hdHRlZEhyZWYiLCJzdGFydEluZGV4IiwiZW5kSW5kZXgiLCJ0b09iamVjdCIsInByb3RvY29sIiwidHlwZSIsImhyZWYiLCJlbmQiLCJ0b0Zvcm1hdHRlZE9iamVjdCIsImZvcm1hdHRlZEhyZWYiLCJjb250ZW50IiwiYXR0cnMiLCJldmVudExpc3RlbmVycyIsImNsYXNzIiwiY3JlYXRlVG9rZW5DbGFzcyIsInByb3BzIiwiVG9rZW4iLCJjb25zdHJ1Y3RvciIsInAiLCJFbWFpbCIsIlRleHQiLCJVcmwiLCJoYXNQcm90b2NvbCIsIm11bHRpIiwiQmFzZSIsIm1ha2VTdGF0ZSIsImFyZyIsImluaXQkMSIsInFzQWNjZXB0aW5nIiwiY29uY2F0IiwicXNOb25BY2NlcHRpbmciLCJsb2NhbHBhcnRBY2NlcHRpbmciLCJMb2NhbHBhcnQiLCJEb21haW4iLCJTY2hlbWUiLCJTbGFzaFNjaGVtZSIsIkxvY2FscGFydEF0IiwiTG9jYWxwYXJ0RG90IiwiRW1haWxEb21haW4iLCJFbWFpbERvbWFpbkRvdCIsIkVtYWlsJDEiLCJFbWFpbERvbWFpbkh5cGhlbiIsIkVtYWlsQ29sb24iLCJEb21haW5IeXBoZW4iLCJEb21haW5Eb3QiLCJEb21haW5Eb3RUbGQiLCJEb21haW5Eb3RUbGRDb2xvbiIsIkRvbWFpbkRvdFRsZENvbG9uUG9ydCIsIlVybCQxIiwiVXJsTm9uYWNjZXB0IiwiU2NoZW1lQ29sb24iLCJTbGFzaFNjaGVtZUNvbG9uIiwiU2xhc2hTY2hlbWVDb2xvblNsYXNoIiwiVXJpUHJlZml4IiwiYnJhY2tldFBhaXJzIiwiT1BFTiIsIkNMT1NFIiwiVXJsT3BlbiIsIlVybE9wZW5RIiwiVXJsT3BlblN5bXMiLCJydW4iLCJtdWx0aXMiLCJ0ZXh0VG9rZW5zIiwic2Vjb25kU3RhdGUiLCJtdWx0aUxlbmd0aCIsImluaXRNdWx0aVRva2VuIiwiTXVsdGkiLCJzdWJ0b2tlbnMiLCJzdGFydElkeCIsImVuZElkeCIsIndhcm4iLCJjb25zb2xlIiwid2FybkFkdmljZSIsIklOSVQiLCJzY2FubmVyIiwicGFyc2VyIiwidG9rZW5RdWV1ZSIsInBsdWdpblF1ZXVlIiwiaW5pdGlhbGl6ZWQiLCJyZXNldCIsInJlZ2lzdGVyVG9rZW5QbHVnaW4iLCJwbHVnaW4iLCJFcnJvciIsInJlZ2lzdGVyUGx1Z2luIiwicmVnaXN0ZXJDdXN0b21Qcm90b2NvbCIsImluaXQiLCJ0b2tlbml6ZSIsInNjYW4iLCJmaW5kIiwiZmlsdGVyZWQiLCJ0ZXh0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/linkifyjs/dist/linkify.mjs\n");

/***/ })

};
;