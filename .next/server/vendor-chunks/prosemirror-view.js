"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/prosemirror-view";
exports.ids = ["vendor-chunks/prosemirror-view"];
exports.modules = {

/***/ "(ssr)/./node_modules/prosemirror-view/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/prosemirror-view/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Decoration: () => (/* binding */ Decoration),\n/* harmony export */   DecorationSet: () => (/* binding */ DecorationSet),\n/* harmony export */   EditorView: () => (/* binding */ EditorView),\n/* harmony export */   __endComposition: () => (/* binding */ __endComposition),\n/* harmony export */   __parseFromClipboard: () => (/* binding */ __parseFromClipboard)\n/* harmony export */ });\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-state */ \"(ssr)/./node_modules/prosemirror-state/dist/index.js\");\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-model */ \"(ssr)/./node_modules/prosemirror-model/dist/index.js\");\n/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-transform */ \"(ssr)/./node_modules/prosemirror-transform/dist/index.js\");\n\n\n\nconst domIndex = function(node) {\n    for(var index = 0;; index++){\n        node = node.previousSibling;\n        if (!node) return index;\n    }\n};\nconst parentNode = function(node) {\n    let parent = node.assignedSlot || node.parentNode;\n    return parent && parent.nodeType == 11 ? parent.host : parent;\n};\nlet reusedRange = null;\n// Note that this will always return the same range, because DOM range\n// objects are every expensive, and keep slowing down subsequent DOM\n// updates, for some reason.\nconst textRange = function(node, from, to) {\n    let range = reusedRange || (reusedRange = document.createRange());\n    range.setEnd(node, to == null ? node.nodeValue.length : to);\n    range.setStart(node, from || 0);\n    return range;\n};\nconst clearReusedRange = function() {\n    reusedRange = null;\n};\n// Scans forward and backward through DOM positions equivalent to the\n// given one to see if the two are in the same place (i.e. after a\n// text node vs at the end of that text node)\nconst isEquivalentPosition = function(node, off, targetNode, targetOff) {\n    return targetNode && (scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1));\n};\nconst atomElements = /^(img|br|input|textarea|hr)$/i;\nfunction scanFor(node, off, targetNode, targetOff, dir) {\n    var _a;\n    for(;;){\n        if (node == targetNode && off == targetOff) return true;\n        if (off == (dir < 0 ? 0 : nodeSize(node))) {\n            let parent = node.parentNode;\n            if (!parent || parent.nodeType != 1 || hasBlockDesc(node) || atomElements.test(node.nodeName) || node.contentEditable == \"false\") return false;\n            off = domIndex(node) + (dir < 0 ? 0 : 1);\n            node = parent;\n        } else if (node.nodeType == 1) {\n            let child = node.childNodes[off + (dir < 0 ? -1 : 0)];\n            if (child.nodeType == 1 && child.contentEditable == \"false\") {\n                if ((_a = child.pmViewDesc) === null || _a === void 0 ? void 0 : _a.ignoreForSelection) off += dir;\n                else return false;\n            } else {\n                node = child;\n                off = dir < 0 ? nodeSize(node) : 0;\n            }\n        } else {\n            return false;\n        }\n    }\n}\nfunction nodeSize(node) {\n    return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;\n}\nfunction textNodeBefore$1(node, offset) {\n    for(;;){\n        if (node.nodeType == 3 && offset) return node;\n        if (node.nodeType == 1 && offset > 0) {\n            if (node.contentEditable == \"false\") return null;\n            node = node.childNodes[offset - 1];\n            offset = nodeSize(node);\n        } else if (node.parentNode && !hasBlockDesc(node)) {\n            offset = domIndex(node);\n            node = node.parentNode;\n        } else {\n            return null;\n        }\n    }\n}\nfunction textNodeAfter$1(node, offset) {\n    for(;;){\n        if (node.nodeType == 3 && offset < node.nodeValue.length) return node;\n        if (node.nodeType == 1 && offset < node.childNodes.length) {\n            if (node.contentEditable == \"false\") return null;\n            node = node.childNodes[offset];\n            offset = 0;\n        } else if (node.parentNode && !hasBlockDesc(node)) {\n            offset = domIndex(node) + 1;\n            node = node.parentNode;\n        } else {\n            return null;\n        }\n    }\n}\nfunction isOnEdge(node, offset, parent) {\n    for(let atStart = offset == 0, atEnd = offset == nodeSize(node); atStart || atEnd;){\n        if (node == parent) return true;\n        let index = domIndex(node);\n        node = node.parentNode;\n        if (!node) return false;\n        atStart = atStart && index == 0;\n        atEnd = atEnd && index == nodeSize(node);\n    }\n}\nfunction hasBlockDesc(dom) {\n    let desc;\n    for(let cur = dom; cur; cur = cur.parentNode)if (desc = cur.pmViewDesc) break;\n    return desc && desc.node && desc.node.isBlock && (desc.dom == dom || desc.contentDOM == dom);\n}\n// Work around Chrome issue https://bugs.chromium.org/p/chromium/issues/detail?id=447523\n// (isCollapsed inappropriately returns true in shadow dom)\nconst selectionCollapsed = function(domSel) {\n    return domSel.focusNode && isEquivalentPosition(domSel.focusNode, domSel.focusOffset, domSel.anchorNode, domSel.anchorOffset);\n};\nfunction keyEvent(keyCode, key) {\n    let event = document.createEvent(\"Event\");\n    event.initEvent(\"keydown\", true, true);\n    event.keyCode = keyCode;\n    event.key = event.code = key;\n    return event;\n}\nfunction deepActiveElement(doc) {\n    let elt = doc.activeElement;\n    while(elt && elt.shadowRoot)elt = elt.shadowRoot.activeElement;\n    return elt;\n}\nfunction caretFromPoint(doc, x, y) {\n    if (doc.caretPositionFromPoint) {\n        try {\n            let pos = doc.caretPositionFromPoint(x, y);\n            // Clip the offset, because Chrome will return a text offset\n            // into <input> nodes, which can't be treated as a regular DOM\n            // offset\n            if (pos) return {\n                node: pos.offsetNode,\n                offset: Math.min(nodeSize(pos.offsetNode), pos.offset)\n            };\n        } catch (_) {}\n    }\n    if (doc.caretRangeFromPoint) {\n        let range = doc.caretRangeFromPoint(x, y);\n        if (range) return {\n            node: range.startContainer,\n            offset: Math.min(nodeSize(range.startContainer), range.startOffset)\n        };\n    }\n}\nconst nav = typeof navigator != \"undefined\" ? navigator : null;\nconst doc = typeof document != \"undefined\" ? document : null;\nconst agent = nav && nav.userAgent || \"\";\nconst ie_edge = /Edge\\/(\\d+)/.exec(agent);\nconst ie_upto10 = /MSIE \\d/.exec(agent);\nconst ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(agent);\nconst ie = !!(ie_upto10 || ie_11up || ie_edge);\nconst ie_version = ie_upto10 ? document.documentMode : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0;\nconst gecko = !ie && /gecko\\/(\\d+)/i.test(agent);\ngecko && +(/Firefox\\/(\\d+)/.exec(agent) || [\n    0,\n    0\n])[1];\nconst _chrome = !ie && /Chrome\\/(\\d+)/.exec(agent);\nconst chrome = !!_chrome;\nconst chrome_version = _chrome ? +_chrome[1] : 0;\nconst safari = !ie && !!nav && /Apple Computer/.test(nav.vendor);\n// Is true for both iOS and iPadOS for convenience\nconst ios = safari && (/Mobile\\/\\w+/.test(agent) || !!nav && nav.maxTouchPoints > 2);\nconst mac = ios || (nav ? /Mac/.test(nav.platform) : false);\nconst windows = nav ? /Win/.test(nav.platform) : false;\nconst android = /Android \\d/.test(agent);\nconst webkit = !!doc && \"webkitFontSmoothing\" in doc.documentElement.style;\nconst webkit_version = webkit ? +(/\\bAppleWebKit\\/(\\d+)/.exec(navigator.userAgent) || [\n    0,\n    0\n])[1] : 0;\nfunction windowRect(doc) {\n    let vp = doc.defaultView && doc.defaultView.visualViewport;\n    if (vp) return {\n        left: 0,\n        right: vp.width,\n        top: 0,\n        bottom: vp.height\n    };\n    return {\n        left: 0,\n        right: doc.documentElement.clientWidth,\n        top: 0,\n        bottom: doc.documentElement.clientHeight\n    };\n}\nfunction getSide(value, side) {\n    return typeof value == \"number\" ? value : value[side];\n}\nfunction clientRect(node) {\n    let rect = node.getBoundingClientRect();\n    // Adjust for elements with style \"transform: scale()\"\n    let scaleX = rect.width / node.offsetWidth || 1;\n    let scaleY = rect.height / node.offsetHeight || 1;\n    // Make sure scrollbar width isn't included in the rectangle\n    return {\n        left: rect.left,\n        right: rect.left + node.clientWidth * scaleX,\n        top: rect.top,\n        bottom: rect.top + node.clientHeight * scaleY\n    };\n}\nfunction scrollRectIntoView(view, rect, startDOM) {\n    let scrollThreshold = view.someProp(\"scrollThreshold\") || 0, scrollMargin = view.someProp(\"scrollMargin\") || 5;\n    let doc = view.dom.ownerDocument;\n    for(let parent = startDOM || view.dom;;){\n        if (!parent) break;\n        if (parent.nodeType != 1) {\n            parent = parentNode(parent);\n            continue;\n        }\n        let elt = parent;\n        let atTop = elt == doc.body;\n        let bounding = atTop ? windowRect(doc) : clientRect(elt);\n        let moveX = 0, moveY = 0;\n        if (rect.top < bounding.top + getSide(scrollThreshold, \"top\")) moveY = -(bounding.top - rect.top + getSide(scrollMargin, \"top\"));\n        else if (rect.bottom > bounding.bottom - getSide(scrollThreshold, \"bottom\")) moveY = rect.bottom - rect.top > bounding.bottom - bounding.top ? rect.top + getSide(scrollMargin, \"top\") - bounding.top : rect.bottom - bounding.bottom + getSide(scrollMargin, \"bottom\");\n        if (rect.left < bounding.left + getSide(scrollThreshold, \"left\")) moveX = -(bounding.left - rect.left + getSide(scrollMargin, \"left\"));\n        else if (rect.right > bounding.right - getSide(scrollThreshold, \"right\")) moveX = rect.right - bounding.right + getSide(scrollMargin, \"right\");\n        if (moveX || moveY) {\n            if (atTop) {\n                doc.defaultView.scrollBy(moveX, moveY);\n            } else {\n                let startX = elt.scrollLeft, startY = elt.scrollTop;\n                if (moveY) elt.scrollTop += moveY;\n                if (moveX) elt.scrollLeft += moveX;\n                let dX = elt.scrollLeft - startX, dY = elt.scrollTop - startY;\n                rect = {\n                    left: rect.left - dX,\n                    top: rect.top - dY,\n                    right: rect.right - dX,\n                    bottom: rect.bottom - dY\n                };\n            }\n        }\n        let pos = atTop ? \"fixed\" : getComputedStyle(parent).position;\n        if (/^(fixed|sticky)$/.test(pos)) break;\n        parent = pos == \"absolute\" ? parent.offsetParent : parentNode(parent);\n    }\n}\n// Store the scroll position of the editor's parent nodes, along with\n// the top position of an element near the top of the editor, which\n// will be used to make sure the visible viewport remains stable even\n// when the size of the content above changes.\nfunction storeScrollPos(view) {\n    let rect = view.dom.getBoundingClientRect(), startY = Math.max(0, rect.top);\n    let refDOM, refTop;\n    for(let x = (rect.left + rect.right) / 2, y = startY + 1; y < Math.min(innerHeight, rect.bottom); y += 5){\n        let dom = view.root.elementFromPoint(x, y);\n        if (!dom || dom == view.dom || !view.dom.contains(dom)) continue;\n        let localRect = dom.getBoundingClientRect();\n        if (localRect.top >= startY - 20) {\n            refDOM = dom;\n            refTop = localRect.top;\n            break;\n        }\n    }\n    return {\n        refDOM: refDOM,\n        refTop: refTop,\n        stack: scrollStack(view.dom)\n    };\n}\nfunction scrollStack(dom) {\n    let stack = [], doc = dom.ownerDocument;\n    for(let cur = dom; cur; cur = parentNode(cur)){\n        stack.push({\n            dom: cur,\n            top: cur.scrollTop,\n            left: cur.scrollLeft\n        });\n        if (dom == doc) break;\n    }\n    return stack;\n}\n// Reset the scroll position of the editor's parent nodes to that what\n// it was before, when storeScrollPos was called.\nfunction resetScrollPos({ refDOM, refTop, stack }) {\n    let newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;\n    restoreScrollStack(stack, newRefTop == 0 ? 0 : newRefTop - refTop);\n}\nfunction restoreScrollStack(stack, dTop) {\n    for(let i = 0; i < stack.length; i++){\n        let { dom, top, left } = stack[i];\n        if (dom.scrollTop != top + dTop) dom.scrollTop = top + dTop;\n        if (dom.scrollLeft != left) dom.scrollLeft = left;\n    }\n}\nlet preventScrollSupported = null;\n// Feature-detects support for .focus({preventScroll: true}), and uses\n// a fallback kludge when not supported.\nfunction focusPreventScroll(dom) {\n    if (dom.setActive) return dom.setActive(); // in IE\n    if (preventScrollSupported) return dom.focus(preventScrollSupported);\n    let stored = scrollStack(dom);\n    dom.focus(preventScrollSupported == null ? {\n        get preventScroll () {\n            preventScrollSupported = {\n                preventScroll: true\n            };\n            return true;\n        }\n    } : undefined);\n    if (!preventScrollSupported) {\n        preventScrollSupported = false;\n        restoreScrollStack(stored, 0);\n    }\n}\nfunction findOffsetInNode(node, coords) {\n    let closest, dxClosest = 2e8, coordsClosest, offset = 0;\n    let rowBot = coords.top, rowTop = coords.top;\n    let firstBelow, coordsBelow;\n    for(let child = node.firstChild, childIndex = 0; child; child = child.nextSibling, childIndex++){\n        let rects;\n        if (child.nodeType == 1) rects = child.getClientRects();\n        else if (child.nodeType == 3) rects = textRange(child).getClientRects();\n        else continue;\n        for(let i = 0; i < rects.length; i++){\n            let rect = rects[i];\n            if (rect.top <= rowBot && rect.bottom >= rowTop) {\n                rowBot = Math.max(rect.bottom, rowBot);\n                rowTop = Math.min(rect.top, rowTop);\n                let dx = rect.left > coords.left ? rect.left - coords.left : rect.right < coords.left ? coords.left - rect.right : 0;\n                if (dx < dxClosest) {\n                    closest = child;\n                    dxClosest = dx;\n                    coordsClosest = dx && closest.nodeType == 3 ? {\n                        left: rect.right < coords.left ? rect.right : rect.left,\n                        top: coords.top\n                    } : coords;\n                    if (child.nodeType == 1 && dx) offset = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0);\n                    continue;\n                }\n            } else if (rect.top > coords.top && !firstBelow && rect.left <= coords.left && rect.right >= coords.left) {\n                firstBelow = child;\n                coordsBelow = {\n                    left: Math.max(rect.left, Math.min(rect.right, coords.left)),\n                    top: rect.top\n                };\n            }\n            if (!closest && (coords.left >= rect.right && coords.top >= rect.top || coords.left >= rect.left && coords.top >= rect.bottom)) offset = childIndex + 1;\n        }\n    }\n    if (!closest && firstBelow) {\n        closest = firstBelow;\n        coordsClosest = coordsBelow;\n        dxClosest = 0;\n    }\n    if (closest && closest.nodeType == 3) return findOffsetInText(closest, coordsClosest);\n    if (!closest || dxClosest && closest.nodeType == 1) return {\n        node,\n        offset\n    };\n    return findOffsetInNode(closest, coordsClosest);\n}\nfunction findOffsetInText(node, coords) {\n    let len = node.nodeValue.length;\n    let range = document.createRange(), result;\n    for(let i = 0; i < len; i++){\n        range.setEnd(node, i + 1);\n        range.setStart(node, i);\n        let rect = singleRect(range, 1);\n        if (rect.top == rect.bottom) continue;\n        if (inRect(coords, rect)) {\n            result = {\n                node,\n                offset: i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0)\n            };\n            break;\n        }\n    }\n    range.detach();\n    return result || {\n        node,\n        offset: 0\n    };\n}\nfunction inRect(coords, rect) {\n    return coords.left >= rect.left - 1 && coords.left <= rect.right + 1 && coords.top >= rect.top - 1 && coords.top <= rect.bottom + 1;\n}\nfunction targetKludge(dom, coords) {\n    let parent = dom.parentNode;\n    if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left) return parent;\n    return dom;\n}\nfunction posFromElement(view, elt, coords) {\n    let { node, offset } = findOffsetInNode(elt, coords), bias = -1;\n    if (node.nodeType == 1 && !node.firstChild) {\n        let rect = node.getBoundingClientRect();\n        bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;\n    }\n    return view.docView.posFromDOM(node, offset, bias);\n}\nfunction posFromCaret(view, node, offset, coords) {\n    // Browser (in caretPosition/RangeFromPoint) will agressively\n    // normalize towards nearby inline nodes. Since we are interested in\n    // positions between block nodes too, we first walk up the hierarchy\n    // of nodes to see if there are block nodes that the coordinates\n    // fall outside of. If so, we take the position before/after that\n    // block. If not, we call `posFromDOM` on the raw node/offset.\n    let outsideBlock = -1;\n    for(let cur = node, sawBlock = false;;){\n        if (cur == view.dom) break;\n        let desc = view.docView.nearestDesc(cur, true), rect;\n        if (!desc) return null;\n        if (desc.dom.nodeType == 1 && (desc.node.isBlock && desc.parent || !desc.contentDOM) && // Ignore elements with zero-size bounding rectangles\n        ((rect = desc.dom.getBoundingClientRect()).width || rect.height)) {\n            if (desc.node.isBlock && desc.parent && !/^T(R|BODY|HEAD|FOOT)$/.test(desc.dom.nodeName)) {\n                // Only apply the horizontal test to the innermost block. Vertical for any parent.\n                if (!sawBlock && rect.left > coords.left || rect.top > coords.top) outsideBlock = desc.posBefore;\n                else if (!sawBlock && rect.right < coords.left || rect.bottom < coords.top) outsideBlock = desc.posAfter;\n                sawBlock = true;\n            }\n            if (!desc.contentDOM && outsideBlock < 0 && !desc.node.isText) {\n                // If we are inside a leaf, return the side of the leaf closer to the coords\n                let before = desc.node.isBlock ? coords.top < (rect.top + rect.bottom) / 2 : coords.left < (rect.left + rect.right) / 2;\n                return before ? desc.posBefore : desc.posAfter;\n            }\n        }\n        cur = desc.dom.parentNode;\n    }\n    return outsideBlock > -1 ? outsideBlock : view.docView.posFromDOM(node, offset, -1);\n}\nfunction elementFromPoint(element, coords, box) {\n    let len = element.childNodes.length;\n    if (len && box.top < box.bottom) {\n        for(let startI = Math.max(0, Math.min(len - 1, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2)), i = startI;;){\n            let child = element.childNodes[i];\n            if (child.nodeType == 1) {\n                let rects = child.getClientRects();\n                for(let j = 0; j < rects.length; j++){\n                    let rect = rects[j];\n                    if (inRect(coords, rect)) return elementFromPoint(child, coords, rect);\n                }\n            }\n            if ((i = (i + 1) % len) == startI) break;\n        }\n    }\n    return element;\n}\n// Given an x,y position on the editor, get the position in the document.\nfunction posAtCoords(view, coords) {\n    let doc = view.dom.ownerDocument, node, offset = 0;\n    let caret = caretFromPoint(doc, coords.left, coords.top);\n    if (caret) ({ node, offset } = caret);\n    let elt = (view.root.elementFromPoint ? view.root : doc).elementFromPoint(coords.left, coords.top);\n    let pos;\n    if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {\n        let box = view.dom.getBoundingClientRect();\n        if (!inRect(coords, box)) return null;\n        elt = elementFromPoint(view.dom, coords, box);\n        if (!elt) return null;\n    }\n    // Safari's caretRangeFromPoint returns nonsense when on a draggable element\n    if (safari) {\n        for(let p = elt; node && p; p = parentNode(p))if (p.draggable) node = undefined;\n    }\n    elt = targetKludge(elt, coords);\n    if (node) {\n        if (gecko && node.nodeType == 1) {\n            // Firefox will sometimes return offsets into <input> nodes, which\n            // have no actual children, from caretPositionFromPoint (#953)\n            offset = Math.min(offset, node.childNodes.length);\n            // It'll also move the returned position before image nodes,\n            // even if those are behind it.\n            if (offset < node.childNodes.length) {\n                let next = node.childNodes[offset], box;\n                if (next.nodeName == \"IMG\" && (box = next.getBoundingClientRect()).right <= coords.left && box.bottom > coords.top) offset++;\n            }\n        }\n        let prev;\n        // When clicking above the right side of an uneditable node, Chrome will report a cursor position after that node.\n        if (webkit && offset && node.nodeType == 1 && (prev = node.childNodes[offset - 1]).nodeType == 1 && prev.contentEditable == \"false\" && prev.getBoundingClientRect().top >= coords.top) offset--;\n        // Suspiciously specific kludge to work around caret*FromPoint\n        // never returning a position at the end of the document\n        if (node == view.dom && offset == node.childNodes.length - 1 && node.lastChild.nodeType == 1 && coords.top > node.lastChild.getBoundingClientRect().bottom) pos = view.state.doc.content.size;\n        else if (offset == 0 || node.nodeType != 1 || node.childNodes[offset - 1].nodeName != \"BR\") pos = posFromCaret(view, node, offset, coords);\n    }\n    if (pos == null) pos = posFromElement(view, elt, coords);\n    let desc = view.docView.nearestDesc(elt, true);\n    return {\n        pos,\n        inside: desc ? desc.posAtStart - desc.border : -1\n    };\n}\nfunction nonZero(rect) {\n    return rect.top < rect.bottom || rect.left < rect.right;\n}\nfunction singleRect(target, bias) {\n    let rects = target.getClientRects();\n    if (rects.length) {\n        let first = rects[bias < 0 ? 0 : rects.length - 1];\n        if (nonZero(first)) return first;\n    }\n    return Array.prototype.find.call(rects, nonZero) || target.getBoundingClientRect();\n}\nconst BIDI = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\n// Given a position in the document model, get a bounding box of the\n// character at that position, relative to the window.\nfunction coordsAtPos(view, pos, side) {\n    let { node, offset, atom } = view.docView.domFromPos(pos, side < 0 ? -1 : 1);\n    let supportEmptyRange = webkit || gecko;\n    if (node.nodeType == 3) {\n        // These browsers support querying empty text ranges. Prefer that in\n        // bidi context or when at the end of a node.\n        if (supportEmptyRange && (BIDI.test(node.nodeValue) || (side < 0 ? !offset : offset == node.nodeValue.length))) {\n            let rect = singleRect(textRange(node, offset, offset), side);\n            // Firefox returns bad results (the position before the space)\n            // when querying a position directly after line-broken\n            // whitespace. Detect this situation and and kludge around it\n            if (gecko && offset && /\\s/.test(node.nodeValue[offset - 1]) && offset < node.nodeValue.length) {\n                let rectBefore = singleRect(textRange(node, offset - 1, offset - 1), -1);\n                if (rectBefore.top == rect.top) {\n                    let rectAfter = singleRect(textRange(node, offset, offset + 1), -1);\n                    if (rectAfter.top != rect.top) return flattenV(rectAfter, rectAfter.left < rectBefore.left);\n                }\n            }\n            return rect;\n        } else {\n            let from = offset, to = offset, takeSide = side < 0 ? 1 : -1;\n            if (side < 0 && !offset) {\n                to++;\n                takeSide = -1;\n            } else if (side >= 0 && offset == node.nodeValue.length) {\n                from--;\n                takeSide = 1;\n            } else if (side < 0) {\n                from--;\n            } else {\n                to++;\n            }\n            return flattenV(singleRect(textRange(node, from, to), takeSide), takeSide < 0);\n        }\n    }\n    let $dom = view.state.doc.resolve(pos - (atom || 0));\n    // Return a horizontal line in block context\n    if (!$dom.parent.inlineContent) {\n        if (atom == null && offset && (side < 0 || offset == nodeSize(node))) {\n            let before = node.childNodes[offset - 1];\n            if (before.nodeType == 1) return flattenH(before.getBoundingClientRect(), false);\n        }\n        if (atom == null && offset < nodeSize(node)) {\n            let after = node.childNodes[offset];\n            if (after.nodeType == 1) return flattenH(after.getBoundingClientRect(), true);\n        }\n        return flattenH(node.getBoundingClientRect(), side >= 0);\n    }\n    // Inline, not in text node (this is not Bidi-safe)\n    if (atom == null && offset && (side < 0 || offset == nodeSize(node))) {\n        let before = node.childNodes[offset - 1];\n        let target = before.nodeType == 3 ? textRange(before, nodeSize(before) - (supportEmptyRange ? 0 : 1)) : before.nodeType == 1 && (before.nodeName != \"BR\" || !before.nextSibling) ? before : null;\n        if (target) return flattenV(singleRect(target, 1), false);\n    }\n    if (atom == null && offset < nodeSize(node)) {\n        let after = node.childNodes[offset];\n        while(after.pmViewDesc && after.pmViewDesc.ignoreForCoords)after = after.nextSibling;\n        let target = !after ? null : after.nodeType == 3 ? textRange(after, 0, supportEmptyRange ? 0 : 1) : after.nodeType == 1 ? after : null;\n        if (target) return flattenV(singleRect(target, -1), true);\n    }\n    // All else failed, just try to get a rectangle for the target node\n    return flattenV(singleRect(node.nodeType == 3 ? textRange(node) : node, -side), side >= 0);\n}\nfunction flattenV(rect, left) {\n    if (rect.width == 0) return rect;\n    let x = left ? rect.left : rect.right;\n    return {\n        top: rect.top,\n        bottom: rect.bottom,\n        left: x,\n        right: x\n    };\n}\nfunction flattenH(rect, top) {\n    if (rect.height == 0) return rect;\n    let y = top ? rect.top : rect.bottom;\n    return {\n        top: y,\n        bottom: y,\n        left: rect.left,\n        right: rect.right\n    };\n}\nfunction withFlushedState(view, state, f) {\n    let viewState = view.state, active = view.root.activeElement;\n    if (viewState != state) view.updateState(state);\n    if (active != view.dom) view.focus();\n    try {\n        return f();\n    } finally{\n        if (viewState != state) view.updateState(viewState);\n        if (active != view.dom && active) active.focus();\n    }\n}\n// Whether vertical position motion in a given direction\n// from a position would leave a text block.\nfunction endOfTextblockVertical(view, state, dir) {\n    let sel = state.selection;\n    let $pos = dir == \"up\" ? sel.$from : sel.$to;\n    return withFlushedState(view, state, ()=>{\n        let { node: dom } = view.docView.domFromPos($pos.pos, dir == \"up\" ? -1 : 1);\n        for(;;){\n            let nearest = view.docView.nearestDesc(dom, true);\n            if (!nearest) break;\n            if (nearest.node.isBlock) {\n                dom = nearest.contentDOM || nearest.dom;\n                break;\n            }\n            dom = nearest.dom.parentNode;\n        }\n        let coords = coordsAtPos(view, $pos.pos, 1);\n        for(let child = dom.firstChild; child; child = child.nextSibling){\n            let boxes;\n            if (child.nodeType == 1) boxes = child.getClientRects();\n            else if (child.nodeType == 3) boxes = textRange(child, 0, child.nodeValue.length).getClientRects();\n            else continue;\n            for(let i = 0; i < boxes.length; i++){\n                let box = boxes[i];\n                if (box.bottom > box.top + 1 && (dir == \"up\" ? coords.top - box.top > (box.bottom - coords.top) * 2 : box.bottom - coords.bottom > (coords.bottom - box.top) * 2)) return false;\n            }\n        }\n        return true;\n    });\n}\nconst maybeRTL = /[\\u0590-\\u08ac]/;\nfunction endOfTextblockHorizontal(view, state, dir) {\n    let { $head } = state.selection;\n    if (!$head.parent.isTextblock) return false;\n    let offset = $head.parentOffset, atStart = !offset, atEnd = offset == $head.parent.content.size;\n    let sel = view.domSelection();\n    if (!sel) return $head.pos == $head.start() || $head.pos == $head.end();\n    // If the textblock is all LTR, or the browser doesn't support\n    // Selection.modify (Edge), fall back to a primitive approach\n    if (!maybeRTL.test($head.parent.textContent) || !sel.modify) return dir == \"left\" || dir == \"backward\" ? atStart : atEnd;\n    return withFlushedState(view, state, ()=>{\n        // This is a huge hack, but appears to be the best we can\n        // currently do: use `Selection.modify` to move the selection by\n        // one character, and see if that moves the cursor out of the\n        // textblock (or doesn't move it at all, when at the start/end of\n        // the document).\n        let { focusNode: oldNode, focusOffset: oldOff, anchorNode, anchorOffset } = view.domSelectionRange();\n        let oldBidiLevel = sel.caretBidiLevel // Only for Firefox\n        ;\n        sel.modify(\"move\", dir, \"character\");\n        let parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom;\n        let { focusNode: newNode, focusOffset: newOff } = view.domSelectionRange();\n        let result = newNode && !parentDOM.contains(newNode.nodeType == 1 ? newNode : newNode.parentNode) || oldNode == newNode && oldOff == newOff;\n        // Restore the previous selection\n        try {\n            sel.collapse(anchorNode, anchorOffset);\n            if (oldNode && (oldNode != anchorNode || oldOff != anchorOffset) && sel.extend) sel.extend(oldNode, oldOff);\n        } catch (_) {}\n        if (oldBidiLevel != null) sel.caretBidiLevel = oldBidiLevel;\n        return result;\n    });\n}\nlet cachedState = null;\nlet cachedDir = null;\nlet cachedResult = false;\nfunction endOfTextblock(view, state, dir) {\n    if (cachedState == state && cachedDir == dir) return cachedResult;\n    cachedState = state;\n    cachedDir = dir;\n    return cachedResult = dir == \"up\" || dir == \"down\" ? endOfTextblockVertical(view, state, dir) : endOfTextblockHorizontal(view, state, dir);\n}\n// View descriptions are data structures that describe the DOM that is\n// used to represent the editor's content. They are used for:\n//\n// - Incremental redrawing when the document changes\n//\n// - Figuring out what part of the document a given DOM position\n//   corresponds to\n//\n// - Wiring in custom implementations of the editing interface for a\n//   given node\n//\n// They form a doubly-linked mutable tree, starting at `view.docView`.\nconst NOT_DIRTY = 0, CHILD_DIRTY = 1, CONTENT_DIRTY = 2, NODE_DIRTY = 3;\n// Superclass for the various kinds of descriptions. Defines their\n// basic structure and shared methods.\nclass ViewDesc {\n    constructor(parent, children, dom, // This is the node that holds the child views. It may be null for\n    // descs that don't have children.\n    contentDOM){\n        this.parent = parent;\n        this.children = children;\n        this.dom = dom;\n        this.contentDOM = contentDOM;\n        this.dirty = NOT_DIRTY;\n        // An expando property on the DOM node provides a link back to its\n        // description.\n        dom.pmViewDesc = this;\n    }\n    // Used to check whether a given description corresponds to a\n    // widget/mark/node.\n    matchesWidget(widget) {\n        return false;\n    }\n    matchesMark(mark) {\n        return false;\n    }\n    matchesNode(node, outerDeco, innerDeco) {\n        return false;\n    }\n    matchesHack(nodeName) {\n        return false;\n    }\n    // When parsing in-editor content (in domchange.js), we allow\n    // descriptions to determine the parse rules that should be used to\n    // parse them.\n    parseRule() {\n        return null;\n    }\n    // Used by the editor's event handler to ignore events that come\n    // from certain descs.\n    stopEvent(event) {\n        return false;\n    }\n    // The size of the content represented by this desc.\n    get size() {\n        let size = 0;\n        for(let i = 0; i < this.children.length; i++)size += this.children[i].size;\n        return size;\n    }\n    // For block nodes, this represents the space taken up by their\n    // start/end tokens.\n    get border() {\n        return 0;\n    }\n    destroy() {\n        this.parent = undefined;\n        if (this.dom.pmViewDesc == this) this.dom.pmViewDesc = undefined;\n        for(let i = 0; i < this.children.length; i++)this.children[i].destroy();\n    }\n    posBeforeChild(child) {\n        for(let i = 0, pos = this.posAtStart;; i++){\n            let cur = this.children[i];\n            if (cur == child) return pos;\n            pos += cur.size;\n        }\n    }\n    get posBefore() {\n        return this.parent.posBeforeChild(this);\n    }\n    get posAtStart() {\n        return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;\n    }\n    get posAfter() {\n        return this.posBefore + this.size;\n    }\n    get posAtEnd() {\n        return this.posAtStart + this.size - 2 * this.border;\n    }\n    localPosFromDOM(dom, offset, bias) {\n        // If the DOM position is in the content, use the child desc after\n        // it to figure out a position.\n        if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {\n            if (bias < 0) {\n                let domBefore, desc;\n                if (dom == this.contentDOM) {\n                    domBefore = dom.childNodes[offset - 1];\n                } else {\n                    while(dom.parentNode != this.contentDOM)dom = dom.parentNode;\n                    domBefore = dom.previousSibling;\n                }\n                while(domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this))domBefore = domBefore.previousSibling;\n                return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart;\n            } else {\n                let domAfter, desc;\n                if (dom == this.contentDOM) {\n                    domAfter = dom.childNodes[offset];\n                } else {\n                    while(dom.parentNode != this.contentDOM)dom = dom.parentNode;\n                    domAfter = dom.nextSibling;\n                }\n                while(domAfter && !((desc = domAfter.pmViewDesc) && desc.parent == this))domAfter = domAfter.nextSibling;\n                return domAfter ? this.posBeforeChild(desc) : this.posAtEnd;\n            }\n        }\n        // Otherwise, use various heuristics, falling back on the bias\n        // parameter, to determine whether to return the position at the\n        // start or at the end of this view desc.\n        let atEnd;\n        if (dom == this.dom && this.contentDOM) {\n            atEnd = offset > domIndex(this.contentDOM);\n        } else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {\n            atEnd = dom.compareDocumentPosition(this.contentDOM) & 2;\n        } else if (this.dom.firstChild) {\n            if (offset == 0) for(let search = dom;; search = search.parentNode){\n                if (search == this.dom) {\n                    atEnd = false;\n                    break;\n                }\n                if (search.previousSibling) break;\n            }\n            if (atEnd == null && offset == dom.childNodes.length) for(let search = dom;; search = search.parentNode){\n                if (search == this.dom) {\n                    atEnd = true;\n                    break;\n                }\n                if (search.nextSibling) break;\n            }\n        }\n        return (atEnd == null ? bias > 0 : atEnd) ? this.posAtEnd : this.posAtStart;\n    }\n    nearestDesc(dom, onlyNodes = false) {\n        for(let first = true, cur = dom; cur; cur = cur.parentNode){\n            let desc = this.getDesc(cur), nodeDOM;\n            if (desc && (!onlyNodes || desc.node)) {\n                // If dom is outside of this desc's nodeDOM, don't count it.\n                if (first && (nodeDOM = desc.nodeDOM) && !(nodeDOM.nodeType == 1 ? nodeDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode) : nodeDOM == dom)) first = false;\n                else return desc;\n            }\n        }\n    }\n    getDesc(dom) {\n        let desc = dom.pmViewDesc;\n        for(let cur = desc; cur; cur = cur.parent)if (cur == this) return desc;\n    }\n    posFromDOM(dom, offset, bias) {\n        for(let scan = dom; scan; scan = scan.parentNode){\n            let desc = this.getDesc(scan);\n            if (desc) return desc.localPosFromDOM(dom, offset, bias);\n        }\n        return -1;\n    }\n    // Find the desc for the node after the given pos, if any. (When a\n    // parent node overrode rendering, there might not be one.)\n    descAt(pos) {\n        for(let i = 0, offset = 0; i < this.children.length; i++){\n            let child = this.children[i], end = offset + child.size;\n            if (offset == pos && end != offset) {\n                while(!child.border && child.children.length){\n                    for(let i = 0; i < child.children.length; i++){\n                        let inner = child.children[i];\n                        if (inner.size) {\n                            child = inner;\n                            break;\n                        }\n                    }\n                }\n                return child;\n            }\n            if (pos < end) return child.descAt(pos - offset - child.border);\n            offset = end;\n        }\n    }\n    domFromPos(pos, side) {\n        if (!this.contentDOM) return {\n            node: this.dom,\n            offset: 0,\n            atom: pos + 1\n        };\n        // First find the position in the child array\n        let i = 0, offset = 0;\n        for(let curPos = 0; i < this.children.length; i++){\n            let child = this.children[i], end = curPos + child.size;\n            if (end > pos || child instanceof TrailingHackViewDesc) {\n                offset = pos - curPos;\n                break;\n            }\n            curPos = end;\n        }\n        // If this points into the middle of a child, call through\n        if (offset) return this.children[i].domFromPos(offset - this.children[i].border, side);\n        // Go back if there were any zero-length widgets with side >= 0 before this point\n        for(let prev; i && !(prev = this.children[i - 1]).size && prev instanceof WidgetViewDesc && prev.side >= 0; i--){}\n        // Scan towards the first useable node\n        if (side <= 0) {\n            let prev, enter = true;\n            for(;; i--, enter = false){\n                prev = i ? this.children[i - 1] : null;\n                if (!prev || prev.dom.parentNode == this.contentDOM) break;\n            }\n            if (prev && side && enter && !prev.border && !prev.domAtom) return prev.domFromPos(prev.size, side);\n            return {\n                node: this.contentDOM,\n                offset: prev ? domIndex(prev.dom) + 1 : 0\n            };\n        } else {\n            let next, enter = true;\n            for(;; i++, enter = false){\n                next = i < this.children.length ? this.children[i] : null;\n                if (!next || next.dom.parentNode == this.contentDOM) break;\n            }\n            if (next && enter && !next.border && !next.domAtom) return next.domFromPos(0, side);\n            return {\n                node: this.contentDOM,\n                offset: next ? domIndex(next.dom) : this.contentDOM.childNodes.length\n            };\n        }\n    }\n    // Used to find a DOM range in a single parent for a given changed\n    // range.\n    parseRange(from, to, base = 0) {\n        if (this.children.length == 0) return {\n            node: this.contentDOM,\n            from,\n            to,\n            fromOffset: 0,\n            toOffset: this.contentDOM.childNodes.length\n        };\n        let fromOffset = -1, toOffset = -1;\n        for(let offset = base, i = 0;; i++){\n            let child = this.children[i], end = offset + child.size;\n            if (fromOffset == -1 && from <= end) {\n                let childBase = offset + child.border;\n                // FIXME maybe descend mark views to parse a narrower range?\n                if (from >= childBase && to <= end - child.border && child.node && child.contentDOM && this.contentDOM.contains(child.contentDOM)) return child.parseRange(from, to, childBase);\n                from = offset;\n                for(let j = i; j > 0; j--){\n                    let prev = this.children[j - 1];\n                    if (prev.size && prev.dom.parentNode == this.contentDOM && !prev.emptyChildAt(1)) {\n                        fromOffset = domIndex(prev.dom) + 1;\n                        break;\n                    }\n                    from -= prev.size;\n                }\n                if (fromOffset == -1) fromOffset = 0;\n            }\n            if (fromOffset > -1 && (end > to || i == this.children.length - 1)) {\n                to = end;\n                for(let j = i + 1; j < this.children.length; j++){\n                    let next = this.children[j];\n                    if (next.size && next.dom.parentNode == this.contentDOM && !next.emptyChildAt(-1)) {\n                        toOffset = domIndex(next.dom);\n                        break;\n                    }\n                    to += next.size;\n                }\n                if (toOffset == -1) toOffset = this.contentDOM.childNodes.length;\n                break;\n            }\n            offset = end;\n        }\n        return {\n            node: this.contentDOM,\n            from,\n            to,\n            fromOffset,\n            toOffset\n        };\n    }\n    emptyChildAt(side) {\n        if (this.border || !this.contentDOM || !this.children.length) return false;\n        let child = this.children[side < 0 ? 0 : this.children.length - 1];\n        return child.size == 0 || child.emptyChildAt(side);\n    }\n    domAfterPos(pos) {\n        let { node, offset } = this.domFromPos(pos, 0);\n        if (node.nodeType != 1 || offset == node.childNodes.length) throw new RangeError(\"No node after pos \" + pos);\n        return node.childNodes[offset];\n    }\n    // View descs are responsible for setting any selection that falls\n    // entirely inside of them, so that custom implementations can do\n    // custom things with the selection. Note that this falls apart when\n    // a selection starts in such a node and ends in another, in which\n    // case we just use whatever domFromPos produces as a best effort.\n    setSelection(anchor, head, view, force = false) {\n        // If the selection falls entirely in a child, give it to that child\n        let from = Math.min(anchor, head), to = Math.max(anchor, head);\n        for(let i = 0, offset = 0; i < this.children.length; i++){\n            let child = this.children[i], end = offset + child.size;\n            if (from > offset && to < end) return child.setSelection(anchor - offset - child.border, head - offset - child.border, view, force);\n            offset = end;\n        }\n        let anchorDOM = this.domFromPos(anchor, anchor ? -1 : 1);\n        let headDOM = head == anchor ? anchorDOM : this.domFromPos(head, head ? -1 : 1);\n        let domSel = view.root.getSelection();\n        let selRange = view.domSelectionRange();\n        let brKludge = false;\n        // On Firefox, using Selection.collapse to put the cursor after a\n        // BR node for some reason doesn't always work (#1073). On Safari,\n        // the cursor sometimes inexplicable visually lags behind its\n        // reported position in such situations (#1092).\n        if ((gecko || safari) && anchor == head) {\n            let { node, offset } = anchorDOM;\n            if (node.nodeType == 3) {\n                brKludge = !!(offset && node.nodeValue[offset - 1] == \"\\n\");\n                // Issue #1128\n                if (brKludge && offset == node.nodeValue.length) {\n                    for(let scan = node, after; scan; scan = scan.parentNode){\n                        if (after = scan.nextSibling) {\n                            if (after.nodeName == \"BR\") anchorDOM = headDOM = {\n                                node: after.parentNode,\n                                offset: domIndex(after) + 1\n                            };\n                            break;\n                        }\n                        let desc = scan.pmViewDesc;\n                        if (desc && desc.node && desc.node.isBlock) break;\n                    }\n                }\n            } else {\n                let prev = node.childNodes[offset - 1];\n                brKludge = prev && (prev.nodeName == \"BR\" || prev.contentEditable == \"false\");\n            }\n        }\n        // Firefox can act strangely when the selection is in front of an\n        // uneditable node. See #1163 and https://bugzilla.mozilla.org/show_bug.cgi?id=1709536\n        if (gecko && selRange.focusNode && selRange.focusNode != headDOM.node && selRange.focusNode.nodeType == 1) {\n            let after = selRange.focusNode.childNodes[selRange.focusOffset];\n            if (after && after.contentEditable == \"false\") force = true;\n        }\n        if (!(force || brKludge && safari) && isEquivalentPosition(anchorDOM.node, anchorDOM.offset, selRange.anchorNode, selRange.anchorOffset) && isEquivalentPosition(headDOM.node, headDOM.offset, selRange.focusNode, selRange.focusOffset)) return;\n        // Selection.extend can be used to create an 'inverted' selection\n        // (one where the focus is before the anchor), but not all\n        // browsers support it yet.\n        let domSelExtended = false;\n        if ((domSel.extend || anchor == head) && !(brKludge && gecko)) {\n            domSel.collapse(anchorDOM.node, anchorDOM.offset);\n            try {\n                if (anchor != head) domSel.extend(headDOM.node, headDOM.offset);\n                domSelExtended = true;\n            } catch (_) {\n            // In some cases with Chrome the selection is empty after calling\n            // collapse, even when it should be valid. This appears to be a bug, but\n            // it is difficult to isolate. If this happens fallback to the old path\n            // without using extend.\n            // Similarly, this could crash on Safari if the editor is hidden, and\n            // there was no selection.\n            }\n        }\n        if (!domSelExtended) {\n            if (anchor > head) {\n                let tmp = anchorDOM;\n                anchorDOM = headDOM;\n                headDOM = tmp;\n            }\n            let range = document.createRange();\n            range.setEnd(headDOM.node, headDOM.offset);\n            range.setStart(anchorDOM.node, anchorDOM.offset);\n            domSel.removeAllRanges();\n            domSel.addRange(range);\n        }\n    }\n    ignoreMutation(mutation) {\n        return !this.contentDOM && mutation.type != \"selection\";\n    }\n    get contentLost() {\n        return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);\n    }\n    // Remove a subtree of the element tree that has been touched\n    // by a DOM change, so that the next update will redraw it.\n    markDirty(from, to) {\n        for(let offset = 0, i = 0; i < this.children.length; i++){\n            let child = this.children[i], end = offset + child.size;\n            if (offset == end ? from <= end && to >= offset : from < end && to > offset) {\n                let startInside = offset + child.border, endInside = end - child.border;\n                if (from >= startInside && to <= endInside) {\n                    this.dirty = from == offset || to == end ? CONTENT_DIRTY : CHILD_DIRTY;\n                    if (from == startInside && to == endInside && (child.contentLost || child.dom.parentNode != this.contentDOM)) child.dirty = NODE_DIRTY;\n                    else child.markDirty(from - startInside, to - startInside);\n                    return;\n                } else {\n                    child.dirty = child.dom == child.contentDOM && child.dom.parentNode == this.contentDOM && !child.children.length ? CONTENT_DIRTY : NODE_DIRTY;\n                }\n            }\n            offset = end;\n        }\n        this.dirty = CONTENT_DIRTY;\n    }\n    markParentsDirty() {\n        let level = 1;\n        for(let node = this.parent; node; node = node.parent, level++){\n            let dirty = level == 1 ? CONTENT_DIRTY : CHILD_DIRTY;\n            if (node.dirty < dirty) node.dirty = dirty;\n        }\n    }\n    get domAtom() {\n        return false;\n    }\n    get ignoreForCoords() {\n        return false;\n    }\n    get ignoreForSelection() {\n        return false;\n    }\n    isText(text) {\n        return false;\n    }\n}\n// A widget desc represents a widget decoration, which is a DOM node\n// drawn between the document nodes.\nclass WidgetViewDesc extends ViewDesc {\n    constructor(parent, widget, view, pos){\n        let self, dom = widget.type.toDOM;\n        if (typeof dom == \"function\") dom = dom(view, ()=>{\n            if (!self) return pos;\n            if (self.parent) return self.parent.posBeforeChild(self);\n        });\n        if (!widget.type.spec.raw) {\n            if (dom.nodeType != 1) {\n                let wrap = document.createElement(\"span\");\n                wrap.appendChild(dom);\n                dom = wrap;\n            }\n            dom.contentEditable = \"false\";\n            dom.classList.add(\"ProseMirror-widget\");\n        }\n        super(parent, [], dom, null);\n        this.widget = widget;\n        this.widget = widget;\n        self = this;\n    }\n    matchesWidget(widget) {\n        return this.dirty == NOT_DIRTY && widget.type.eq(this.widget.type);\n    }\n    parseRule() {\n        return {\n            ignore: true\n        };\n    }\n    stopEvent(event) {\n        let stop = this.widget.spec.stopEvent;\n        return stop ? stop(event) : false;\n    }\n    ignoreMutation(mutation) {\n        return mutation.type != \"selection\" || this.widget.spec.ignoreSelection;\n    }\n    destroy() {\n        this.widget.type.destroy(this.dom);\n        super.destroy();\n    }\n    get domAtom() {\n        return true;\n    }\n    get ignoreForSelection() {\n        return !!this.widget.type.spec.relaxedSide;\n    }\n    get side() {\n        return this.widget.type.side;\n    }\n}\nclass CompositionViewDesc extends ViewDesc {\n    constructor(parent, dom, textDOM, text){\n        super(parent, [], dom, null);\n        this.textDOM = textDOM;\n        this.text = text;\n    }\n    get size() {\n        return this.text.length;\n    }\n    localPosFromDOM(dom, offset) {\n        if (dom != this.textDOM) return this.posAtStart + (offset ? this.size : 0);\n        return this.posAtStart + offset;\n    }\n    domFromPos(pos) {\n        return {\n            node: this.textDOM,\n            offset: pos\n        };\n    }\n    ignoreMutation(mut) {\n        return mut.type === \"characterData\" && mut.target.nodeValue == mut.oldValue;\n    }\n}\n// A mark desc represents a mark. May have multiple children,\n// depending on how the mark is split. Note that marks are drawn using\n// a fixed nesting order, for simplicity and predictability, so in\n// some cases they will be split more often than would appear\n// necessary.\nclass MarkViewDesc extends ViewDesc {\n    constructor(parent, mark, dom, contentDOM, spec){\n        super(parent, [], dom, contentDOM);\n        this.mark = mark;\n        this.spec = spec;\n    }\n    static create(parent, mark, inline, view) {\n        let custom = view.nodeViews[mark.type.name];\n        let spec = custom && custom(mark, view, inline);\n        if (!spec || !spec.dom) spec = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMSerializer.renderSpec(document, mark.type.spec.toDOM(mark, inline), null, mark.attrs);\n        return new MarkViewDesc(parent, mark, spec.dom, spec.contentDOM || spec.dom, spec);\n    }\n    parseRule() {\n        if (this.dirty & NODE_DIRTY || this.mark.type.spec.reparseInView) return null;\n        return {\n            mark: this.mark.type.name,\n            attrs: this.mark.attrs,\n            contentElement: this.contentDOM\n        };\n    }\n    matchesMark(mark) {\n        return this.dirty != NODE_DIRTY && this.mark.eq(mark);\n    }\n    markDirty(from, to) {\n        super.markDirty(from, to);\n        // Move dirty info to nearest node view\n        if (this.dirty != NOT_DIRTY) {\n            let parent = this.parent;\n            while(!parent.node)parent = parent.parent;\n            if (parent.dirty < this.dirty) parent.dirty = this.dirty;\n            this.dirty = NOT_DIRTY;\n        }\n    }\n    slice(from, to, view) {\n        let copy = MarkViewDesc.create(this.parent, this.mark, true, view);\n        let nodes = this.children, size = this.size;\n        if (to < size) nodes = replaceNodes(nodes, to, size, view);\n        if (from > 0) nodes = replaceNodes(nodes, 0, from, view);\n        for(let i = 0; i < nodes.length; i++)nodes[i].parent = copy;\n        copy.children = nodes;\n        return copy;\n    }\n    ignoreMutation(mutation) {\n        return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation);\n    }\n    destroy() {\n        if (this.spec.destroy) this.spec.destroy();\n        super.destroy();\n    }\n}\n// Node view descs are the main, most common type of view desc, and\n// correspond to an actual node in the document. Unlike mark descs,\n// they populate their child array themselves.\nclass NodeViewDesc extends ViewDesc {\n    constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos){\n        super(parent, [], dom, contentDOM);\n        this.node = node;\n        this.outerDeco = outerDeco;\n        this.innerDeco = innerDeco;\n        this.nodeDOM = nodeDOM;\n    }\n    // By default, a node is rendered using the `toDOM` method from the\n    // node type spec. But client code can use the `nodeViews` spec to\n    // supply a custom node view, which can influence various aspects of\n    // the way the node works.\n    //\n    // (Using subclassing for this was intentionally decided against,\n    // since it'd require exposing a whole slew of finicky\n    // implementation details to the user code that they probably will\n    // never need.)\n    static create(parent, node, outerDeco, innerDeco, view, pos) {\n        let custom = view.nodeViews[node.type.name], descObj;\n        let spec = custom && custom(node, view, ()=>{\n            // (This is a function that allows the custom view to find its\n            // own position)\n            if (!descObj) return pos;\n            if (descObj.parent) return descObj.parent.posBeforeChild(descObj);\n        }, outerDeco, innerDeco);\n        let dom = spec && spec.dom, contentDOM = spec && spec.contentDOM;\n        if (node.isText) {\n            if (!dom) dom = document.createTextNode(node.text);\n            else if (dom.nodeType != 3) throw new RangeError(\"Text must be rendered as a DOM text node\");\n        } else if (!dom) {\n            let spec = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMSerializer.renderSpec(document, node.type.spec.toDOM(node), null, node.attrs);\n            ({ dom, contentDOM } = spec);\n        }\n        if (!contentDOM && !node.isText && dom.nodeName != \"BR\") {\n            if (!dom.hasAttribute(\"contenteditable\")) dom.contentEditable = \"false\";\n            if (node.type.spec.draggable) dom.draggable = true;\n        }\n        let nodeDOM = dom;\n        dom = applyOuterDeco(dom, outerDeco, node);\n        if (spec) return descObj = new CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, spec, view, pos + 1);\n        else if (node.isText) return new TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view);\n        else return new NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, view, pos + 1);\n    }\n    parseRule() {\n        // Experimental kludge to allow opt-in re-parsing of nodes\n        if (this.node.type.spec.reparseInView) return null;\n        // FIXME the assumption that this can always return the current\n        // attrs means that if the user somehow manages to change the\n        // attrs in the dom, that won't be picked up. Not entirely sure\n        // whether this is a problem\n        let rule = {\n            node: this.node.type.name,\n            attrs: this.node.attrs\n        };\n        if (this.node.type.whitespace == \"pre\") rule.preserveWhitespace = \"full\";\n        if (!this.contentDOM) {\n            rule.getContent = ()=>this.node.content;\n        } else if (!this.contentLost) {\n            rule.contentElement = this.contentDOM;\n        } else {\n            // Chrome likes to randomly recreate parent nodes when\n            // backspacing things. When that happens, this tries to find the\n            // new parent.\n            for(let i = this.children.length - 1; i >= 0; i--){\n                let child = this.children[i];\n                if (this.dom.contains(child.dom.parentNode)) {\n                    rule.contentElement = child.dom.parentNode;\n                    break;\n                }\n            }\n            if (!rule.contentElement) rule.getContent = ()=>prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty;\n        }\n        return rule;\n    }\n    matchesNode(node, outerDeco, innerDeco) {\n        return this.dirty == NOT_DIRTY && node.eq(this.node) && sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco);\n    }\n    get size() {\n        return this.node.nodeSize;\n    }\n    get border() {\n        return this.node.isLeaf ? 0 : 1;\n    }\n    // Syncs `this.children` to match `this.node.content` and the local\n    // decorations, possibly introducing nesting for marks. Then, in a\n    // separate step, syncs the DOM inside `this.contentDOM` to\n    // `this.children`.\n    updateChildren(view, pos) {\n        let inline = this.node.inlineContent, off = pos;\n        let composition = view.composing ? this.localCompositionInfo(view, pos) : null;\n        let localComposition = composition && composition.pos > -1 ? composition : null;\n        let compositionInChild = composition && composition.pos < 0;\n        let updater = new ViewTreeUpdater(this, localComposition && localComposition.node, view);\n        iterDeco(this.node, this.innerDeco, (widget, i, insideNode)=>{\n            if (widget.spec.marks) updater.syncToMarks(widget.spec.marks, inline, view);\n            else if (widget.type.side >= 0 && !insideNode) updater.syncToMarks(i == this.node.childCount ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Mark.none : this.node.child(i).marks, inline, view);\n            // If the next node is a desc matching this widget, reuse it,\n            // otherwise insert the widget as a new view desc.\n            updater.placeWidget(widget, view, off);\n        }, (child, outerDeco, innerDeco, i)=>{\n            // Make sure the wrapping mark descs match the node's marks.\n            updater.syncToMarks(child.marks, inline, view);\n            // Try several strategies for drawing this node\n            let compIndex;\n            if (updater.findNodeMatch(child, outerDeco, innerDeco, i)) ;\n            else if (compositionInChild && view.state.selection.from > off && view.state.selection.to < off + child.nodeSize && (compIndex = updater.findIndexWithChild(composition.node)) > -1 && updater.updateNodeAt(child, outerDeco, innerDeco, compIndex, view)) ;\n            else if (updater.updateNextNode(child, outerDeco, innerDeco, view, i, off)) ;\n            else {\n                // Add it as a new view\n                updater.addNode(child, outerDeco, innerDeco, view, off);\n            }\n            off += child.nodeSize;\n        });\n        // Drop all remaining descs after the current position.\n        updater.syncToMarks([], inline, view);\n        if (this.node.isTextblock) updater.addTextblockHacks();\n        updater.destroyRest();\n        // Sync the DOM if anything changed\n        if (updater.changed || this.dirty == CONTENT_DIRTY) {\n            // May have to protect focused DOM from being changed if a composition is active\n            if (localComposition) this.protectLocalComposition(view, localComposition);\n            renderDescs(this.contentDOM, this.children, view);\n            if (ios) iosHacks(this.dom);\n        }\n    }\n    localCompositionInfo(view, pos) {\n        // Only do something if both the selection and a focused text node\n        // are inside of this node\n        let { from, to } = view.state.selection;\n        if (!(view.state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection) || from < pos || to > pos + this.node.content.size) return null;\n        let textNode = view.input.compositionNode;\n        if (!textNode || !this.dom.contains(textNode.parentNode)) return null;\n        if (this.node.inlineContent) {\n            // Find the text in the focused node in the node, stop if it's not\n            // there (may have been modified through other means, in which\n            // case it should overwritten)\n            let text = textNode.nodeValue;\n            let textPos = findTextInFragment(this.node.content, text, from - pos, to - pos);\n            return textPos < 0 ? null : {\n                node: textNode,\n                pos: textPos,\n                text\n            };\n        } else {\n            return {\n                node: textNode,\n                pos: -1,\n                text: \"\"\n            };\n        }\n    }\n    protectLocalComposition(view, { node, pos, text }) {\n        // The node is already part of a local view desc, leave it there\n        if (this.getDesc(node)) return;\n        // Create a composition view for the orphaned nodes\n        let topNode = node;\n        for(;; topNode = topNode.parentNode){\n            if (topNode.parentNode == this.contentDOM) break;\n            while(topNode.previousSibling)topNode.parentNode.removeChild(topNode.previousSibling);\n            while(topNode.nextSibling)topNode.parentNode.removeChild(topNode.nextSibling);\n            if (topNode.pmViewDesc) topNode.pmViewDesc = undefined;\n        }\n        let desc = new CompositionViewDesc(this, topNode, node, text);\n        view.input.compositionNodes.push(desc);\n        // Patch up this.children to contain the composition view\n        this.children = replaceNodes(this.children, pos, pos + text.length, view, desc);\n    }\n    // If this desc must be updated to match the given node decoration,\n    // do so and return true.\n    update(node, outerDeco, innerDeco, view) {\n        if (this.dirty == NODE_DIRTY || !node.sameMarkup(this.node)) return false;\n        this.updateInner(node, outerDeco, innerDeco, view);\n        return true;\n    }\n    updateInner(node, outerDeco, innerDeco, view) {\n        this.updateOuterDeco(outerDeco);\n        this.node = node;\n        this.innerDeco = innerDeco;\n        if (this.contentDOM) this.updateChildren(view, this.posAtStart);\n        this.dirty = NOT_DIRTY;\n    }\n    updateOuterDeco(outerDeco) {\n        if (sameOuterDeco(outerDeco, this.outerDeco)) return;\n        let needsWrap = this.nodeDOM.nodeType != 1;\n        let oldDOM = this.dom;\n        this.dom = patchOuterDeco(this.dom, this.nodeDOM, computeOuterDeco(this.outerDeco, this.node, needsWrap), computeOuterDeco(outerDeco, this.node, needsWrap));\n        if (this.dom != oldDOM) {\n            oldDOM.pmViewDesc = undefined;\n            this.dom.pmViewDesc = this;\n        }\n        this.outerDeco = outerDeco;\n    }\n    // Mark this node as being the selected node.\n    selectNode() {\n        if (this.nodeDOM.nodeType == 1) {\n            this.nodeDOM.classList.add(\"ProseMirror-selectednode\");\n            if (this.contentDOM || !this.node.type.spec.draggable) this.nodeDOM.draggable = true;\n        }\n    }\n    // Remove selected node marking from this node.\n    deselectNode() {\n        if (this.nodeDOM.nodeType == 1) {\n            this.nodeDOM.classList.remove(\"ProseMirror-selectednode\");\n            if (this.contentDOM || !this.node.type.spec.draggable) this.nodeDOM.removeAttribute(\"draggable\");\n        }\n    }\n    get domAtom() {\n        return this.node.isAtom;\n    }\n}\n// Create a view desc for the top-level document node, to be exported\n// and used by the view class.\nfunction docViewDesc(doc, outerDeco, innerDeco, dom, view) {\n    applyOuterDeco(dom, outerDeco, doc);\n    let docView = new NodeViewDesc(undefined, doc, outerDeco, innerDeco, dom, dom, dom, view, 0);\n    if (docView.contentDOM) docView.updateChildren(view, 0);\n    return docView;\n}\nclass TextViewDesc extends NodeViewDesc {\n    constructor(parent, node, outerDeco, innerDeco, dom, nodeDOM, view){\n        super(parent, node, outerDeco, innerDeco, dom, null, nodeDOM, view, 0);\n    }\n    parseRule() {\n        let skip = this.nodeDOM.parentNode;\n        while(skip && skip != this.dom && !skip.pmIsDeco)skip = skip.parentNode;\n        return {\n            skip: skip || true\n        };\n    }\n    update(node, outerDeco, innerDeco, view) {\n        if (this.dirty == NODE_DIRTY || this.dirty != NOT_DIRTY && !this.inParent() || !node.sameMarkup(this.node)) return false;\n        this.updateOuterDeco(outerDeco);\n        if ((this.dirty != NOT_DIRTY || node.text != this.node.text) && node.text != this.nodeDOM.nodeValue) {\n            this.nodeDOM.nodeValue = node.text;\n            if (view.trackWrites == this.nodeDOM) view.trackWrites = null;\n        }\n        this.node = node;\n        this.dirty = NOT_DIRTY;\n        return true;\n    }\n    inParent() {\n        let parentDOM = this.parent.contentDOM;\n        for(let n = this.nodeDOM; n; n = n.parentNode)if (n == parentDOM) return true;\n        return false;\n    }\n    domFromPos(pos) {\n        return {\n            node: this.nodeDOM,\n            offset: pos\n        };\n    }\n    localPosFromDOM(dom, offset, bias) {\n        if (dom == this.nodeDOM) return this.posAtStart + Math.min(offset, this.node.text.length);\n        return super.localPosFromDOM(dom, offset, bias);\n    }\n    ignoreMutation(mutation) {\n        return mutation.type != \"characterData\" && mutation.type != \"selection\";\n    }\n    slice(from, to, view) {\n        let node = this.node.cut(from, to), dom = document.createTextNode(node.text);\n        return new TextViewDesc(this.parent, node, this.outerDeco, this.innerDeco, dom, dom, view);\n    }\n    markDirty(from, to) {\n        super.markDirty(from, to);\n        if (this.dom != this.nodeDOM && (from == 0 || to == this.nodeDOM.nodeValue.length)) this.dirty = NODE_DIRTY;\n    }\n    get domAtom() {\n        return false;\n    }\n    isText(text) {\n        return this.node.text == text;\n    }\n}\n// A dummy desc used to tag trailing BR or IMG nodes created to work\n// around contentEditable terribleness.\nclass TrailingHackViewDesc extends ViewDesc {\n    parseRule() {\n        return {\n            ignore: true\n        };\n    }\n    matchesHack(nodeName) {\n        return this.dirty == NOT_DIRTY && this.dom.nodeName == nodeName;\n    }\n    get domAtom() {\n        return true;\n    }\n    get ignoreForCoords() {\n        return this.dom.nodeName == \"IMG\";\n    }\n}\n// A separate subclass is used for customized node views, so that the\n// extra checks only have to be made for nodes that are actually\n// customized.\nclass CustomNodeViewDesc extends NodeViewDesc {\n    constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view, pos){\n        super(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos);\n        this.spec = spec;\n    }\n    // A custom `update` method gets to decide whether the update goes\n    // through. If it does, and there's a `contentDOM` node, our logic\n    // updates the children.\n    update(node, outerDeco, innerDeco, view) {\n        if (this.dirty == NODE_DIRTY) return false;\n        if (this.spec.update && (this.node.type == node.type || this.spec.multiType)) {\n            let result = this.spec.update(node, outerDeco, innerDeco);\n            if (result) this.updateInner(node, outerDeco, innerDeco, view);\n            return result;\n        } else if (!this.contentDOM && !node.isLeaf) {\n            return false;\n        } else {\n            return super.update(node, outerDeco, innerDeco, view);\n        }\n    }\n    selectNode() {\n        this.spec.selectNode ? this.spec.selectNode() : super.selectNode();\n    }\n    deselectNode() {\n        this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();\n    }\n    setSelection(anchor, head, view, force) {\n        this.spec.setSelection ? this.spec.setSelection(anchor, head, view.root) : super.setSelection(anchor, head, view, force);\n    }\n    destroy() {\n        if (this.spec.destroy) this.spec.destroy();\n        super.destroy();\n    }\n    stopEvent(event) {\n        return this.spec.stopEvent ? this.spec.stopEvent(event) : false;\n    }\n    ignoreMutation(mutation) {\n        return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation);\n    }\n}\n// Sync the content of the given DOM node with the nodes associated\n// with the given array of view descs, recursing into mark descs\n// because this should sync the subtree for a whole node at a time.\nfunction renderDescs(parentDOM, descs, view) {\n    let dom = parentDOM.firstChild, written = false;\n    for(let i = 0; i < descs.length; i++){\n        let desc = descs[i], childDOM = desc.dom;\n        if (childDOM.parentNode == parentDOM) {\n            while(childDOM != dom){\n                dom = rm(dom);\n                written = true;\n            }\n            dom = dom.nextSibling;\n        } else {\n            written = true;\n            parentDOM.insertBefore(childDOM, dom);\n        }\n        if (desc instanceof MarkViewDesc) {\n            let pos = dom ? dom.previousSibling : parentDOM.lastChild;\n            renderDescs(desc.contentDOM, desc.children, view);\n            dom = pos ? pos.nextSibling : parentDOM.firstChild;\n        }\n    }\n    while(dom){\n        dom = rm(dom);\n        written = true;\n    }\n    if (written && view.trackWrites == parentDOM) view.trackWrites = null;\n}\nconst OuterDecoLevel = function(nodeName) {\n    if (nodeName) this.nodeName = nodeName;\n};\nOuterDecoLevel.prototype = Object.create(null);\nconst noDeco = [\n    new OuterDecoLevel\n];\nfunction computeOuterDeco(outerDeco, node, needsWrap) {\n    if (outerDeco.length == 0) return noDeco;\n    let top = needsWrap ? noDeco[0] : new OuterDecoLevel, result = [\n        top\n    ];\n    for(let i = 0; i < outerDeco.length; i++){\n        let attrs = outerDeco[i].type.attrs;\n        if (!attrs) continue;\n        if (attrs.nodeName) result.push(top = new OuterDecoLevel(attrs.nodeName));\n        for(let name in attrs){\n            let val = attrs[name];\n            if (val == null) continue;\n            if (needsWrap && result.length == 1) result.push(top = new OuterDecoLevel(node.isInline ? \"span\" : \"div\"));\n            if (name == \"class\") top.class = (top.class ? top.class + \" \" : \"\") + val;\n            else if (name == \"style\") top.style = (top.style ? top.style + \";\" : \"\") + val;\n            else if (name != \"nodeName\") top[name] = val;\n        }\n    }\n    return result;\n}\nfunction patchOuterDeco(outerDOM, nodeDOM, prevComputed, curComputed) {\n    // Shortcut for trivial case\n    if (prevComputed == noDeco && curComputed == noDeco) return nodeDOM;\n    let curDOM = nodeDOM;\n    for(let i = 0; i < curComputed.length; i++){\n        let deco = curComputed[i], prev = prevComputed[i];\n        if (i) {\n            let parent;\n            if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM && (parent = curDOM.parentNode) && parent.nodeName.toLowerCase() == deco.nodeName) {\n                curDOM = parent;\n            } else {\n                parent = document.createElement(deco.nodeName);\n                parent.pmIsDeco = true;\n                parent.appendChild(curDOM);\n                prev = noDeco[0];\n                curDOM = parent;\n            }\n        }\n        patchAttributes(curDOM, prev || noDeco[0], deco);\n    }\n    return curDOM;\n}\nfunction patchAttributes(dom, prev, cur) {\n    for(let name in prev)if (name != \"class\" && name != \"style\" && name != \"nodeName\" && !(name in cur)) dom.removeAttribute(name);\n    for(let name in cur)if (name != \"class\" && name != \"style\" && name != \"nodeName\" && cur[name] != prev[name]) dom.setAttribute(name, cur[name]);\n    if (prev.class != cur.class) {\n        let prevList = prev.class ? prev.class.split(\" \").filter(Boolean) : [];\n        let curList = cur.class ? cur.class.split(\" \").filter(Boolean) : [];\n        for(let i = 0; i < prevList.length; i++)if (curList.indexOf(prevList[i]) == -1) dom.classList.remove(prevList[i]);\n        for(let i = 0; i < curList.length; i++)if (prevList.indexOf(curList[i]) == -1) dom.classList.add(curList[i]);\n        if (dom.classList.length == 0) dom.removeAttribute(\"class\");\n    }\n    if (prev.style != cur.style) {\n        if (prev.style) {\n            let prop = /\\s*([\\w\\-\\xa1-\\uffff]+)\\s*:(?:\"(?:\\\\.|[^\"])*\"|'(?:\\\\.|[^'])*'|\\(.*?\\)|[^;])*/g, m;\n            while(m = prop.exec(prev.style))dom.style.removeProperty(m[1]);\n        }\n        if (cur.style) dom.style.cssText += cur.style;\n    }\n}\nfunction applyOuterDeco(dom, deco, node) {\n    return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node, dom.nodeType != 1));\n}\nfunction sameOuterDeco(a, b) {\n    if (a.length != b.length) return false;\n    for(let i = 0; i < a.length; i++)if (!a[i].type.eq(b[i].type)) return false;\n    return true;\n}\n// Remove a DOM node and return its next sibling.\nfunction rm(dom) {\n    let next = dom.nextSibling;\n    dom.parentNode.removeChild(dom);\n    return next;\n}\n// Helper class for incrementally updating a tree of mark descs and\n// the widget and node descs inside of them.\nclass ViewTreeUpdater {\n    constructor(top, lock, view){\n        this.lock = lock;\n        this.view = view;\n        // Index into `this.top`'s child array, represents the current\n        // update position.\n        this.index = 0;\n        // When entering a mark, the current top and index are pushed\n        // onto this.\n        this.stack = [];\n        // Tracks whether anything was changed\n        this.changed = false;\n        this.top = top;\n        this.preMatch = preMatch(top.node.content, top);\n    }\n    // Destroy and remove the children between the given indices in\n    // `this.top`.\n    destroyBetween(start, end) {\n        if (start == end) return;\n        for(let i = start; i < end; i++)this.top.children[i].destroy();\n        this.top.children.splice(start, end - start);\n        this.changed = true;\n    }\n    // Destroy all remaining children in `this.top`.\n    destroyRest() {\n        this.destroyBetween(this.index, this.top.children.length);\n    }\n    // Sync the current stack of mark descs with the given array of\n    // marks, reusing existing mark descs when possible.\n    syncToMarks(marks, inline, view) {\n        let keep = 0, depth = this.stack.length >> 1;\n        let maxKeep = Math.min(depth, marks.length);\n        while(keep < maxKeep && (keep == depth - 1 ? this.top : this.stack[keep + 1 << 1]).matchesMark(marks[keep]) && marks[keep].type.spec.spanning !== false)keep++;\n        while(keep < depth){\n            this.destroyRest();\n            this.top.dirty = NOT_DIRTY;\n            this.index = this.stack.pop();\n            this.top = this.stack.pop();\n            depth--;\n        }\n        while(depth < marks.length){\n            this.stack.push(this.top, this.index + 1);\n            let found = -1;\n            for(let i = this.index; i < Math.min(this.index + 3, this.top.children.length); i++){\n                let next = this.top.children[i];\n                if (next.matchesMark(marks[depth]) && !this.isLocked(next.dom)) {\n                    found = i;\n                    break;\n                }\n            }\n            if (found > -1) {\n                if (found > this.index) {\n                    this.changed = true;\n                    this.destroyBetween(this.index, found);\n                }\n                this.top = this.top.children[this.index];\n            } else {\n                let markDesc = MarkViewDesc.create(this.top, marks[depth], inline, view);\n                this.top.children.splice(this.index, 0, markDesc);\n                this.top = markDesc;\n                this.changed = true;\n            }\n            this.index = 0;\n            depth++;\n        }\n    }\n    // Try to find a node desc matching the given data. Skip over it and\n    // return true when successful.\n    findNodeMatch(node, outerDeco, innerDeco, index) {\n        let found = -1, targetDesc;\n        if (index >= this.preMatch.index && (targetDesc = this.preMatch.matches[index - this.preMatch.index]).parent == this.top && targetDesc.matchesNode(node, outerDeco, innerDeco)) {\n            found = this.top.children.indexOf(targetDesc, this.index);\n        } else {\n            for(let i = this.index, e = Math.min(this.top.children.length, i + 5); i < e; i++){\n                let child = this.top.children[i];\n                if (child.matchesNode(node, outerDeco, innerDeco) && !this.preMatch.matched.has(child)) {\n                    found = i;\n                    break;\n                }\n            }\n        }\n        if (found < 0) return false;\n        this.destroyBetween(this.index, found);\n        this.index++;\n        return true;\n    }\n    updateNodeAt(node, outerDeco, innerDeco, index, view) {\n        let child = this.top.children[index];\n        if (child.dirty == NODE_DIRTY && child.dom == child.contentDOM) child.dirty = CONTENT_DIRTY;\n        if (!child.update(node, outerDeco, innerDeco, view)) return false;\n        this.destroyBetween(this.index, index);\n        this.index++;\n        return true;\n    }\n    findIndexWithChild(domNode) {\n        for(;;){\n            let parent = domNode.parentNode;\n            if (!parent) return -1;\n            if (parent == this.top.contentDOM) {\n                let desc = domNode.pmViewDesc;\n                if (desc) for(let i = this.index; i < this.top.children.length; i++){\n                    if (this.top.children[i] == desc) return i;\n                }\n                return -1;\n            }\n            domNode = parent;\n        }\n    }\n    // Try to update the next node, if any, to the given data. Checks\n    // pre-matches to avoid overwriting nodes that could still be used.\n    updateNextNode(node, outerDeco, innerDeco, view, index, pos) {\n        for(let i = this.index; i < this.top.children.length; i++){\n            let next = this.top.children[i];\n            if (next instanceof NodeViewDesc) {\n                let preMatch = this.preMatch.matched.get(next);\n                if (preMatch != null && preMatch != index) return false;\n                let nextDOM = next.dom, updated;\n                // Can't update if nextDOM is or contains this.lock, except if\n                // it's a text node whose content already matches the new text\n                // and whose decorations match the new ones.\n                let locked = this.isLocked(nextDOM) && !(node.isText && next.node && next.node.isText && next.nodeDOM.nodeValue == node.text && next.dirty != NODE_DIRTY && sameOuterDeco(outerDeco, next.outerDeco));\n                if (!locked && next.update(node, outerDeco, innerDeco, view)) {\n                    this.destroyBetween(this.index, i);\n                    if (next.dom != nextDOM) this.changed = true;\n                    this.index++;\n                    return true;\n                } else if (!locked && (updated = this.recreateWrapper(next, node, outerDeco, innerDeco, view, pos))) {\n                    this.destroyBetween(this.index, i);\n                    this.top.children[this.index] = updated;\n                    if (updated.contentDOM) {\n                        updated.dirty = CONTENT_DIRTY;\n                        updated.updateChildren(view, pos + 1);\n                        updated.dirty = NOT_DIRTY;\n                    }\n                    this.changed = true;\n                    this.index++;\n                    return true;\n                }\n                break;\n            }\n        }\n        return false;\n    }\n    // When a node with content is replaced by a different node with\n    // identical content, move over its children.\n    recreateWrapper(next, node, outerDeco, innerDeco, view, pos) {\n        if (next.dirty || node.isAtom || !next.children.length || !next.node.content.eq(node.content) || !sameOuterDeco(outerDeco, next.outerDeco) || !innerDeco.eq(next.innerDeco)) return null;\n        let wrapper = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);\n        if (wrapper.contentDOM) {\n            wrapper.children = next.children;\n            next.children = [];\n            for (let ch of wrapper.children)ch.parent = wrapper;\n        }\n        next.destroy();\n        return wrapper;\n    }\n    // Insert the node as a newly created node desc.\n    addNode(node, outerDeco, innerDeco, view, pos) {\n        let desc = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);\n        if (desc.contentDOM) desc.updateChildren(view, pos + 1);\n        this.top.children.splice(this.index++, 0, desc);\n        this.changed = true;\n    }\n    placeWidget(widget, view, pos) {\n        let next = this.index < this.top.children.length ? this.top.children[this.index] : null;\n        if (next && next.matchesWidget(widget) && (widget == next.widget || !next.widget.type.toDOM.parentNode)) {\n            this.index++;\n        } else {\n            let desc = new WidgetViewDesc(this.top, widget, view, pos);\n            this.top.children.splice(this.index++, 0, desc);\n            this.changed = true;\n        }\n    }\n    // Make sure a textblock looks and behaves correctly in\n    // contentEditable.\n    addTextblockHacks() {\n        let lastChild = this.top.children[this.index - 1], parent = this.top;\n        while(lastChild instanceof MarkViewDesc){\n            parent = lastChild;\n            lastChild = parent.children[parent.children.length - 1];\n        }\n        if (!lastChild || // Empty textblock\n        !(lastChild instanceof TextViewDesc) || /\\n$/.test(lastChild.node.text) || this.view.requiresGeckoHackNode && /\\s$/.test(lastChild.node.text)) {\n            // Avoid bugs in Safari's cursor drawing (#1165) and Chrome's mouse selection (#1152)\n            if ((safari || chrome) && lastChild && lastChild.dom.contentEditable == \"false\") this.addHackNode(\"IMG\", parent);\n            this.addHackNode(\"BR\", this.top);\n        }\n    }\n    addHackNode(nodeName, parent) {\n        if (parent == this.top && this.index < parent.children.length && parent.children[this.index].matchesHack(nodeName)) {\n            this.index++;\n        } else {\n            let dom = document.createElement(nodeName);\n            if (nodeName == \"IMG\") {\n                dom.className = \"ProseMirror-separator\";\n                dom.alt = \"\";\n            }\n            if (nodeName == \"BR\") dom.className = \"ProseMirror-trailingBreak\";\n            let hack = new TrailingHackViewDesc(this.top, [], dom, null);\n            if (parent != this.top) parent.children.push(hack);\n            else parent.children.splice(this.index++, 0, hack);\n            this.changed = true;\n        }\n    }\n    isLocked(node) {\n        return this.lock && (node == this.lock || node.nodeType == 1 && node.contains(this.lock.parentNode));\n    }\n}\n// Iterate from the end of the fragment and array of descs to find\n// directly matching ones, in order to avoid overeagerly reusing those\n// for other nodes. Returns the fragment index of the first node that\n// is part of the sequence of matched nodes at the end of the\n// fragment.\nfunction preMatch(frag, parentDesc) {\n    let curDesc = parentDesc, descI = curDesc.children.length;\n    let fI = frag.childCount, matched = new Map, matches = [];\n    outer: while(fI > 0){\n        let desc;\n        for(;;){\n            if (descI) {\n                let next = curDesc.children[descI - 1];\n                if (next instanceof MarkViewDesc) {\n                    curDesc = next;\n                    descI = next.children.length;\n                } else {\n                    desc = next;\n                    descI--;\n                    break;\n                }\n            } else if (curDesc == parentDesc) {\n                break outer;\n            } else {\n                // FIXME\n                descI = curDesc.parent.children.indexOf(curDesc);\n                curDesc = curDesc.parent;\n            }\n        }\n        let node = desc.node;\n        if (!node) continue;\n        if (node != frag.child(fI - 1)) break;\n        --fI;\n        matched.set(desc, fI);\n        matches.push(desc);\n    }\n    return {\n        index: fI,\n        matched,\n        matches: matches.reverse()\n    };\n}\nfunction compareSide(a, b) {\n    return a.type.side - b.type.side;\n}\n// This function abstracts iterating over the nodes and decorations in\n// a fragment. Calls `onNode` for each node, with its local and child\n// decorations. Splits text nodes when there is a decoration starting\n// or ending inside of them. Calls `onWidget` for each widget.\nfunction iterDeco(parent, deco, onWidget, onNode) {\n    let locals = deco.locals(parent), offset = 0;\n    // Simple, cheap variant for when there are no local decorations\n    if (locals.length == 0) {\n        for(let i = 0; i < parent.childCount; i++){\n            let child = parent.child(i);\n            onNode(child, locals, deco.forChild(offset, child), i);\n            offset += child.nodeSize;\n        }\n        return;\n    }\n    let decoIndex = 0, active = [], restNode = null;\n    for(let parentIndex = 0;;){\n        let widget, widgets;\n        while(decoIndex < locals.length && locals[decoIndex].to == offset){\n            let next = locals[decoIndex++];\n            if (next.widget) {\n                if (!widget) widget = next;\n                else (widgets || (widgets = [\n                    widget\n                ])).push(next);\n            }\n        }\n        if (widget) {\n            if (widgets) {\n                widgets.sort(compareSide);\n                for(let i = 0; i < widgets.length; i++)onWidget(widgets[i], parentIndex, !!restNode);\n            } else {\n                onWidget(widget, parentIndex, !!restNode);\n            }\n        }\n        let child, index;\n        if (restNode) {\n            index = -1;\n            child = restNode;\n            restNode = null;\n        } else if (parentIndex < parent.childCount) {\n            index = parentIndex;\n            child = parent.child(parentIndex++);\n        } else {\n            break;\n        }\n        for(let i = 0; i < active.length; i++)if (active[i].to <= offset) active.splice(i--, 1);\n        while(decoIndex < locals.length && locals[decoIndex].from <= offset && locals[decoIndex].to > offset)active.push(locals[decoIndex++]);\n        let end = offset + child.nodeSize;\n        if (child.isText) {\n            let cutAt = end;\n            if (decoIndex < locals.length && locals[decoIndex].from < cutAt) cutAt = locals[decoIndex].from;\n            for(let i = 0; i < active.length; i++)if (active[i].to < cutAt) cutAt = active[i].to;\n            if (cutAt < end) {\n                restNode = child.cut(cutAt - offset);\n                child = child.cut(0, cutAt - offset);\n                end = cutAt;\n                index = -1;\n            }\n        } else {\n            while(decoIndex < locals.length && locals[decoIndex].to < end)decoIndex++;\n        }\n        let outerDeco = child.isInline && !child.isLeaf ? active.filter((d)=>!d.inline) : active.slice();\n        onNode(child, outerDeco, deco.forChild(offset, child), index);\n        offset = end;\n    }\n}\n// List markers in Mobile Safari will mysteriously disappear\n// sometimes. This works around that.\nfunction iosHacks(dom) {\n    if (dom.nodeName == \"UL\" || dom.nodeName == \"OL\") {\n        let oldCSS = dom.style.cssText;\n        dom.style.cssText = oldCSS + \"; list-style: square !important\";\n        window.getComputedStyle(dom).listStyle;\n        dom.style.cssText = oldCSS;\n    }\n}\n// Find a piece of text in an inline fragment, overlapping from-to\nfunction findTextInFragment(frag, text, from, to) {\n    for(let i = 0, pos = 0; i < frag.childCount && pos <= to;){\n        let child = frag.child(i++), childStart = pos;\n        pos += child.nodeSize;\n        if (!child.isText) continue;\n        let str = child.text;\n        while(i < frag.childCount){\n            let next = frag.child(i++);\n            pos += next.nodeSize;\n            if (!next.isText) break;\n            str += next.text;\n        }\n        if (pos >= from) {\n            if (pos >= to && str.slice(to - text.length - childStart, to - childStart) == text) return to - text.length;\n            let found = childStart < to ? str.lastIndexOf(text, to - childStart - 1) : -1;\n            if (found >= 0 && found + text.length + childStart >= from) return childStart + found;\n            if (from == to && str.length >= to + text.length - childStart && str.slice(to - childStart, to - childStart + text.length) == text) return to;\n        }\n    }\n    return -1;\n}\n// Replace range from-to in an array of view descs with replacement\n// (may be null to just delete). This goes very much against the grain\n// of the rest of this code, which tends to create nodes with the\n// right shape in one go, rather than messing with them after\n// creation, but is necessary in the composition hack.\nfunction replaceNodes(nodes, from, to, view, replacement) {\n    let result = [];\n    for(let i = 0, off = 0; i < nodes.length; i++){\n        let child = nodes[i], start = off, end = off += child.size;\n        if (start >= to || end <= from) {\n            result.push(child);\n        } else {\n            if (start < from) result.push(child.slice(0, from - start, view));\n            if (replacement) {\n                result.push(replacement);\n                replacement = undefined;\n            }\n            if (end > to) result.push(child.slice(to - start, child.size, view));\n        }\n    }\n    return result;\n}\nfunction selectionFromDOM(view, origin = null) {\n    let domSel = view.domSelectionRange(), doc = view.state.doc;\n    if (!domSel.focusNode) return null;\n    let nearestDesc = view.docView.nearestDesc(domSel.focusNode), inWidget = nearestDesc && nearestDesc.size == 0;\n    let head = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset, 1);\n    if (head < 0) return null;\n    let $head = doc.resolve(head), anchor, selection;\n    if (selectionCollapsed(domSel)) {\n        anchor = head;\n        while(nearestDesc && !nearestDesc.node)nearestDesc = nearestDesc.parent;\n        let nearestDescNode = nearestDesc.node;\n        if (nearestDesc && nearestDescNode.isAtom && prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(nearestDescNode) && nearestDesc.parent && !(nearestDescNode.isInline && isOnEdge(domSel.focusNode, domSel.focusOffset, nearestDesc.dom))) {\n            let pos = nearestDesc.posBefore;\n            selection = new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection(head == pos ? $head : doc.resolve(pos));\n        }\n    } else {\n        if (domSel instanceof view.dom.ownerDocument.defaultView.Selection && domSel.rangeCount > 1) {\n            let min = head, max = head;\n            for(let i = 0; i < domSel.rangeCount; i++){\n                let range = domSel.getRangeAt(i);\n                min = Math.min(min, view.docView.posFromDOM(range.startContainer, range.startOffset, 1));\n                max = Math.max(max, view.docView.posFromDOM(range.endContainer, range.endOffset, -1));\n            }\n            if (min < 0) return null;\n            [anchor, head] = max == view.state.selection.anchor ? [\n                max,\n                min\n            ] : [\n                min,\n                max\n            ];\n            $head = doc.resolve(head);\n        } else {\n            anchor = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset, 1);\n        }\n        if (anchor < 0) return null;\n    }\n    let $anchor = doc.resolve(anchor);\n    if (!selection) {\n        let bias = origin == \"pointer\" || view.state.selection.head < $head.pos && !inWidget ? 1 : -1;\n        selection = selectionBetween(view, $anchor, $head, bias);\n    }\n    return selection;\n}\nfunction editorOwnsSelection(view) {\n    return view.editable ? view.hasFocus() : hasSelection(view) && document.activeElement && document.activeElement.contains(view.dom);\n}\nfunction selectionToDOM(view, force = false) {\n    let sel = view.state.selection;\n    syncNodeSelection(view, sel);\n    if (!editorOwnsSelection(view)) return;\n    // The delayed drag selection causes issues with Cell Selections\n    // in Safari. And the drag selection delay is to workarond issues\n    // which only present in Chrome.\n    if (!force && view.input.mouseDown && view.input.mouseDown.allowDefault && chrome) {\n        let domSel = view.domSelectionRange(), curSel = view.domObserver.currentSelection;\n        if (domSel.anchorNode && curSel.anchorNode && isEquivalentPosition(domSel.anchorNode, domSel.anchorOffset, curSel.anchorNode, curSel.anchorOffset)) {\n            view.input.mouseDown.delayedSelectionSync = true;\n            view.domObserver.setCurSelection();\n            return;\n        }\n    }\n    view.domObserver.disconnectSelection();\n    if (view.cursorWrapper) {\n        selectCursorWrapper(view);\n    } else {\n        let { anchor, head } = sel, resetEditableFrom, resetEditableTo;\n        if (brokenSelectBetweenUneditable && !(sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection)) {\n            if (!sel.$from.parent.inlineContent) resetEditableFrom = temporarilyEditableNear(view, sel.from);\n            if (!sel.empty && !sel.$from.parent.inlineContent) resetEditableTo = temporarilyEditableNear(view, sel.to);\n        }\n        view.docView.setSelection(anchor, head, view, force);\n        if (brokenSelectBetweenUneditable) {\n            if (resetEditableFrom) resetEditable(resetEditableFrom);\n            if (resetEditableTo) resetEditable(resetEditableTo);\n        }\n        if (sel.visible) {\n            view.dom.classList.remove(\"ProseMirror-hideselection\");\n        } else {\n            view.dom.classList.add(\"ProseMirror-hideselection\");\n            if (\"onselectionchange\" in document) removeClassOnSelectionChange(view);\n        }\n    }\n    view.domObserver.setCurSelection();\n    view.domObserver.connectSelection();\n}\n// Kludge to work around Webkit not allowing a selection to start/end\n// between non-editable block nodes. We briefly make something\n// editable, set the selection, then set it uneditable again.\nconst brokenSelectBetweenUneditable = safari || chrome && chrome_version < 63;\nfunction temporarilyEditableNear(view, pos) {\n    let { node, offset } = view.docView.domFromPos(pos, 0);\n    let after = offset < node.childNodes.length ? node.childNodes[offset] : null;\n    let before = offset ? node.childNodes[offset - 1] : null;\n    if (safari && after && after.contentEditable == \"false\") return setEditable(after);\n    if ((!after || after.contentEditable == \"false\") && (!before || before.contentEditable == \"false\")) {\n        if (after) return setEditable(after);\n        else if (before) return setEditable(before);\n    }\n}\nfunction setEditable(element) {\n    element.contentEditable = \"true\";\n    if (safari && element.draggable) {\n        element.draggable = false;\n        element.wasDraggable = true;\n    }\n    return element;\n}\nfunction resetEditable(element) {\n    element.contentEditable = \"false\";\n    if (element.wasDraggable) {\n        element.draggable = true;\n        element.wasDraggable = null;\n    }\n}\nfunction removeClassOnSelectionChange(view) {\n    let doc = view.dom.ownerDocument;\n    doc.removeEventListener(\"selectionchange\", view.input.hideSelectionGuard);\n    let domSel = view.domSelectionRange();\n    let node = domSel.anchorNode, offset = domSel.anchorOffset;\n    doc.addEventListener(\"selectionchange\", view.input.hideSelectionGuard = ()=>{\n        if (domSel.anchorNode != node || domSel.anchorOffset != offset) {\n            doc.removeEventListener(\"selectionchange\", view.input.hideSelectionGuard);\n            setTimeout(()=>{\n                if (!editorOwnsSelection(view) || view.state.selection.visible) view.dom.classList.remove(\"ProseMirror-hideselection\");\n            }, 20);\n        }\n    });\n}\nfunction selectCursorWrapper(view) {\n    let domSel = view.domSelection();\n    if (!domSel) return;\n    let node = view.cursorWrapper.dom, img = node.nodeName == \"IMG\";\n    if (img) domSel.collapse(node.parentNode, domIndex(node) + 1);\n    else domSel.collapse(node, 0);\n    // Kludge to kill 'control selection' in IE11 when selecting an\n    // invisible cursor wrapper, since that would result in those weird\n    // resize handles and a selection that considers the absolutely\n    // positioned wrapper, rather than the root editable node, the\n    // focused element.\n    if (!img && !view.state.selection.visible && ie && ie_version <= 11) {\n        node.disabled = true;\n        node.disabled = false;\n    }\n}\nfunction syncNodeSelection(view, sel) {\n    if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection) {\n        let desc = view.docView.descAt(sel.from);\n        if (desc != view.lastSelectedViewDesc) {\n            clearNodeSelection(view);\n            if (desc) desc.selectNode();\n            view.lastSelectedViewDesc = desc;\n        }\n    } else {\n        clearNodeSelection(view);\n    }\n}\n// Clear all DOM statefulness of the last node selection.\nfunction clearNodeSelection(view) {\n    if (view.lastSelectedViewDesc) {\n        if (view.lastSelectedViewDesc.parent) view.lastSelectedViewDesc.deselectNode();\n        view.lastSelectedViewDesc = undefined;\n    }\n}\nfunction selectionBetween(view, $anchor, $head, bias) {\n    return view.someProp(\"createSelectionBetween\", (f)=>f(view, $anchor, $head)) || prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.between($anchor, $head, bias);\n}\nfunction hasFocusAndSelection(view) {\n    if (view.editable && !view.hasFocus()) return false;\n    return hasSelection(view);\n}\nfunction hasSelection(view) {\n    let sel = view.domSelectionRange();\n    if (!sel.anchorNode) return false;\n    try {\n        // Firefox will raise 'permission denied' errors when accessing\n        // properties of `sel.anchorNode` when it's in a generated CSS\n        // element.\n        return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) && (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode));\n    } catch (_) {\n        return false;\n    }\n}\nfunction anchorInRightPlace(view) {\n    let anchorDOM = view.docView.domFromPos(view.state.selection.anchor, 0);\n    let domSel = view.domSelectionRange();\n    return isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset);\n}\nfunction moveSelectionBlock(state, dir) {\n    let { $anchor, $head } = state.selection;\n    let $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);\n    let $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;\n    return $start && prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.findFrom($start, dir);\n}\nfunction apply(view, sel) {\n    view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());\n    return true;\n}\nfunction selectHorizontally(view, dir, mods) {\n    let sel = view.state.selection;\n    if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection) {\n        if (mods.indexOf(\"s\") > -1) {\n            let { $head } = sel, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter;\n            if (!node || node.isText || !node.isLeaf) return false;\n            let $newHead = view.state.doc.resolve($head.pos + node.nodeSize * (dir < 0 ? -1 : 1));\n            return apply(view, new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection(sel.$anchor, $newHead));\n        } else if (!sel.empty) {\n            return false;\n        } else if (view.endOfTextblock(dir > 0 ? \"forward\" : \"backward\")) {\n            let next = moveSelectionBlock(view.state, dir);\n            if (next && next instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection) return apply(view, next);\n            return false;\n        } else if (!(mac && mods.indexOf(\"m\") > -1)) {\n            let $head = sel.$head, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter, desc;\n            if (!node || node.isText) return false;\n            let nodePos = dir < 0 ? $head.pos - node.nodeSize : $head.pos;\n            if (!(node.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM)) return false;\n            if (prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(node)) {\n                return apply(view, new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection(dir < 0 ? view.state.doc.resolve($head.pos - node.nodeSize) : $head));\n            } else if (webkit) {\n                // Chrome and Safari will introduce extra pointless cursor\n                // positions around inline uneditable nodes, so we have to\n                // take over and move the cursor past them (#937)\n                return apply(view, new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + node.nodeSize)));\n            } else {\n                return false;\n            }\n        }\n    } else if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection && sel.node.isInline) {\n        return apply(view, new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection(dir > 0 ? sel.$to : sel.$from));\n    } else {\n        let next = moveSelectionBlock(view.state, dir);\n        if (next) return apply(view, next);\n        return false;\n    }\n}\nfunction nodeLen(node) {\n    return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;\n}\nfunction isIgnorable(dom, dir) {\n    let desc = dom.pmViewDesc;\n    return desc && desc.size == 0 && (dir < 0 || dom.nextSibling || dom.nodeName != \"BR\");\n}\nfunction skipIgnoredNodes(view, dir) {\n    return dir < 0 ? skipIgnoredNodesBefore(view) : skipIgnoredNodesAfter(view);\n}\n// Make sure the cursor isn't directly after one or more ignored\n// nodes, which will confuse the browser's cursor motion logic.\nfunction skipIgnoredNodesBefore(view) {\n    let sel = view.domSelectionRange();\n    let node = sel.focusNode, offset = sel.focusOffset;\n    if (!node) return;\n    let moveNode, moveOffset, force = false;\n    // Gecko will do odd things when the selection is directly in front\n    // of a non-editable node, so in that case, move it into the next\n    // node if possible. Issue prosemirror/prosemirror#832.\n    if (gecko && node.nodeType == 1 && offset < nodeLen(node) && isIgnorable(node.childNodes[offset], -1)) force = true;\n    for(;;){\n        if (offset > 0) {\n            if (node.nodeType != 1) {\n                break;\n            } else {\n                let before = node.childNodes[offset - 1];\n                if (isIgnorable(before, -1)) {\n                    moveNode = node;\n                    moveOffset = --offset;\n                } else if (before.nodeType == 3) {\n                    node = before;\n                    offset = node.nodeValue.length;\n                } else break;\n            }\n        } else if (isBlockNode(node)) {\n            break;\n        } else {\n            let prev = node.previousSibling;\n            while(prev && isIgnorable(prev, -1)){\n                moveNode = node.parentNode;\n                moveOffset = domIndex(prev);\n                prev = prev.previousSibling;\n            }\n            if (!prev) {\n                node = node.parentNode;\n                if (node == view.dom) break;\n                offset = 0;\n            } else {\n                node = prev;\n                offset = nodeLen(node);\n            }\n        }\n    }\n    if (force) setSelFocus(view, node, offset);\n    else if (moveNode) setSelFocus(view, moveNode, moveOffset);\n}\n// Make sure the cursor isn't directly before one or more ignored\n// nodes.\nfunction skipIgnoredNodesAfter(view) {\n    let sel = view.domSelectionRange();\n    let node = sel.focusNode, offset = sel.focusOffset;\n    if (!node) return;\n    let len = nodeLen(node);\n    let moveNode, moveOffset;\n    for(;;){\n        if (offset < len) {\n            if (node.nodeType != 1) break;\n            let after = node.childNodes[offset];\n            if (isIgnorable(after, 1)) {\n                moveNode = node;\n                moveOffset = ++offset;\n            } else break;\n        } else if (isBlockNode(node)) {\n            break;\n        } else {\n            let next = node.nextSibling;\n            while(next && isIgnorable(next, 1)){\n                moveNode = next.parentNode;\n                moveOffset = domIndex(next) + 1;\n                next = next.nextSibling;\n            }\n            if (!next) {\n                node = node.parentNode;\n                if (node == view.dom) break;\n                offset = len = 0;\n            } else {\n                node = next;\n                offset = 0;\n                len = nodeLen(node);\n            }\n        }\n    }\n    if (moveNode) setSelFocus(view, moveNode, moveOffset);\n}\nfunction isBlockNode(dom) {\n    let desc = dom.pmViewDesc;\n    return desc && desc.node && desc.node.isBlock;\n}\nfunction textNodeAfter(node, offset) {\n    while(node && offset == node.childNodes.length && !hasBlockDesc(node)){\n        offset = domIndex(node) + 1;\n        node = node.parentNode;\n    }\n    while(node && offset < node.childNodes.length){\n        let next = node.childNodes[offset];\n        if (next.nodeType == 3) return next;\n        if (next.nodeType == 1 && next.contentEditable == \"false\") break;\n        node = next;\n        offset = 0;\n    }\n}\nfunction textNodeBefore(node, offset) {\n    while(node && !offset && !hasBlockDesc(node)){\n        offset = domIndex(node);\n        node = node.parentNode;\n    }\n    while(node && offset){\n        let next = node.childNodes[offset - 1];\n        if (next.nodeType == 3) return next;\n        if (next.nodeType == 1 && next.contentEditable == \"false\") break;\n        node = next;\n        offset = node.childNodes.length;\n    }\n}\nfunction setSelFocus(view, node, offset) {\n    if (node.nodeType != 3) {\n        let before, after;\n        if (after = textNodeAfter(node, offset)) {\n            node = after;\n            offset = 0;\n        } else if (before = textNodeBefore(node, offset)) {\n            node = before;\n            offset = before.nodeValue.length;\n        }\n    }\n    let sel = view.domSelection();\n    if (!sel) return;\n    if (selectionCollapsed(sel)) {\n        let range = document.createRange();\n        range.setEnd(node, offset);\n        range.setStart(node, offset);\n        sel.removeAllRanges();\n        sel.addRange(range);\n    } else if (sel.extend) {\n        sel.extend(node, offset);\n    }\n    view.domObserver.setCurSelection();\n    let { state } = view;\n    // If no state update ends up happening, reset the selection.\n    setTimeout(()=>{\n        if (view.state == state) selectionToDOM(view);\n    }, 50);\n}\nfunction findDirection(view, pos) {\n    let $pos = view.state.doc.resolve(pos);\n    if (!(chrome || windows) && $pos.parent.inlineContent) {\n        let coords = view.coordsAtPos(pos);\n        if (pos > $pos.start()) {\n            let before = view.coordsAtPos(pos - 1);\n            let mid = (before.top + before.bottom) / 2;\n            if (mid > coords.top && mid < coords.bottom && Math.abs(before.left - coords.left) > 1) return before.left < coords.left ? \"ltr\" : \"rtl\";\n        }\n        if (pos < $pos.end()) {\n            let after = view.coordsAtPos(pos + 1);\n            let mid = (after.top + after.bottom) / 2;\n            if (mid > coords.top && mid < coords.bottom && Math.abs(after.left - coords.left) > 1) return after.left > coords.left ? \"ltr\" : \"rtl\";\n        }\n    }\n    let computed = getComputedStyle(view.dom).direction;\n    return computed == \"rtl\" ? \"rtl\" : \"ltr\";\n}\n// Check whether vertical selection motion would involve node\n// selections. If so, apply it (if not, the result is left to the\n// browser)\nfunction selectVertically(view, dir, mods) {\n    let sel = view.state.selection;\n    if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection && !sel.empty || mods.indexOf(\"s\") > -1) return false;\n    if (mac && mods.indexOf(\"m\") > -1) return false;\n    let { $from, $to } = sel;\n    if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? \"up\" : \"down\")) {\n        let next = moveSelectionBlock(view.state, dir);\n        if (next && next instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection) return apply(view, next);\n    }\n    if (!$from.parent.inlineContent) {\n        let side = dir < 0 ? $from : $to;\n        let beyond = sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.AllSelection ? prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.near(side, dir) : prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.findFrom(side, dir);\n        return beyond ? apply(view, beyond) : false;\n    }\n    return false;\n}\nfunction stopNativeHorizontalDelete(view, dir) {\n    if (!(view.state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection)) return true;\n    let { $head, $anchor, empty } = view.state.selection;\n    if (!$head.sameParent($anchor)) return true;\n    if (!empty) return false;\n    if (view.endOfTextblock(dir > 0 ? \"forward\" : \"backward\")) return true;\n    let nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);\n    if (nextNode && !nextNode.isText) {\n        let tr = view.state.tr;\n        if (dir < 0) tr.delete($head.pos - nextNode.nodeSize, $head.pos);\n        else tr.delete($head.pos, $head.pos + nextNode.nodeSize);\n        view.dispatch(tr);\n        return true;\n    }\n    return false;\n}\nfunction switchEditable(view, node, state) {\n    view.domObserver.stop();\n    node.contentEditable = state;\n    view.domObserver.start();\n}\n// Issue #867 / #1090 / https://bugs.chromium.org/p/chromium/issues/detail?id=903821\n// In which Safari (and at some point in the past, Chrome) does really\n// wrong things when the down arrow is pressed when the cursor is\n// directly at the start of a textblock and has an uneditable node\n// after it\nfunction safariDownArrowBug(view) {\n    if (!safari || view.state.selection.$head.parentOffset > 0) return false;\n    let { focusNode, focusOffset } = view.domSelectionRange();\n    if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 && focusNode.firstChild && focusNode.firstChild.contentEditable == \"false\") {\n        let child = focusNode.firstChild;\n        switchEditable(view, child, \"true\");\n        setTimeout(()=>switchEditable(view, child, \"false\"), 20);\n    }\n    return false;\n}\n// A backdrop key mapping used to make sure we always suppress keys\n// that have a dangerous default effect, even if the commands they are\n// bound to return false, and to make sure that cursor-motion keys\n// find a cursor (as opposed to a node selection) when pressed. For\n// cursor-motion keys, the code in the handlers also takes care of\n// block selections.\nfunction getMods(event) {\n    let result = \"\";\n    if (event.ctrlKey) result += \"c\";\n    if (event.metaKey) result += \"m\";\n    if (event.altKey) result += \"a\";\n    if (event.shiftKey) result += \"s\";\n    return result;\n}\nfunction captureKeyDown(view, event) {\n    let code = event.keyCode, mods = getMods(event);\n    if (code == 8 || mac && code == 72 && mods == \"c\") {\n        return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodes(view, -1);\n    } else if (code == 46 && !event.shiftKey || mac && code == 68 && mods == \"c\") {\n        return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodes(view, 1);\n    } else if (code == 13 || code == 27) {\n        return true;\n    } else if (code == 37 || mac && code == 66 && mods == \"c\") {\n        let dir = code == 37 ? findDirection(view, view.state.selection.from) == \"ltr\" ? -1 : 1 : -1;\n        return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);\n    } else if (code == 39 || mac && code == 70 && mods == \"c\") {\n        let dir = code == 39 ? findDirection(view, view.state.selection.from) == \"ltr\" ? 1 : -1 : 1;\n        return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);\n    } else if (code == 38 || mac && code == 80 && mods == \"c\") {\n        return selectVertically(view, -1, mods) || skipIgnoredNodes(view, -1);\n    } else if (code == 40 || mac && code == 78 && mods == \"c\") {\n        return safariDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodes(view, 1);\n    } else if (mods == (mac ? \"m\" : \"c\") && (code == 66 || code == 73 || code == 89 || code == 90)) {\n        return true;\n    }\n    return false;\n}\nfunction serializeForClipboard(view, slice) {\n    view.someProp(\"transformCopied\", (f)=>{\n        slice = f(slice, view);\n    });\n    let context = [], { content, openStart, openEnd } = slice;\n    while(openStart > 1 && openEnd > 1 && content.childCount == 1 && content.firstChild.childCount == 1){\n        openStart--;\n        openEnd--;\n        let node = content.firstChild;\n        context.push(node.type.name, node.attrs != node.type.defaultAttrs ? node.attrs : null);\n        content = node.content;\n    }\n    let serializer = view.someProp(\"clipboardSerializer\") || prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMSerializer.fromSchema(view.state.schema);\n    let doc = detachedDoc(), wrap = doc.createElement(\"div\");\n    wrap.appendChild(serializer.serializeFragment(content, {\n        document: doc\n    }));\n    let firstChild = wrap.firstChild, needsWrap, wrappers = 0;\n    while(firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])){\n        for(let i = needsWrap.length - 1; i >= 0; i--){\n            let wrapper = doc.createElement(needsWrap[i]);\n            while(wrap.firstChild)wrapper.appendChild(wrap.firstChild);\n            wrap.appendChild(wrapper);\n            wrappers++;\n        }\n        firstChild = wrap.firstChild;\n    }\n    if (firstChild && firstChild.nodeType == 1) firstChild.setAttribute(\"data-pm-slice\", `${openStart} ${openEnd}${wrappers ? ` -${wrappers}` : \"\"} ${JSON.stringify(context)}`);\n    let text = view.someProp(\"clipboardTextSerializer\", (f)=>f(slice, view)) || slice.content.textBetween(0, slice.content.size, \"\\n\\n\");\n    return {\n        dom: wrap,\n        text,\n        slice\n    };\n}\n// Read a slice of content from the clipboard (or drop data).\nfunction parseFromClipboard(view, text, html, plainText, $context) {\n    let inCode = $context.parent.type.spec.code;\n    let dom, slice;\n    if (!html && !text) return null;\n    let asText = !!text && (plainText || inCode || !html);\n    if (asText) {\n        view.someProp(\"transformPastedText\", (f)=>{\n            text = f(text, inCode || plainText, view);\n        });\n        if (inCode) {\n            slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(view.state.schema.text(text.replace(/\\r\\n?/g, \"\\n\"))), 0, 0);\n            view.someProp(\"transformPasted\", (f)=>{\n                slice = f(slice, view, true);\n            });\n            return slice;\n        }\n        let parsed = view.someProp(\"clipboardTextParser\", (f)=>f(text, $context, plainText, view));\n        if (parsed) {\n            slice = parsed;\n        } else {\n            let marks = $context.marks();\n            let { schema } = view.state, serializer = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMSerializer.fromSchema(schema);\n            dom = document.createElement(\"div\");\n            text.split(/(?:\\r\\n?|\\n)+/).forEach((block)=>{\n                let p = dom.appendChild(document.createElement(\"p\"));\n                if (block) p.appendChild(serializer.serializeNode(schema.text(block, marks)));\n            });\n        }\n    } else {\n        view.someProp(\"transformPastedHTML\", (f)=>{\n            html = f(html, view);\n        });\n        dom = readHTML(html);\n        if (webkit) restoreReplacedSpaces(dom);\n    }\n    let contextNode = dom && dom.querySelector(\"[data-pm-slice]\");\n    let sliceData = contextNode && /^(\\d+) (\\d+)(?: -(\\d+))? (.*)/.exec(contextNode.getAttribute(\"data-pm-slice\") || \"\");\n    if (sliceData && sliceData[3]) for(let i = +sliceData[3]; i > 0; i--){\n        let child = dom.firstChild;\n        while(child && child.nodeType != 1)child = child.nextSibling;\n        if (!child) break;\n        dom = child;\n    }\n    if (!slice) {\n        let parser = view.someProp(\"clipboardParser\") || view.someProp(\"domParser\") || prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMParser.fromSchema(view.state.schema);\n        slice = parser.parseSlice(dom, {\n            preserveWhitespace: !!(asText || sliceData),\n            context: $context,\n            ruleFromNode (dom) {\n                if (dom.nodeName == \"BR\" && !dom.nextSibling && dom.parentNode && !inlineParents.test(dom.parentNode.nodeName)) return {\n                    ignore: true\n                };\n                return null;\n            }\n        });\n    }\n    if (sliceData) {\n        slice = addContext(closeSlice(slice, +sliceData[1], +sliceData[2]), sliceData[4]);\n    } else {\n        slice = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.maxOpen(normalizeSiblings(slice.content, $context), true);\n        if (slice.openStart || slice.openEnd) {\n            let openStart = 0, openEnd = 0;\n            for(let node = slice.content.firstChild; openStart < slice.openStart && !node.type.spec.isolating; openStart++, node = node.firstChild){}\n            for(let node = slice.content.lastChild; openEnd < slice.openEnd && !node.type.spec.isolating; openEnd++, node = node.lastChild){}\n            slice = closeSlice(slice, openStart, openEnd);\n        }\n    }\n    view.someProp(\"transformPasted\", (f)=>{\n        slice = f(slice, view, asText);\n    });\n    return slice;\n}\nconst inlineParents = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;\n// Takes a slice parsed with parseSlice, which means there hasn't been\n// any content-expression checking done on the top nodes, tries to\n// find a parent node in the current context that might fit the nodes,\n// and if successful, rebuilds the slice so that it fits into that parent.\n//\n// This addresses the problem that Transform.replace expects a\n// coherent slice, and will fail to place a set of siblings that don't\n// fit anywhere in the schema.\nfunction normalizeSiblings(fragment, $context) {\n    if (fragment.childCount < 2) return fragment;\n    for(let d = $context.depth; d >= 0; d--){\n        let parent = $context.node(d);\n        let match = parent.contentMatchAt($context.index(d));\n        let lastWrap, result = [];\n        fragment.forEach((node)=>{\n            if (!result) return;\n            let wrap = match.findWrapping(node.type), inLast;\n            if (!wrap) return result = null;\n            if (inLast = result.length && lastWrap.length && addToSibling(wrap, lastWrap, node, result[result.length - 1], 0)) {\n                result[result.length - 1] = inLast;\n            } else {\n                if (result.length) result[result.length - 1] = closeRight(result[result.length - 1], lastWrap.length);\n                let wrapped = withWrappers(node, wrap);\n                result.push(wrapped);\n                match = match.matchType(wrapped.type);\n                lastWrap = wrap;\n            }\n        });\n        if (result) return prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(result);\n    }\n    return fragment;\n}\nfunction withWrappers(node, wrap, from = 0) {\n    for(let i = wrap.length - 1; i >= from; i--)node = wrap[i].create(null, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(node));\n    return node;\n}\n// Used to group adjacent nodes wrapped in similar parents by\n// normalizeSiblings into the same parent node\nfunction addToSibling(wrap, lastWrap, node, sibling, depth) {\n    if (depth < wrap.length && depth < lastWrap.length && wrap[depth] == lastWrap[depth]) {\n        let inner = addToSibling(wrap, lastWrap, node, sibling.lastChild, depth + 1);\n        if (inner) return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner));\n        let match = sibling.contentMatchAt(sibling.childCount);\n        if (match.matchType(depth == wrap.length - 1 ? node.type : wrap[depth + 1])) return sibling.copy(sibling.content.append(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(withWrappers(node, wrap, depth + 1))));\n    }\n}\nfunction closeRight(node, depth) {\n    if (depth == 0) return node;\n    let fragment = node.content.replaceChild(node.childCount - 1, closeRight(node.lastChild, depth - 1));\n    let fill = node.contentMatchAt(node.childCount).fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, true);\n    return node.copy(fragment.append(fill));\n}\nfunction closeRange(fragment, side, from, to, depth, openEnd) {\n    let node = side < 0 ? fragment.firstChild : fragment.lastChild, inner = node.content;\n    if (fragment.childCount > 1) openEnd = 0;\n    if (depth < to - 1) inner = closeRange(inner, side, from, to, depth + 1, openEnd);\n    if (depth >= from) inner = side < 0 ? node.contentMatchAt(0).fillBefore(inner, openEnd <= depth).append(inner) : inner.append(node.contentMatchAt(node.childCount).fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, true));\n    return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node.copy(inner));\n}\nfunction closeSlice(slice, openStart, openEnd) {\n    if (openStart < slice.openStart) slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(closeRange(slice.content, -1, openStart, slice.openStart, 0, slice.openEnd), openStart, slice.openEnd);\n    if (openEnd < slice.openEnd) slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(closeRange(slice.content, 1, openEnd, slice.openEnd, 0, 0), slice.openStart, openEnd);\n    return slice;\n}\n// Trick from jQuery -- some elements must be wrapped in other\n// elements for innerHTML to work. I.e. if you do `div.innerHTML =\n// \"<td>..</td>\"` the table cells are ignored.\nconst wrapMap = {\n    thead: [\n        \"table\"\n    ],\n    tbody: [\n        \"table\"\n    ],\n    tfoot: [\n        \"table\"\n    ],\n    caption: [\n        \"table\"\n    ],\n    colgroup: [\n        \"table\"\n    ],\n    col: [\n        \"table\",\n        \"colgroup\"\n    ],\n    tr: [\n        \"table\",\n        \"tbody\"\n    ],\n    td: [\n        \"table\",\n        \"tbody\",\n        \"tr\"\n    ],\n    th: [\n        \"table\",\n        \"tbody\",\n        \"tr\"\n    ]\n};\nlet _detachedDoc = null;\nfunction detachedDoc() {\n    return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument(\"title\"));\n}\nlet _policy = null;\nfunction maybeWrapTrusted(html) {\n    let trustedTypes = window.trustedTypes;\n    if (!trustedTypes) return html;\n    // With the require-trusted-types-for CSP, Chrome will block\n    // innerHTML, even on a detached document. This wraps the string in\n    // a way that makes the browser allow us to use its parser again.\n    if (!_policy) _policy = trustedTypes.defaultPolicy || trustedTypes.createPolicy(\"ProseMirrorClipboard\", {\n        createHTML: (s)=>s\n    });\n    return _policy.createHTML(html);\n}\nfunction readHTML(html) {\n    let metas = /^(\\s*<meta [^>]*>)*/.exec(html);\n    if (metas) html = html.slice(metas[0].length);\n    let elt = detachedDoc().createElement(\"div\");\n    let firstTag = /<([a-z][^>\\s]+)/i.exec(html), wrap;\n    if (wrap = firstTag && wrapMap[firstTag[1].toLowerCase()]) html = wrap.map((n)=>\"<\" + n + \">\").join(\"\") + html + wrap.map((n)=>\"</\" + n + \">\").reverse().join(\"\");\n    elt.innerHTML = maybeWrapTrusted(html);\n    if (wrap) for(let i = 0; i < wrap.length; i++)elt = elt.querySelector(wrap[i]) || elt;\n    return elt;\n}\n// Webkit browsers do some hard-to-predict replacement of regular\n// spaces with non-breaking spaces when putting content on the\n// clipboard. This tries to convert such non-breaking spaces (which\n// will be wrapped in a plain span on Chrome, a span with class\n// Apple-converted-space on Safari) back to regular spaces.\nfunction restoreReplacedSpaces(dom) {\n    let nodes = dom.querySelectorAll(chrome ? \"span:not([class]):not([style])\" : \"span.Apple-converted-space\");\n    for(let i = 0; i < nodes.length; i++){\n        let node = nodes[i];\n        if (node.childNodes.length == 1 && node.textContent == \"\\xa0\" && node.parentNode) node.parentNode.replaceChild(dom.ownerDocument.createTextNode(\" \"), node);\n    }\n}\nfunction addContext(slice, context) {\n    if (!slice.size) return slice;\n    let schema = slice.content.firstChild.type.schema, array;\n    try {\n        array = JSON.parse(context);\n    } catch (e) {\n        return slice;\n    }\n    let { content, openStart, openEnd } = slice;\n    for(let i = array.length - 2; i >= 0; i -= 2){\n        let type = schema.nodes[array[i]];\n        if (!type || type.hasRequiredAttrs()) break;\n        content = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(type.create(array[i + 1], content));\n        openStart++;\n        openEnd++;\n    }\n    return new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(content, openStart, openEnd);\n}\n// A collection of DOM events that occur within the editor, and callback functions\n// to invoke when the event fires.\nconst handlers = {};\nconst editHandlers = {};\nconst passiveHandlers = {\n    touchstart: true,\n    touchmove: true\n};\nclass InputState {\n    constructor(){\n        this.shiftKey = false;\n        this.mouseDown = null;\n        this.lastKeyCode = null;\n        this.lastKeyCodeTime = 0;\n        this.lastClick = {\n            time: 0,\n            x: 0,\n            y: 0,\n            type: \"\",\n            button: 0\n        };\n        this.lastSelectionOrigin = null;\n        this.lastSelectionTime = 0;\n        this.lastIOSEnter = 0;\n        this.lastIOSEnterFallbackTimeout = -1;\n        this.lastFocus = 0;\n        this.lastTouch = 0;\n        this.lastChromeDelete = 0;\n        this.composing = false;\n        this.compositionNode = null;\n        this.composingTimeout = -1;\n        this.compositionNodes = [];\n        this.compositionEndedAt = -2e8;\n        this.compositionID = 1;\n        // Set to a composition ID when there are pending changes at compositionend\n        this.compositionPendingChanges = 0;\n        this.domChangeCount = 0;\n        this.eventHandlers = Object.create(null);\n        this.hideSelectionGuard = null;\n    }\n}\nfunction initInput(view) {\n    for(let event in handlers){\n        let handler = handlers[event];\n        view.dom.addEventListener(event, view.input.eventHandlers[event] = (event)=>{\n            if (eventBelongsToView(view, event) && !runCustomHandler(view, event) && (view.editable || !(event.type in editHandlers))) handler(view, event);\n        }, passiveHandlers[event] ? {\n            passive: true\n        } : undefined);\n    }\n    // On Safari, for reasons beyond my understanding, adding an input\n    // event handler makes an issue where the composition vanishes when\n    // you press enter go away.\n    if (safari) view.dom.addEventListener(\"input\", ()=>null);\n    ensureListeners(view);\n}\nfunction setSelectionOrigin(view, origin) {\n    view.input.lastSelectionOrigin = origin;\n    view.input.lastSelectionTime = Date.now();\n}\nfunction destroyInput(view) {\n    view.domObserver.stop();\n    for(let type in view.input.eventHandlers)view.dom.removeEventListener(type, view.input.eventHandlers[type]);\n    clearTimeout(view.input.composingTimeout);\n    clearTimeout(view.input.lastIOSEnterFallbackTimeout);\n}\nfunction ensureListeners(view) {\n    view.someProp(\"handleDOMEvents\", (currentHandlers)=>{\n        for(let type in currentHandlers)if (!view.input.eventHandlers[type]) view.dom.addEventListener(type, view.input.eventHandlers[type] = (event)=>runCustomHandler(view, event));\n    });\n}\nfunction runCustomHandler(view, event) {\n    return view.someProp(\"handleDOMEvents\", (handlers)=>{\n        let handler = handlers[event.type];\n        return handler ? handler(view, event) || event.defaultPrevented : false;\n    });\n}\nfunction eventBelongsToView(view, event) {\n    if (!event.bubbles) return true;\n    if (event.defaultPrevented) return false;\n    for(let node = event.target; node != view.dom; node = node.parentNode)if (!node || node.nodeType == 11 || node.pmViewDesc && node.pmViewDesc.stopEvent(event)) return false;\n    return true;\n}\nfunction dispatchEvent(view, event) {\n    if (!runCustomHandler(view, event) && handlers[event.type] && (view.editable || !(event.type in editHandlers))) handlers[event.type](view, event);\n}\neditHandlers.keydown = (view, _event)=>{\n    let event = _event;\n    view.input.shiftKey = event.keyCode == 16 || event.shiftKey;\n    if (inOrNearComposition(view, event)) return;\n    view.input.lastKeyCode = event.keyCode;\n    view.input.lastKeyCodeTime = Date.now();\n    // Suppress enter key events on Chrome Android, because those tend\n    // to be part of a confused sequence of composition events fired,\n    // and handling them eagerly tends to corrupt the input.\n    if (android && chrome && event.keyCode == 13) return;\n    if (event.keyCode != 229) view.domObserver.forceFlush();\n    // On iOS, if we preventDefault enter key presses, the virtual\n    // keyboard gets confused. So the hack here is to set a flag that\n    // makes the DOM change code recognize that what just happens should\n    // be replaced by whatever the Enter key handlers do.\n    if (ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {\n        let now = Date.now();\n        view.input.lastIOSEnter = now;\n        view.input.lastIOSEnterFallbackTimeout = setTimeout(()=>{\n            if (view.input.lastIOSEnter == now) {\n                view.someProp(\"handleKeyDown\", (f)=>f(view, keyEvent(13, \"Enter\")));\n                view.input.lastIOSEnter = 0;\n            }\n        }, 200);\n    } else if (view.someProp(\"handleKeyDown\", (f)=>f(view, event)) || captureKeyDown(view, event)) {\n        event.preventDefault();\n    } else {\n        setSelectionOrigin(view, \"key\");\n    }\n};\neditHandlers.keyup = (view, event)=>{\n    if (event.keyCode == 16) view.input.shiftKey = false;\n};\neditHandlers.keypress = (view, _event)=>{\n    let event = _event;\n    if (inOrNearComposition(view, event) || !event.charCode || event.ctrlKey && !event.altKey || mac && event.metaKey) return;\n    if (view.someProp(\"handleKeyPress\", (f)=>f(view, event))) {\n        event.preventDefault();\n        return;\n    }\n    let sel = view.state.selection;\n    if (!(sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection) || !sel.$from.sameParent(sel.$to)) {\n        let text = String.fromCharCode(event.charCode);\n        let deflt = ()=>view.state.tr.insertText(text).scrollIntoView();\n        if (!/[\\r\\n]/.test(text) && !view.someProp(\"handleTextInput\", (f)=>f(view, sel.$from.pos, sel.$to.pos, text, deflt))) view.dispatch(deflt());\n        event.preventDefault();\n    }\n};\nfunction eventCoords(event) {\n    return {\n        left: event.clientX,\n        top: event.clientY\n    };\n}\nfunction isNear(event, click) {\n    let dx = click.x - event.clientX, dy = click.y - event.clientY;\n    return dx * dx + dy * dy < 100;\n}\nfunction runHandlerOnContext(view, propName, pos, inside, event) {\n    if (inside == -1) return false;\n    let $pos = view.state.doc.resolve(inside);\n    for(let i = $pos.depth + 1; i > 0; i--){\n        if (view.someProp(propName, (f)=>i > $pos.depth ? f(view, pos, $pos.nodeAfter, $pos.before(i), event, true) : f(view, pos, $pos.node(i), $pos.before(i), event, false))) return true;\n    }\n    return false;\n}\nfunction updateSelection(view, selection, origin) {\n    if (!view.focused) view.focus();\n    if (view.state.selection.eq(selection)) return;\n    let tr = view.state.tr.setSelection(selection);\n    if (origin == \"pointer\") tr.setMeta(\"pointer\", true);\n    view.dispatch(tr);\n}\nfunction selectClickedLeaf(view, inside) {\n    if (inside == -1) return false;\n    let $pos = view.state.doc.resolve(inside), node = $pos.nodeAfter;\n    if (node && node.isAtom && prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(node)) {\n        updateSelection(view, new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection($pos), \"pointer\");\n        return true;\n    }\n    return false;\n}\nfunction selectClickedNode(view, inside) {\n    if (inside == -1) return false;\n    let sel = view.state.selection, selectedNode, selectAt;\n    if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection) selectedNode = sel.node;\n    let $pos = view.state.doc.resolve(inside);\n    for(let i = $pos.depth + 1; i > 0; i--){\n        let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);\n        if (prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(node)) {\n            if (selectedNode && sel.$from.depth > 0 && i >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos) selectAt = $pos.before(sel.$from.depth);\n            else selectAt = $pos.before(i);\n            break;\n        }\n    }\n    if (selectAt != null) {\n        updateSelection(view, prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(view.state.doc, selectAt), \"pointer\");\n        return true;\n    } else {\n        return false;\n    }\n}\nfunction handleSingleClick(view, pos, inside, event, selectNode) {\n    return runHandlerOnContext(view, \"handleClickOn\", pos, inside, event) || view.someProp(\"handleClick\", (f)=>f(view, pos, event)) || (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside));\n}\nfunction handleDoubleClick(view, pos, inside, event) {\n    return runHandlerOnContext(view, \"handleDoubleClickOn\", pos, inside, event) || view.someProp(\"handleDoubleClick\", (f)=>f(view, pos, event));\n}\nfunction handleTripleClick(view, pos, inside, event) {\n    return runHandlerOnContext(view, \"handleTripleClickOn\", pos, inside, event) || view.someProp(\"handleTripleClick\", (f)=>f(view, pos, event)) || defaultTripleClick(view, inside, event);\n}\nfunction defaultTripleClick(view, inside, event) {\n    if (event.button != 0) return false;\n    let doc = view.state.doc;\n    if (inside == -1) {\n        if (doc.inlineContent) {\n            updateSelection(view, prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.create(doc, 0, doc.content.size), \"pointer\");\n            return true;\n        }\n        return false;\n    }\n    let $pos = doc.resolve(inside);\n    for(let i = $pos.depth + 1; i > 0; i--){\n        let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);\n        let nodePos = $pos.before(i);\n        if (node.inlineContent) updateSelection(view, prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.create(doc, nodePos + 1, nodePos + 1 + node.content.size), \"pointer\");\n        else if (prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(node)) updateSelection(view, prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(doc, nodePos), \"pointer\");\n        else continue;\n        return true;\n    }\n}\nfunction forceDOMFlush(view) {\n    return endComposition(view);\n}\nconst selectNodeModifier = mac ? \"metaKey\" : \"ctrlKey\";\nhandlers.mousedown = (view, _event)=>{\n    let event = _event;\n    view.input.shiftKey = event.shiftKey;\n    let flushed = forceDOMFlush(view);\n    let now = Date.now(), type = \"singleClick\";\n    if (now - view.input.lastClick.time < 500 && isNear(event, view.input.lastClick) && !event[selectNodeModifier] && view.input.lastClick.button == event.button) {\n        if (view.input.lastClick.type == \"singleClick\") type = \"doubleClick\";\n        else if (view.input.lastClick.type == \"doubleClick\") type = \"tripleClick\";\n    }\n    view.input.lastClick = {\n        time: now,\n        x: event.clientX,\n        y: event.clientY,\n        type,\n        button: event.button\n    };\n    let pos = view.posAtCoords(eventCoords(event));\n    if (!pos) return;\n    if (type == \"singleClick\") {\n        if (view.input.mouseDown) view.input.mouseDown.done();\n        view.input.mouseDown = new MouseDown(view, pos, event, !!flushed);\n    } else if ((type == \"doubleClick\" ? handleDoubleClick : handleTripleClick)(view, pos.pos, pos.inside, event)) {\n        event.preventDefault();\n    } else {\n        setSelectionOrigin(view, \"pointer\");\n    }\n};\nclass MouseDown {\n    constructor(view, pos, event, flushed){\n        this.view = view;\n        this.pos = pos;\n        this.event = event;\n        this.flushed = flushed;\n        this.delayedSelectionSync = false;\n        this.mightDrag = null;\n        this.startDoc = view.state.doc;\n        this.selectNode = !!event[selectNodeModifier];\n        this.allowDefault = event.shiftKey;\n        let targetNode, targetPos;\n        if (pos.inside > -1) {\n            targetNode = view.state.doc.nodeAt(pos.inside);\n            targetPos = pos.inside;\n        } else {\n            let $pos = view.state.doc.resolve(pos.pos);\n            targetNode = $pos.parent;\n            targetPos = $pos.depth ? $pos.before() : 0;\n        }\n        const target = flushed ? null : event.target;\n        const targetDesc = target ? view.docView.nearestDesc(target, true) : null;\n        this.target = targetDesc && targetDesc.nodeDOM.nodeType == 1 ? targetDesc.nodeDOM : null;\n        let { selection } = view.state;\n        if (event.button == 0 && targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false || selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection && selection.from <= targetPos && selection.to > targetPos) this.mightDrag = {\n            node: targetNode,\n            pos: targetPos,\n            addAttr: !!(this.target && !this.target.draggable),\n            setUneditable: !!(this.target && gecko && !this.target.hasAttribute(\"contentEditable\"))\n        };\n        if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {\n            this.view.domObserver.stop();\n            if (this.mightDrag.addAttr) this.target.draggable = true;\n            if (this.mightDrag.setUneditable) setTimeout(()=>{\n                if (this.view.input.mouseDown == this) this.target.setAttribute(\"contentEditable\", \"false\");\n            }, 20);\n            this.view.domObserver.start();\n        }\n        view.root.addEventListener(\"mouseup\", this.up = this.up.bind(this));\n        view.root.addEventListener(\"mousemove\", this.move = this.move.bind(this));\n        setSelectionOrigin(view, \"pointer\");\n    }\n    done() {\n        this.view.root.removeEventListener(\"mouseup\", this.up);\n        this.view.root.removeEventListener(\"mousemove\", this.move);\n        if (this.mightDrag && this.target) {\n            this.view.domObserver.stop();\n            if (this.mightDrag.addAttr) this.target.removeAttribute(\"draggable\");\n            if (this.mightDrag.setUneditable) this.target.removeAttribute(\"contentEditable\");\n            this.view.domObserver.start();\n        }\n        if (this.delayedSelectionSync) setTimeout(()=>selectionToDOM(this.view));\n        this.view.input.mouseDown = null;\n    }\n    up(event) {\n        this.done();\n        if (!this.view.dom.contains(event.target)) return;\n        let pos = this.pos;\n        if (this.view.state.doc != this.startDoc) pos = this.view.posAtCoords(eventCoords(event));\n        this.updateAllowDefault(event);\n        if (this.allowDefault || !pos) {\n            setSelectionOrigin(this.view, \"pointer\");\n        } else if (handleSingleClick(this.view, pos.pos, pos.inside, event, this.selectNode)) {\n            event.preventDefault();\n        } else if (event.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements\n        safari && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a\n        // cursor, but still report that the node is selected\n        // when asked through getSelection. You'll then get a\n        // situation where clicking at the point where that\n        // (hidden) cursor is doesn't change the selection, and\n        // thus doesn't get a reaction from ProseMirror. This\n        // works around that.\n        chrome && !this.view.state.selection.visible && Math.min(Math.abs(pos.pos - this.view.state.selection.from), Math.abs(pos.pos - this.view.state.selection.to)) <= 2)) {\n            updateSelection(this.view, prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.near(this.view.state.doc.resolve(pos.pos)), \"pointer\");\n            event.preventDefault();\n        } else {\n            setSelectionOrigin(this.view, \"pointer\");\n        }\n    }\n    move(event) {\n        this.updateAllowDefault(event);\n        setSelectionOrigin(this.view, \"pointer\");\n        if (event.buttons == 0) this.done();\n    }\n    updateAllowDefault(event) {\n        if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 || Math.abs(this.event.y - event.clientY) > 4)) this.allowDefault = true;\n    }\n}\nhandlers.touchstart = (view)=>{\n    view.input.lastTouch = Date.now();\n    forceDOMFlush(view);\n    setSelectionOrigin(view, \"pointer\");\n};\nhandlers.touchmove = (view)=>{\n    view.input.lastTouch = Date.now();\n    setSelectionOrigin(view, \"pointer\");\n};\nhandlers.contextmenu = (view)=>forceDOMFlush(view);\nfunction inOrNearComposition(view, event) {\n    if (view.composing) return true;\n    // See https://www.stum.de/2016/06/24/handling-ime-events-in-javascript/.\n    // On Japanese input method editors (IMEs), the Enter key is used to confirm character\n    // selection. On Safari, when Enter is pressed, compositionend and keydown events are\n    // emitted. The keydown event triggers newline insertion, which we don't want.\n    // This method returns true if the keydown event should be ignored.\n    // We only ignore it once, as pressing Enter a second time *should* insert a newline.\n    // Furthermore, the keydown event timestamp must be close to the compositionEndedAt timestamp.\n    // This guards against the case where compositionend is triggered without the keyboard\n    // (e.g. character confirmation may be done with the mouse), and keydown is triggered\n    // afterwards- we wouldn't want to ignore the keydown event in this case.\n    if (safari && Math.abs(event.timeStamp - view.input.compositionEndedAt) < 500) {\n        view.input.compositionEndedAt = -2e8;\n        return true;\n    }\n    return false;\n}\n// Drop active composition after 5 seconds of inactivity on Android\nconst timeoutComposition = android ? 5000 : -1;\neditHandlers.compositionstart = editHandlers.compositionupdate = (view)=>{\n    if (!view.composing) {\n        view.domObserver.flush();\n        let { state } = view, $pos = state.selection.$to;\n        if (state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection && (state.storedMarks || !$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some((m)=>m.type.spec.inclusive === false) || chrome && windows && selectionBeforeUneditable(view))) {\n            // Need to wrap the cursor in mark nodes different from the ones in the DOM context\n            view.markCursor = view.state.storedMarks || $pos.marks();\n            endComposition(view, true);\n            view.markCursor = null;\n        } else {\n            endComposition(view, !state.selection.empty);\n            // In firefox, if the cursor is after but outside a marked node,\n            // the inserted text won't inherit the marks. So this moves it\n            // inside if necessary.\n            if (gecko && state.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {\n                let sel = view.domSelectionRange();\n                for(let node = sel.focusNode, offset = sel.focusOffset; node && node.nodeType == 1 && offset != 0;){\n                    let before = offset < 0 ? node.lastChild : node.childNodes[offset - 1];\n                    if (!before) break;\n                    if (before.nodeType == 3) {\n                        let sel = view.domSelection();\n                        if (sel) sel.collapse(before, before.nodeValue.length);\n                        break;\n                    } else {\n                        node = before;\n                        offset = -1;\n                    }\n                }\n            }\n        }\n        view.input.composing = true;\n    }\n    scheduleComposeEnd(view, timeoutComposition);\n};\nfunction selectionBeforeUneditable(view) {\n    let { focusNode, focusOffset } = view.domSelectionRange();\n    if (!focusNode || focusNode.nodeType != 1 || focusOffset >= focusNode.childNodes.length) return false;\n    let next = focusNode.childNodes[focusOffset];\n    return next.nodeType == 1 && next.contentEditable == \"false\";\n}\neditHandlers.compositionend = (view, event)=>{\n    if (view.composing) {\n        view.input.composing = false;\n        view.input.compositionEndedAt = event.timeStamp;\n        view.input.compositionPendingChanges = view.domObserver.pendingRecords().length ? view.input.compositionID : 0;\n        view.input.compositionNode = null;\n        if (view.input.compositionPendingChanges) Promise.resolve().then(()=>view.domObserver.flush());\n        view.input.compositionID++;\n        scheduleComposeEnd(view, 20);\n    }\n};\nfunction scheduleComposeEnd(view, delay) {\n    clearTimeout(view.input.composingTimeout);\n    if (delay > -1) view.input.composingTimeout = setTimeout(()=>endComposition(view), delay);\n}\nfunction clearComposition(view) {\n    if (view.composing) {\n        view.input.composing = false;\n        view.input.compositionEndedAt = timestampFromCustomEvent();\n    }\n    while(view.input.compositionNodes.length > 0)view.input.compositionNodes.pop().markParentsDirty();\n}\nfunction findCompositionNode(view) {\n    let sel = view.domSelectionRange();\n    if (!sel.focusNode) return null;\n    let textBefore = textNodeBefore$1(sel.focusNode, sel.focusOffset);\n    let textAfter = textNodeAfter$1(sel.focusNode, sel.focusOffset);\n    if (textBefore && textAfter && textBefore != textAfter) {\n        let descAfter = textAfter.pmViewDesc, lastChanged = view.domObserver.lastChangedTextNode;\n        if (textBefore == lastChanged || textAfter == lastChanged) return lastChanged;\n        if (!descAfter || !descAfter.isText(textAfter.nodeValue)) {\n            return textAfter;\n        } else if (view.input.compositionNode == textAfter) {\n            let descBefore = textBefore.pmViewDesc;\n            if (!(!descBefore || !descBefore.isText(textBefore.nodeValue))) return textAfter;\n        }\n    }\n    return textBefore || textAfter;\n}\nfunction timestampFromCustomEvent() {\n    let event = document.createEvent(\"Event\");\n    event.initEvent(\"event\", true, true);\n    return event.timeStamp;\n}\n/**\n@internal\n*/ function endComposition(view, restarting = false) {\n    if (android && view.domObserver.flushingSoon >= 0) return;\n    view.domObserver.forceFlush();\n    clearComposition(view);\n    if (restarting || view.docView && view.docView.dirty) {\n        let sel = selectionFromDOM(view), cur = view.state.selection;\n        if (sel && !sel.eq(cur)) view.dispatch(view.state.tr.setSelection(sel));\n        else if ((view.markCursor || restarting) && !cur.$from.node(cur.$from.sharedDepth(cur.to)).inlineContent) view.dispatch(view.state.tr.deleteSelection());\n        else view.updateState(view.state);\n        return true;\n    }\n    return false;\n}\nfunction captureCopy(view, dom) {\n    // The extra wrapper is somehow necessary on IE/Edge to prevent the\n    // content from being mangled when it is put onto the clipboard\n    if (!view.dom.parentNode) return;\n    let wrap = view.dom.parentNode.appendChild(document.createElement(\"div\"));\n    wrap.appendChild(dom);\n    wrap.style.cssText = \"position: fixed; left: -10000px; top: 10px\";\n    let sel = getSelection(), range = document.createRange();\n    range.selectNodeContents(dom);\n    // Done because IE will fire a selectionchange moving the selection\n    // to its start when removeAllRanges is called and the editor still\n    // has focus (which will mess up the editor's selection state).\n    view.dom.blur();\n    sel.removeAllRanges();\n    sel.addRange(range);\n    setTimeout(()=>{\n        if (wrap.parentNode) wrap.parentNode.removeChild(wrap);\n        view.focus();\n    }, 50);\n}\n// This is very crude, but unfortunately both these browsers _pretend_\n// that they have a clipboard APIall the objects and methods are\n// there, they just don't work, and they are hard to test.\nconst brokenClipboardAPI = ie && ie_version < 15 || ios && webkit_version < 604;\nhandlers.copy = editHandlers.cut = (view, _event)=>{\n    let event = _event;\n    let sel = view.state.selection, cut = event.type == \"cut\";\n    if (sel.empty) return;\n    // IE and Edge's clipboard interface is completely broken\n    let data = brokenClipboardAPI ? null : event.clipboardData;\n    let slice = sel.content(), { dom, text } = serializeForClipboard(view, slice);\n    if (data) {\n        event.preventDefault();\n        data.clearData();\n        data.setData(\"text/html\", dom.innerHTML);\n        data.setData(\"text/plain\", text);\n    } else {\n        captureCopy(view, dom);\n    }\n    if (cut) view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta(\"uiEvent\", \"cut\"));\n};\nfunction sliceSingleNode(slice) {\n    return slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1 ? slice.content.firstChild : null;\n}\nfunction capturePaste(view, event) {\n    if (!view.dom.parentNode) return;\n    let plainText = view.input.shiftKey || view.state.selection.$from.parent.type.spec.code;\n    let target = view.dom.parentNode.appendChild(document.createElement(plainText ? \"textarea\" : \"div\"));\n    if (!plainText) target.contentEditable = \"true\";\n    target.style.cssText = \"position: fixed; left: -10000px; top: 10px\";\n    target.focus();\n    let plain = view.input.shiftKey && view.input.lastKeyCode != 45;\n    setTimeout(()=>{\n        view.focus();\n        if (target.parentNode) target.parentNode.removeChild(target);\n        if (plainText) doPaste(view, target.value, null, plain, event);\n        else doPaste(view, target.textContent, target.innerHTML, plain, event);\n    }, 50);\n}\nfunction doPaste(view, text, html, preferPlain, event) {\n    let slice = parseFromClipboard(view, text, html, preferPlain, view.state.selection.$from);\n    if (view.someProp(\"handlePaste\", (f)=>f(view, event, slice || prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty))) return true;\n    if (!slice) return false;\n    let singleNode = sliceSingleNode(slice);\n    let tr = singleNode ? view.state.tr.replaceSelectionWith(singleNode, preferPlain) : view.state.tr.replaceSelection(slice);\n    view.dispatch(tr.scrollIntoView().setMeta(\"paste\", true).setMeta(\"uiEvent\", \"paste\"));\n    return true;\n}\nfunction getText(clipboardData) {\n    let text = clipboardData.getData(\"text/plain\") || clipboardData.getData(\"Text\");\n    if (text) return text;\n    let uris = clipboardData.getData(\"text/uri-list\");\n    return uris ? uris.replace(/\\r?\\n/g, \" \") : \"\";\n}\neditHandlers.paste = (view, _event)=>{\n    let event = _event;\n    // Handling paste from JavaScript during composition is very poorly\n    // handled by browsers, so as a dodgy but preferable kludge, we just\n    // let the browser do its native thing there, except on Android,\n    // where the editor is almost always composing.\n    if (view.composing && !android) return;\n    let data = brokenClipboardAPI ? null : event.clipboardData;\n    let plain = view.input.shiftKey && view.input.lastKeyCode != 45;\n    if (data && doPaste(view, getText(data), data.getData(\"text/html\"), plain, event)) event.preventDefault();\n    else capturePaste(view, event);\n};\nclass Dragging {\n    constructor(slice, move, node){\n        this.slice = slice;\n        this.move = move;\n        this.node = node;\n    }\n}\nconst dragCopyModifier = mac ? \"altKey\" : \"ctrlKey\";\nfunction dragMoves(view, event) {\n    let moves = view.someProp(\"dragCopies\", (test)=>!test(event));\n    return moves != null ? moves : !event[dragCopyModifier];\n}\nhandlers.dragstart = (view, _event)=>{\n    let event = _event;\n    let mouseDown = view.input.mouseDown;\n    if (mouseDown) mouseDown.done();\n    if (!event.dataTransfer) return;\n    let sel = view.state.selection;\n    let pos = sel.empty ? null : view.posAtCoords(eventCoords(event));\n    let node;\n    if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection ? sel.to - 1 : sel.to)) ;\n    else if (mouseDown && mouseDown.mightDrag) {\n        node = prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos);\n    } else if (event.target && event.target.nodeType == 1) {\n        let desc = view.docView.nearestDesc(event.target, true);\n        if (desc && desc.node.type.spec.draggable && desc != view.docView) node = prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(view.state.doc, desc.posBefore);\n    }\n    let draggedSlice = (node || view.state.selection).content();\n    let { dom, text, slice } = serializeForClipboard(view, draggedSlice);\n    // Pre-120 Chrome versions clear files when calling `clearData` (#1472)\n    if (!event.dataTransfer.files.length || !chrome || chrome_version > 120) event.dataTransfer.clearData();\n    event.dataTransfer.setData(brokenClipboardAPI ? \"Text\" : \"text/html\", dom.innerHTML);\n    // See https://github.com/ProseMirror/prosemirror/issues/1156\n    event.dataTransfer.effectAllowed = \"copyMove\";\n    if (!brokenClipboardAPI) event.dataTransfer.setData(\"text/plain\", text);\n    view.dragging = new Dragging(slice, dragMoves(view, event), node);\n};\nhandlers.dragend = (view)=>{\n    let dragging = view.dragging;\n    window.setTimeout(()=>{\n        if (view.dragging == dragging) view.dragging = null;\n    }, 50);\n};\neditHandlers.dragover = editHandlers.dragenter = (_, e)=>e.preventDefault();\neditHandlers.drop = (view, event)=>{\n    try {\n        handleDrop(view, event, view.dragging);\n    } finally{\n        view.dragging = null;\n    }\n};\nfunction handleDrop(view, event, dragging) {\n    if (!event.dataTransfer) return;\n    let eventPos = view.posAtCoords(eventCoords(event));\n    if (!eventPos) return;\n    let $mouse = view.state.doc.resolve(eventPos.pos);\n    let slice = dragging && dragging.slice;\n    if (slice) {\n        view.someProp(\"transformPasted\", (f)=>{\n            slice = f(slice, view, false);\n        });\n    } else {\n        slice = parseFromClipboard(view, getText(event.dataTransfer), brokenClipboardAPI ? null : event.dataTransfer.getData(\"text/html\"), false, $mouse);\n    }\n    let move = !!(dragging && dragMoves(view, event));\n    if (view.someProp(\"handleDrop\", (f)=>f(view, event, slice || prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty, move))) {\n        event.preventDefault();\n        return;\n    }\n    if (!slice) return;\n    event.preventDefault();\n    let insertPos = slice ? (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_2__.dropPoint)(view.state.doc, $mouse.pos, slice) : $mouse.pos;\n    if (insertPos == null) insertPos = $mouse.pos;\n    let tr = view.state.tr;\n    if (move) {\n        let { node } = dragging;\n        if (node) node.replace(tr);\n        else tr.deleteSelection();\n    }\n    let pos = tr.mapping.map(insertPos);\n    let isNode = slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1;\n    let beforeInsert = tr.doc;\n    if (isNode) tr.replaceRangeWith(pos, pos, slice.content.firstChild);\n    else tr.replaceRange(pos, pos, slice);\n    if (tr.doc.eq(beforeInsert)) return;\n    let $pos = tr.doc.resolve(pos);\n    if (isNode && prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(slice.content.firstChild) && $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice.content.firstChild)) {\n        tr.setSelection(new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection($pos));\n    } else {\n        let end = tr.mapping.map(insertPos);\n        tr.mapping.maps[tr.mapping.maps.length - 1].forEach((_from, _to, _newFrom, newTo)=>end = newTo);\n        tr.setSelection(selectionBetween(view, $pos, tr.doc.resolve(end)));\n    }\n    view.focus();\n    view.dispatch(tr.setMeta(\"uiEvent\", \"drop\"));\n}\nhandlers.focus = (view)=>{\n    view.input.lastFocus = Date.now();\n    if (!view.focused) {\n        view.domObserver.stop();\n        view.dom.classList.add(\"ProseMirror-focused\");\n        view.domObserver.start();\n        view.focused = true;\n        setTimeout(()=>{\n            if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.domSelectionRange())) selectionToDOM(view);\n        }, 20);\n    }\n};\nhandlers.blur = (view, _event)=>{\n    let event = _event;\n    if (view.focused) {\n        view.domObserver.stop();\n        view.dom.classList.remove(\"ProseMirror-focused\");\n        view.domObserver.start();\n        if (event.relatedTarget && view.dom.contains(event.relatedTarget)) view.domObserver.currentSelection.clear();\n        view.focused = false;\n    }\n};\nhandlers.beforeinput = (view, _event)=>{\n    let event = _event;\n    // We should probably do more with beforeinput events, but support\n    // is so spotty that I'm still waiting to see where they are going.\n    // Very specific hack to deal with backspace sometimes failing on\n    // Chrome Android when after an uneditable node.\n    if (chrome && android && event.inputType == \"deleteContentBackward\") {\n        view.domObserver.flushSoon();\n        let { domChangeCount } = view.input;\n        setTimeout(()=>{\n            if (view.input.domChangeCount != domChangeCount) return; // Event already had some effect\n            // This bug tends to close the virtual keyboard, so we refocus\n            view.dom.blur();\n            view.focus();\n            if (view.someProp(\"handleKeyDown\", (f)=>f(view, keyEvent(8, \"Backspace\")))) return;\n            let { $cursor } = view.state.selection;\n            // Crude approximation of backspace behavior when no command handled it\n            if ($cursor && $cursor.pos > 0) view.dispatch(view.state.tr.delete($cursor.pos - 1, $cursor.pos).scrollIntoView());\n        }, 50);\n    }\n};\n// Make sure all handlers get registered\nfor(let prop in editHandlers)handlers[prop] = editHandlers[prop];\nfunction compareObjs(a, b) {\n    if (a == b) return true;\n    for(let p in a)if (a[p] !== b[p]) return false;\n    for(let p in b)if (!(p in a)) return false;\n    return true;\n}\nclass WidgetType {\n    constructor(toDOM, spec){\n        this.toDOM = toDOM;\n        this.spec = spec || noSpec;\n        this.side = this.spec.side || 0;\n    }\n    map(mapping, span, offset, oldOffset) {\n        let { pos, deleted } = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1);\n        return deleted ? null : new Decoration(pos - offset, pos - offset, this);\n    }\n    valid() {\n        return true;\n    }\n    eq(other) {\n        return this == other || other instanceof WidgetType && (this.spec.key && this.spec.key == other.spec.key || this.toDOM == other.toDOM && compareObjs(this.spec, other.spec));\n    }\n    destroy(node) {\n        if (this.spec.destroy) this.spec.destroy(node);\n    }\n}\nclass InlineType {\n    constructor(attrs, spec){\n        this.attrs = attrs;\n        this.spec = spec || noSpec;\n    }\n    map(mapping, span, offset, oldOffset) {\n        let from = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset;\n        let to = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset;\n        return from >= to ? null : new Decoration(from, to, this);\n    }\n    valid(_, span) {\n        return span.from < span.to;\n    }\n    eq(other) {\n        return this == other || other instanceof InlineType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);\n    }\n    static is(span) {\n        return span.type instanceof InlineType;\n    }\n    destroy() {}\n}\nclass NodeType {\n    constructor(attrs, spec){\n        this.attrs = attrs;\n        this.spec = spec || noSpec;\n    }\n    map(mapping, span, offset, oldOffset) {\n        let from = mapping.mapResult(span.from + oldOffset, 1);\n        if (from.deleted) return null;\n        let to = mapping.mapResult(span.to + oldOffset, -1);\n        if (to.deleted || to.pos <= from.pos) return null;\n        return new Decoration(from.pos - offset, to.pos - offset, this);\n    }\n    valid(node, span) {\n        let { index, offset } = node.content.findIndex(span.from), child;\n        return offset == span.from && !(child = node.child(index)).isText && offset + child.nodeSize == span.to;\n    }\n    eq(other) {\n        return this == other || other instanceof NodeType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);\n    }\n    destroy() {}\n}\n/**\nDecoration objects can be provided to the view through the\n[`decorations` prop](https://prosemirror.net/docs/ref/#view.EditorProps.decorations). They come in\nseveral variantssee the static members of this class for details.\n*/ class Decoration {\n    /**\n    @internal\n    */ constructor(/**\n    The start position of the decoration.\n    */ from, /**\n    The end position. Will be the same as `from` for [widget\n    decorations](https://prosemirror.net/docs/ref/#view.Decoration^widget).\n    */ to, /**\n    @internal\n    */ type){\n        this.from = from;\n        this.to = to;\n        this.type = type;\n    }\n    /**\n    @internal\n    */ copy(from, to) {\n        return new Decoration(from, to, this.type);\n    }\n    /**\n    @internal\n    */ eq(other, offset = 0) {\n        return this.type.eq(other.type) && this.from + offset == other.from && this.to + offset == other.to;\n    }\n    /**\n    @internal\n    */ map(mapping, offset, oldOffset) {\n        return this.type.map(mapping, this, offset, oldOffset);\n    }\n    /**\n    Creates a widget decoration, which is a DOM node that's shown in\n    the document at the given position. It is recommended that you\n    delay rendering the widget by passing a function that will be\n    called when the widget is actually drawn in a view, but you can\n    also directly pass a DOM node. `getPos` can be used to find the\n    widget's current document position.\n    */ static widget(pos, toDOM, spec) {\n        return new Decoration(pos, pos, new WidgetType(toDOM, spec));\n    }\n    /**\n    Creates an inline decoration, which adds the given attributes to\n    each inline node between `from` and `to`.\n    */ static inline(from, to, attrs, spec) {\n        return new Decoration(from, to, new InlineType(attrs, spec));\n    }\n    /**\n    Creates a node decoration. `from` and `to` should point precisely\n    before and after a node in the document. That node, and only that\n    node, will receive the given attributes.\n    */ static node(from, to, attrs, spec) {\n        return new Decoration(from, to, new NodeType(attrs, spec));\n    }\n    /**\n    The spec provided when creating this decoration. Can be useful\n    if you've stored extra information in that object.\n    */ get spec() {\n        return this.type.spec;\n    }\n    /**\n    @internal\n    */ get inline() {\n        return this.type instanceof InlineType;\n    }\n    /**\n    @internal\n    */ get widget() {\n        return this.type instanceof WidgetType;\n    }\n}\nconst none = [], noSpec = {};\n/**\nA collection of [decorations](https://prosemirror.net/docs/ref/#view.Decoration), organized in such\na way that the drawing algorithm can efficiently use and compare\nthem. This is a persistent data structureit is not modified,\nupdates create a new value.\n*/ class DecorationSet {\n    /**\n    @internal\n    */ constructor(local, children){\n        this.local = local.length ? local : none;\n        this.children = children.length ? children : none;\n    }\n    /**\n    Create a set of decorations, using the structure of the given\n    document. This will consume (modify) the `decorations` array, so\n    you must make a copy if you want need to preserve that.\n    */ static create(doc, decorations) {\n        return decorations.length ? buildTree(decorations, doc, 0, noSpec) : empty;\n    }\n    /**\n    Find all decorations in this set which touch the given range\n    (including decorations that start or end directly at the\n    boundaries) and match the given predicate on their spec. When\n    `start` and `end` are omitted, all decorations in the set are\n    considered. When `predicate` isn't given, all decorations are\n    assumed to match.\n    */ find(start, end, predicate) {\n        let result = [];\n        this.findInner(start == null ? 0 : start, end == null ? 1e9 : end, result, 0, predicate);\n        return result;\n    }\n    findInner(start, end, result, offset, predicate) {\n        for(let i = 0; i < this.local.length; i++){\n            let span = this.local[i];\n            if (span.from <= end && span.to >= start && (!predicate || predicate(span.spec))) result.push(span.copy(span.from + offset, span.to + offset));\n        }\n        for(let i = 0; i < this.children.length; i += 3){\n            if (this.children[i] < end && this.children[i + 1] > start) {\n                let childOff = this.children[i] + 1;\n                this.children[i + 2].findInner(start - childOff, end - childOff, result, offset + childOff, predicate);\n            }\n        }\n    }\n    /**\n    Map the set of decorations in response to a change in the\n    document.\n    */ map(mapping, doc, options) {\n        if (this == empty || mapping.maps.length == 0) return this;\n        return this.mapInner(mapping, doc, 0, 0, options || noSpec);\n    }\n    /**\n    @internal\n    */ mapInner(mapping, node, offset, oldOffset, options) {\n        let newLocal;\n        for(let i = 0; i < this.local.length; i++){\n            let mapped = this.local[i].map(mapping, offset, oldOffset);\n            if (mapped && mapped.type.valid(node, mapped)) (newLocal || (newLocal = [])).push(mapped);\n            else if (options.onRemove) options.onRemove(this.local[i].spec);\n        }\n        if (this.children.length) return mapChildren(this.children, newLocal || [], mapping, node, offset, oldOffset, options);\n        else return newLocal ? new DecorationSet(newLocal.sort(byPos), none) : empty;\n    }\n    /**\n    Add the given array of decorations to the ones in the set,\n    producing a new set. Consumes the `decorations` array. Needs\n    access to the current document to create the appropriate tree\n    structure.\n    */ add(doc, decorations) {\n        if (!decorations.length) return this;\n        if (this == empty) return DecorationSet.create(doc, decorations);\n        return this.addInner(doc, decorations, 0);\n    }\n    addInner(doc, decorations, offset) {\n        let children, childIndex = 0;\n        doc.forEach((childNode, childOffset)=>{\n            let baseOffset = childOffset + offset, found;\n            if (!(found = takeSpansForNode(decorations, childNode, baseOffset))) return;\n            if (!children) children = this.children.slice();\n            while(childIndex < children.length && children[childIndex] < childOffset)childIndex += 3;\n            if (children[childIndex] == childOffset) children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found, baseOffset + 1);\n            else children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found, childNode, baseOffset + 1, noSpec));\n            childIndex += 3;\n        });\n        let local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset);\n        for(let i = 0; i < local.length; i++)if (!local[i].type.valid(doc, local[i])) local.splice(i--, 1);\n        return new DecorationSet(local.length ? this.local.concat(local).sort(byPos) : this.local, children || this.children);\n    }\n    /**\n    Create a new set that contains the decorations in this set, minus\n    the ones in the given array.\n    */ remove(decorations) {\n        if (decorations.length == 0 || this == empty) return this;\n        return this.removeInner(decorations, 0);\n    }\n    removeInner(decorations, offset) {\n        let children = this.children, local = this.local;\n        for(let i = 0; i < children.length; i += 3){\n            let found;\n            let from = children[i] + offset, to = children[i + 1] + offset;\n            for(let j = 0, span; j < decorations.length; j++)if (span = decorations[j]) {\n                if (span.from > from && span.to < to) {\n                    decorations[j] = null;\n                    (found || (found = [])).push(span);\n                }\n            }\n            if (!found) continue;\n            if (children == this.children) children = this.children.slice();\n            let removed = children[i + 2].removeInner(found, from + 1);\n            if (removed != empty) {\n                children[i + 2] = removed;\n            } else {\n                children.splice(i, 3);\n                i -= 3;\n            }\n        }\n        if (local.length) {\n            for(let i = 0, span; i < decorations.length; i++)if (span = decorations[i]) {\n                for(let j = 0; j < local.length; j++)if (local[j].eq(span, offset)) {\n                    if (local == this.local) local = this.local.slice();\n                    local.splice(j--, 1);\n                }\n            }\n        }\n        if (children == this.children && local == this.local) return this;\n        return local.length || children.length ? new DecorationSet(local, children) : empty;\n    }\n    forChild(offset, node) {\n        if (this == empty) return this;\n        if (node.isLeaf) return DecorationSet.empty;\n        let child, local;\n        for(let i = 0; i < this.children.length; i += 3)if (this.children[i] >= offset) {\n            if (this.children[i] == offset) child = this.children[i + 2];\n            break;\n        }\n        let start = offset + 1, end = start + node.content.size;\n        for(let i = 0; i < this.local.length; i++){\n            let dec = this.local[i];\n            if (dec.from < end && dec.to > start && dec.type instanceof InlineType) {\n                let from = Math.max(start, dec.from) - start, to = Math.min(end, dec.to) - start;\n                if (from < to) (local || (local = [])).push(dec.copy(from, to));\n            }\n        }\n        if (local) {\n            let localSet = new DecorationSet(local.sort(byPos), none);\n            return child ? new DecorationGroup([\n                localSet,\n                child\n            ]) : localSet;\n        }\n        return child || empty;\n    }\n    /**\n    @internal\n    */ eq(other) {\n        if (this == other) return true;\n        if (!(other instanceof DecorationSet) || this.local.length != other.local.length || this.children.length != other.children.length) return false;\n        for(let i = 0; i < this.local.length; i++)if (!this.local[i].eq(other.local[i])) return false;\n        for(let i = 0; i < this.children.length; i += 3)if (this.children[i] != other.children[i] || this.children[i + 1] != other.children[i + 1] || !this.children[i + 2].eq(other.children[i + 2])) return false;\n        return true;\n    }\n    /**\n    @internal\n    */ locals(node) {\n        return removeOverlap(this.localsInner(node));\n    }\n    /**\n    @internal\n    */ localsInner(node) {\n        if (this == empty) return none;\n        if (node.inlineContent || !this.local.some(InlineType.is)) return this.local;\n        let result = [];\n        for(let i = 0; i < this.local.length; i++){\n            if (!(this.local[i].type instanceof InlineType)) result.push(this.local[i]);\n        }\n        return result;\n    }\n    forEachSet(f) {\n        f(this);\n    }\n}\n/**\nThe empty set of decorations.\n*/ DecorationSet.empty = new DecorationSet([], []);\n/**\n@internal\n*/ DecorationSet.removeOverlap = removeOverlap;\nconst empty = DecorationSet.empty;\n// An abstraction that allows the code dealing with decorations to\n// treat multiple DecorationSet objects as if it were a single object\n// with (a subset of) the same interface.\nclass DecorationGroup {\n    constructor(members){\n        this.members = members;\n    }\n    map(mapping, doc) {\n        const mappedDecos = this.members.map((member)=>member.map(mapping, doc, noSpec));\n        return DecorationGroup.from(mappedDecos);\n    }\n    forChild(offset, child) {\n        if (child.isLeaf) return DecorationSet.empty;\n        let found = [];\n        for(let i = 0; i < this.members.length; i++){\n            let result = this.members[i].forChild(offset, child);\n            if (result == empty) continue;\n            if (result instanceof DecorationGroup) found = found.concat(result.members);\n            else found.push(result);\n        }\n        return DecorationGroup.from(found);\n    }\n    eq(other) {\n        if (!(other instanceof DecorationGroup) || other.members.length != this.members.length) return false;\n        for(let i = 0; i < this.members.length; i++)if (!this.members[i].eq(other.members[i])) return false;\n        return true;\n    }\n    locals(node) {\n        let result, sorted = true;\n        for(let i = 0; i < this.members.length; i++){\n            let locals = this.members[i].localsInner(node);\n            if (!locals.length) continue;\n            if (!result) {\n                result = locals;\n            } else {\n                if (sorted) {\n                    result = result.slice();\n                    sorted = false;\n                }\n                for(let j = 0; j < locals.length; j++)result.push(locals[j]);\n            }\n        }\n        return result ? removeOverlap(sorted ? result : result.sort(byPos)) : none;\n    }\n    // Create a group for the given array of decoration sets, or return\n    // a single set when possible.\n    static from(members) {\n        switch(members.length){\n            case 0:\n                return empty;\n            case 1:\n                return members[0];\n            default:\n                return new DecorationGroup(members.every((m)=>m instanceof DecorationSet) ? members : members.reduce((r, m)=>r.concat(m instanceof DecorationSet ? m : m.members), []));\n        }\n    }\n    forEachSet(f) {\n        for(let i = 0; i < this.members.length; i++)this.members[i].forEachSet(f);\n    }\n}\nfunction mapChildren(oldChildren, newLocal, mapping, node, offset, oldOffset, options) {\n    let children = oldChildren.slice();\n    // Mark the children that are directly touched by changes, and\n    // move those that are after the changes.\n    for(let i = 0, baseOffset = oldOffset; i < mapping.maps.length; i++){\n        let moved = 0;\n        mapping.maps[i].forEach((oldStart, oldEnd, newStart, newEnd)=>{\n            let dSize = newEnd - newStart - (oldEnd - oldStart);\n            for(let i = 0; i < children.length; i += 3){\n                let end = children[i + 1];\n                if (end < 0 || oldStart > end + baseOffset - moved) continue;\n                let start = children[i] + baseOffset - moved;\n                if (oldEnd >= start) {\n                    children[i + 1] = oldStart <= start ? -2 : -1;\n                } else if (oldStart >= baseOffset && dSize) {\n                    children[i] += dSize;\n                    children[i + 1] += dSize;\n                }\n            }\n            moved += dSize;\n        });\n        baseOffset = mapping.maps[i].map(baseOffset, -1);\n    }\n    // Find the child nodes that still correspond to a single node,\n    // recursively call mapInner on them and update their positions.\n    let mustRebuild = false;\n    for(let i = 0; i < children.length; i += 3)if (children[i + 1] < 0) {\n        if (children[i + 1] == -2) {\n            mustRebuild = true;\n            children[i + 1] = -1;\n            continue;\n        }\n        let from = mapping.map(oldChildren[i] + oldOffset), fromLocal = from - offset;\n        if (fromLocal < 0 || fromLocal >= node.content.size) {\n            mustRebuild = true;\n            continue;\n        }\n        // Must read oldChildren because children was tagged with -1\n        let to = mapping.map(oldChildren[i + 1] + oldOffset, -1), toLocal = to - offset;\n        let { index, offset: childOffset } = node.content.findIndex(fromLocal);\n        let childNode = node.maybeChild(index);\n        if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {\n            let mapped = children[i + 2].mapInner(mapping, childNode, from + 1, oldChildren[i] + oldOffset + 1, options);\n            if (mapped != empty) {\n                children[i] = fromLocal;\n                children[i + 1] = toLocal;\n                children[i + 2] = mapped;\n            } else {\n                children[i + 1] = -2;\n                mustRebuild = true;\n            }\n        } else {\n            mustRebuild = true;\n        }\n    }\n    // Remaining children must be collected and rebuilt into the appropriate structure\n    if (mustRebuild) {\n        let decorations = mapAndGatherRemainingDecorations(children, oldChildren, newLocal, mapping, offset, oldOffset, options);\n        let built = buildTree(decorations, node, 0, options);\n        newLocal = built.local;\n        for(let i = 0; i < children.length; i += 3)if (children[i + 1] < 0) {\n            children.splice(i, 3);\n            i -= 3;\n        }\n        for(let i = 0, j = 0; i < built.children.length; i += 3){\n            let from = built.children[i];\n            while(j < children.length && children[j] < from)j += 3;\n            children.splice(j, 0, built.children[i], built.children[i + 1], built.children[i + 2]);\n        }\n    }\n    return new DecorationSet(newLocal.sort(byPos), children);\n}\nfunction moveSpans(spans, offset) {\n    if (!offset || !spans.length) return spans;\n    let result = [];\n    for(let i = 0; i < spans.length; i++){\n        let span = spans[i];\n        result.push(new Decoration(span.from + offset, span.to + offset, span.type));\n    }\n    return result;\n}\nfunction mapAndGatherRemainingDecorations(children, oldChildren, decorations, mapping, offset, oldOffset, options) {\n    // Gather all decorations from the remaining marked children\n    function gather(set, oldOffset) {\n        for(let i = 0; i < set.local.length; i++){\n            let mapped = set.local[i].map(mapping, offset, oldOffset);\n            if (mapped) decorations.push(mapped);\n            else if (options.onRemove) options.onRemove(set.local[i].spec);\n        }\n        for(let i = 0; i < set.children.length; i += 3)gather(set.children[i + 2], set.children[i] + oldOffset + 1);\n    }\n    for(let i = 0; i < children.length; i += 3)if (children[i + 1] == -1) gather(children[i + 2], oldChildren[i] + oldOffset + 1);\n    return decorations;\n}\nfunction takeSpansForNode(spans, node, offset) {\n    if (node.isLeaf) return null;\n    let end = offset + node.nodeSize, found = null;\n    for(let i = 0, span; i < spans.length; i++){\n        if ((span = spans[i]) && span.from > offset && span.to < end) {\n            (found || (found = [])).push(span);\n            spans[i] = null;\n        }\n    }\n    return found;\n}\nfunction withoutNulls(array) {\n    let result = [];\n    for(let i = 0; i < array.length; i++)if (array[i] != null) result.push(array[i]);\n    return result;\n}\n// Build up a tree that corresponds to a set of decorations. `offset`\n// is a base offset that should be subtracted from the `from` and `to`\n// positions in the spans (so that we don't have to allocate new spans\n// for recursive calls).\nfunction buildTree(spans, node, offset, options) {\n    let children = [], hasNulls = false;\n    node.forEach((childNode, localStart)=>{\n        let found = takeSpansForNode(spans, childNode, localStart + offset);\n        if (found) {\n            hasNulls = true;\n            let subtree = buildTree(found, childNode, offset + localStart + 1, options);\n            if (subtree != empty) children.push(localStart, localStart + childNode.nodeSize, subtree);\n        }\n    });\n    let locals = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset).sort(byPos);\n    for(let i = 0; i < locals.length; i++)if (!locals[i].type.valid(node, locals[i])) {\n        if (options.onRemove) options.onRemove(locals[i].spec);\n        locals.splice(i--, 1);\n    }\n    return locals.length || children.length ? new DecorationSet(locals, children) : empty;\n}\n// Used to sort decorations so that ones with a low start position\n// come first, and within a set with the same start position, those\n// with an smaller end position come first.\nfunction byPos(a, b) {\n    return a.from - b.from || a.to - b.to;\n}\n// Scan a sorted array of decorations for partially overlapping spans,\n// and split those so that only fully overlapping spans are left (to\n// make subsequent rendering easier). Will return the input array if\n// no partially overlapping spans are found (the common case).\nfunction removeOverlap(spans) {\n    let working = spans;\n    for(let i = 0; i < working.length - 1; i++){\n        let span = working[i];\n        if (span.from != span.to) for(let j = i + 1; j < working.length; j++){\n            let next = working[j];\n            if (next.from == span.from) {\n                if (next.to != span.to) {\n                    if (working == spans) working = spans.slice();\n                    // Followed by a partially overlapping larger span. Split that\n                    // span.\n                    working[j] = next.copy(next.from, span.to);\n                    insertAhead(working, j + 1, next.copy(span.to, next.to));\n                }\n                continue;\n            } else {\n                if (next.from < span.to) {\n                    if (working == spans) working = spans.slice();\n                    // The end of this one overlaps with a subsequent span. Split\n                    // this one.\n                    working[i] = span.copy(span.from, next.from);\n                    insertAhead(working, j, span.copy(next.from, span.to));\n                }\n                break;\n            }\n        }\n    }\n    return working;\n}\nfunction insertAhead(array, i, deco) {\n    while(i < array.length && byPos(deco, array[i]) > 0)i++;\n    array.splice(i, 0, deco);\n}\n// Get the decorations associated with the current props of a view.\nfunction viewDecorations(view) {\n    let found = [];\n    view.someProp(\"decorations\", (f)=>{\n        let result = f(view.state);\n        if (result && result != empty) found.push(result);\n    });\n    if (view.cursorWrapper) found.push(DecorationSet.create(view.state.doc, [\n        view.cursorWrapper.deco\n    ]));\n    return DecorationGroup.from(found);\n}\nconst observeOptions = {\n    childList: true,\n    characterData: true,\n    characterDataOldValue: true,\n    attributes: true,\n    attributeOldValue: true,\n    subtree: true\n};\n// IE11 has very broken mutation observers, so we also listen to DOMCharacterDataModified\nconst useCharData = ie && ie_version <= 11;\nclass SelectionState {\n    constructor(){\n        this.anchorNode = null;\n        this.anchorOffset = 0;\n        this.focusNode = null;\n        this.focusOffset = 0;\n    }\n    set(sel) {\n        this.anchorNode = sel.anchorNode;\n        this.anchorOffset = sel.anchorOffset;\n        this.focusNode = sel.focusNode;\n        this.focusOffset = sel.focusOffset;\n    }\n    clear() {\n        this.anchorNode = this.focusNode = null;\n    }\n    eq(sel) {\n        return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset && sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset;\n    }\n}\nclass DOMObserver {\n    constructor(view, handleDOMChange){\n        this.view = view;\n        this.handleDOMChange = handleDOMChange;\n        this.queue = [];\n        this.flushingSoon = -1;\n        this.observer = null;\n        this.currentSelection = new SelectionState;\n        this.onCharData = null;\n        this.suppressingSelectionUpdates = false;\n        this.lastChangedTextNode = null;\n        this.observer = window.MutationObserver && new window.MutationObserver((mutations)=>{\n            for(let i = 0; i < mutations.length; i++)this.queue.push(mutations[i]);\n            // IE11 will sometimes (on backspacing out a single character\n            // text node after a BR node) call the observer callback\n            // before actually updating the DOM, which will cause\n            // ProseMirror to miss the change (see #930)\n            if (ie && ie_version <= 11 && mutations.some((m)=>m.type == \"childList\" && m.removedNodes.length || m.type == \"characterData\" && m.oldValue.length > m.target.nodeValue.length)) this.flushSoon();\n            else this.flush();\n        });\n        if (useCharData) {\n            this.onCharData = (e)=>{\n                this.queue.push({\n                    target: e.target,\n                    type: \"characterData\",\n                    oldValue: e.prevValue\n                });\n                this.flushSoon();\n            };\n        }\n        this.onSelectionChange = this.onSelectionChange.bind(this);\n    }\n    flushSoon() {\n        if (this.flushingSoon < 0) this.flushingSoon = window.setTimeout(()=>{\n            this.flushingSoon = -1;\n            this.flush();\n        }, 20);\n    }\n    forceFlush() {\n        if (this.flushingSoon > -1) {\n            window.clearTimeout(this.flushingSoon);\n            this.flushingSoon = -1;\n            this.flush();\n        }\n    }\n    start() {\n        if (this.observer) {\n            this.observer.takeRecords();\n            this.observer.observe(this.view.dom, observeOptions);\n        }\n        if (this.onCharData) this.view.dom.addEventListener(\"DOMCharacterDataModified\", this.onCharData);\n        this.connectSelection();\n    }\n    stop() {\n        if (this.observer) {\n            let take = this.observer.takeRecords();\n            if (take.length) {\n                for(let i = 0; i < take.length; i++)this.queue.push(take[i]);\n                window.setTimeout(()=>this.flush(), 20);\n            }\n            this.observer.disconnect();\n        }\n        if (this.onCharData) this.view.dom.removeEventListener(\"DOMCharacterDataModified\", this.onCharData);\n        this.disconnectSelection();\n    }\n    connectSelection() {\n        this.view.dom.ownerDocument.addEventListener(\"selectionchange\", this.onSelectionChange);\n    }\n    disconnectSelection() {\n        this.view.dom.ownerDocument.removeEventListener(\"selectionchange\", this.onSelectionChange);\n    }\n    suppressSelectionUpdates() {\n        this.suppressingSelectionUpdates = true;\n        setTimeout(()=>this.suppressingSelectionUpdates = false, 50);\n    }\n    onSelectionChange() {\n        if (!hasFocusAndSelection(this.view)) return;\n        if (this.suppressingSelectionUpdates) return selectionToDOM(this.view);\n        // Deletions on IE11 fire their events in the wrong order, giving\n        // us a selection change event before the DOM changes are\n        // reported.\n        if (ie && ie_version <= 11 && !this.view.state.selection.empty) {\n            let sel = this.view.domSelectionRange();\n            // Selection.isCollapsed isn't reliable on IE\n            if (sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset)) return this.flushSoon();\n        }\n        this.flush();\n    }\n    setCurSelection() {\n        this.currentSelection.set(this.view.domSelectionRange());\n    }\n    ignoreSelectionChange(sel) {\n        if (!sel.focusNode) return true;\n        let ancestors = new Set, container;\n        for(let scan = sel.focusNode; scan; scan = parentNode(scan))ancestors.add(scan);\n        for(let scan = sel.anchorNode; scan; scan = parentNode(scan))if (ancestors.has(scan)) {\n            container = scan;\n            break;\n        }\n        let desc = container && this.view.docView.nearestDesc(container);\n        if (desc && desc.ignoreMutation({\n            type: \"selection\",\n            target: container.nodeType == 3 ? container.parentNode : container\n        })) {\n            this.setCurSelection();\n            return true;\n        }\n    }\n    pendingRecords() {\n        if (this.observer) for (let mut of this.observer.takeRecords())this.queue.push(mut);\n        return this.queue;\n    }\n    flush() {\n        let { view } = this;\n        if (!view.docView || this.flushingSoon > -1) return;\n        let mutations = this.pendingRecords();\n        if (mutations.length) this.queue = [];\n        let sel = view.domSelectionRange();\n        let newSel = !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasFocusAndSelection(view) && !this.ignoreSelectionChange(sel);\n        let from = -1, to = -1, typeOver = false, added = [];\n        if (view.editable) {\n            for(let i = 0; i < mutations.length; i++){\n                let result = this.registerMutation(mutations[i], added);\n                if (result) {\n                    from = from < 0 ? result.from : Math.min(result.from, from);\n                    to = to < 0 ? result.to : Math.max(result.to, to);\n                    if (result.typeOver) typeOver = true;\n                }\n            }\n        }\n        if (gecko && added.length) {\n            let brs = added.filter((n)=>n.nodeName == \"BR\");\n            if (brs.length == 2) {\n                let [a, b] = brs;\n                if (a.parentNode && a.parentNode.parentNode == b.parentNode) b.remove();\n                else a.remove();\n            } else {\n                let { focusNode } = this.currentSelection;\n                for (let br of brs){\n                    let parent = br.parentNode;\n                    if (parent && parent.nodeName == \"LI\" && (!focusNode || blockParent(view, focusNode) != parent)) br.remove();\n                }\n            }\n        } else if ((chrome || safari) && added.some((n)=>n.nodeName == \"BR\") && (view.input.lastKeyCode == 8 || view.input.lastKeyCode == 46)) {\n            // Chrome/Safari sometimes insert a bogus break node if you\n            // backspace out the last bit of text before an inline-flex node (#1552)\n            for (let node of added)if (node.nodeName == \"BR\" && node.parentNode) {\n                let after = node.nextSibling;\n                if (after && after.nodeType == 1 && after.contentEditable == \"false\") node.parentNode.removeChild(node);\n            }\n        }\n        let readSel = null;\n        // If it looks like the browser has reset the selection to the\n        // start of the document after focus, restore the selection from\n        // the state\n        if (from < 0 && newSel && view.input.lastFocus > Date.now() - 200 && Math.max(view.input.lastTouch, view.input.lastClick.time) < Date.now() - 300 && selectionCollapsed(sel) && (readSel = selectionFromDOM(view)) && readSel.eq(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.near(view.state.doc.resolve(0), 1))) {\n            view.input.lastFocus = 0;\n            selectionToDOM(view);\n            this.currentSelection.set(sel);\n            view.scrollToSelection();\n        } else if (from > -1 || newSel) {\n            if (from > -1) {\n                view.docView.markDirty(from, to);\n                checkCSS(view);\n            }\n            this.handleDOMChange(from, to, typeOver, added);\n            if (view.docView && view.docView.dirty) view.updateState(view.state);\n            else if (!this.currentSelection.eq(sel)) selectionToDOM(view);\n            this.currentSelection.set(sel);\n        }\n    }\n    registerMutation(mut, added) {\n        // Ignore mutations inside nodes that were already noted as inserted\n        if (added.indexOf(mut.target) > -1) return null;\n        let desc = this.view.docView.nearestDesc(mut.target);\n        if (mut.type == \"attributes\" && (desc == this.view.docView || mut.attributeName == \"contenteditable\" || // Firefox sometimes fires spurious events for null/empty styles\n        mut.attributeName == \"style\" && !mut.oldValue && !mut.target.getAttribute(\"style\"))) return null;\n        if (!desc || desc.ignoreMutation(mut)) return null;\n        if (mut.type == \"childList\") {\n            for(let i = 0; i < mut.addedNodes.length; i++){\n                let node = mut.addedNodes[i];\n                added.push(node);\n                if (node.nodeType == 3) this.lastChangedTextNode = node;\n            }\n            if (desc.contentDOM && desc.contentDOM != desc.dom && !desc.contentDOM.contains(mut.target)) return {\n                from: desc.posBefore,\n                to: desc.posAfter\n            };\n            let prev = mut.previousSibling, next = mut.nextSibling;\n            if (ie && ie_version <= 11 && mut.addedNodes.length) {\n                // IE11 gives us incorrect next/prev siblings for some\n                // insertions, so if there are added nodes, recompute those\n                for(let i = 0; i < mut.addedNodes.length; i++){\n                    let { previousSibling, nextSibling } = mut.addedNodes[i];\n                    if (!previousSibling || Array.prototype.indexOf.call(mut.addedNodes, previousSibling) < 0) prev = previousSibling;\n                    if (!nextSibling || Array.prototype.indexOf.call(mut.addedNodes, nextSibling) < 0) next = nextSibling;\n                }\n            }\n            let fromOffset = prev && prev.parentNode == mut.target ? domIndex(prev) + 1 : 0;\n            let from = desc.localPosFromDOM(mut.target, fromOffset, -1);\n            let toOffset = next && next.parentNode == mut.target ? domIndex(next) : mut.target.childNodes.length;\n            let to = desc.localPosFromDOM(mut.target, toOffset, 1);\n            return {\n                from,\n                to\n            };\n        } else if (mut.type == \"attributes\") {\n            return {\n                from: desc.posAtStart - desc.border,\n                to: desc.posAtEnd + desc.border\n            };\n        } else {\n            this.lastChangedTextNode = mut.target;\n            return {\n                from: desc.posAtStart,\n                to: desc.posAtEnd,\n                // An event was generated for a text change that didn't change\n                // any text. Mark the dom change to fall back to assuming the\n                // selection was typed over with an identical value if it can't\n                // find another change.\n                typeOver: mut.target.nodeValue == mut.oldValue\n            };\n        }\n    }\n}\nlet cssChecked = new WeakMap();\nlet cssCheckWarned = false;\nfunction checkCSS(view) {\n    if (cssChecked.has(view)) return;\n    cssChecked.set(view, null);\n    if ([\n        \"normal\",\n        \"nowrap\",\n        \"pre-line\"\n    ].indexOf(getComputedStyle(view.dom).whiteSpace) !== -1) {\n        view.requiresGeckoHackNode = gecko;\n        if (cssCheckWarned) return;\n        console[\"warn\"](\"ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.\");\n        cssCheckWarned = true;\n    }\n}\nfunction rangeToSelectionRange(view, range) {\n    let anchorNode = range.startContainer, anchorOffset = range.startOffset;\n    let focusNode = range.endContainer, focusOffset = range.endOffset;\n    let currentAnchor = view.domAtPos(view.state.selection.anchor);\n    // Since such a range doesn't distinguish between anchor and head,\n    // use a heuristic that flips it around if its end matches the\n    // current anchor.\n    if (isEquivalentPosition(currentAnchor.node, currentAnchor.offset, focusNode, focusOffset)) [anchorNode, anchorOffset, focusNode, focusOffset] = [\n        focusNode,\n        focusOffset,\n        anchorNode,\n        anchorOffset\n    ];\n    return {\n        anchorNode,\n        anchorOffset,\n        focusNode,\n        focusOffset\n    };\n}\n// Used to work around a Safari Selection/shadow DOM bug\n// Based on https://github.com/codemirror/dev/issues/414 fix\nfunction safariShadowSelectionRange(view, selection) {\n    if (selection.getComposedRanges) {\n        let range = selection.getComposedRanges(view.root)[0];\n        if (range) return rangeToSelectionRange(view, range);\n    }\n    let found;\n    function read(event) {\n        event.preventDefault();\n        event.stopImmediatePropagation();\n        found = event.getTargetRanges()[0];\n    }\n    // Because Safari (at least in 2018-2022) doesn't provide regular\n    // access to the selection inside a shadowRoot, we have to perform a\n    // ridiculous hack to get at itusing `execCommand` to trigger a\n    // `beforeInput` event so that we can read the target range from the\n    // event.\n    view.dom.addEventListener(\"beforeinput\", read, true);\n    document.execCommand(\"indent\");\n    view.dom.removeEventListener(\"beforeinput\", read, true);\n    return found ? rangeToSelectionRange(view, found) : null;\n}\nfunction blockParent(view, node) {\n    for(let p = node.parentNode; p && p != view.dom; p = p.parentNode){\n        let desc = view.docView.nearestDesc(p, true);\n        if (desc && desc.node.isBlock) return p;\n    }\n    return null;\n}\n// Note that all referencing and parsing is done with the\n// start-of-operation selection and document, since that's the one\n// that the DOM represents. If any changes came in in the meantime,\n// the modification is mapped over those before it is applied, in\n// readDOMChange.\nfunction parseBetween(view, from_, to_) {\n    let { node: parent, fromOffset, toOffset, from, to } = view.docView.parseRange(from_, to_);\n    let domSel = view.domSelectionRange();\n    let find;\n    let anchor = domSel.anchorNode;\n    if (anchor && view.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {\n        find = [\n            {\n                node: anchor,\n                offset: domSel.anchorOffset\n            }\n        ];\n        if (!selectionCollapsed(domSel)) find.push({\n            node: domSel.focusNode,\n            offset: domSel.focusOffset\n        });\n    }\n    // Work around issue in Chrome where backspacing sometimes replaces\n    // the deleted content with a random BR node (issues #799, #831)\n    if (chrome && view.input.lastKeyCode === 8) {\n        for(let off = toOffset; off > fromOffset; off--){\n            let node = parent.childNodes[off - 1], desc = node.pmViewDesc;\n            if (node.nodeName == \"BR\" && !desc) {\n                toOffset = off;\n                break;\n            }\n            if (!desc || desc.size) break;\n        }\n    }\n    let startDoc = view.state.doc;\n    let parser = view.someProp(\"domParser\") || prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMParser.fromSchema(view.state.schema);\n    let $from = startDoc.resolve(from);\n    let sel = null, doc = parser.parse(parent, {\n        topNode: $from.parent,\n        topMatch: $from.parent.contentMatchAt($from.index()),\n        topOpen: true,\n        from: fromOffset,\n        to: toOffset,\n        preserveWhitespace: $from.parent.type.whitespace == \"pre\" ? \"full\" : true,\n        findPositions: find,\n        ruleFromNode,\n        context: $from\n    });\n    if (find && find[0].pos != null) {\n        let anchor = find[0].pos, head = find[1] && find[1].pos;\n        if (head == null) head = anchor;\n        sel = {\n            anchor: anchor + from,\n            head: head + from\n        };\n    }\n    return {\n        doc,\n        sel,\n        from,\n        to\n    };\n}\nfunction ruleFromNode(dom) {\n    let desc = dom.pmViewDesc;\n    if (desc) {\n        return desc.parseRule();\n    } else if (dom.nodeName == \"BR\" && dom.parentNode) {\n        // Safari replaces the list item or table cell with a BR\n        // directly in the list node (?!) if you delete the last\n        // character in a list item or table cell (#708, #862)\n        if (safari && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {\n            let skip = document.createElement(\"div\");\n            skip.appendChild(document.createElement(\"li\"));\n            return {\n                skip\n            };\n        } else if (dom.parentNode.lastChild == dom || safari && /^(tr|table)$/i.test(dom.parentNode.nodeName)) {\n            return {\n                ignore: true\n            };\n        }\n    } else if (dom.nodeName == \"IMG\" && dom.getAttribute(\"mark-placeholder\")) {\n        return {\n            ignore: true\n        };\n    }\n    return null;\n}\nconst isInline = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|img|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;\nfunction readDOMChange(view, from, to, typeOver, addedNodes) {\n    let compositionID = view.input.compositionPendingChanges || (view.composing ? view.input.compositionID : 0);\n    view.input.compositionPendingChanges = 0;\n    if (from < 0) {\n        let origin = view.input.lastSelectionTime > Date.now() - 50 ? view.input.lastSelectionOrigin : null;\n        let newSel = selectionFromDOM(view, origin);\n        if (newSel && !view.state.selection.eq(newSel)) {\n            if (chrome && android && view.input.lastKeyCode === 13 && Date.now() - 100 < view.input.lastKeyCodeTime && view.someProp(\"handleKeyDown\", (f)=>f(view, keyEvent(13, \"Enter\")))) return;\n            let tr = view.state.tr.setSelection(newSel);\n            if (origin == \"pointer\") tr.setMeta(\"pointer\", true);\n            else if (origin == \"key\") tr.scrollIntoView();\n            if (compositionID) tr.setMeta(\"composition\", compositionID);\n            view.dispatch(tr);\n        }\n        return;\n    }\n    let $before = view.state.doc.resolve(from);\n    let shared = $before.sharedDepth(to);\n    from = $before.before(shared + 1);\n    to = view.state.doc.resolve(to).after(shared + 1);\n    let sel = view.state.selection;\n    let parse = parseBetween(view, from, to);\n    let doc = view.state.doc, compare = doc.slice(parse.from, parse.to);\n    let preferredPos, preferredSide;\n    // Prefer anchoring to end when Backspace is pressed\n    if (view.input.lastKeyCode === 8 && Date.now() - 100 < view.input.lastKeyCodeTime) {\n        preferredPos = view.state.selection.to;\n        preferredSide = \"end\";\n    } else {\n        preferredPos = view.state.selection.from;\n        preferredSide = \"start\";\n    }\n    view.input.lastKeyCode = null;\n    let change = findDiff(compare.content, parse.doc.content, parse.from, preferredPos, preferredSide);\n    if (change) view.input.domChangeCount++;\n    if ((ios && view.input.lastIOSEnter > Date.now() - 225 || android) && addedNodes.some((n)=>n.nodeType == 1 && !isInline.test(n.nodeName)) && (!change || change.endA >= change.endB) && view.someProp(\"handleKeyDown\", (f)=>f(view, keyEvent(13, \"Enter\")))) {\n        view.input.lastIOSEnter = 0;\n        return;\n    }\n    if (!change) {\n        if (typeOver && sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor) && !view.composing && !(parse.sel && parse.sel.anchor != parse.sel.head)) {\n            change = {\n                start: sel.from,\n                endA: sel.to,\n                endB: sel.to\n            };\n        } else {\n            if (parse.sel) {\n                let sel = resolveSelection(view, view.state.doc, parse.sel);\n                if (sel && !sel.eq(view.state.selection)) {\n                    let tr = view.state.tr.setSelection(sel);\n                    if (compositionID) tr.setMeta(\"composition\", compositionID);\n                    view.dispatch(tr);\n                }\n            }\n            return;\n        }\n    }\n    // Handle the case where overwriting a selection by typing matches\n    // the start or end of the selected content, creating a change\n    // that's smaller than what was actually overwritten.\n    if (view.state.selection.from < view.state.selection.to && change.start == change.endB && view.state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection) {\n        if (change.start > view.state.selection.from && change.start <= view.state.selection.from + 2 && view.state.selection.from >= parse.from) {\n            change.start = view.state.selection.from;\n        } else if (change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2 && view.state.selection.to <= parse.to) {\n            change.endB += view.state.selection.to - change.endA;\n            change.endA = view.state.selection.to;\n        }\n    }\n    // IE11 will insert a non-breaking space _ahead_ of the space after\n    // the cursor space when adding a space before another space. When\n    // that happened, adjust the change to cover the space instead.\n    if (ie && ie_version <= 11 && change.endB == change.start + 1 && change.endA == change.start && change.start > parse.from && parse.doc.textBetween(change.start - parse.from - 1, change.start - parse.from + 1) == \" \\xa0\") {\n        change.start--;\n        change.endA--;\n        change.endB--;\n    }\n    let $from = parse.doc.resolveNoCache(change.start - parse.from);\n    let $to = parse.doc.resolveNoCache(change.endB - parse.from);\n    let $fromA = doc.resolve(change.start);\n    let inlineChange = $from.sameParent($to) && $from.parent.inlineContent && $fromA.end() >= change.endA;\n    // If this looks like the effect of pressing Enter (or was recorded\n    // as being an iOS enter press), just dispatch an Enter key instead.\n    if ((ios && view.input.lastIOSEnter > Date.now() - 225 && (!inlineChange || addedNodes.some((n)=>n.nodeName == \"DIV\" || n.nodeName == \"P\")) || !inlineChange && $from.pos < parse.doc.content.size && (!$from.sameParent($to) || !$from.parent.inlineContent) && $from.pos < $to.pos && !/\\S/.test(parse.doc.textBetween($from.pos, $to.pos, \"\", \"\"))) && view.someProp(\"handleKeyDown\", (f)=>f(view, keyEvent(13, \"Enter\")))) {\n        view.input.lastIOSEnter = 0;\n        return;\n    }\n    // Same for backspace\n    if (view.state.selection.anchor > change.start && looksLikeBackspace(doc, change.start, change.endA, $from, $to) && view.someProp(\"handleKeyDown\", (f)=>f(view, keyEvent(8, \"Backspace\")))) {\n        if (android && chrome) view.domObserver.suppressSelectionUpdates(); // #820\n        return;\n    }\n    // Chrome will occasionally, during composition, delete the\n    // entire composition and then immediately insert it again. This is\n    // used to detect that situation.\n    if (chrome && change.endB == change.start) view.input.lastChromeDelete = Date.now();\n    // This tries to detect Android virtual keyboard\n    // enter-and-pick-suggestion action. That sometimes (see issue\n    // #1059) first fires a DOM mutation, before moving the selection to\n    // the newly created block. And then, because ProseMirror cleans up\n    // the DOM selection, it gives up moving the selection entirely,\n    // leaving the cursor in the wrong place. When that happens, we drop\n    // the new paragraph from the initial change, and fire a simulated\n    // enter key afterwards.\n    if (android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth && parse.sel && parse.sel.anchor == parse.sel.head && parse.sel.head == change.endA) {\n        change.endB -= 2;\n        $to = parse.doc.resolveNoCache(change.endB - parse.from);\n        setTimeout(()=>{\n            view.someProp(\"handleKeyDown\", function(f) {\n                return f(view, keyEvent(13, \"Enter\"));\n            });\n        }, 20);\n    }\n    let chFrom = change.start, chTo = change.endA;\n    let mkTr = (base)=>{\n        let tr = base || view.state.tr.replace(chFrom, chTo, parse.doc.slice(change.start - parse.from, change.endB - parse.from));\n        if (parse.sel) {\n            let sel = resolveSelection(view, tr.doc, parse.sel);\n            // Chrome will sometimes, during composition, report the\n            // selection in the wrong place. If it looks like that is\n            // happening, don't update the selection.\n            // Edge just doesn't move the cursor forward when you start typing\n            // in an empty block or between br nodes.\n            if (sel && !(chrome && view.composing && sel.empty && (change.start != change.endB || view.input.lastChromeDelete < Date.now() - 100) && (sel.head == chFrom || sel.head == tr.mapping.map(chTo) - 1) || ie && sel.empty && sel.head == chFrom)) tr.setSelection(sel);\n        }\n        if (compositionID) tr.setMeta(\"composition\", compositionID);\n        return tr.scrollIntoView();\n    };\n    let markChange;\n    if (inlineChange) {\n        if ($from.pos == $to.pos) {\n            // IE11 sometimes weirdly moves the DOM selection around after\n            // backspacing out the first element in a textblock\n            if (ie && ie_version <= 11 && $from.parentOffset == 0) {\n                view.domObserver.suppressSelectionUpdates();\n                setTimeout(()=>selectionToDOM(view), 20);\n            }\n            let tr = mkTr(view.state.tr.delete(chFrom, chTo));\n            let marks = doc.resolve(change.start).marksAcross(doc.resolve(change.endA));\n            if (marks) tr.ensureMarks(marks);\n            view.dispatch(tr);\n        } else if (change.endA == change.endB && (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset), $fromA.parent.content.cut($fromA.parentOffset, change.endA - $fromA.start())))) {\n            let tr = mkTr(view.state.tr);\n            if (markChange.type == \"add\") tr.addMark(chFrom, chTo, markChange.mark);\n            else tr.removeMark(chFrom, chTo, markChange.mark);\n            view.dispatch(tr);\n        } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {\n            // Both positions in the same text node -- simply insert text\n            let text = $from.parent.textBetween($from.parentOffset, $to.parentOffset);\n            let deflt = ()=>mkTr(view.state.tr.insertText(text, chFrom, chTo));\n            if (!view.someProp(\"handleTextInput\", (f)=>f(view, chFrom, chTo, text, deflt))) view.dispatch(deflt());\n        } else {\n            view.dispatch(mkTr());\n        }\n    } else {\n        view.dispatch(mkTr());\n    }\n}\nfunction resolveSelection(view, doc, parsedSel) {\n    if (Math.max(parsedSel.anchor, parsedSel.head) > doc.content.size) return null;\n    return selectionBetween(view, doc.resolve(parsedSel.anchor), doc.resolve(parsedSel.head));\n}\n// Given two same-length, non-empty fragments of inline content,\n// determine whether the first could be created from the second by\n// removing or adding a single mark type.\nfunction isMarkChange(cur, prev) {\n    let curMarks = cur.firstChild.marks, prevMarks = prev.firstChild.marks;\n    let added = curMarks, removed = prevMarks, type, mark, update;\n    for(let i = 0; i < prevMarks.length; i++)added = prevMarks[i].removeFromSet(added);\n    for(let i = 0; i < curMarks.length; i++)removed = curMarks[i].removeFromSet(removed);\n    if (added.length == 1 && removed.length == 0) {\n        mark = added[0];\n        type = \"add\";\n        update = (node)=>node.mark(mark.addToSet(node.marks));\n    } else if (added.length == 0 && removed.length == 1) {\n        mark = removed[0];\n        type = \"remove\";\n        update = (node)=>node.mark(mark.removeFromSet(node.marks));\n    } else {\n        return null;\n    }\n    let updated = [];\n    for(let i = 0; i < prev.childCount; i++)updated.push(update(prev.child(i)));\n    if (prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(updated).eq(cur)) return {\n        mark,\n        type\n    };\n}\nfunction looksLikeBackspace(old, start, end, $newStart, $newEnd) {\n    if (end - start <= $newEnd.pos - $newStart.pos || // newEnd must point directly at or after the end of the block that newStart points into\n    skipClosingAndOpening($newStart, true, false) < $newEnd.pos) return false;\n    let $start = old.resolve(start);\n    // Handle the case where, rather than joining blocks, the change just removed an entire block\n    if (!$newStart.parent.isTextblock) {\n        let after = $start.nodeAfter;\n        return after != null && end == start + after.nodeSize;\n    }\n    // Start must be at the end of a block\n    if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock) return false;\n    let $next = old.resolve(skipClosingAndOpening($start, true, true));\n    // The next textblock must start before end and end near it\n    if (!$next.parent.isTextblock || $next.pos > end || skipClosingAndOpening($next, true, false) < end) return false;\n    // The fragments after the join point must match\n    return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content);\n}\nfunction skipClosingAndOpening($pos, fromEnd, mayOpen) {\n    let depth = $pos.depth, end = fromEnd ? $pos.end() : $pos.pos;\n    while(depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)){\n        depth--;\n        end++;\n        fromEnd = false;\n    }\n    if (mayOpen) {\n        let next = $pos.node(depth).maybeChild($pos.indexAfter(depth));\n        while(next && !next.isLeaf){\n            next = next.firstChild;\n            end++;\n        }\n    }\n    return end;\n}\nfunction findDiff(a, b, pos, preferredPos, preferredSide) {\n    let start = a.findDiffStart(b, pos);\n    if (start == null) return null;\n    let { a: endA, b: endB } = a.findDiffEnd(b, pos + a.size, pos + b.size);\n    if (preferredSide == \"end\") {\n        let adjust = Math.max(0, start - Math.min(endA, endB));\n        preferredPos -= endA + adjust - start;\n    }\n    if (endA < start && a.size < b.size) {\n        let move = preferredPos <= start && preferredPos >= endA ? start - preferredPos : 0;\n        start -= move;\n        if (start && start < b.size && isSurrogatePair(b.textBetween(start - 1, start + 1))) start += move ? 1 : -1;\n        endB = start + (endB - endA);\n        endA = start;\n    } else if (endB < start) {\n        let move = preferredPos <= start && preferredPos >= endB ? start - preferredPos : 0;\n        start -= move;\n        if (start && start < a.size && isSurrogatePair(a.textBetween(start - 1, start + 1))) start += move ? 1 : -1;\n        endA = start + (endA - endB);\n        endB = start;\n    }\n    return {\n        start,\n        endA,\n        endB\n    };\n}\nfunction isSurrogatePair(str) {\n    if (str.length != 2) return false;\n    let a = str.charCodeAt(0), b = str.charCodeAt(1);\n    return a >= 0xDC00 && a <= 0xDFFF && b >= 0xD800 && b <= 0xDBFF;\n}\n/**\n@internal\n*/ const __parseFromClipboard = parseFromClipboard;\n/**\n@internal\n*/ const __endComposition = endComposition;\n/**\nAn editor view manages the DOM structure that represents an\neditable document. Its state and behavior are determined by its\n[props](https://prosemirror.net/docs/ref/#view.DirectEditorProps).\n*/ class EditorView {\n    /**\n    Create a view. `place` may be a DOM node that the editor should\n    be appended to, a function that will place it into the document,\n    or an object whose `mount` property holds the node to use as the\n    document container. If it is `null`, the editor will not be\n    added to the document.\n    */ constructor(place, props){\n        this._root = null;\n        /**\n        @internal\n        */ this.focused = false;\n        /**\n        Kludge used to work around a Chrome bug @internal\n        */ this.trackWrites = null;\n        this.mounted = false;\n        /**\n        @internal\n        */ this.markCursor = null;\n        /**\n        @internal\n        */ this.cursorWrapper = null;\n        /**\n        @internal\n        */ this.lastSelectedViewDesc = undefined;\n        /**\n        @internal\n        */ this.input = new InputState;\n        this.prevDirectPlugins = [];\n        this.pluginViews = [];\n        /**\n        Holds `true` when a hack node is needed in Firefox to prevent the\n        [space is eaten issue](https://github.com/ProseMirror/prosemirror/issues/651)\n        @internal\n        */ this.requiresGeckoHackNode = false;\n        /**\n        When editor content is being dragged, this object contains\n        information about the dragged slice and whether it is being\n        copied or moved. At any other time, it is null.\n        */ this.dragging = null;\n        this._props = props;\n        this.state = props.state;\n        this.directPlugins = props.plugins || [];\n        this.directPlugins.forEach(checkStateComponent);\n        this.dispatch = this.dispatch.bind(this);\n        this.dom = place && place.mount || document.createElement(\"div\");\n        if (place) {\n            if (place.appendChild) place.appendChild(this.dom);\n            else if (typeof place == \"function\") place(this.dom);\n            else if (place.mount) this.mounted = true;\n        }\n        this.editable = getEditable(this);\n        updateCursorWrapper(this);\n        this.nodeViews = buildNodeViews(this);\n        this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this);\n        this.domObserver = new DOMObserver(this, (from, to, typeOver, added)=>readDOMChange(this, from, to, typeOver, added));\n        this.domObserver.start();\n        initInput(this);\n        this.updatePluginViews();\n    }\n    /**\n    Holds `true` when a\n    [composition](https://w3c.github.io/uievents/#events-compositionevents)\n    is active.\n    */ get composing() {\n        return this.input.composing;\n    }\n    /**\n    The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).\n    */ get props() {\n        if (this._props.state != this.state) {\n            let prev = this._props;\n            this._props = {};\n            for(let name in prev)this._props[name] = prev[name];\n            this._props.state = this.state;\n        }\n        return this._props;\n    }\n    /**\n    Update the view's props. Will immediately cause an update to\n    the DOM.\n    */ update(props) {\n        if (props.handleDOMEvents != this._props.handleDOMEvents) ensureListeners(this);\n        let prevProps = this._props;\n        this._props = props;\n        if (props.plugins) {\n            props.plugins.forEach(checkStateComponent);\n            this.directPlugins = props.plugins;\n        }\n        this.updateStateInner(props.state, prevProps);\n    }\n    /**\n    Update the view by updating existing props object with the object\n    given as argument. Equivalent to `view.update(Object.assign({},\n    view.props, props))`.\n    */ setProps(props) {\n        let updated = {};\n        for(let name in this._props)updated[name] = this._props[name];\n        updated.state = this.state;\n        for(let name in props)updated[name] = props[name];\n        this.update(updated);\n    }\n    /**\n    Update the editor's `state` prop, without touching any of the\n    other props.\n    */ updateState(state) {\n        this.updateStateInner(state, this._props);\n    }\n    updateStateInner(state, prevProps) {\n        var _a;\n        let prev = this.state, redraw = false, updateSel = false;\n        // When stored marks are added, stop composition, so that they can\n        // be displayed.\n        if (state.storedMarks && this.composing) {\n            clearComposition(this);\n            updateSel = true;\n        }\n        this.state = state;\n        let pluginsChanged = prev.plugins != state.plugins || this._props.plugins != prevProps.plugins;\n        if (pluginsChanged || this._props.plugins != prevProps.plugins || this._props.nodeViews != prevProps.nodeViews) {\n            let nodeViews = buildNodeViews(this);\n            if (changedNodeViews(nodeViews, this.nodeViews)) {\n                this.nodeViews = nodeViews;\n                redraw = true;\n            }\n        }\n        if (pluginsChanged || prevProps.handleDOMEvents != this._props.handleDOMEvents) {\n            ensureListeners(this);\n        }\n        this.editable = getEditable(this);\n        updateCursorWrapper(this);\n        let innerDeco = viewDecorations(this), outerDeco = computeDocDeco(this);\n        let scroll = prev.plugins != state.plugins && !prev.doc.eq(state.doc) ? \"reset\" : state.scrollToSelection > prev.scrollToSelection ? \"to selection\" : \"preserve\";\n        let updateDoc = redraw || !this.docView.matchesNode(state.doc, outerDeco, innerDeco);\n        if (updateDoc || !state.selection.eq(prev.selection)) updateSel = true;\n        let oldScrollPos = scroll == \"preserve\" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos(this);\n        if (updateSel) {\n            this.domObserver.stop();\n            // Work around an issue in Chrome, IE, and Edge where changing\n            // the DOM around an active selection puts it into a broken\n            // state where the thing the user sees differs from the\n            // selection reported by the Selection object (#710, #973,\n            // #1011, #1013, #1035).\n            let forceSelUpdate = updateDoc && (ie || chrome) && !this.composing && !prev.selection.empty && !state.selection.empty && selectionContextChanged(prev.selection, state.selection);\n            if (updateDoc) {\n                // If the node that the selection points into is written to,\n                // Chrome sometimes starts misreporting the selection, so this\n                // tracks that and forces a selection reset when our update\n                // did write to the node.\n                let chromeKludge = chrome ? this.trackWrites = this.domSelectionRange().focusNode : null;\n                if (this.composing) this.input.compositionNode = findCompositionNode(this);\n                if (redraw || !this.docView.update(state.doc, outerDeco, innerDeco, this)) {\n                    this.docView.updateOuterDeco(outerDeco);\n                    this.docView.destroy();\n                    this.docView = docViewDesc(state.doc, outerDeco, innerDeco, this.dom, this);\n                }\n                if (chromeKludge && !this.trackWrites) forceSelUpdate = true;\n            }\n            // Work around for an issue where an update arriving right between\n            // a DOM selection change and the \"selectionchange\" event for it\n            // can cause a spurious DOM selection update, disrupting mouse\n            // drag selection.\n            if (forceSelUpdate || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && anchorInRightPlace(this))) {\n                selectionToDOM(this, forceSelUpdate);\n            } else {\n                syncNodeSelection(this, state.selection);\n                this.domObserver.setCurSelection();\n            }\n            this.domObserver.start();\n        }\n        this.updatePluginViews(prev);\n        if (((_a = this.dragging) === null || _a === void 0 ? void 0 : _a.node) && !prev.doc.eq(state.doc)) this.updateDraggedNode(this.dragging, prev);\n        if (scroll == \"reset\") {\n            this.dom.scrollTop = 0;\n        } else if (scroll == \"to selection\") {\n            this.scrollToSelection();\n        } else if (oldScrollPos) {\n            resetScrollPos(oldScrollPos);\n        }\n    }\n    /**\n    @internal\n    */ scrollToSelection() {\n        let startDOM = this.domSelectionRange().focusNode;\n        if (!startDOM || !this.dom.contains(startDOM.nodeType == 1 ? startDOM : startDOM.parentNode)) ;\n        else if (this.someProp(\"handleScrollToSelection\", (f)=>f(this))) ;\n        else if (this.state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection) {\n            let target = this.docView.domAfterPos(this.state.selection.from);\n            if (target.nodeType == 1) scrollRectIntoView(this, target.getBoundingClientRect(), startDOM);\n        } else {\n            scrollRectIntoView(this, this.coordsAtPos(this.state.selection.head, 1), startDOM);\n        }\n    }\n    destroyPluginViews() {\n        let view;\n        while(view = this.pluginViews.pop())if (view.destroy) view.destroy();\n    }\n    updatePluginViews(prevState) {\n        if (!prevState || prevState.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {\n            this.prevDirectPlugins = this.directPlugins;\n            this.destroyPluginViews();\n            for(let i = 0; i < this.directPlugins.length; i++){\n                let plugin = this.directPlugins[i];\n                if (plugin.spec.view) this.pluginViews.push(plugin.spec.view(this));\n            }\n            for(let i = 0; i < this.state.plugins.length; i++){\n                let plugin = this.state.plugins[i];\n                if (plugin.spec.view) this.pluginViews.push(plugin.spec.view(this));\n            }\n        } else {\n            for(let i = 0; i < this.pluginViews.length; i++){\n                let pluginView = this.pluginViews[i];\n                if (pluginView.update) pluginView.update(this, prevState);\n            }\n        }\n    }\n    updateDraggedNode(dragging, prev) {\n        let sel = dragging.node, found = -1;\n        if (this.state.doc.nodeAt(sel.from) == sel.node) {\n            found = sel.from;\n        } else {\n            let movedPos = sel.from + (this.state.doc.content.size - prev.doc.content.size);\n            let moved = movedPos > 0 && this.state.doc.nodeAt(movedPos);\n            if (moved == sel.node) found = movedPos;\n        }\n        this.dragging = new Dragging(dragging.slice, dragging.move, found < 0 ? undefined : prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(this.state.doc, found));\n    }\n    someProp(propName, f) {\n        let prop = this._props && this._props[propName], value;\n        if (prop != null && (value = f ? f(prop) : prop)) return value;\n        for(let i = 0; i < this.directPlugins.length; i++){\n            let prop = this.directPlugins[i].props[propName];\n            if (prop != null && (value = f ? f(prop) : prop)) return value;\n        }\n        let plugins = this.state.plugins;\n        if (plugins) for(let i = 0; i < plugins.length; i++){\n            let prop = plugins[i].props[propName];\n            if (prop != null && (value = f ? f(prop) : prop)) return value;\n        }\n    }\n    /**\n    Query whether the view has focus.\n    */ hasFocus() {\n        // Work around IE not handling focus correctly if resize handles are shown.\n        // If the cursor is inside an element with resize handles, activeElement\n        // will be that element instead of this.dom.\n        if (ie) {\n            // If activeElement is within this.dom, and there are no other elements\n            // setting `contenteditable` to false in between, treat it as focused.\n            let node = this.root.activeElement;\n            if (node == this.dom) return true;\n            if (!node || !this.dom.contains(node)) return false;\n            while(node && this.dom != node && this.dom.contains(node)){\n                if (node.contentEditable == \"false\") return false;\n                node = node.parentElement;\n            }\n            return true;\n        }\n        return this.root.activeElement == this.dom;\n    }\n    /**\n    Focus the editor.\n    */ focus() {\n        this.domObserver.stop();\n        if (this.editable) focusPreventScroll(this.dom);\n        selectionToDOM(this);\n        this.domObserver.start();\n    }\n    /**\n    Get the document root in which the editor exists. This will\n    usually be the top-level `document`, but might be a [shadow\n    DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)\n    root if the editor is inside one.\n    */ get root() {\n        let cached = this._root;\n        if (cached == null) for(let search = this.dom.parentNode; search; search = search.parentNode){\n            if (search.nodeType == 9 || search.nodeType == 11 && search.host) {\n                if (!search.getSelection) Object.getPrototypeOf(search).getSelection = ()=>search.ownerDocument.getSelection();\n                return this._root = search;\n            }\n        }\n        return cached || document;\n    }\n    /**\n    When an existing editor view is moved to a new document or\n    shadow tree, call this to make it recompute its root.\n    */ updateRoot() {\n        this._root = null;\n    }\n    /**\n    Given a pair of viewport coordinates, return the document\n    position that corresponds to them. May return null if the given\n    coordinates aren't inside of the editor. When an object is\n    returned, its `pos` property is the position nearest to the\n    coordinates, and its `inside` property holds the position of the\n    inner node that the position falls inside of, or -1 if it is at\n    the top level, not in any node.\n    */ posAtCoords(coords) {\n        return posAtCoords(this, coords);\n    }\n    /**\n    Returns the viewport rectangle at a given document position.\n    `left` and `right` will be the same number, as this returns a\n    flat cursor-ish rectangle. If the position is between two things\n    that aren't directly adjacent, `side` determines which element\n    is used. When < 0, the element before the position is used,\n    otherwise the element after.\n    */ coordsAtPos(pos, side = 1) {\n        return coordsAtPos(this, pos, side);\n    }\n    /**\n    Find the DOM position that corresponds to the given document\n    position. When `side` is negative, find the position as close as\n    possible to the content before the position. When positive,\n    prefer positions close to the content after the position. When\n    zero, prefer as shallow a position as possible.\n    \n    Note that you should **not** mutate the editor's internal DOM,\n    only inspect it (and even that is usually not necessary).\n    */ domAtPos(pos, side = 0) {\n        return this.docView.domFromPos(pos, side);\n    }\n    /**\n    Find the DOM node that represents the document node after the\n    given position. May return `null` when the position doesn't point\n    in front of a node or if the node is inside an opaque node view.\n    \n    This is intended to be able to call things like\n    `getBoundingClientRect` on that DOM node. Do **not** mutate the\n    editor DOM directly, or add styling this way, since that will be\n    immediately overriden by the editor as it redraws the node.\n    */ nodeDOM(pos) {\n        let desc = this.docView.descAt(pos);\n        return desc ? desc.nodeDOM : null;\n    }\n    /**\n    Find the document position that corresponds to a given DOM\n    position. (Whenever possible, it is preferable to inspect the\n    document structure directly, rather than poking around in the\n    DOM, but sometimesfor example when interpreting an event\n    targetyou don't have a choice.)\n    \n    The `bias` parameter can be used to influence which side of a DOM\n    node to use when the position is inside a leaf node.\n    */ posAtDOM(node, offset, bias = -1) {\n        let pos = this.docView.posFromDOM(node, offset, bias);\n        if (pos == null) throw new RangeError(\"DOM position not inside the editor\");\n        return pos;\n    }\n    /**\n    Find out whether the selection is at the end of a textblock when\n    moving in a given direction. When, for example, given `\"left\"`,\n    it will return true if moving left from the current cursor\n    position would leave that position's parent textblock. Will apply\n    to the view's current state by default, but it is possible to\n    pass a different state.\n    */ endOfTextblock(dir, state) {\n        return endOfTextblock(this, state || this.state, dir);\n    }\n    /**\n    Run the editor's paste logic with the given HTML string. The\n    `event`, if given, will be passed to the\n    [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.\n    */ pasteHTML(html, event) {\n        return doPaste(this, \"\", html, false, event || new ClipboardEvent(\"paste\"));\n    }\n    /**\n    Run the editor's paste logic with the given plain-text input.\n    */ pasteText(text, event) {\n        return doPaste(this, text, null, true, event || new ClipboardEvent(\"paste\"));\n    }\n    /**\n    Serialize the given slice as it would be if it was copied from\n    this editor. Returns a DOM element that contains a\n    representation of the slice as its children, a textual\n    representation, and the transformed slice (which can be\n    different from the given input due to hooks like\n    [`transformCopied`](https://prosemirror.net/docs/ref/#view.EditorProps.transformCopied)).\n    */ serializeForClipboard(slice) {\n        return serializeForClipboard(this, slice);\n    }\n    /**\n    Removes the editor from the DOM and destroys all [node\n    views](https://prosemirror.net/docs/ref/#view.NodeView).\n    */ destroy() {\n        if (!this.docView) return;\n        destroyInput(this);\n        this.destroyPluginViews();\n        if (this.mounted) {\n            this.docView.update(this.state.doc, [], viewDecorations(this), this);\n            this.dom.textContent = \"\";\n        } else if (this.dom.parentNode) {\n            this.dom.parentNode.removeChild(this.dom);\n        }\n        this.docView.destroy();\n        this.docView = null;\n        clearReusedRange();\n    }\n    /**\n    This is true when the view has been\n    [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be\n    used anymore).\n    */ get isDestroyed() {\n        return this.docView == null;\n    }\n    /**\n    Used for testing.\n    */ dispatchEvent(event) {\n        return dispatchEvent(this, event);\n    }\n    /**\n    @internal\n    */ domSelectionRange() {\n        let sel = this.domSelection();\n        if (!sel) return {\n            focusNode: null,\n            focusOffset: 0,\n            anchorNode: null,\n            anchorOffset: 0\n        };\n        return safari && this.root.nodeType === 11 && deepActiveElement(this.dom.ownerDocument) == this.dom && safariShadowSelectionRange(this, sel) || sel;\n    }\n    /**\n    @internal\n    */ domSelection() {\n        return this.root.getSelection();\n    }\n}\nEditorView.prototype.dispatch = function(tr) {\n    let dispatchTransaction = this._props.dispatchTransaction;\n    if (dispatchTransaction) dispatchTransaction.call(this, tr);\n    else this.updateState(this.state.apply(tr));\n};\nfunction computeDocDeco(view) {\n    let attrs = Object.create(null);\n    attrs.class = \"ProseMirror\";\n    attrs.contenteditable = String(view.editable);\n    view.someProp(\"attributes\", (value)=>{\n        if (typeof value == \"function\") value = value(view.state);\n        if (value) for(let attr in value){\n            if (attr == \"class\") attrs.class += \" \" + value[attr];\n            else if (attr == \"style\") attrs.style = (attrs.style ? attrs.style + \";\" : \"\") + value[attr];\n            else if (!attrs[attr] && attr != \"contenteditable\" && attr != \"nodeName\") attrs[attr] = String(value[attr]);\n        }\n    });\n    if (!attrs.translate) attrs.translate = \"no\";\n    return [\n        Decoration.node(0, view.state.doc.content.size, attrs)\n    ];\n}\nfunction updateCursorWrapper(view) {\n    if (view.markCursor) {\n        let dom = document.createElement(\"img\");\n        dom.className = \"ProseMirror-separator\";\n        dom.setAttribute(\"mark-placeholder\", \"true\");\n        dom.setAttribute(\"alt\", \"\");\n        view.cursorWrapper = {\n            dom,\n            deco: Decoration.widget(view.state.selection.from, dom, {\n                raw: true,\n                marks: view.markCursor\n            })\n        };\n    } else {\n        view.cursorWrapper = null;\n    }\n}\nfunction getEditable(view) {\n    return !view.someProp(\"editable\", (value)=>value(view.state) === false);\n}\nfunction selectionContextChanged(sel1, sel2) {\n    let depth = Math.min(sel1.$anchor.sharedDepth(sel1.head), sel2.$anchor.sharedDepth(sel2.head));\n    return sel1.$anchor.start(depth) != sel2.$anchor.start(depth);\n}\nfunction buildNodeViews(view) {\n    let result = Object.create(null);\n    function add(obj) {\n        for(let prop in obj)if (!Object.prototype.hasOwnProperty.call(result, prop)) result[prop] = obj[prop];\n    }\n    view.someProp(\"nodeViews\", add);\n    view.someProp(\"markViews\", add);\n    return result;\n}\nfunction changedNodeViews(a, b) {\n    let nA = 0, nB = 0;\n    for(let prop in a){\n        if (a[prop] != b[prop]) return true;\n        nA++;\n    }\n    for(let _ in b)nB++;\n    return nA != nB;\n}\nfunction checkStateComponent(plugin) {\n    if (plugin.spec.state || plugin.spec.filterTransaction || plugin.spec.appendTransaction) throw new RangeError(\"Plugins passed directly to the view must not have a state component\");\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3Itdmlldy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQTBGO0FBQ047QUFDbEM7QUFFbEQsTUFBTVUsV0FBVyxTQUFVQyxJQUFJO0lBQzNCLElBQUssSUFBSUMsUUFBUSxJQUFJQSxRQUFTO1FBQzFCRCxPQUFPQSxLQUFLRSxlQUFlO1FBQzNCLElBQUksQ0FBQ0YsTUFDRCxPQUFPQztJQUNmO0FBQ0o7QUFDQSxNQUFNRSxhQUFhLFNBQVVILElBQUk7SUFDN0IsSUFBSUksU0FBU0osS0FBS0ssWUFBWSxJQUFJTCxLQUFLRyxVQUFVO0lBQ2pELE9BQU9DLFVBQVVBLE9BQU9FLFFBQVEsSUFBSSxLQUFLRixPQUFPRyxJQUFJLEdBQUdIO0FBQzNEO0FBQ0EsSUFBSUksY0FBYztBQUNsQixzRUFBc0U7QUFDdEUsb0VBQW9FO0FBQ3BFLDRCQUE0QjtBQUM1QixNQUFNQyxZQUFZLFNBQVVULElBQUksRUFBRVUsSUFBSSxFQUFFQyxFQUFFO0lBQ3RDLElBQUlDLFFBQVFKLGVBQWdCQSxDQUFBQSxjQUFjSyxTQUFTQyxXQUFXLEVBQUM7SUFDL0RGLE1BQU1HLE1BQU0sQ0FBQ2YsTUFBTVcsTUFBTSxPQUFPWCxLQUFLZ0IsU0FBUyxDQUFDQyxNQUFNLEdBQUdOO0lBQ3hEQyxNQUFNTSxRQUFRLENBQUNsQixNQUFNVSxRQUFRO0lBQzdCLE9BQU9FO0FBQ1g7QUFDQSxNQUFNTyxtQkFBbUI7SUFDckJYLGNBQWM7QUFDbEI7QUFDQSxxRUFBcUU7QUFDckUsa0VBQWtFO0FBQ2xFLDZDQUE2QztBQUM3QyxNQUFNWSx1QkFBdUIsU0FBVXBCLElBQUksRUFBRXFCLEdBQUcsRUFBRUMsVUFBVSxFQUFFQyxTQUFTO0lBQ25FLE9BQU9ELGNBQWVFLENBQUFBLFFBQVF4QixNQUFNcUIsS0FBS0MsWUFBWUMsV0FBVyxDQUFDLE1BQzdEQyxRQUFReEIsTUFBTXFCLEtBQUtDLFlBQVlDLFdBQVcsRUFBQztBQUNu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YXNPO0lBQzNCLE9BQU8zSztBQUNYO0FBQ0EsU0FBUzI0QixpQkFBaUJybUIsQ0FBQyxFQUFFQyxDQUFDO0lBQzFCLElBQUltb0IsS0FBSyxHQUFHQyxLQUFLO0lBQ2pCLElBQUssSUFBSXpvQixRQUFRSSxFQUFHO1FBQ2hCLElBQUlBLENBQUMsQ0FBQ0osS0FBSyxJQUFJSyxDQUFDLENBQUNMLEtBQUssRUFDbEIsT0FBTztRQUNYd29CO0lBQ0o7SUFDQSxJQUFLLElBQUk5aEMsS0FBSzJaLEVBQ1Zvb0I7SUFDSixPQUFPRCxNQUFNQztBQUNqQjtBQUNBLFNBQVM5QyxvQkFBb0J5QixNQUFNO0lBQy9CLElBQUlBLE9BQU9qdkIsSUFBSSxDQUFDeEksS0FBSyxJQUFJeTNCLE9BQU9qdkIsSUFBSSxDQUFDdXdCLGlCQUFpQixJQUFJdEIsT0FBT2p2QixJQUFJLENBQUN3d0IsaUJBQWlCLEVBQ25GLE1BQU0sSUFBSWx5QixXQUFXO0FBQzdCO0FBRXlGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJhc29icGFpLXdlYi8uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci12aWV3L2Rpc3QvaW5kZXguanM/NGUzMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBUZXh0U2VsZWN0aW9uLCBOb2RlU2VsZWN0aW9uLCBBbGxTZWxlY3Rpb24sIFNlbGVjdGlvbiB9IGZyb20gJ3Byb3NlbWlycm9yLXN0YXRlJztcbmltcG9ydCB7IERPTVNlcmlhbGl6ZXIsIEZyYWdtZW50LCBNYXJrLCBTbGljZSwgRE9NUGFyc2VyIH0gZnJvbSAncHJvc2VtaXJyb3ItbW9kZWwnO1xuaW1wb3J0IHsgZHJvcFBvaW50IH0gZnJvbSAncHJvc2VtaXJyb3ItdHJhbnNmb3JtJztcblxuY29uc3QgZG9tSW5kZXggPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIGZvciAodmFyIGluZGV4ID0gMDs7IGluZGV4KyspIHtcbiAgICAgICAgbm9kZSA9IG5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxufTtcbmNvbnN0IHBhcmVudE5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIGxldCBwYXJlbnQgPSBub2RlLmFzc2lnbmVkU2xvdCB8fCBub2RlLnBhcmVudE5vZGU7XG4gICAgcmV0dXJuIHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgPT0gMTEgPyBwYXJlbnQuaG9zdCA6IHBhcmVudDtcbn07XG5sZXQgcmV1c2VkUmFuZ2UgPSBudWxsO1xuLy8gTm90ZSB0aGF0IHRoaXMgd2lsbCBhbHdheXMgcmV0dXJuIHRoZSBzYW1lIHJhbmdlLCBiZWNhdXNlIERPTSByYW5nZVxuLy8gb2JqZWN0cyBhcmUgZXZlcnkgZXhwZW5zaXZlLCBhbmQga2VlcCBzbG93aW5nIGRvd24gc3Vic2VxdWVudCBET01cbi8vIHVwZGF0ZXMsIGZvciBzb21lIHJlYXNvbi5cbmNvbnN0IHRleHRSYW5nZSA9IGZ1bmN0aW9uIChub2RlLCBmcm9tLCB0bykge1xuICAgIGxldCByYW5nZSA9IHJldXNlZFJhbmdlIHx8IChyZXVzZWRSYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCkpO1xuICAgIHJhbmdlLnNldEVuZChub2RlLCB0byA9PSBudWxsID8gbm9kZS5ub2RlVmFsdWUubGVuZ3RoIDogdG8pO1xuICAgIHJhbmdlLnNldFN0YXJ0KG5vZGUsIGZyb20gfHwgMCk7XG4gICAgcmV0dXJuIHJhbmdlO1xufTtcbmNvbnN0IGNsZWFyUmV1c2VkUmFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV1c2VkUmFuZ2UgPSBudWxsO1xufTtcbi8vIFNjYW5zIGZvcndhcmQgYW5kIGJhY2t3YXJkIHRocm91Z2ggRE9NIHBvc2l0aW9ucyBlcXVpdmFsZW50IHRvIHRoZVxuLy8gZ2l2ZW4gb25lIHRvIHNlZSBpZiB0aGUgdHdvIGFyZSBpbiB0aGUgc2FtZSBwbGFjZSAoaS5lLiBhZnRlciBhXG4vLyB0ZXh0IG5vZGUgdnMgYXQgdGhlIGVuZCBvZiB0aGF0IHRleHQgbm9kZSlcbmNvbnN0IGlzRXF1aXZhbGVudFBvc2l0aW9uID0gZnVuY3Rpb24gKG5vZGUsIG9mZiwgdGFyZ2V0Tm9kZSwgdGFyZ2V0T2ZmKSB7XG4gICAgcmV0dXJuIHRhcmdldE5vZGUgJiYgKHNjYW5Gb3Iobm9kZSwgb2ZmLCB0YXJnZXROb2RlLCB0YXJnZXRPZmYsIC0xKSB8fFxuICAgICAgICBzY2FuRm9yKG5vZGUsIG9mZiwgdGFyZ2V0Tm9kZSwgdGFyZ2V0T2ZmLCAxKSk7XG59O1xuY29uc3QgYXRvbUVsZW1lbnRzID0gL14oaW1nfGJyfGlucHV0fHRleHRhcmVhfGhyKSQvaTtcbmZ1bmN0aW9uIHNjYW5Gb3Iobm9kZSwgb2ZmLCB0YXJnZXROb2RlLCB0YXJnZXRPZmYsIGRpcikge1xuICAgIHZhciBfYTtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmIChub2RlID09IHRhcmdldE5vZGUgJiYgb2ZmID09IHRhcmdldE9mZilcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAob2ZmID09IChkaXIgPCAwID8gMCA6IG5vZGVTaXplKG5vZGUpKSkge1xuICAgICAgICAgICAgbGV0IHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIGlmICghcGFyZW50IHx8IHBhcmVudC5ub2RlVHlwZSAhPSAxIHx8IGhhc0Jsb2NrRGVzYyhub2RlKSB8fCBhdG9tRWxlbWVudHMudGVzdChub2RlLm5vZGVOYW1lKSB8fFxuICAgICAgICAgICAgICAgIG5vZGUuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBvZmYgPSBkb21JbmRleChub2RlKSArIChkaXIgPCAwID8gMCA6IDEpO1xuICAgICAgICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IG5vZGUuY2hpbGROb2Rlc1tvZmYgKyAoZGlyIDwgMCA/IC0xIDogMCldO1xuICAgICAgICAgICAgaWYgKGNoaWxkLm5vZGVUeXBlID09IDEgJiYgY2hpbGQuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIikge1xuICAgICAgICAgICAgICAgIGlmICgoX2EgPSBjaGlsZC5wbVZpZXdEZXNjKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaWdub3JlRm9yU2VsZWN0aW9uKVxuICAgICAgICAgICAgICAgICAgICBvZmYgKz0gZGlyO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IGNoaWxkO1xuICAgICAgICAgICAgICAgIG9mZiA9IGRpciA8IDAgPyBub2RlU2l6ZShub2RlKSA6IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBub2RlU2l6ZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT0gMyA/IG5vZGUubm9kZVZhbHVlLmxlbmd0aCA6IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7XG59XG5mdW5jdGlvbiB0ZXh0Tm9kZUJlZm9yZSQxKG5vZGUsIG9mZnNldCkge1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMyAmJiBvZmZzZXQpXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSAmJiBvZmZzZXQgPiAwKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXTtcbiAgICAgICAgICAgIG9mZnNldCA9IG5vZGVTaXplKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUucGFyZW50Tm9kZSAmJiAhaGFzQmxvY2tEZXNjKG5vZGUpKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSBkb21JbmRleChub2RlKTtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHRleHROb2RlQWZ0ZXIkMShub2RlLCBvZmZzZXQpIHtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDMgJiYgb2Zmc2V0IDwgbm9kZS5ub2RlVmFsdWUubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDEgJiYgb2Zmc2V0IDwgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKG5vZGUuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XTtcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZS5wYXJlbnROb2RlICYmICFoYXNCbG9ja0Rlc2Mobm9kZSkpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IGRvbUluZGV4KG5vZGUpICsgMTtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGlzT25FZGdlKG5vZGUsIG9mZnNldCwgcGFyZW50KSB7XG4gICAgZm9yIChsZXQgYXRTdGFydCA9IG9mZnNldCA9PSAwLCBhdEVuZCA9IG9mZnNldCA9PSBub2RlU2l6ZShub2RlKTsgYXRTdGFydCB8fCBhdEVuZDspIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gcGFyZW50KVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGxldCBpbmRleCA9IGRvbUluZGV4KG5vZGUpO1xuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGF0U3RhcnQgPSBhdFN0YXJ0ICYmIGluZGV4ID09IDA7XG4gICAgICAgIGF0RW5kID0gYXRFbmQgJiYgaW5kZXggPT0gbm9kZVNpemUobm9kZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaGFzQmxvY2tEZXNjKGRvbSkge1xuICAgIGxldCBkZXNjO1xuICAgIGZvciAobGV0IGN1ciA9IGRvbTsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSlcbiAgICAgICAgaWYgKGRlc2MgPSBjdXIucG1WaWV3RGVzYylcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIHJldHVybiBkZXNjICYmIGRlc2Mubm9kZSAmJiBkZXNjLm5vZGUuaXNCbG9jayAmJiAoZGVzYy5kb20gPT0gZG9tIHx8IGRlc2MuY29udGVudERPTSA9PSBkb20pO1xufVxuLy8gV29yayBhcm91bmQgQ2hyb21lIGlzc3VlIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ0NzUyM1xuLy8gKGlzQ29sbGFwc2VkIGluYXBwcm9wcmlhdGVseSByZXR1cm5zIHRydWUgaW4gc2hhZG93IGRvbSlcbmNvbnN0IHNlbGVjdGlvbkNvbGxhcHNlZCA9IGZ1bmN0aW9uIChkb21TZWwpIHtcbiAgICByZXR1cm4gZG9tU2VsLmZvY3VzTm9kZSAmJiBpc0VxdWl2YWxlbnRQb3NpdGlvbihkb21TZWwuZm9jdXNOb2RlLCBkb21TZWwuZm9jdXNPZmZzZXQsIGRvbVNlbC5hbmNob3JOb2RlLCBkb21TZWwuYW5jaG9yT2Zmc2V0KTtcbn07XG5mdW5jdGlvbiBrZXlFdmVudChrZXlDb2RlLCBrZXkpIHtcbiAgICBsZXQgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkV2ZW50XCIpO1xuICAgIGV2ZW50LmluaXRFdmVudChcImtleWRvd25cIiwgdHJ1ZSwgdHJ1ZSk7XG4gICAgZXZlbnQua2V5Q29kZSA9IGtleUNvZGU7XG4gICAgZXZlbnQua2V5ID0gZXZlbnQuY29kZSA9IGtleTtcbiAgICByZXR1cm4gZXZlbnQ7XG59XG5mdW5jdGlvbiBkZWVwQWN0aXZlRWxlbWVudChkb2MpIHtcbiAgICBsZXQgZWx0ID0gZG9jLmFjdGl2ZUVsZW1lbnQ7XG4gICAgd2hpbGUgKGVsdCAmJiBlbHQuc2hhZG93Um9vdClcbiAgICAgICAgZWx0ID0gZWx0LnNoYWRvd1Jvb3QuYWN0aXZlRWxlbWVudDtcbiAgICByZXR1cm4gZWx0O1xufVxuZnVuY3Rpb24gY2FyZXRGcm9tUG9pbnQoZG9jLCB4LCB5KSB7XG4gICAgaWYgKGRvYy5jYXJldFBvc2l0aW9uRnJvbVBvaW50KSB7XG4gICAgICAgIHRyeSB7IC8vIEZpcmVmb3ggdGhyb3dzIGZvciB0aGlzIGNhbGwgaW4gaGFyZC10by1wcmVkaWN0IGNpcmN1bXN0YW5jZXMgKCM5OTQpXG4gICAgICAgICAgICBsZXQgcG9zID0gZG9jLmNhcmV0UG9zaXRpb25Gcm9tUG9pbnQoeCwgeSk7XG4gICAgICAgICAgICAvLyBDbGlwIHRoZSBvZmZzZXQsIGJlY2F1c2UgQ2hyb21lIHdpbGwgcmV0dXJuIGEgdGV4dCBvZmZzZXRcbiAgICAgICAgICAgIC8vIGludG8gPGlucHV0PiBub2Rlcywgd2hpY2ggY2FuJ3QgYmUgdHJlYXRlZCBhcyBhIHJlZ3VsYXIgRE9NXG4gICAgICAgICAgICAvLyBvZmZzZXRcbiAgICAgICAgICAgIGlmIChwb3MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbm9kZTogcG9zLm9mZnNldE5vZGUsIG9mZnNldDogTWF0aC5taW4obm9kZVNpemUocG9zLm9mZnNldE5vZGUpLCBwb3Mub2Zmc2V0KSB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfKSB7IH1cbiAgICB9XG4gICAgaWYgKGRvYy5jYXJldFJhbmdlRnJvbVBvaW50KSB7XG4gICAgICAgIGxldCByYW5nZSA9IGRvYy5jYXJldFJhbmdlRnJvbVBvaW50KHgsIHkpO1xuICAgICAgICBpZiAocmFuZ2UpXG4gICAgICAgICAgICByZXR1cm4geyBub2RlOiByYW5nZS5zdGFydENvbnRhaW5lciwgb2Zmc2V0OiBNYXRoLm1pbihub2RlU2l6ZShyYW5nZS5zdGFydENvbnRhaW5lciksIHJhbmdlLnN0YXJ0T2Zmc2V0KSB9O1xuICAgIH1cbn1cblxuY29uc3QgbmF2ID0gdHlwZW9mIG5hdmlnYXRvciAhPSBcInVuZGVmaW5lZFwiID8gbmF2aWdhdG9yIDogbnVsbDtcbmNvbnN0IGRvYyA9IHR5cGVvZiBkb2N1bWVudCAhPSBcInVuZGVmaW5lZFwiID8gZG9jdW1lbnQgOiBudWxsO1xuY29uc3QgYWdlbnQgPSAobmF2ICYmIG5hdi51c2VyQWdlbnQpIHx8IFwiXCI7XG5jb25zdCBpZV9lZGdlID0gL0VkZ2VcXC8oXFxkKykvLmV4ZWMoYWdlbnQpO1xuY29uc3QgaWVfdXB0bzEwID0gL01TSUUgXFxkLy5leGVjKGFnZW50KTtcbmNvbnN0IGllXzExdXAgPSAvVHJpZGVudFxcLyg/Ols3LTldfFxcZHsyLH0pXFwuLipydjooXFxkKykvLmV4ZWMoYWdlbnQpO1xuY29uc3QgaWUgPSAhIShpZV91cHRvMTAgfHwgaWVfMTF1cCB8fCBpZV9lZGdlKTtcbmNvbnN0IGllX3ZlcnNpb24gPSBpZV91cHRvMTAgPyBkb2N1bWVudC5kb2N1bWVudE1vZGUgOiBpZV8xMXVwID8gK2llXzExdXBbMV0gOiBpZV9lZGdlID8gK2llX2VkZ2VbMV0gOiAwO1xuY29uc3QgZ2Vja28gPSAhaWUgJiYgL2dlY2tvXFwvKFxcZCspL2kudGVzdChhZ2VudCk7XG5nZWNrbyAmJiArKC9GaXJlZm94XFwvKFxcZCspLy5leGVjKGFnZW50KSB8fCBbMCwgMF0pWzFdO1xuY29uc3QgX2Nocm9tZSA9ICFpZSAmJiAvQ2hyb21lXFwvKFxcZCspLy5leGVjKGFnZW50KTtcbmNvbnN0IGNocm9tZSA9ICEhX2Nocm9tZTtcbmNvbnN0IGNocm9tZV92ZXJzaW9uID0gX2Nocm9tZSA/ICtfY2hyb21lWzFdIDogMDtcbmNvbnN0IHNhZmFyaSA9ICFpZSAmJiAhIW5hdiAmJiAvQXBwbGUgQ29tcHV0ZXIvLnRlc3QobmF2LnZlbmRvcik7XG4vLyBJcyB0cnVlIGZvciBib3RoIGlPUyBhbmQgaVBhZE9TIGZvciBjb252ZW5pZW5jZVxuY29uc3QgaW9zID0gc2FmYXJpICYmICgvTW9iaWxlXFwvXFx3Ky8udGVzdChhZ2VudCkgfHwgISFuYXYgJiYgbmF2Lm1heFRvdWNoUG9pbnRzID4gMik7XG5jb25zdCBtYWMgPSBpb3MgfHwgKG5hdiA/IC9NYWMvLnRlc3QobmF2LnBsYXRmb3JtKSA6IGZhbHNlKTtcbmNvbnN0IHdpbmRvd3MgPSBuYXYgPyAvV2luLy50ZXN0KG5hdi5wbGF0Zm9ybSkgOiBmYWxzZTtcbmNvbnN0IGFuZHJvaWQgPSAvQW5kcm9pZCBcXGQvLnRlc3QoYWdlbnQpO1xuY29uc3Qgd2Via2l0ID0gISFkb2MgJiYgXCJ3ZWJraXRGb250U21vb3RoaW5nXCIgaW4gZG9jLmRvY3VtZW50RWxlbWVudC5zdHlsZTtcbmNvbnN0IHdlYmtpdF92ZXJzaW9uID0gd2Via2l0ID8gKygvXFxiQXBwbGVXZWJLaXRcXC8oXFxkKykvLmV4ZWMobmF2aWdhdG9yLnVzZXJBZ2VudCkgfHwgWzAsIDBdKVsxXSA6IDA7XG5cbmZ1bmN0aW9uIHdpbmRvd1JlY3QoZG9jKSB7XG4gICAgbGV0IHZwID0gZG9jLmRlZmF1bHRWaWV3ICYmIGRvYy5kZWZhdWx0Vmlldy52aXN1YWxWaWV3cG9ydDtcbiAgICBpZiAodnApXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWZ0OiAwLCByaWdodDogdnAud2lkdGgsXG4gICAgICAgICAgICB0b3A6IDAsIGJvdHRvbTogdnAuaGVpZ2h0XG4gICAgICAgIH07XG4gICAgcmV0dXJuIHsgbGVmdDogMCwgcmlnaHQ6IGRvYy5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgsXG4gICAgICAgIHRvcDogMCwgYm90dG9tOiBkb2MuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCB9O1xufVxuZnVuY3Rpb24gZ2V0U2lkZSh2YWx1ZSwgc2lkZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gXCJudW1iZXJcIiA/IHZhbHVlIDogdmFsdWVbc2lkZV07XG59XG5mdW5jdGlvbiBjbGllbnRSZWN0KG5vZGUpIHtcbiAgICBsZXQgcmVjdCA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgLy8gQWRqdXN0IGZvciBlbGVtZW50cyB3aXRoIHN0eWxlIFwidHJhbnNmb3JtOiBzY2FsZSgpXCJcbiAgICBsZXQgc2NhbGVYID0gKHJlY3Qud2lkdGggLyBub2RlLm9mZnNldFdpZHRoKSB8fCAxO1xuICAgIGxldCBzY2FsZVkgPSAocmVjdC5oZWlnaHQgLyBub2RlLm9mZnNldEhlaWdodCkgfHwgMTtcbiAgICAvLyBNYWtlIHN1cmUgc2Nyb2xsYmFyIHdpZHRoIGlzbid0IGluY2x1ZGVkIGluIHRoZSByZWN0YW5nbGVcbiAgICByZXR1cm4geyBsZWZ0OiByZWN0LmxlZnQsIHJpZ2h0OiByZWN0LmxlZnQgKyBub2RlLmNsaWVudFdpZHRoICogc2NhbGVYLFxuICAgICAgICB0b3A6IHJlY3QudG9wLCBib3R0b206IHJlY3QudG9wICsgbm9kZS5jbGllbnRIZWlnaHQgKiBzY2FsZVkgfTtcbn1cbmZ1bmN0aW9uIHNjcm9sbFJlY3RJbnRvVmlldyh2aWV3LCByZWN0LCBzdGFydERPTSkge1xuICAgIGxldCBzY3JvbGxUaHJlc2hvbGQgPSB2aWV3LnNvbWVQcm9wKFwic2Nyb2xsVGhyZXNob2xkXCIpIHx8IDAsIHNjcm9sbE1hcmdpbiA9IHZpZXcuc29tZVByb3AoXCJzY3JvbGxNYXJnaW5cIikgfHwgNTtcbiAgICBsZXQgZG9jID0gdmlldy5kb20ub3duZXJEb2N1bWVudDtcbiAgICBmb3IgKGxldCBwYXJlbnQgPSBzdGFydERPTSB8fCB2aWV3LmRvbTs7KSB7XG4gICAgICAgIGlmICghcGFyZW50KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmIChwYXJlbnQubm9kZVR5cGUgIT0gMSkge1xuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50Tm9kZShwYXJlbnQpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGVsdCA9IHBhcmVudDtcbiAgICAgICAgbGV0IGF0VG9wID0gZWx0ID09IGRvYy5ib2R5O1xuICAgICAgICBsZXQgYm91bmRpbmcgPSBhdFRvcCA/IHdpbmRvd1JlY3QoZG9jKSA6IGNsaWVudFJlY3QoZWx0KTtcbiAgICAgICAgbGV0IG1vdmVYID0gMCwgbW92ZVkgPSAwO1xuICAgICAgICBpZiAocmVjdC50b3AgPCBib3VuZGluZy50b3AgKyBnZXRTaWRlKHNjcm9sbFRocmVzaG9sZCwgXCJ0b3BcIikpXG4gICAgICAgICAgICBtb3ZlWSA9IC0oYm91bmRpbmcudG9wIC0gcmVjdC50b3AgKyBnZXRTaWRlKHNjcm9sbE1hcmdpbiwgXCJ0b3BcIikpO1xuICAgICAgICBlbHNlIGlmIChyZWN0LmJvdHRvbSA+IGJvdW5kaW5nLmJvdHRvbSAtIGdldFNpZGUoc2Nyb2xsVGhyZXNob2xkLCBcImJvdHRvbVwiKSlcbiAgICAgICAgICAgIG1vdmVZID0gcmVjdC5ib3R0b20gLSByZWN0LnRvcCA+IGJvdW5kaW5nLmJvdHRvbSAtIGJvdW5kaW5nLnRvcFxuICAgICAgICAgICAgICAgID8gcmVjdC50b3AgKyBnZXRTaWRlKHNjcm9sbE1hcmdpbiwgXCJ0b3BcIikgLSBib3VuZGluZy50b3BcbiAgICAgICAgICAgICAgICA6IHJlY3QuYm90dG9tIC0gYm91bmRpbmcuYm90dG9tICsgZ2V0U2lkZShzY3JvbGxNYXJnaW4sIFwiYm90dG9tXCIpO1xuICAgICAgICBpZiAocmVjdC5sZWZ0IDwgYm91bmRpbmcubGVmdCArIGdldFNpZGUoc2Nyb2xsVGhyZXNob2xkLCBcImxlZnRcIikpXG4gICAgICAgICAgICBtb3ZlWCA9IC0oYm91bmRpbmcubGVmdCAtIHJlY3QubGVmdCArIGdldFNpZGUoc2Nyb2xsTWFyZ2luLCBcImxlZnRcIikpO1xuICAgICAgICBlbHNlIGlmIChyZWN0LnJpZ2h0ID4gYm91bmRpbmcucmlnaHQgLSBnZXRTaWRlKHNjcm9sbFRocmVzaG9sZCwgXCJyaWdodFwiKSlcbiAgICAgICAgICAgIG1vdmVYID0gcmVjdC5yaWdodCAtIGJvdW5kaW5nLnJpZ2h0ICsgZ2V0U2lkZShzY3JvbGxNYXJnaW4sIFwicmlnaHRcIik7XG4gICAgICAgIGlmIChtb3ZlWCB8fCBtb3ZlWSkge1xuICAgICAgICAgICAgaWYgKGF0VG9wKSB7XG4gICAgICAgICAgICAgICAgZG9jLmRlZmF1bHRWaWV3LnNjcm9sbEJ5KG1vdmVYLCBtb3ZlWSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnRYID0gZWx0LnNjcm9sbExlZnQsIHN0YXJ0WSA9IGVsdC5zY3JvbGxUb3A7XG4gICAgICAgICAgICAgICAgaWYgKG1vdmVZKVxuICAgICAgICAgICAgICAgICAgICBlbHQuc2Nyb2xsVG9wICs9IG1vdmVZO1xuICAgICAgICAgICAgICAgIGlmIChtb3ZlWClcbiAgICAgICAgICAgICAgICAgICAgZWx0LnNjcm9sbExlZnQgKz0gbW92ZVg7XG4gICAgICAgICAgICAgICAgbGV0IGRYID0gZWx0LnNjcm9sbExlZnQgLSBzdGFydFgsIGRZID0gZWx0LnNjcm9sbFRvcCAtIHN0YXJ0WTtcbiAgICAgICAgICAgICAgICByZWN0ID0geyBsZWZ0OiByZWN0LmxlZnQgLSBkWCwgdG9wOiByZWN0LnRvcCAtIGRZLCByaWdodDogcmVjdC5yaWdodCAtIGRYLCBib3R0b206IHJlY3QuYm90dG9tIC0gZFkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgcG9zID0gYXRUb3AgPyBcImZpeGVkXCIgOiBnZXRDb21wdXRlZFN0eWxlKHBhcmVudCkucG9zaXRpb247XG4gICAgICAgIGlmICgvXihmaXhlZHxzdGlja3kpJC8udGVzdChwb3MpKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIHBhcmVudCA9IHBvcyA9PSBcImFic29sdXRlXCIgPyBwYXJlbnQub2Zmc2V0UGFyZW50IDogcGFyZW50Tm9kZShwYXJlbnQpO1xuICAgIH1cbn1cbi8vIFN0b3JlIHRoZSBzY3JvbGwgcG9zaXRpb24gb2YgdGhlIGVkaXRvcidzIHBhcmVudCBub2RlcywgYWxvbmcgd2l0aFxuLy8gdGhlIHRvcCBwb3NpdGlvbiBvZiBhbiBlbGVtZW50IG5lYXIgdGhlIHRvcCBvZiB0aGUgZWRpdG9yLCB3aGljaFxuLy8gd2lsbCBiZSB1c2VkIHRvIG1ha2Ugc3VyZSB0aGUgdmlzaWJsZSB2aWV3cG9ydCByZW1haW5zIHN0YWJsZSBldmVuXG4vLyB3aGVuIHRoZSBzaXplIG9mIHRoZSBjb250ZW50IGFib3ZlIGNoYW5nZXMuXG5mdW5jdGlvbiBzdG9yZVNjcm9sbFBvcyh2aWV3KSB7XG4gICAgbGV0IHJlY3QgPSB2aWV3LmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgc3RhcnRZID0gTWF0aC5tYXgoMCwgcmVjdC50b3ApO1xuICAgIGxldCByZWZET00sIHJlZlRvcDtcbiAgICBmb3IgKGxldCB4ID0gKHJlY3QubGVmdCArIHJlY3QucmlnaHQpIC8gMiwgeSA9IHN0YXJ0WSArIDE7IHkgPCBNYXRoLm1pbihpbm5lckhlaWdodCwgcmVjdC5ib3R0b20pOyB5ICs9IDUpIHtcbiAgICAgICAgbGV0IGRvbSA9IHZpZXcucm9vdC5lbGVtZW50RnJvbVBvaW50KHgsIHkpO1xuICAgICAgICBpZiAoIWRvbSB8fCBkb20gPT0gdmlldy5kb20gfHwgIXZpZXcuZG9tLmNvbnRhaW5zKGRvbSkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgbGV0IGxvY2FsUmVjdCA9IGRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKGxvY2FsUmVjdC50b3AgPj0gc3RhcnRZIC0gMjApIHtcbiAgICAgICAgICAgIHJlZkRPTSA9IGRvbTtcbiAgICAgICAgICAgIHJlZlRvcCA9IGxvY2FsUmVjdC50b3A7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyByZWZET006IHJlZkRPTSwgcmVmVG9wOiByZWZUb3AsIHN0YWNrOiBzY3JvbGxTdGFjayh2aWV3LmRvbSkgfTtcbn1cbmZ1bmN0aW9uIHNjcm9sbFN0YWNrKGRvbSkge1xuICAgIGxldCBzdGFjayA9IFtdLCBkb2MgPSBkb20ub3duZXJEb2N1bWVudDtcbiAgICBmb3IgKGxldCBjdXIgPSBkb207IGN1cjsgY3VyID0gcGFyZW50Tm9kZShjdXIpKSB7XG4gICAgICAgIHN0YWNrLnB1c2goeyBkb206IGN1ciwgdG9wOiBjdXIuc2Nyb2xsVG9wLCBsZWZ0OiBjdXIuc2Nyb2xsTGVmdCB9KTtcbiAgICAgICAgaWYgKGRvbSA9PSBkb2MpXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHN0YWNrO1xufVxuLy8gUmVzZXQgdGhlIHNjcm9sbCBwb3NpdGlvbiBvZiB0aGUgZWRpdG9yJ3MgcGFyZW50IG5vZGVzIHRvIHRoYXQgd2hhdFxuLy8gaXQgd2FzIGJlZm9yZSwgd2hlbiBzdG9yZVNjcm9sbFBvcyB3YXMgY2FsbGVkLlxuZnVuY3Rpb24gcmVzZXRTY3JvbGxQb3MoeyByZWZET00sIHJlZlRvcCwgc3RhY2sgfSkge1xuICAgIGxldCBuZXdSZWZUb3AgPSByZWZET00gPyByZWZET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wIDogMDtcbiAgICByZXN0b3JlU2Nyb2xsU3RhY2soc3RhY2ssIG5ld1JlZlRvcCA9PSAwID8gMCA6IG5ld1JlZlRvcCAtIHJlZlRvcCk7XG59XG5mdW5jdGlvbiByZXN0b3JlU2Nyb2xsU3RhY2soc3RhY2ssIGRUb3ApIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCB7IGRvbSwgdG9wLCBsZWZ0IH0gPSBzdGFja1tpXTtcbiAgICAgICAgaWYgKGRvbS5zY3JvbGxUb3AgIT0gdG9wICsgZFRvcClcbiAgICAgICAgICAgIGRvbS5zY3JvbGxUb3AgPSB0b3AgKyBkVG9wO1xuICAgICAgICBpZiAoZG9tLnNjcm9sbExlZnQgIT0gbGVmdClcbiAgICAgICAgICAgIGRvbS5zY3JvbGxMZWZ0ID0gbGVmdDtcbiAgICB9XG59XG5sZXQgcHJldmVudFNjcm9sbFN1cHBvcnRlZCA9IG51bGw7XG4vLyBGZWF0dXJlLWRldGVjdHMgc3VwcG9ydCBmb3IgLmZvY3VzKHtwcmV2ZW50U2Nyb2xsOiB0cnVlfSksIGFuZCB1c2VzXG4vLyBhIGZhbGxiYWNrIGtsdWRnZSB3aGVuIG5vdCBzdXBwb3J0ZWQuXG5mdW5jdGlvbiBmb2N1c1ByZXZlbnRTY3JvbGwoZG9tKSB7XG4gICAgaWYgKGRvbS5zZXRBY3RpdmUpXG4gICAgICAgIHJldHVybiBkb20uc2V0QWN0aXZlKCk7IC8vIGluIElFXG4gICAgaWYgKHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQpXG4gICAgICAgIHJldHVybiBkb20uZm9jdXMocHJldmVudFNjcm9sbFN1cHBvcnRlZCk7XG4gICAgbGV0IHN0b3JlZCA9IHNjcm9sbFN0YWNrKGRvbSk7XG4gICAgZG9tLmZvY3VzKHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQgPT0gbnVsbCA/IHtcbiAgICAgICAgZ2V0IHByZXZlbnRTY3JvbGwoKSB7XG4gICAgICAgICAgICBwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkID0geyBwcmV2ZW50U2Nyb2xsOiB0cnVlIH07XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0gOiB1bmRlZmluZWQpO1xuICAgIGlmICghcHJldmVudFNjcm9sbFN1cHBvcnRlZCkge1xuICAgICAgICBwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgIHJlc3RvcmVTY3JvbGxTdGFjayhzdG9yZWQsIDApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbmRPZmZzZXRJbk5vZGUobm9kZSwgY29vcmRzKSB7XG4gICAgbGV0IGNsb3Nlc3QsIGR4Q2xvc2VzdCA9IDJlOCwgY29vcmRzQ2xvc2VzdCwgb2Zmc2V0ID0gMDtcbiAgICBsZXQgcm93Qm90ID0gY29vcmRzLnRvcCwgcm93VG9wID0gY29vcmRzLnRvcDtcbiAgICBsZXQgZmlyc3RCZWxvdywgY29vcmRzQmVsb3c7XG4gICAgZm9yIChsZXQgY2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQsIGNoaWxkSW5kZXggPSAwOyBjaGlsZDsgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZywgY2hpbGRJbmRleCsrKSB7XG4gICAgICAgIGxldCByZWN0cztcbiAgICAgICAgaWYgKGNoaWxkLm5vZGVUeXBlID09IDEpXG4gICAgICAgICAgICByZWN0cyA9IGNoaWxkLmdldENsaWVudFJlY3RzKCk7XG4gICAgICAgIGVsc2UgaWYgKGNoaWxkLm5vZGVUeXBlID09IDMpXG4gICAgICAgICAgICByZWN0cyA9IHRleHRSYW5nZShjaGlsZCkuZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCByZWN0ID0gcmVjdHNbaV07XG4gICAgICAgICAgICBpZiAocmVjdC50b3AgPD0gcm93Qm90ICYmIHJlY3QuYm90dG9tID49IHJvd1RvcCkge1xuICAgICAgICAgICAgICAgIHJvd0JvdCA9IE1hdGgubWF4KHJlY3QuYm90dG9tLCByb3dCb3QpO1xuICAgICAgICAgICAgICAgIHJvd1RvcCA9IE1hdGgubWluKHJlY3QudG9wLCByb3dUb3ApO1xuICAgICAgICAgICAgICAgIGxldCBkeCA9IHJlY3QubGVmdCA+IGNvb3Jkcy5sZWZ0ID8gcmVjdC5sZWZ0IC0gY29vcmRzLmxlZnRcbiAgICAgICAgICAgICAgICAgICAgOiByZWN0LnJpZ2h0IDwgY29vcmRzLmxlZnQgPyBjb29yZHMubGVmdCAtIHJlY3QucmlnaHQgOiAwO1xuICAgICAgICAgICAgICAgIGlmIChkeCA8IGR4Q2xvc2VzdCkge1xuICAgICAgICAgICAgICAgICAgICBjbG9zZXN0ID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIGR4Q2xvc2VzdCA9IGR4O1xuICAgICAgICAgICAgICAgICAgICBjb29yZHNDbG9zZXN0ID0gZHggJiYgY2xvc2VzdC5ub2RlVHlwZSA9PSAzID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogcmVjdC5yaWdodCA8IGNvb3Jkcy5sZWZ0ID8gcmVjdC5yaWdodCA6IHJlY3QubGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogY29vcmRzLnRvcFxuICAgICAgICAgICAgICAgICAgICB9IDogY29vcmRzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT0gMSAmJiBkeClcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IGNoaWxkSW5kZXggKyAoY29vcmRzLmxlZnQgPj0gKHJlY3QubGVmdCArIHJlY3QucmlnaHQpIC8gMiA/IDEgOiAwKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVjdC50b3AgPiBjb29yZHMudG9wICYmICFmaXJzdEJlbG93ICYmIHJlY3QubGVmdCA8PSBjb29yZHMubGVmdCAmJiByZWN0LnJpZ2h0ID49IGNvb3Jkcy5sZWZ0KSB7XG4gICAgICAgICAgICAgICAgZmlyc3RCZWxvdyA9IGNoaWxkO1xuICAgICAgICAgICAgICAgIGNvb3Jkc0JlbG93ID0geyBsZWZ0OiBNYXRoLm1heChyZWN0LmxlZnQsIE1hdGgubWluKHJlY3QucmlnaHQsIGNvb3Jkcy5sZWZ0KSksIHRvcDogcmVjdC50b3AgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY2xvc2VzdCAmJiAoY29vcmRzLmxlZnQgPj0gcmVjdC5yaWdodCAmJiBjb29yZHMudG9wID49IHJlY3QudG9wIHx8XG4gICAgICAgICAgICAgICAgY29vcmRzLmxlZnQgPj0gcmVjdC5sZWZ0ICYmIGNvb3Jkcy50b3AgPj0gcmVjdC5ib3R0b20pKVxuICAgICAgICAgICAgICAgIG9mZnNldCA9IGNoaWxkSW5kZXggKyAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghY2xvc2VzdCAmJiBmaXJzdEJlbG93KSB7XG4gICAgICAgIGNsb3Nlc3QgPSBmaXJzdEJlbG93O1xuICAgICAgICBjb29yZHNDbG9zZXN0ID0gY29vcmRzQmVsb3c7XG4gICAgICAgIGR4Q2xvc2VzdCA9IDA7XG4gICAgfVxuICAgIGlmIChjbG9zZXN0ICYmIGNsb3Nlc3Qubm9kZVR5cGUgPT0gMylcbiAgICAgICAgcmV0dXJuIGZpbmRPZmZzZXRJblRleHQoY2xvc2VzdCwgY29vcmRzQ2xvc2VzdCk7XG4gICAgaWYgKCFjbG9zZXN0IHx8IChkeENsb3Nlc3QgJiYgY2xvc2VzdC5ub2RlVHlwZSA9PSAxKSlcbiAgICAgICAgcmV0dXJuIHsgbm9kZSwgb2Zmc2V0IH07XG4gICAgcmV0dXJuIGZpbmRPZmZzZXRJbk5vZGUoY2xvc2VzdCwgY29vcmRzQ2xvc2VzdCk7XG59XG5mdW5jdGlvbiBmaW5kT2Zmc2V0SW5UZXh0KG5vZGUsIGNvb3Jkcykge1xuICAgIGxldCBsZW4gPSBub2RlLm5vZGVWYWx1ZS5sZW5ndGg7XG4gICAgbGV0IHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKSwgcmVzdWx0O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgcmFuZ2Uuc2V0RW5kKG5vZGUsIGkgKyAxKTtcbiAgICAgICAgcmFuZ2Uuc2V0U3RhcnQobm9kZSwgaSk7XG4gICAgICAgIGxldCByZWN0ID0gc2luZ2xlUmVjdChyYW5nZSwgMSk7XG4gICAgICAgIGlmIChyZWN0LnRvcCA9PSByZWN0LmJvdHRvbSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAoaW5SZWN0KGNvb3JkcywgcmVjdCkpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHsgbm9kZSwgb2Zmc2V0OiBpICsgKGNvb3Jkcy5sZWZ0ID49IChyZWN0LmxlZnQgKyByZWN0LnJpZ2h0KSAvIDIgPyAxIDogMCkgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJhbmdlLmRldGFjaCgpO1xuICAgIHJldHVybiByZXN1bHQgfHwgeyBub2RlLCBvZmZzZXQ6IDAgfTtcbn1cbmZ1bmN0aW9uIGluUmVjdChjb29yZHMsIHJlY3QpIHtcbiAgICByZXR1cm4gY29vcmRzLmxlZnQgPj0gcmVjdC5sZWZ0IC0gMSAmJiBjb29yZHMubGVmdCA8PSByZWN0LnJpZ2h0ICsgMSAmJlxuICAgICAgICBjb29yZHMudG9wID49IHJlY3QudG9wIC0gMSAmJiBjb29yZHMudG9wIDw9IHJlY3QuYm90dG9tICsgMTtcbn1cbmZ1bmN0aW9uIHRhcmdldEtsdWRnZShkb20sIGNvb3Jkcykge1xuICAgIGxldCBwYXJlbnQgPSBkb20ucGFyZW50Tm9kZTtcbiAgICBpZiAocGFyZW50ICYmIC9ebGkkL2kudGVzdChwYXJlbnQubm9kZU5hbWUpICYmIGNvb3Jkcy5sZWZ0IDwgZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQpXG4gICAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgcmV0dXJuIGRvbTtcbn1cbmZ1bmN0aW9uIHBvc0Zyb21FbGVtZW50KHZpZXcsIGVsdCwgY29vcmRzKSB7XG4gICAgbGV0IHsgbm9kZSwgb2Zmc2V0IH0gPSBmaW5kT2Zmc2V0SW5Ob2RlKGVsdCwgY29vcmRzKSwgYmlhcyA9IC0xO1xuICAgIGlmIChub2RlLm5vZGVUeXBlID09IDEgJiYgIW5vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgICBsZXQgcmVjdCA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGJpYXMgPSByZWN0LmxlZnQgIT0gcmVjdC5yaWdodCAmJiBjb29yZHMubGVmdCA+IChyZWN0LmxlZnQgKyByZWN0LnJpZ2h0KSAvIDIgPyAxIDogLTE7XG4gICAgfVxuICAgIHJldHVybiB2aWV3LmRvY1ZpZXcucG9zRnJvbURPTShub2RlLCBvZmZzZXQsIGJpYXMpO1xufVxuZnVuY3Rpb24gcG9zRnJvbUNhcmV0KHZpZXcsIG5vZGUsIG9mZnNldCwgY29vcmRzKSB7XG4gICAgLy8gQnJvd3NlciAoaW4gY2FyZXRQb3NpdGlvbi9SYW5nZUZyb21Qb2ludCkgd2lsbCBhZ3Jlc3NpdmVseVxuICAgIC8vIG5vcm1hbGl6ZSB0b3dhcmRzIG5lYXJieSBpbmxpbmUgbm9kZXMuIFNpbmNlIHdlIGFyZSBpbnRlcmVzdGVkIGluXG4gICAgLy8gcG9zaXRpb25zIGJldHdlZW4gYmxvY2sgbm9kZXMgdG9vLCB3ZSBmaXJzdCB3YWxrIHVwIHRoZSBoaWVyYXJjaHlcbiAgICAvLyBvZiBub2RlcyB0byBzZWUgaWYgdGhlcmUgYXJlIGJsb2NrIG5vZGVzIHRoYXQgdGhlIGNvb3JkaW5hdGVzXG4gICAgLy8gZmFsbCBvdXRzaWRlIG9mLiBJZiBzbywgd2UgdGFrZSB0aGUgcG9zaXRpb24gYmVmb3JlL2FmdGVyIHRoYXRcbiAgICAvLyBibG9jay4gSWYgbm90LCB3ZSBjYWxsIGBwb3NGcm9tRE9NYCBvbiB0aGUgcmF3IG5vZGUvb2Zmc2V0LlxuICAgIGxldCBvdXRzaWRlQmxvY2sgPSAtMTtcbiAgICBmb3IgKGxldCBjdXIgPSBub2RlLCBzYXdCbG9jayA9IGZhbHNlOzspIHtcbiAgICAgICAgaWYgKGN1ciA9PSB2aWV3LmRvbSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBsZXQgZGVzYyA9IHZpZXcuZG9jVmlldy5uZWFyZXN0RGVzYyhjdXIsIHRydWUpLCByZWN0O1xuICAgICAgICBpZiAoIWRlc2MpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKGRlc2MuZG9tLm5vZGVUeXBlID09IDEgJiYgKGRlc2Mubm9kZS5pc0Jsb2NrICYmIGRlc2MucGFyZW50IHx8ICFkZXNjLmNvbnRlbnRET00pICYmXG4gICAgICAgICAgICAvLyBJZ25vcmUgZWxlbWVudHMgd2l0aCB6ZXJvLXNpemUgYm91bmRpbmcgcmVjdGFuZ2xlc1xuICAgICAgICAgICAgKChyZWN0ID0gZGVzYy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpLndpZHRoIHx8IHJlY3QuaGVpZ2h0KSkge1xuICAgICAgICAgICAgaWYgKGRlc2Mubm9kZS5pc0Jsb2NrICYmIGRlc2MucGFyZW50ICYmICEvXlQoUnxCT0RZfEhFQUR8Rk9PVCkkLy50ZXN0KGRlc2MuZG9tLm5vZGVOYW1lKSkge1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgYXBwbHkgdGhlIGhvcml6b250YWwgdGVzdCB0byB0aGUgaW5uZXJtb3N0IGJsb2NrLiBWZXJ0aWNhbCBmb3IgYW55IHBhcmVudC5cbiAgICAgICAgICAgICAgICBpZiAoIXNhd0Jsb2NrICYmIHJlY3QubGVmdCA+IGNvb3Jkcy5sZWZ0IHx8IHJlY3QudG9wID4gY29vcmRzLnRvcClcbiAgICAgICAgICAgICAgICAgICAgb3V0c2lkZUJsb2NrID0gZGVzYy5wb3NCZWZvcmU7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIXNhd0Jsb2NrICYmIHJlY3QucmlnaHQgPCBjb29yZHMubGVmdCB8fCByZWN0LmJvdHRvbSA8IGNvb3Jkcy50b3ApXG4gICAgICAgICAgICAgICAgICAgIG91dHNpZGVCbG9jayA9IGRlc2MucG9zQWZ0ZXI7XG4gICAgICAgICAgICAgICAgc2F3QmxvY2sgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkZXNjLmNvbnRlbnRET00gJiYgb3V0c2lkZUJsb2NrIDwgMCAmJiAhZGVzYy5ub2RlLmlzVGV4dCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGFyZSBpbnNpZGUgYSBsZWFmLCByZXR1cm4gdGhlIHNpZGUgb2YgdGhlIGxlYWYgY2xvc2VyIHRvIHRoZSBjb29yZHNcbiAgICAgICAgICAgICAgICBsZXQgYmVmb3JlID0gZGVzYy5ub2RlLmlzQmxvY2sgPyBjb29yZHMudG9wIDwgKHJlY3QudG9wICsgcmVjdC5ib3R0b20pIC8gMlxuICAgICAgICAgICAgICAgICAgICA6IGNvb3Jkcy5sZWZ0IDwgKHJlY3QubGVmdCArIHJlY3QucmlnaHQpIC8gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmVmb3JlID8gZGVzYy5wb3NCZWZvcmUgOiBkZXNjLnBvc0FmdGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN1ciA9IGRlc2MuZG9tLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHJldHVybiBvdXRzaWRlQmxvY2sgPiAtMSA/IG91dHNpZGVCbG9jayA6IHZpZXcuZG9jVmlldy5wb3NGcm9tRE9NKG5vZGUsIG9mZnNldCwgLTEpO1xufVxuZnVuY3Rpb24gZWxlbWVudEZyb21Qb2ludChlbGVtZW50LCBjb29yZHMsIGJveCkge1xuICAgIGxldCBsZW4gPSBlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgIGlmIChsZW4gJiYgYm94LnRvcCA8IGJveC5ib3R0b20pIHtcbiAgICAgICAgZm9yIChsZXQgc3RhcnRJID0gTWF0aC5tYXgoMCwgTWF0aC5taW4obGVuIC0gMSwgTWF0aC5mbG9vcihsZW4gKiAoY29vcmRzLnRvcCAtIGJveC50b3ApIC8gKGJveC5ib3R0b20gLSBib3gudG9wKSkgLSAyKSksIGkgPSBzdGFydEk7Oykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gZWxlbWVudC5jaGlsZE5vZGVzW2ldO1xuICAgICAgICAgICAgaWYgKGNoaWxkLm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVjdHMgPSBjaGlsZC5nZXRDbGllbnRSZWN0cygpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcmVjdHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlY3QgPSByZWN0c1tqXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluUmVjdChjb29yZHMsIHJlY3QpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRGcm9tUG9pbnQoY2hpbGQsIGNvb3JkcywgcmVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChpID0gKGkgKyAxKSAlIGxlbikgPT0gc3RhcnRJKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50O1xufVxuLy8gR2l2ZW4gYW4geCx5IHBvc2l0aW9uIG9uIHRoZSBlZGl0b3IsIGdldCB0aGUgcG9zaXRpb24gaW4gdGhlIGRvY3VtZW50LlxuZnVuY3Rpb24gcG9zQXRDb29yZHModmlldywgY29vcmRzKSB7XG4gICAgbGV0IGRvYyA9IHZpZXcuZG9tLm93bmVyRG9jdW1lbnQsIG5vZGUsIG9mZnNldCA9IDA7XG4gICAgbGV0IGNhcmV0ID0gY2FyZXRGcm9tUG9pbnQoZG9jLCBjb29yZHMubGVmdCwgY29vcmRzLnRvcCk7XG4gICAgaWYgKGNhcmV0KVxuICAgICAgICAoeyBub2RlLCBvZmZzZXQgfSA9IGNhcmV0KTtcbiAgICBsZXQgZWx0ID0gKHZpZXcucm9vdC5lbGVtZW50RnJvbVBvaW50ID8gdmlldy5yb290IDogZG9jKVxuICAgICAgICAuZWxlbWVudEZyb21Qb2ludChjb29yZHMubGVmdCwgY29vcmRzLnRvcCk7XG4gICAgbGV0IHBvcztcbiAgICBpZiAoIWVsdCB8fCAhdmlldy5kb20uY29udGFpbnMoZWx0Lm5vZGVUeXBlICE9IDEgPyBlbHQucGFyZW50Tm9kZSA6IGVsdCkpIHtcbiAgICAgICAgbGV0IGJveCA9IHZpZXcuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAoIWluUmVjdChjb29yZHMsIGJveCkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgZWx0ID0gZWxlbWVudEZyb21Qb2ludCh2aWV3LmRvbSwgY29vcmRzLCBib3gpO1xuICAgICAgICBpZiAoIWVsdClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBTYWZhcmkncyBjYXJldFJhbmdlRnJvbVBvaW50IHJldHVybnMgbm9uc2Vuc2Ugd2hlbiBvbiBhIGRyYWdnYWJsZSBlbGVtZW50XG4gICAgaWYgKHNhZmFyaSkge1xuICAgICAgICBmb3IgKGxldCBwID0gZWx0OyBub2RlICYmIHA7IHAgPSBwYXJlbnROb2RlKHApKVxuICAgICAgICAgICAgaWYgKHAuZHJhZ2dhYmxlKVxuICAgICAgICAgICAgICAgIG5vZGUgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGVsdCA9IHRhcmdldEtsdWRnZShlbHQsIGNvb3Jkcyk7XG4gICAgaWYgKG5vZGUpIHtcbiAgICAgICAgaWYgKGdlY2tvICYmIG5vZGUubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgLy8gRmlyZWZveCB3aWxsIHNvbWV0aW1lcyByZXR1cm4gb2Zmc2V0cyBpbnRvIDxpbnB1dD4gbm9kZXMsIHdoaWNoXG4gICAgICAgICAgICAvLyBoYXZlIG5vIGFjdHVhbCBjaGlsZHJlbiwgZnJvbSBjYXJldFBvc2l0aW9uRnJvbVBvaW50ICgjOTUzKVxuICAgICAgICAgICAgb2Zmc2V0ID0gTWF0aC5taW4ob2Zmc2V0LCBub2RlLmNoaWxkTm9kZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIC8vIEl0J2xsIGFsc28gbW92ZSB0aGUgcmV0dXJuZWQgcG9zaXRpb24gYmVmb3JlIGltYWdlIG5vZGVzLFxuICAgICAgICAgICAgLy8gZXZlbiBpZiB0aG9zZSBhcmUgYmVoaW5kIGl0LlxuICAgICAgICAgICAgaWYgKG9mZnNldCA8IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdLCBib3g7XG4gICAgICAgICAgICAgICAgaWYgKG5leHQubm9kZU5hbWUgPT0gXCJJTUdcIiAmJiAoYm94ID0gbmV4dC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSkucmlnaHQgPD0gY29vcmRzLmxlZnQgJiZcbiAgICAgICAgICAgICAgICAgICAgYm94LmJvdHRvbSA+IGNvb3Jkcy50b3ApXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBwcmV2O1xuICAgICAgICAvLyBXaGVuIGNsaWNraW5nIGFib3ZlIHRoZSByaWdodCBzaWRlIG9mIGFuIHVuZWRpdGFibGUgbm9kZSwgQ2hyb21lIHdpbGwgcmVwb3J0IGEgY3Vyc29yIHBvc2l0aW9uIGFmdGVyIHRoYXQgbm9kZS5cbiAgICAgICAgaWYgKHdlYmtpdCAmJiBvZmZzZXQgJiYgbm9kZS5ub2RlVHlwZSA9PSAxICYmIChwcmV2ID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdKS5ub2RlVHlwZSA9PSAxICYmXG4gICAgICAgICAgICBwcmV2LmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIgJiYgcHJldi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgPj0gY29vcmRzLnRvcClcbiAgICAgICAgICAgIG9mZnNldC0tO1xuICAgICAgICAvLyBTdXNwaWNpb3VzbHkgc3BlY2lmaWMga2x1ZGdlIHRvIHdvcmsgYXJvdW5kIGNhcmV0KkZyb21Qb2ludFxuICAgICAgICAvLyBuZXZlciByZXR1cm5pbmcgYSBwb3NpdGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBkb2N1bWVudFxuICAgICAgICBpZiAobm9kZSA9PSB2aWV3LmRvbSAmJiBvZmZzZXQgPT0gbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCAtIDEgJiYgbm9kZS5sYXN0Q2hpbGQubm9kZVR5cGUgPT0gMSAmJlxuICAgICAgICAgICAgY29vcmRzLnRvcCA+IG5vZGUubGFzdENoaWxkLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmJvdHRvbSlcbiAgICAgICAgICAgIHBvcyA9IHZpZXcuc3RhdGUuZG9jLmNvbnRlbnQuc2l6ZTtcbiAgICAgICAgLy8gSWdub3JlIHBvc2l0aW9ucyBkaXJlY3RseSBhZnRlciBhIEJSLCBzaW5jZSBjYXJldCpGcm9tUG9pbnRcbiAgICAgICAgLy8gJ3JvdW5kIHVwJyBwb3NpdGlvbnMgdGhhdCB3b3VsZCBiZSBtb3JlIGFjY3VyYXRlbHkgcGxhY2VkXG4gICAgICAgIC8vIGJlZm9yZSB0aGUgQlIgbm9kZS5cbiAgICAgICAgZWxzZSBpZiAob2Zmc2V0ID09IDAgfHwgbm9kZS5ub2RlVHlwZSAhPSAxIHx8IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXS5ub2RlTmFtZSAhPSBcIkJSXCIpXG4gICAgICAgICAgICBwb3MgPSBwb3NGcm9tQ2FyZXQodmlldywgbm9kZSwgb2Zmc2V0LCBjb29yZHMpO1xuICAgIH1cbiAgICBpZiAocG9zID09IG51bGwpXG4gICAgICAgIHBvcyA9IHBvc0Zyb21FbGVtZW50KHZpZXcsIGVsdCwgY29vcmRzKTtcbiAgICBsZXQgZGVzYyA9IHZpZXcuZG9jVmlldy5uZWFyZXN0RGVzYyhlbHQsIHRydWUpO1xuICAgIHJldHVybiB7IHBvcywgaW5zaWRlOiBkZXNjID8gZGVzYy5wb3NBdFN0YXJ0IC0gZGVzYy5ib3JkZXIgOiAtMSB9O1xufVxuZnVuY3Rpb24gbm9uWmVybyhyZWN0KSB7XG4gICAgcmV0dXJuIHJlY3QudG9wIDwgcmVjdC5ib3R0b20gfHwgcmVjdC5sZWZ0IDwgcmVjdC5yaWdodDtcbn1cbmZ1bmN0aW9uIHNpbmdsZVJlY3QodGFyZ2V0LCBiaWFzKSB7XG4gICAgbGV0IHJlY3RzID0gdGFyZ2V0LmdldENsaWVudFJlY3RzKCk7XG4gICAgaWYgKHJlY3RzLmxlbmd0aCkge1xuICAgICAgICBsZXQgZmlyc3QgPSByZWN0c1tiaWFzIDwgMCA/IDAgOiByZWN0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKG5vblplcm8oZmlyc3QpKVxuICAgICAgICAgICAgcmV0dXJuIGZpcnN0O1xuICAgIH1cbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmZpbmQuY2FsbChyZWN0cywgbm9uWmVybykgfHwgdGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xufVxuY29uc3QgQklESSA9IC9bXFx1MDU5MC1cXHUwNWY0XFx1MDYwMC1cXHUwNmZmXFx1MDcwMC1cXHUwOGFjXS87XG4vLyBHaXZlbiBhIHBvc2l0aW9uIGluIHRoZSBkb2N1bWVudCBtb2RlbCwgZ2V0IGEgYm91bmRpbmcgYm94IG9mIHRoZVxuLy8gY2hhcmFjdGVyIGF0IHRoYXQgcG9zaXRpb24sIHJlbGF0aXZlIHRvIHRoZSB3aW5kb3cuXG5mdW5jdGlvbiBjb29yZHNBdFBvcyh2aWV3LCBwb3MsIHNpZGUpIHtcbiAgICBsZXQgeyBub2RlLCBvZmZzZXQsIGF0b20gfSA9IHZpZXcuZG9jVmlldy5kb21Gcm9tUG9zKHBvcywgc2lkZSA8IDAgPyAtMSA6IDEpO1xuICAgIGxldCBzdXBwb3J0RW1wdHlSYW5nZSA9IHdlYmtpdCB8fCBnZWNrbztcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAzKSB7XG4gICAgICAgIC8vIFRoZXNlIGJyb3dzZXJzIHN1cHBvcnQgcXVlcnlpbmcgZW1wdHkgdGV4dCByYW5nZXMuIFByZWZlciB0aGF0IGluXG4gICAgICAgIC8vIGJpZGkgY29udGV4dCBvciB3aGVuIGF0IHRoZSBlbmQgb2YgYSBub2RlLlxuICAgICAgICBpZiAoc3VwcG9ydEVtcHR5UmFuZ2UgJiYgKEJJREkudGVzdChub2RlLm5vZGVWYWx1ZSkgfHwgKHNpZGUgPCAwID8gIW9mZnNldCA6IG9mZnNldCA9PSBub2RlLm5vZGVWYWx1ZS5sZW5ndGgpKSkge1xuICAgICAgICAgICAgbGV0IHJlY3QgPSBzaW5nbGVSZWN0KHRleHRSYW5nZShub2RlLCBvZmZzZXQsIG9mZnNldCksIHNpZGUpO1xuICAgICAgICAgICAgLy8gRmlyZWZveCByZXR1cm5zIGJhZCByZXN1bHRzICh0aGUgcG9zaXRpb24gYmVmb3JlIHRoZSBzcGFjZSlcbiAgICAgICAgICAgIC8vIHdoZW4gcXVlcnlpbmcgYSBwb3NpdGlvbiBkaXJlY3RseSBhZnRlciBsaW5lLWJyb2tlblxuICAgICAgICAgICAgLy8gd2hpdGVzcGFjZS4gRGV0ZWN0IHRoaXMgc2l0dWF0aW9uIGFuZCBhbmQga2x1ZGdlIGFyb3VuZCBpdFxuICAgICAgICAgICAgaWYgKGdlY2tvICYmIG9mZnNldCAmJiAvXFxzLy50ZXN0KG5vZGUubm9kZVZhbHVlW29mZnNldCAtIDFdKSAmJiBvZmZzZXQgPCBub2RlLm5vZGVWYWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVjdEJlZm9yZSA9IHNpbmdsZVJlY3QodGV4dFJhbmdlKG5vZGUsIG9mZnNldCAtIDEsIG9mZnNldCAtIDEpLCAtMSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlY3RCZWZvcmUudG9wID09IHJlY3QudG9wKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZWN0QWZ0ZXIgPSBzaW5nbGVSZWN0KHRleHRSYW5nZShub2RlLCBvZmZzZXQsIG9mZnNldCArIDEpLCAtMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWN0QWZ0ZXIudG9wICE9IHJlY3QudG9wKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZsYXR0ZW5WKHJlY3RBZnRlciwgcmVjdEFmdGVyLmxlZnQgPCByZWN0QmVmb3JlLmxlZnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZWN0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGZyb20gPSBvZmZzZXQsIHRvID0gb2Zmc2V0LCB0YWtlU2lkZSA9IHNpZGUgPCAwID8gMSA6IC0xO1xuICAgICAgICAgICAgaWYgKHNpZGUgPCAwICYmICFvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICB0bysrO1xuICAgICAgICAgICAgICAgIHRha2VTaWRlID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzaWRlID49IDAgJiYgb2Zmc2V0ID09IG5vZGUubm9kZVZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZyb20tLTtcbiAgICAgICAgICAgICAgICB0YWtlU2lkZSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzaWRlIDwgMCkge1xuICAgICAgICAgICAgICAgIGZyb20tLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRvKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmxhdHRlblYoc2luZ2xlUmVjdCh0ZXh0UmFuZ2Uobm9kZSwgZnJvbSwgdG8pLCB0YWtlU2lkZSksIHRha2VTaWRlIDwgMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0ICRkb20gPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKHBvcyAtIChhdG9tIHx8IDApKTtcbiAgICAvLyBSZXR1cm4gYSBob3Jpem9udGFsIGxpbmUgaW4gYmxvY2sgY29udGV4dFxuICAgIGlmICghJGRvbS5wYXJlbnQuaW5saW5lQ29udGVudCkge1xuICAgICAgICBpZiAoYXRvbSA9PSBudWxsICYmIG9mZnNldCAmJiAoc2lkZSA8IDAgfHwgb2Zmc2V0ID09IG5vZGVTaXplKG5vZGUpKSkge1xuICAgICAgICAgICAgbGV0IGJlZm9yZSA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXTtcbiAgICAgICAgICAgIGlmIChiZWZvcmUubm9kZVR5cGUgPT0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmxhdHRlbkgoYmVmb3JlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF0b20gPT0gbnVsbCAmJiBvZmZzZXQgPCBub2RlU2l6ZShub2RlKSkge1xuICAgICAgICAgICAgbGV0IGFmdGVyID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgICAgICAgICBpZiAoYWZ0ZXIubm9kZVR5cGUgPT0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmxhdHRlbkgoYWZ0ZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmbGF0dGVuSChub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBzaWRlID49IDApO1xuICAgIH1cbiAgICAvLyBJbmxpbmUsIG5vdCBpbiB0ZXh0IG5vZGUgKHRoaXMgaXMgbm90IEJpZGktc2FmZSlcbiAgICBpZiAoYXRvbSA9PSBudWxsICYmIG9mZnNldCAmJiAoc2lkZSA8IDAgfHwgb2Zmc2V0ID09IG5vZGVTaXplKG5vZGUpKSkge1xuICAgICAgICBsZXQgYmVmb3JlID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdO1xuICAgICAgICBsZXQgdGFyZ2V0ID0gYmVmb3JlLm5vZGVUeXBlID09IDMgPyB0ZXh0UmFuZ2UoYmVmb3JlLCBub2RlU2l6ZShiZWZvcmUpIC0gKHN1cHBvcnRFbXB0eVJhbmdlID8gMCA6IDEpKVxuICAgICAgICAgICAgLy8gQlIgbm9kZXMgdGVuZCB0byBvbmx5IHJldHVybiB0aGUgcmVjdGFuZ2xlIGJlZm9yZSB0aGVtLlxuICAgICAgICAgICAgLy8gT25seSB1c2UgdGhlbSBpZiB0aGV5IGFyZSB0aGUgbGFzdCBlbGVtZW50IGluIHRoZWlyIHBhcmVudFxuICAgICAgICAgICAgOiBiZWZvcmUubm9kZVR5cGUgPT0gMSAmJiAoYmVmb3JlLm5vZGVOYW1lICE9IFwiQlJcIiB8fCAhYmVmb3JlLm5leHRTaWJsaW5nKSA/IGJlZm9yZSA6IG51bGw7XG4gICAgICAgIGlmICh0YXJnZXQpXG4gICAgICAgICAgICByZXR1cm4gZmxhdHRlblYoc2luZ2xlUmVjdCh0YXJnZXQsIDEpLCBmYWxzZSk7XG4gICAgfVxuICAgIGlmIChhdG9tID09IG51bGwgJiYgb2Zmc2V0IDwgbm9kZVNpemUobm9kZSkpIHtcbiAgICAgICAgbGV0IGFmdGVyID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgICAgIHdoaWxlIChhZnRlci5wbVZpZXdEZXNjICYmIGFmdGVyLnBtVmlld0Rlc2MuaWdub3JlRm9yQ29vcmRzKVxuICAgICAgICAgICAgYWZ0ZXIgPSBhZnRlci5uZXh0U2libGluZztcbiAgICAgICAgbGV0IHRhcmdldCA9ICFhZnRlciA/IG51bGwgOiBhZnRlci5ub2RlVHlwZSA9PSAzID8gdGV4dFJhbmdlKGFmdGVyLCAwLCAoc3VwcG9ydEVtcHR5UmFuZ2UgPyAwIDogMSkpXG4gICAgICAgICAgICA6IGFmdGVyLm5vZGVUeXBlID09IDEgPyBhZnRlciA6IG51bGw7XG4gICAgICAgIGlmICh0YXJnZXQpXG4gICAgICAgICAgICByZXR1cm4gZmxhdHRlblYoc2luZ2xlUmVjdCh0YXJnZXQsIC0xKSwgdHJ1ZSk7XG4gICAgfVxuICAgIC8vIEFsbCBlbHNlIGZhaWxlZCwganVzdCB0cnkgdG8gZ2V0IGEgcmVjdGFuZ2xlIGZvciB0aGUgdGFyZ2V0IG5vZGVcbiAgICByZXR1cm4gZmxhdHRlblYoc2luZ2xlUmVjdChub2RlLm5vZGVUeXBlID09IDMgPyB0ZXh0UmFuZ2Uobm9kZSkgOiBub2RlLCAtc2lkZSksIHNpZGUgPj0gMCk7XG59XG5mdW5jdGlvbiBmbGF0dGVuVihyZWN0LCBsZWZ0KSB7XG4gICAgaWYgKHJlY3Qud2lkdGggPT0gMClcbiAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgbGV0IHggPSBsZWZ0ID8gcmVjdC5sZWZ0IDogcmVjdC5yaWdodDtcbiAgICByZXR1cm4geyB0b3A6IHJlY3QudG9wLCBib3R0b206IHJlY3QuYm90dG9tLCBsZWZ0OiB4LCByaWdodDogeCB9O1xufVxuZnVuY3Rpb24gZmxhdHRlbkgocmVjdCwgdG9wKSB7XG4gICAgaWYgKHJlY3QuaGVpZ2h0ID09IDApXG4gICAgICAgIHJldHVybiByZWN0O1xuICAgIGxldCB5ID0gdG9wID8gcmVjdC50b3AgOiByZWN0LmJvdHRvbTtcbiAgICByZXR1cm4geyB0b3A6IHksIGJvdHRvbTogeSwgbGVmdDogcmVjdC5sZWZ0LCByaWdodDogcmVjdC5yaWdodCB9O1xufVxuZnVuY3Rpb24gd2l0aEZsdXNoZWRTdGF0ZSh2aWV3LCBzdGF0ZSwgZikge1xuICAgIGxldCB2aWV3U3RhdGUgPSB2aWV3LnN0YXRlLCBhY3RpdmUgPSB2aWV3LnJvb3QuYWN0aXZlRWxlbWVudDtcbiAgICBpZiAodmlld1N0YXRlICE9IHN0YXRlKVxuICAgICAgICB2aWV3LnVwZGF0ZVN0YXRlKHN0YXRlKTtcbiAgICBpZiAoYWN0aXZlICE9IHZpZXcuZG9tKVxuICAgICAgICB2aWV3LmZvY3VzKCk7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGYoKTtcbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIGlmICh2aWV3U3RhdGUgIT0gc3RhdGUpXG4gICAgICAgICAgICB2aWV3LnVwZGF0ZVN0YXRlKHZpZXdTdGF0ZSk7XG4gICAgICAgIGlmIChhY3RpdmUgIT0gdmlldy5kb20gJiYgYWN0aXZlKVxuICAgICAgICAgICAgYWN0aXZlLmZvY3VzKCk7XG4gICAgfVxufVxuLy8gV2hldGhlciB2ZXJ0aWNhbCBwb3NpdGlvbiBtb3Rpb24gaW4gYSBnaXZlbiBkaXJlY3Rpb25cbi8vIGZyb20gYSBwb3NpdGlvbiB3b3VsZCBsZWF2ZSBhIHRleHQgYmxvY2suXG5mdW5jdGlvbiBlbmRPZlRleHRibG9ja1ZlcnRpY2FsKHZpZXcsIHN0YXRlLCBkaXIpIHtcbiAgICBsZXQgc2VsID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGxldCAkcG9zID0gZGlyID09IFwidXBcIiA/IHNlbC4kZnJvbSA6IHNlbC4kdG87XG4gICAgcmV0dXJuIHdpdGhGbHVzaGVkU3RhdGUodmlldywgc3RhdGUsICgpID0+IHtcbiAgICAgICAgbGV0IHsgbm9kZTogZG9tIH0gPSB2aWV3LmRvY1ZpZXcuZG9tRnJvbVBvcygkcG9zLnBvcywgZGlyID09IFwidXBcIiA/IC0xIDogMSk7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBuZWFyZXN0ID0gdmlldy5kb2NWaWV3Lm5lYXJlc3REZXNjKGRvbSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoIW5lYXJlc3QpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAobmVhcmVzdC5ub2RlLmlzQmxvY2spIHtcbiAgICAgICAgICAgICAgICBkb20gPSBuZWFyZXN0LmNvbnRlbnRET00gfHwgbmVhcmVzdC5kb207XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb20gPSBuZWFyZXN0LmRvbS5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb29yZHMgPSBjb29yZHNBdFBvcyh2aWV3LCAkcG9zLnBvcywgMSk7XG4gICAgICAgIGZvciAobGV0IGNoaWxkID0gZG9tLmZpcnN0Q2hpbGQ7IGNoaWxkOyBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICBsZXQgYm94ZXM7XG4gICAgICAgICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT0gMSlcbiAgICAgICAgICAgICAgICBib3hlcyA9IGNoaWxkLmdldENsaWVudFJlY3RzKCk7XG4gICAgICAgICAgICBlbHNlIGlmIChjaGlsZC5ub2RlVHlwZSA9PSAzKVxuICAgICAgICAgICAgICAgIGJveGVzID0gdGV4dFJhbmdlKGNoaWxkLCAwLCBjaGlsZC5ub2RlVmFsdWUubGVuZ3RoKS5nZXRDbGllbnRSZWN0cygpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBib3hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBib3ggPSBib3hlc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoYm94LmJvdHRvbSA+IGJveC50b3AgKyAxICYmXG4gICAgICAgICAgICAgICAgICAgIChkaXIgPT0gXCJ1cFwiID8gY29vcmRzLnRvcCAtIGJveC50b3AgPiAoYm94LmJvdHRvbSAtIGNvb3Jkcy50b3ApICogMlxuICAgICAgICAgICAgICAgICAgICAgICAgOiBib3guYm90dG9tIC0gY29vcmRzLmJvdHRvbSA+IChjb29yZHMuYm90dG9tIC0gYm94LnRvcCkgKiAyKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xufVxuY29uc3QgbWF5YmVSVEwgPSAvW1xcdTA1OTAtXFx1MDhhY10vO1xuZnVuY3Rpb24gZW5kT2ZUZXh0YmxvY2tIb3Jpem9udGFsKHZpZXcsIHN0YXRlLCBkaXIpIHtcbiAgICBsZXQgeyAkaGVhZCB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmICghJGhlYWQucGFyZW50LmlzVGV4dGJsb2NrKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IG9mZnNldCA9ICRoZWFkLnBhcmVudE9mZnNldCwgYXRTdGFydCA9ICFvZmZzZXQsIGF0RW5kID0gb2Zmc2V0ID09ICRoZWFkLnBhcmVudC5jb250ZW50LnNpemU7XG4gICAgbGV0IHNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uKCk7XG4gICAgaWYgKCFzZWwpXG4gICAgICAgIHJldHVybiAkaGVhZC5wb3MgPT0gJGhlYWQuc3RhcnQoKSB8fCAkaGVhZC5wb3MgPT0gJGhlYWQuZW5kKCk7XG4gICAgLy8gSWYgdGhlIHRleHRibG9jayBpcyBhbGwgTFRSLCBvciB0aGUgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnRcbiAgICAvLyBTZWxlY3Rpb24ubW9kaWZ5IChFZGdlKSwgZmFsbCBiYWNrIHRvIGEgcHJpbWl0aXZlIGFwcHJvYWNoXG4gICAgaWYgKCFtYXliZVJUTC50ZXN0KCRoZWFkLnBhcmVudC50ZXh0Q29udGVudCkgfHwgIXNlbC5tb2RpZnkpXG4gICAgICAgIHJldHVybiBkaXIgPT0gXCJsZWZ0XCIgfHwgZGlyID09IFwiYmFja3dhcmRcIiA/IGF0U3RhcnQgOiBhdEVuZDtcbiAgICByZXR1cm4gd2l0aEZsdXNoZWRTdGF0ZSh2aWV3LCBzdGF0ZSwgKCkgPT4ge1xuICAgICAgICAvLyBUaGlzIGlzIGEgaHVnZSBoYWNrLCBidXQgYXBwZWFycyB0byBiZSB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgLy8gY3VycmVudGx5IGRvOiB1c2UgYFNlbGVjdGlvbi5tb2RpZnlgIHRvIG1vdmUgdGhlIHNlbGVjdGlvbiBieVxuICAgICAgICAvLyBvbmUgY2hhcmFjdGVyLCBhbmQgc2VlIGlmIHRoYXQgbW92ZXMgdGhlIGN1cnNvciBvdXQgb2YgdGhlXG4gICAgICAgIC8vIHRleHRibG9jayAob3IgZG9lc24ndCBtb3ZlIGl0IGF0IGFsbCwgd2hlbiBhdCB0aGUgc3RhcnQvZW5kIG9mXG4gICAgICAgIC8vIHRoZSBkb2N1bWVudCkuXG4gICAgICAgIGxldCB7IGZvY3VzTm9kZTogb2xkTm9kZSwgZm9jdXNPZmZzZXQ6IG9sZE9mZiwgYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0IH0gPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgIGxldCBvbGRCaWRpTGV2ZWwgPSBzZWwuY2FyZXRCaWRpTGV2ZWwgLy8gT25seSBmb3IgRmlyZWZveFxuICAgICAgICA7XG4gICAgICAgIHNlbC5tb2RpZnkoXCJtb3ZlXCIsIGRpciwgXCJjaGFyYWN0ZXJcIik7XG4gICAgICAgIGxldCBwYXJlbnRET00gPSAkaGVhZC5kZXB0aCA/IHZpZXcuZG9jVmlldy5kb21BZnRlclBvcygkaGVhZC5iZWZvcmUoKSkgOiB2aWV3LmRvbTtcbiAgICAgICAgbGV0IHsgZm9jdXNOb2RlOiBuZXdOb2RlLCBmb2N1c09mZnNldDogbmV3T2ZmIH0gPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSBuZXdOb2RlICYmICFwYXJlbnRET00uY29udGFpbnMobmV3Tm9kZS5ub2RlVHlwZSA9PSAxID8gbmV3Tm9kZSA6IG5ld05vZGUucGFyZW50Tm9kZSkgfHxcbiAgICAgICAgICAgIChvbGROb2RlID09IG5ld05vZGUgJiYgb2xkT2ZmID09IG5ld09mZik7XG4gICAgICAgIC8vIFJlc3RvcmUgdGhlIHByZXZpb3VzIHNlbGVjdGlvblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc2VsLmNvbGxhcHNlKGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCk7XG4gICAgICAgICAgICBpZiAob2xkTm9kZSAmJiAob2xkTm9kZSAhPSBhbmNob3JOb2RlIHx8IG9sZE9mZiAhPSBhbmNob3JPZmZzZXQpICYmIHNlbC5leHRlbmQpXG4gICAgICAgICAgICAgICAgc2VsLmV4dGVuZChvbGROb2RlLCBvbGRPZmYpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfKSB7IH1cbiAgICAgICAgaWYgKG9sZEJpZGlMZXZlbCAhPSBudWxsKVxuICAgICAgICAgICAgc2VsLmNhcmV0QmlkaUxldmVsID0gb2xkQmlkaUxldmVsO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xufVxubGV0IGNhY2hlZFN0YXRlID0gbnVsbDtcbmxldCBjYWNoZWREaXIgPSBudWxsO1xubGV0IGNhY2hlZFJlc3VsdCA9IGZhbHNlO1xuZnVuY3Rpb24gZW5kT2ZUZXh0YmxvY2sodmlldywgc3RhdGUsIGRpcikge1xuICAgIGlmIChjYWNoZWRTdGF0ZSA9PSBzdGF0ZSAmJiBjYWNoZWREaXIgPT0gZGlyKVxuICAgICAgICByZXR1cm4gY2FjaGVkUmVzdWx0O1xuICAgIGNhY2hlZFN0YXRlID0gc3RhdGU7XG4gICAgY2FjaGVkRGlyID0gZGlyO1xuICAgIHJldHVybiBjYWNoZWRSZXN1bHQgPSBkaXIgPT0gXCJ1cFwiIHx8IGRpciA9PSBcImRvd25cIlxuICAgICAgICA/IGVuZE9mVGV4dGJsb2NrVmVydGljYWwodmlldywgc3RhdGUsIGRpcilcbiAgICAgICAgOiBlbmRPZlRleHRibG9ja0hvcml6b250YWwodmlldywgc3RhdGUsIGRpcik7XG59XG5cbi8vIFZpZXcgZGVzY3JpcHRpb25zIGFyZSBkYXRhIHN0cnVjdHVyZXMgdGhhdCBkZXNjcmliZSB0aGUgRE9NIHRoYXQgaXNcbi8vIHVzZWQgdG8gcmVwcmVzZW50IHRoZSBlZGl0b3IncyBjb250ZW50LiBUaGV5IGFyZSB1c2VkIGZvcjpcbi8vXG4vLyAtIEluY3JlbWVudGFsIHJlZHJhd2luZyB3aGVuIHRoZSBkb2N1bWVudCBjaGFuZ2VzXG4vL1xuLy8gLSBGaWd1cmluZyBvdXQgd2hhdCBwYXJ0IG9mIHRoZSBkb2N1bWVudCBhIGdpdmVuIERPTSBwb3NpdGlvblxuLy8gICBjb3JyZXNwb25kcyB0b1xuLy9cbi8vIC0gV2lyaW5nIGluIGN1c3RvbSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIGVkaXRpbmcgaW50ZXJmYWNlIGZvciBhXG4vLyAgIGdpdmVuIG5vZGVcbi8vXG4vLyBUaGV5IGZvcm0gYSBkb3VibHktbGlua2VkIG11dGFibGUgdHJlZSwgc3RhcnRpbmcgYXQgYHZpZXcuZG9jVmlld2AuXG5jb25zdCBOT1RfRElSVFkgPSAwLCBDSElMRF9ESVJUWSA9IDEsIENPTlRFTlRfRElSVFkgPSAyLCBOT0RFX0RJUlRZID0gMztcbi8vIFN1cGVyY2xhc3MgZm9yIHRoZSB2YXJpb3VzIGtpbmRzIG9mIGRlc2NyaXB0aW9ucy4gRGVmaW5lcyB0aGVpclxuLy8gYmFzaWMgc3RydWN0dXJlIGFuZCBzaGFyZWQgbWV0aG9kcy5cbmNsYXNzIFZpZXdEZXNjIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIGNoaWxkcmVuLCBkb20sIFxuICAgIC8vIFRoaXMgaXMgdGhlIG5vZGUgdGhhdCBob2xkcyB0aGUgY2hpbGQgdmlld3MuIEl0IG1heSBiZSBudWxsIGZvclxuICAgIC8vIGRlc2NzIHRoYXQgZG9uJ3QgaGF2ZSBjaGlsZHJlbi5cbiAgICBjb250ZW50RE9NKSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMuZG9tID0gZG9tO1xuICAgICAgICB0aGlzLmNvbnRlbnRET00gPSBjb250ZW50RE9NO1xuICAgICAgICB0aGlzLmRpcnR5ID0gTk9UX0RJUlRZO1xuICAgICAgICAvLyBBbiBleHBhbmRvIHByb3BlcnR5IG9uIHRoZSBET00gbm9kZSBwcm92aWRlcyBhIGxpbmsgYmFjayB0byBpdHNcbiAgICAgICAgLy8gZGVzY3JpcHRpb24uXG4gICAgICAgIGRvbS5wbVZpZXdEZXNjID0gdGhpcztcbiAgICB9XG4gICAgLy8gVXNlZCB0byBjaGVjayB3aGV0aGVyIGEgZ2l2ZW4gZGVzY3JpcHRpb24gY29ycmVzcG9uZHMgdG8gYVxuICAgIC8vIHdpZGdldC9tYXJrL25vZGUuXG4gICAgbWF0Y2hlc1dpZGdldCh3aWRnZXQpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgbWF0Y2hlc01hcmsobWFyaykgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBtYXRjaGVzTm9kZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbykgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBtYXRjaGVzSGFjayhub2RlTmFtZSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAvLyBXaGVuIHBhcnNpbmcgaW4tZWRpdG9yIGNvbnRlbnQgKGluIGRvbWNoYW5nZS5qcyksIHdlIGFsbG93XG4gICAgLy8gZGVzY3JpcHRpb25zIHRvIGRldGVybWluZSB0aGUgcGFyc2UgcnVsZXMgdGhhdCBzaG91bGQgYmUgdXNlZCB0b1xuICAgIC8vIHBhcnNlIHRoZW0uXG4gICAgcGFyc2VSdWxlKCkgeyByZXR1cm4gbnVsbDsgfVxuICAgIC8vIFVzZWQgYnkgdGhlIGVkaXRvcidzIGV2ZW50IGhhbmRsZXIgdG8gaWdub3JlIGV2ZW50cyB0aGF0IGNvbWVcbiAgICAvLyBmcm9tIGNlcnRhaW4gZGVzY3MuXG4gICAgc3RvcEV2ZW50KGV2ZW50KSB7IHJldHVybiBmYWxzZTsgfVxuICAgIC8vIFRoZSBzaXplIG9mIHRoZSBjb250ZW50IHJlcHJlc2VudGVkIGJ5IHRoaXMgZGVzYy5cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgbGV0IHNpemUgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBzaXplICs9IHRoaXMuY2hpbGRyZW5baV0uc2l6ZTtcbiAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgfVxuICAgIC8vIEZvciBibG9jayBub2RlcywgdGhpcyByZXByZXNlbnRzIHRoZSBzcGFjZSB0YWtlbiB1cCBieSB0aGVpclxuICAgIC8vIHN0YXJ0L2VuZCB0b2tlbnMuXG4gICAgZ2V0IGJvcmRlcigpIHsgcmV0dXJuIDA7IH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnBhcmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHRoaXMuZG9tLnBtVmlld0Rlc2MgPT0gdGhpcylcbiAgICAgICAgICAgIHRoaXMuZG9tLnBtVmlld0Rlc2MgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5baV0uZGVzdHJveSgpO1xuICAgIH1cbiAgICBwb3NCZWZvcmVDaGlsZChjaGlsZCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gdGhpcy5wb3NBdFN0YXJ0OzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY3VyID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmIChjdXIgPT0gY2hpbGQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgICAgIHBvcyArPSBjdXIuc2l6ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgcG9zQmVmb3JlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQucG9zQmVmb3JlQ2hpbGQodGhpcyk7XG4gICAgfVxuICAgIGdldCBwb3NBdFN0YXJ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudC5wb3NCZWZvcmVDaGlsZCh0aGlzKSArIHRoaXMuYm9yZGVyIDogMDtcbiAgICB9XG4gICAgZ2V0IHBvc0FmdGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NCZWZvcmUgKyB0aGlzLnNpemU7XG4gICAgfVxuICAgIGdldCBwb3NBdEVuZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zQXRTdGFydCArIHRoaXMuc2l6ZSAtIDIgKiB0aGlzLmJvcmRlcjtcbiAgICB9XG4gICAgbG9jYWxQb3NGcm9tRE9NKGRvbSwgb2Zmc2V0LCBiaWFzKSB7XG4gICAgICAgIC8vIElmIHRoZSBET00gcG9zaXRpb24gaXMgaW4gdGhlIGNvbnRlbnQsIHVzZSB0aGUgY2hpbGQgZGVzYyBhZnRlclxuICAgICAgICAvLyBpdCB0byBmaWd1cmUgb3V0IGEgcG9zaXRpb24uXG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnRET00gJiYgdGhpcy5jb250ZW50RE9NLmNvbnRhaW5zKGRvbS5ub2RlVHlwZSA9PSAxID8gZG9tIDogZG9tLnBhcmVudE5vZGUpKSB7XG4gICAgICAgICAgICBpZiAoYmlhcyA8IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgZG9tQmVmb3JlLCBkZXNjO1xuICAgICAgICAgICAgICAgIGlmIChkb20gPT0gdGhpcy5jb250ZW50RE9NKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbUJlZm9yZSA9IGRvbS5jaGlsZE5vZGVzW29mZnNldCAtIDFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGRvbS5wYXJlbnROb2RlICE9IHRoaXMuY29udGVudERPTSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbSA9IGRvbS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICBkb21CZWZvcmUgPSBkb20ucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGlsZSAoZG9tQmVmb3JlICYmICEoKGRlc2MgPSBkb21CZWZvcmUucG1WaWV3RGVzYykgJiYgZGVzYy5wYXJlbnQgPT0gdGhpcykpXG4gICAgICAgICAgICAgICAgICAgIGRvbUJlZm9yZSA9IGRvbUJlZm9yZS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvbUJlZm9yZSA/IHRoaXMucG9zQmVmb3JlQ2hpbGQoZGVzYykgKyBkZXNjLnNpemUgOiB0aGlzLnBvc0F0U3RhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgZG9tQWZ0ZXIsIGRlc2M7XG4gICAgICAgICAgICAgICAgaWYgKGRvbSA9PSB0aGlzLmNvbnRlbnRET00pIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tQWZ0ZXIgPSBkb20uY2hpbGROb2Rlc1tvZmZzZXRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGRvbS5wYXJlbnROb2RlICE9IHRoaXMuY29udGVudERPTSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbSA9IGRvbS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICBkb21BZnRlciA9IGRvbS5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKGRvbUFmdGVyICYmICEoKGRlc2MgPSBkb21BZnRlci5wbVZpZXdEZXNjKSAmJiBkZXNjLnBhcmVudCA9PSB0aGlzKSlcbiAgICAgICAgICAgICAgICAgICAgZG9tQWZ0ZXIgPSBkb21BZnRlci5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9tQWZ0ZXIgPyB0aGlzLnBvc0JlZm9yZUNoaWxkKGRlc2MpIDogdGhpcy5wb3NBdEVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBPdGhlcndpc2UsIHVzZSB2YXJpb3VzIGhldXJpc3RpY3MsIGZhbGxpbmcgYmFjayBvbiB0aGUgYmlhc1xuICAgICAgICAvLyBwYXJhbWV0ZXIsIHRvIGRldGVybWluZSB3aGV0aGVyIHRvIHJldHVybiB0aGUgcG9zaXRpb24gYXQgdGhlXG4gICAgICAgIC8vIHN0YXJ0IG9yIGF0IHRoZSBlbmQgb2YgdGhpcyB2aWV3IGRlc2MuXG4gICAgICAgIGxldCBhdEVuZDtcbiAgICAgICAgaWYgKGRvbSA9PSB0aGlzLmRvbSAmJiB0aGlzLmNvbnRlbnRET00pIHtcbiAgICAgICAgICAgIGF0RW5kID0gb2Zmc2V0ID4gZG9tSW5kZXgodGhpcy5jb250ZW50RE9NKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmNvbnRlbnRET00gJiYgdGhpcy5jb250ZW50RE9NICE9IHRoaXMuZG9tICYmIHRoaXMuZG9tLmNvbnRhaW5zKHRoaXMuY29udGVudERPTSkpIHtcbiAgICAgICAgICAgIGF0RW5kID0gZG9tLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKHRoaXMuY29udGVudERPTSkgJiAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZG9tLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPT0gMClcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBzZWFyY2ggPSBkb207OyBzZWFyY2ggPSBzZWFyY2gucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VhcmNoID09IHRoaXMuZG9tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdEVuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlYXJjaC5wcmV2aW91c1NpYmxpbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXRFbmQgPT0gbnVsbCAmJiBvZmZzZXQgPT0gZG9tLmNoaWxkTm9kZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IHNlYXJjaCA9IGRvbTs7IHNlYXJjaCA9IHNlYXJjaC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWFyY2ggPT0gdGhpcy5kb20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0RW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWFyY2gubmV4dFNpYmxpbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChhdEVuZCA9PSBudWxsID8gYmlhcyA+IDAgOiBhdEVuZCkgPyB0aGlzLnBvc0F0RW5kIDogdGhpcy5wb3NBdFN0YXJ0O1xuICAgIH1cbiAgICBuZWFyZXN0RGVzYyhkb20sIG9ubHlOb2RlcyA9IGZhbHNlKSB7XG4gICAgICAgIGZvciAobGV0IGZpcnN0ID0gdHJ1ZSwgY3VyID0gZG9tOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBsZXQgZGVzYyA9IHRoaXMuZ2V0RGVzYyhjdXIpLCBub2RlRE9NO1xuICAgICAgICAgICAgaWYgKGRlc2MgJiYgKCFvbmx5Tm9kZXMgfHwgZGVzYy5ub2RlKSkge1xuICAgICAgICAgICAgICAgIC8vIElmIGRvbSBpcyBvdXRzaWRlIG9mIHRoaXMgZGVzYydzIG5vZGVET00sIGRvbid0IGNvdW50IGl0LlxuICAgICAgICAgICAgICAgIGlmIChmaXJzdCAmJiAobm9kZURPTSA9IGRlc2Mubm9kZURPTSkgJiZcbiAgICAgICAgICAgICAgICAgICAgIShub2RlRE9NLm5vZGVUeXBlID09IDEgPyBub2RlRE9NLmNvbnRhaW5zKGRvbS5ub2RlVHlwZSA9PSAxID8gZG9tIDogZG9tLnBhcmVudE5vZGUpIDogbm9kZURPTSA9PSBkb20pKVxuICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlc2M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0RGVzYyhkb20pIHtcbiAgICAgICAgbGV0IGRlc2MgPSBkb20ucG1WaWV3RGVzYztcbiAgICAgICAgZm9yIChsZXQgY3VyID0gZGVzYzsgY3VyOyBjdXIgPSBjdXIucGFyZW50KVxuICAgICAgICAgICAgaWYgKGN1ciA9PSB0aGlzKVxuICAgICAgICAgICAgICAgIHJldHVybiBkZXNjO1xuICAgIH1cbiAgICBwb3NGcm9tRE9NKGRvbSwgb2Zmc2V0LCBiaWFzKSB7XG4gICAgICAgIGZvciAobGV0IHNjYW4gPSBkb207IHNjYW47IHNjYW4gPSBzY2FuLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIGxldCBkZXNjID0gdGhpcy5nZXREZXNjKHNjYW4pO1xuICAgICAgICAgICAgaWYgKGRlc2MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlc2MubG9jYWxQb3NGcm9tRE9NKGRvbSwgb2Zmc2V0LCBiaWFzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIC8vIEZpbmQgdGhlIGRlc2MgZm9yIHRoZSBub2RlIGFmdGVyIHRoZSBnaXZlbiBwb3MsIGlmIGFueS4gKFdoZW4gYVxuICAgIC8vIHBhcmVudCBub2RlIG92ZXJyb2RlIHJlbmRlcmluZywgdGhlcmUgbWlnaHQgbm90IGJlIG9uZS4pXG4gICAgZGVzY0F0KHBvcykge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgb2Zmc2V0ID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IG9mZnNldCArIGNoaWxkLnNpemU7XG4gICAgICAgICAgICBpZiAob2Zmc2V0ID09IHBvcyAmJiBlbmQgIT0gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKCFjaGlsZC5ib3JkZXIgJiYgY2hpbGQuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGQuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpbm5lciA9IGNoaWxkLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlubmVyLnNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IGlubmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwb3MgPCBlbmQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLmRlc2NBdChwb3MgLSBvZmZzZXQgLSBjaGlsZC5ib3JkZXIpO1xuICAgICAgICAgICAgb2Zmc2V0ID0gZW5kO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRvbUZyb21Qb3MocG9zLCBzaWRlKSB7XG4gICAgICAgIGlmICghdGhpcy5jb250ZW50RE9NKVxuICAgICAgICAgICAgcmV0dXJuIHsgbm9kZTogdGhpcy5kb20sIG9mZnNldDogMCwgYXRvbTogcG9zICsgMSB9O1xuICAgICAgICAvLyBGaXJzdCBmaW5kIHRoZSBwb3NpdGlvbiBpbiB0aGUgY2hpbGQgYXJyYXlcbiAgICAgICAgbGV0IGkgPSAwLCBvZmZzZXQgPSAwO1xuICAgICAgICBmb3IgKGxldCBjdXJQb3MgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSwgZW5kID0gY3VyUG9zICsgY2hpbGQuc2l6ZTtcbiAgICAgICAgICAgIGlmIChlbmQgPiBwb3MgfHwgY2hpbGQgaW5zdGFuY2VvZiBUcmFpbGluZ0hhY2tWaWV3RGVzYykge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IHBvcyAtIGN1clBvcztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1clBvcyA9IGVuZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGlzIHBvaW50cyBpbnRvIHRoZSBtaWRkbGUgb2YgYSBjaGlsZCwgY2FsbCB0aHJvdWdoXG4gICAgICAgIGlmIChvZmZzZXQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbltpXS5kb21Gcm9tUG9zKG9mZnNldCAtIHRoaXMuY2hpbGRyZW5baV0uYm9yZGVyLCBzaWRlKTtcbiAgICAgICAgLy8gR28gYmFjayBpZiB0aGVyZSB3ZXJlIGFueSB6ZXJvLWxlbmd0aCB3aWRnZXRzIHdpdGggc2lkZSA+PSAwIGJlZm9yZSB0aGlzIHBvaW50XG4gICAgICAgIGZvciAobGV0IHByZXY7IGkgJiYgIShwcmV2ID0gdGhpcy5jaGlsZHJlbltpIC0gMV0pLnNpemUgJiYgcHJldiBpbnN0YW5jZW9mIFdpZGdldFZpZXdEZXNjICYmIHByZXYuc2lkZSA+PSAwOyBpLS0pIHsgfVxuICAgICAgICAvLyBTY2FuIHRvd2FyZHMgdGhlIGZpcnN0IHVzZWFibGUgbm9kZVxuICAgICAgICBpZiAoc2lkZSA8PSAwKSB7XG4gICAgICAgICAgICBsZXQgcHJldiwgZW50ZXIgPSB0cnVlO1xuICAgICAgICAgICAgZm9yICg7OyBpLS0sIGVudGVyID0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBwcmV2ID0gaSA/IHRoaXMuY2hpbGRyZW5baSAtIDFdIDogbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoIXByZXYgfHwgcHJldi5kb20ucGFyZW50Tm9kZSA9PSB0aGlzLmNvbnRlbnRET00pXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByZXYgJiYgc2lkZSAmJiBlbnRlciAmJiAhcHJldi5ib3JkZXIgJiYgIXByZXYuZG9tQXRvbSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJldi5kb21Gcm9tUG9zKHByZXYuc2l6ZSwgc2lkZSk7XG4gICAgICAgICAgICByZXR1cm4geyBub2RlOiB0aGlzLmNvbnRlbnRET00sIG9mZnNldDogcHJldiA/IGRvbUluZGV4KHByZXYuZG9tKSArIDEgOiAwIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbmV4dCwgZW50ZXIgPSB0cnVlO1xuICAgICAgICAgICAgZm9yICg7OyBpKyssIGVudGVyID0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBuZXh0ID0gaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoID8gdGhpcy5jaGlsZHJlbltpXSA6IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKCFuZXh0IHx8IG5leHQuZG9tLnBhcmVudE5vZGUgPT0gdGhpcy5jb250ZW50RE9NKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0ICYmIGVudGVyICYmICFuZXh0LmJvcmRlciAmJiAhbmV4dC5kb21BdG9tKVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXh0LmRvbUZyb21Qb3MoMCwgc2lkZSk7XG4gICAgICAgICAgICByZXR1cm4geyBub2RlOiB0aGlzLmNvbnRlbnRET00sIG9mZnNldDogbmV4dCA/IGRvbUluZGV4KG5leHQuZG9tKSA6IHRoaXMuY29udGVudERPTS5jaGlsZE5vZGVzLmxlbmd0aCB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFVzZWQgdG8gZmluZCBhIERPTSByYW5nZSBpbiBhIHNpbmdsZSBwYXJlbnQgZm9yIGEgZ2l2ZW4gY2hhbmdlZFxuICAgIC8vIHJhbmdlLlxuICAgIHBhcnNlUmFuZ2UoZnJvbSwgdG8sIGJhc2UgPSAwKSB7XG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHsgbm9kZTogdGhpcy5jb250ZW50RE9NLCBmcm9tLCB0bywgZnJvbU9mZnNldDogMCwgdG9PZmZzZXQ6IHRoaXMuY29udGVudERPTS5jaGlsZE5vZGVzLmxlbmd0aCB9O1xuICAgICAgICBsZXQgZnJvbU9mZnNldCA9IC0xLCB0b09mZnNldCA9IC0xO1xuICAgICAgICBmb3IgKGxldCBvZmZzZXQgPSBiYXNlLCBpID0gMDs7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSwgZW5kID0gb2Zmc2V0ICsgY2hpbGQuc2l6ZTtcbiAgICAgICAgICAgIGlmIChmcm9tT2Zmc2V0ID09IC0xICYmIGZyb20gPD0gZW5kKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkQmFzZSA9IG9mZnNldCArIGNoaWxkLmJvcmRlcjtcbiAgICAgICAgICAgICAgICAvLyBGSVhNRSBtYXliZSBkZXNjZW5kIG1hcmsgdmlld3MgdG8gcGFyc2UgYSBuYXJyb3dlciByYW5nZT9cbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA+PSBjaGlsZEJhc2UgJiYgdG8gPD0gZW5kIC0gY2hpbGQuYm9yZGVyICYmIGNoaWxkLm5vZGUgJiZcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuY29udGVudERPTSAmJiB0aGlzLmNvbnRlbnRET00uY29udGFpbnMoY2hpbGQuY29udGVudERPTSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZC5wYXJzZVJhbmdlKGZyb20sIHRvLCBjaGlsZEJhc2UpO1xuICAgICAgICAgICAgICAgIGZyb20gPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IGk7IGogPiAwOyBqLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHByZXYgPSB0aGlzLmNoaWxkcmVuW2ogLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXYuc2l6ZSAmJiBwcmV2LmRvbS5wYXJlbnROb2RlID09IHRoaXMuY29udGVudERPTSAmJiAhcHJldi5lbXB0eUNoaWxkQXQoMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb21PZmZzZXQgPSBkb21JbmRleChwcmV2LmRvbSkgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZnJvbSAtPSBwcmV2LnNpemU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmcm9tT2Zmc2V0ID09IC0xKVxuICAgICAgICAgICAgICAgICAgICBmcm9tT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmcm9tT2Zmc2V0ID4gLTEgJiYgKGVuZCA+IHRvIHx8IGkgPT0gdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxKSkge1xuICAgICAgICAgICAgICAgIHRvID0gZW5kO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5leHQgPSB0aGlzLmNoaWxkcmVuW2pdO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dC5zaXplICYmIG5leHQuZG9tLnBhcmVudE5vZGUgPT0gdGhpcy5jb250ZW50RE9NICYmICFuZXh0LmVtcHR5Q2hpbGRBdCgtMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvT2Zmc2V0ID0gZG9tSW5kZXgobmV4dC5kb20pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdG8gKz0gbmV4dC5zaXplO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodG9PZmZzZXQgPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIHRvT2Zmc2V0ID0gdGhpcy5jb250ZW50RE9NLmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0ID0gZW5kO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IG5vZGU6IHRoaXMuY29udGVudERPTSwgZnJvbSwgdG8sIGZyb21PZmZzZXQsIHRvT2Zmc2V0IH07XG4gICAgfVxuICAgIGVtcHR5Q2hpbGRBdChzaWRlKSB7XG4gICAgICAgIGlmICh0aGlzLmJvcmRlciB8fCAhdGhpcy5jb250ZW50RE9NIHx8ICF0aGlzLmNoaWxkcmVuLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltzaWRlIDwgMCA/IDAgOiB0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICAgICAgICByZXR1cm4gY2hpbGQuc2l6ZSA9PSAwIHx8IGNoaWxkLmVtcHR5Q2hpbGRBdChzaWRlKTtcbiAgICB9XG4gICAgZG9tQWZ0ZXJQb3MocG9zKSB7XG4gICAgICAgIGxldCB7IG5vZGUsIG9mZnNldCB9ID0gdGhpcy5kb21Gcm9tUG9zKHBvcywgMCk7XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlICE9IDEgfHwgb2Zmc2V0ID09IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk5vIG5vZGUgYWZ0ZXIgcG9zIFwiICsgcG9zKTtcbiAgICAgICAgcmV0dXJuIG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdO1xuICAgIH1cbiAgICAvLyBWaWV3IGRlc2NzIGFyZSByZXNwb25zaWJsZSBmb3Igc2V0dGluZyBhbnkgc2VsZWN0aW9uIHRoYXQgZmFsbHNcbiAgICAvLyBlbnRpcmVseSBpbnNpZGUgb2YgdGhlbSwgc28gdGhhdCBjdXN0b20gaW1wbGVtZW50YXRpb25zIGNhbiBkb1xuICAgIC8vIGN1c3RvbSB0aGluZ3Mgd2l0aCB0aGUgc2VsZWN0aW9uLiBOb3RlIHRoYXQgdGhpcyBmYWxscyBhcGFydCB3aGVuXG4gICAgLy8gYSBzZWxlY3Rpb24gc3RhcnRzIGluIHN1Y2ggYSBub2RlIGFuZCBlbmRzIGluIGFub3RoZXIsIGluIHdoaWNoXG4gICAgLy8gY2FzZSB3ZSBqdXN0IHVzZSB3aGF0ZXZlciBkb21Gcm9tUG9zIHByb2R1Y2VzIGFzIGEgYmVzdCBlZmZvcnQuXG4gICAgc2V0U2VsZWN0aW9uKGFuY2hvciwgaGVhZCwgdmlldywgZm9yY2UgPSBmYWxzZSkge1xuICAgICAgICAvLyBJZiB0aGUgc2VsZWN0aW9uIGZhbGxzIGVudGlyZWx5IGluIGEgY2hpbGQsIGdpdmUgaXQgdG8gdGhhdCBjaGlsZFxuICAgICAgICBsZXQgZnJvbSA9IE1hdGgubWluKGFuY2hvciwgaGVhZCksIHRvID0gTWF0aC5tYXgoYW5jaG9yLCBoZWFkKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG9mZnNldCA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBlbmQgPSBvZmZzZXQgKyBjaGlsZC5zaXplO1xuICAgICAgICAgICAgaWYgKGZyb20gPiBvZmZzZXQgJiYgdG8gPCBlbmQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLnNldFNlbGVjdGlvbihhbmNob3IgLSBvZmZzZXQgLSBjaGlsZC5ib3JkZXIsIGhlYWQgLSBvZmZzZXQgLSBjaGlsZC5ib3JkZXIsIHZpZXcsIGZvcmNlKTtcbiAgICAgICAgICAgIG9mZnNldCA9IGVuZDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYW5jaG9yRE9NID0gdGhpcy5kb21Gcm9tUG9zKGFuY2hvciwgYW5jaG9yID8gLTEgOiAxKTtcbiAgICAgICAgbGV0IGhlYWRET00gPSBoZWFkID09IGFuY2hvciA/IGFuY2hvckRPTSA6IHRoaXMuZG9tRnJvbVBvcyhoZWFkLCBoZWFkID8gLTEgOiAxKTtcbiAgICAgICAgbGV0IGRvbVNlbCA9IHZpZXcucm9vdC5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgbGV0IHNlbFJhbmdlID0gdmlldy5kb21TZWxlY3Rpb25SYW5nZSgpO1xuICAgICAgICBsZXQgYnJLbHVkZ2UgPSBmYWxzZTtcbiAgICAgICAgLy8gT24gRmlyZWZveCwgdXNpbmcgU2VsZWN0aW9uLmNvbGxhcHNlIHRvIHB1dCB0aGUgY3Vyc29yIGFmdGVyIGFcbiAgICAgICAgLy8gQlIgbm9kZSBmb3Igc29tZSByZWFzb24gZG9lc24ndCBhbHdheXMgd29yayAoIzEwNzMpLiBPbiBTYWZhcmksXG4gICAgICAgIC8vIHRoZSBjdXJzb3Igc29tZXRpbWVzIGluZXhwbGljYWJsZSB2aXN1YWxseSBsYWdzIGJlaGluZCBpdHNcbiAgICAgICAgLy8gcmVwb3J0ZWQgcG9zaXRpb24gaW4gc3VjaCBzaXR1YXRpb25zICgjMTA5MikuXG4gICAgICAgIGlmICgoZ2Vja28gfHwgc2FmYXJpKSAmJiBhbmNob3IgPT0gaGVhZCkge1xuICAgICAgICAgICAgbGV0IHsgbm9kZSwgb2Zmc2V0IH0gPSBhbmNob3JET007XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAzKSB7XG4gICAgICAgICAgICAgICAgYnJLbHVkZ2UgPSAhIShvZmZzZXQgJiYgbm9kZS5ub2RlVmFsdWVbb2Zmc2V0IC0gMV0gPT0gXCJcXG5cIik7XG4gICAgICAgICAgICAgICAgLy8gSXNzdWUgIzExMjhcbiAgICAgICAgICAgICAgICBpZiAoYnJLbHVkZ2UgJiYgb2Zmc2V0ID09IG5vZGUubm9kZVZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBzY2FuID0gbm9kZSwgYWZ0ZXI7IHNjYW47IHNjYW4gPSBzY2FuLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhZnRlciA9IHNjYW4ubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWZ0ZXIubm9kZU5hbWUgPT0gXCJCUlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmNob3JET00gPSBoZWFkRE9NID0geyBub2RlOiBhZnRlci5wYXJlbnROb2RlLCBvZmZzZXQ6IGRvbUluZGV4KGFmdGVyKSArIDEgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkZXNjID0gc2Nhbi5wbVZpZXdEZXNjO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlc2MgJiYgZGVzYy5ub2RlICYmIGRlc2Mubm9kZS5pc0Jsb2NrKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHByZXYgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV07XG4gICAgICAgICAgICAgICAgYnJLbHVkZ2UgPSBwcmV2ICYmIChwcmV2Lm5vZGVOYW1lID09IFwiQlJcIiB8fCBwcmV2LmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEZpcmVmb3ggY2FuIGFjdCBzdHJhbmdlbHkgd2hlbiB0aGUgc2VsZWN0aW9uIGlzIGluIGZyb250IG9mIGFuXG4gICAgICAgIC8vIHVuZWRpdGFibGUgbm9kZS4gU2VlICMxMTYzIGFuZCBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xNzA5NTM2XG4gICAgICAgIGlmIChnZWNrbyAmJiBzZWxSYW5nZS5mb2N1c05vZGUgJiYgc2VsUmFuZ2UuZm9jdXNOb2RlICE9IGhlYWRET00ubm9kZSAmJiBzZWxSYW5nZS5mb2N1c05vZGUubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgbGV0IGFmdGVyID0gc2VsUmFuZ2UuZm9jdXNOb2RlLmNoaWxkTm9kZXNbc2VsUmFuZ2UuZm9jdXNPZmZzZXRdO1xuICAgICAgICAgICAgaWYgKGFmdGVyICYmIGFmdGVyLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpXG4gICAgICAgICAgICAgICAgZm9yY2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKGZvcmNlIHx8IGJyS2x1ZGdlICYmIHNhZmFyaSkgJiZcbiAgICAgICAgICAgIGlzRXF1aXZhbGVudFBvc2l0aW9uKGFuY2hvckRPTS5ub2RlLCBhbmNob3JET00ub2Zmc2V0LCBzZWxSYW5nZS5hbmNob3JOb2RlLCBzZWxSYW5nZS5hbmNob3JPZmZzZXQpICYmXG4gICAgICAgICAgICBpc0VxdWl2YWxlbnRQb3NpdGlvbihoZWFkRE9NLm5vZGUsIGhlYWRET00ub2Zmc2V0LCBzZWxSYW5nZS5mb2N1c05vZGUsIHNlbFJhbmdlLmZvY3VzT2Zmc2V0KSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gU2VsZWN0aW9uLmV4dGVuZCBjYW4gYmUgdXNlZCB0byBjcmVhdGUgYW4gJ2ludmVydGVkJyBzZWxlY3Rpb25cbiAgICAgICAgLy8gKG9uZSB3aGVyZSB0aGUgZm9jdXMgaXMgYmVmb3JlIHRoZSBhbmNob3IpLCBidXQgbm90IGFsbFxuICAgICAgICAvLyBicm93c2VycyBzdXBwb3J0IGl0IHlldC5cbiAgICAgICAgbGV0IGRvbVNlbEV4dGVuZGVkID0gZmFsc2U7XG4gICAgICAgIGlmICgoZG9tU2VsLmV4dGVuZCB8fCBhbmNob3IgPT0gaGVhZCkgJiYgIShicktsdWRnZSAmJiBnZWNrbykpIHtcbiAgICAgICAgICAgIGRvbVNlbC5jb2xsYXBzZShhbmNob3JET00ubm9kZSwgYW5jaG9yRE9NLm9mZnNldCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChhbmNob3IgIT0gaGVhZClcbiAgICAgICAgICAgICAgICAgICAgZG9tU2VsLmV4dGVuZChoZWFkRE9NLm5vZGUsIGhlYWRET00ub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBkb21TZWxFeHRlbmRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoXykge1xuICAgICAgICAgICAgICAgIC8vIEluIHNvbWUgY2FzZXMgd2l0aCBDaHJvbWUgdGhlIHNlbGVjdGlvbiBpcyBlbXB0eSBhZnRlciBjYWxsaW5nXG4gICAgICAgICAgICAgICAgLy8gY29sbGFwc2UsIGV2ZW4gd2hlbiBpdCBzaG91bGQgYmUgdmFsaWQuIFRoaXMgYXBwZWFycyB0byBiZSBhIGJ1ZywgYnV0XG4gICAgICAgICAgICAgICAgLy8gaXQgaXMgZGlmZmljdWx0IHRvIGlzb2xhdGUuIElmIHRoaXMgaGFwcGVucyBmYWxsYmFjayB0byB0aGUgb2xkIHBhdGhcbiAgICAgICAgICAgICAgICAvLyB3aXRob3V0IHVzaW5nIGV4dGVuZC5cbiAgICAgICAgICAgICAgICAvLyBTaW1pbGFybHksIHRoaXMgY291bGQgY3Jhc2ggb24gU2FmYXJpIGlmIHRoZSBlZGl0b3IgaXMgaGlkZGVuLCBhbmRcbiAgICAgICAgICAgICAgICAvLyB0aGVyZSB3YXMgbm8gc2VsZWN0aW9uLlxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghZG9tU2VsRXh0ZW5kZWQpIHtcbiAgICAgICAgICAgIGlmIChhbmNob3IgPiBoZWFkKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRtcCA9IGFuY2hvckRPTTtcbiAgICAgICAgICAgICAgICBhbmNob3JET00gPSBoZWFkRE9NO1xuICAgICAgICAgICAgICAgIGhlYWRET00gPSB0bXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgICAgICAgICAgcmFuZ2Uuc2V0RW5kKGhlYWRET00ubm9kZSwgaGVhZERPTS5vZmZzZXQpO1xuICAgICAgICAgICAgcmFuZ2Uuc2V0U3RhcnQoYW5jaG9yRE9NLm5vZGUsIGFuY2hvckRPTS5vZmZzZXQpO1xuICAgICAgICAgICAgZG9tU2VsLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICAgICAgZG9tU2VsLmFkZFJhbmdlKHJhbmdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZ25vcmVNdXRhdGlvbihtdXRhdGlvbikge1xuICAgICAgICByZXR1cm4gIXRoaXMuY29udGVudERPTSAmJiBtdXRhdGlvbi50eXBlICE9IFwic2VsZWN0aW9uXCI7XG4gICAgfVxuICAgIGdldCBjb250ZW50TG9zdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudERPTSAmJiB0aGlzLmNvbnRlbnRET00gIT0gdGhpcy5kb20gJiYgIXRoaXMuZG9tLmNvbnRhaW5zKHRoaXMuY29udGVudERPTSk7XG4gICAgfVxuICAgIC8vIFJlbW92ZSBhIHN1YnRyZWUgb2YgdGhlIGVsZW1lbnQgdHJlZSB0aGF0IGhhcyBiZWVuIHRvdWNoZWRcbiAgICAvLyBieSBhIERPTSBjaGFuZ2UsIHNvIHRoYXQgdGhlIG5leHQgdXBkYXRlIHdpbGwgcmVkcmF3IGl0LlxuICAgIG1hcmtEaXJ0eShmcm9tLCB0bykge1xuICAgICAgICBmb3IgKGxldCBvZmZzZXQgPSAwLCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IG9mZnNldCArIGNoaWxkLnNpemU7XG4gICAgICAgICAgICBpZiAob2Zmc2V0ID09IGVuZCA/IGZyb20gPD0gZW5kICYmIHRvID49IG9mZnNldCA6IGZyb20gPCBlbmQgJiYgdG8gPiBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnRJbnNpZGUgPSBvZmZzZXQgKyBjaGlsZC5ib3JkZXIsIGVuZEluc2lkZSA9IGVuZCAtIGNoaWxkLmJvcmRlcjtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA+PSBzdGFydEluc2lkZSAmJiB0byA8PSBlbmRJbnNpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IGZyb20gPT0gb2Zmc2V0IHx8IHRvID09IGVuZCA/IENPTlRFTlRfRElSVFkgOiBDSElMRF9ESVJUWTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyb20gPT0gc3RhcnRJbnNpZGUgJiYgdG8gPT0gZW5kSW5zaWRlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoY2hpbGQuY29udGVudExvc3QgfHwgY2hpbGQuZG9tLnBhcmVudE5vZGUgIT0gdGhpcy5jb250ZW50RE9NKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLmRpcnR5ID0gTk9ERV9ESVJUWTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQubWFya0RpcnR5KGZyb20gLSBzdGFydEluc2lkZSwgdG8gLSBzdGFydEluc2lkZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmRpcnR5ID0gY2hpbGQuZG9tID09IGNoaWxkLmNvbnRlbnRET00gJiYgY2hpbGQuZG9tLnBhcmVudE5vZGUgPT0gdGhpcy5jb250ZW50RE9NICYmICFjaGlsZC5jaGlsZHJlbi5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgID8gQ09OVEVOVF9ESVJUWSA6IE5PREVfRElSVFk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0ID0gZW5kO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGlydHkgPSBDT05URU5UX0RJUlRZO1xuICAgIH1cbiAgICBtYXJrUGFyZW50c0RpcnR5KCkge1xuICAgICAgICBsZXQgbGV2ZWwgPSAxO1xuICAgICAgICBmb3IgKGxldCBub2RlID0gdGhpcy5wYXJlbnQ7IG5vZGU7IG5vZGUgPSBub2RlLnBhcmVudCwgbGV2ZWwrKykge1xuICAgICAgICAgICAgbGV0IGRpcnR5ID0gbGV2ZWwgPT0gMSA/IENPTlRFTlRfRElSVFkgOiBDSElMRF9ESVJUWTtcbiAgICAgICAgICAgIGlmIChub2RlLmRpcnR5IDwgZGlydHkpXG4gICAgICAgICAgICAgICAgbm9kZS5kaXJ0eSA9IGRpcnR5O1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBkb21BdG9tKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBnZXQgaWdub3JlRm9yQ29vcmRzKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBnZXQgaWdub3JlRm9yU2VsZWN0aW9uKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBpc1RleHQodGV4dCkgeyByZXR1cm4gZmFsc2U7IH1cbn1cbi8vIEEgd2lkZ2V0IGRlc2MgcmVwcmVzZW50cyBhIHdpZGdldCBkZWNvcmF0aW9uLCB3aGljaCBpcyBhIERPTSBub2RlXG4vLyBkcmF3biBiZXR3ZWVuIHRoZSBkb2N1bWVudCBub2Rlcy5cbmNsYXNzIFdpZGdldFZpZXdEZXNjIGV4dGVuZHMgVmlld0Rlc2Mge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgd2lkZ2V0LCB2aWV3LCBwb3MpIHtcbiAgICAgICAgbGV0IHNlbGYsIGRvbSA9IHdpZGdldC50eXBlLnRvRE9NO1xuICAgICAgICBpZiAodHlwZW9mIGRvbSA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICBkb20gPSBkb20odmlldywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghc2VsZilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5wYXJlbnQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnBhcmVudC5wb3NCZWZvcmVDaGlsZChzZWxmKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBpZiAoIXdpZGdldC50eXBlLnNwZWMucmF3KSB7XG4gICAgICAgICAgICBpZiAoZG9tLm5vZGVUeXBlICE9IDEpIHtcbiAgICAgICAgICAgICAgICBsZXQgd3JhcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICAgICAgICAgIHdyYXAuYXBwZW5kQ2hpbGQoZG9tKTtcbiAgICAgICAgICAgICAgICBkb20gPSB3cmFwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9tLmNvbnRlbnRFZGl0YWJsZSA9IFwiZmFsc2VcIjtcbiAgICAgICAgICAgIGRvbS5jbGFzc0xpc3QuYWRkKFwiUHJvc2VNaXJyb3Itd2lkZ2V0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKHBhcmVudCwgW10sIGRvbSwgbnVsbCk7XG4gICAgICAgIHRoaXMud2lkZ2V0ID0gd2lkZ2V0O1xuICAgICAgICB0aGlzLndpZGdldCA9IHdpZGdldDtcbiAgICAgICAgc2VsZiA9IHRoaXM7XG4gICAgfVxuICAgIG1hdGNoZXNXaWRnZXQod2lkZ2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpcnR5ID09IE5PVF9ESVJUWSAmJiB3aWRnZXQudHlwZS5lcSh0aGlzLndpZGdldC50eXBlKTtcbiAgICB9XG4gICAgcGFyc2VSdWxlKCkgeyByZXR1cm4geyBpZ25vcmU6IHRydWUgfTsgfVxuICAgIHN0b3BFdmVudChldmVudCkge1xuICAgICAgICBsZXQgc3RvcCA9IHRoaXMud2lkZ2V0LnNwZWMuc3RvcEV2ZW50O1xuICAgICAgICByZXR1cm4gc3RvcCA/IHN0b3AoZXZlbnQpIDogZmFsc2U7XG4gICAgfVxuICAgIGlnbm9yZU11dGF0aW9uKG11dGF0aW9uKSB7XG4gICAgICAgIHJldHVybiBtdXRhdGlvbi50eXBlICE9IFwic2VsZWN0aW9uXCIgfHwgdGhpcy53aWRnZXQuc3BlYy5pZ25vcmVTZWxlY3Rpb247XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMud2lkZ2V0LnR5cGUuZGVzdHJveSh0aGlzLmRvbSk7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgZ2V0IGRvbUF0b20oKSB7IHJldHVybiB0cnVlOyB9XG4gICAgZ2V0IGlnbm9yZUZvclNlbGVjdGlvbigpIHsgcmV0dXJuICEhdGhpcy53aWRnZXQudHlwZS5zcGVjLnJlbGF4ZWRTaWRlOyB9XG4gICAgZ2V0IHNpZGUoKSB7IHJldHVybiB0aGlzLndpZGdldC50eXBlLnNpZGU7IH1cbn1cbmNsYXNzIENvbXBvc2l0aW9uVmlld0Rlc2MgZXh0ZW5kcyBWaWV3RGVzYyB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCBkb20sIHRleHRET00sIHRleHQpIHtcbiAgICAgICAgc3VwZXIocGFyZW50LCBbXSwgZG9tLCBudWxsKTtcbiAgICAgICAgdGhpcy50ZXh0RE9NID0gdGV4dERPTTtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7IHJldHVybiB0aGlzLnRleHQubGVuZ3RoOyB9XG4gICAgbG9jYWxQb3NGcm9tRE9NKGRvbSwgb2Zmc2V0KSB7XG4gICAgICAgIGlmIChkb20gIT0gdGhpcy50ZXh0RE9NKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucG9zQXRTdGFydCArIChvZmZzZXQgPyB0aGlzLnNpemUgOiAwKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zQXRTdGFydCArIG9mZnNldDtcbiAgICB9XG4gICAgZG9tRnJvbVBvcyhwb3MpIHtcbiAgICAgICAgcmV0dXJuIHsgbm9kZTogdGhpcy50ZXh0RE9NLCBvZmZzZXQ6IHBvcyB9O1xuICAgIH1cbiAgICBpZ25vcmVNdXRhdGlvbihtdXQpIHtcbiAgICAgICAgcmV0dXJuIG11dC50eXBlID09PSAnY2hhcmFjdGVyRGF0YScgJiYgbXV0LnRhcmdldC5ub2RlVmFsdWUgPT0gbXV0Lm9sZFZhbHVlO1xuICAgIH1cbn1cbi8vIEEgbWFyayBkZXNjIHJlcHJlc2VudHMgYSBtYXJrLiBNYXkgaGF2ZSBtdWx0aXBsZSBjaGlsZHJlbixcbi8vIGRlcGVuZGluZyBvbiBob3cgdGhlIG1hcmsgaXMgc3BsaXQuIE5vdGUgdGhhdCBtYXJrcyBhcmUgZHJhd24gdXNpbmdcbi8vIGEgZml4ZWQgbmVzdGluZyBvcmRlciwgZm9yIHNpbXBsaWNpdHkgYW5kIHByZWRpY3RhYmlsaXR5LCBzbyBpblxuLy8gc29tZSBjYXNlcyB0aGV5IHdpbGwgYmUgc3BsaXQgbW9yZSBvZnRlbiB0aGFuIHdvdWxkIGFwcGVhclxuLy8gbmVjZXNzYXJ5LlxuY2xhc3MgTWFya1ZpZXdEZXNjIGV4dGVuZHMgVmlld0Rlc2Mge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgbWFyaywgZG9tLCBjb250ZW50RE9NLCBzcGVjKSB7XG4gICAgICAgIHN1cGVyKHBhcmVudCwgW10sIGRvbSwgY29udGVudERPTSk7XG4gICAgICAgIHRoaXMubWFyayA9IG1hcms7XG4gICAgICAgIHRoaXMuc3BlYyA9IHNwZWM7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUocGFyZW50LCBtYXJrLCBpbmxpbmUsIHZpZXcpIHtcbiAgICAgICAgbGV0IGN1c3RvbSA9IHZpZXcubm9kZVZpZXdzW21hcmsudHlwZS5uYW1lXTtcbiAgICAgICAgbGV0IHNwZWMgPSBjdXN0b20gJiYgY3VzdG9tKG1hcmssIHZpZXcsIGlubGluZSk7XG4gICAgICAgIGlmICghc3BlYyB8fCAhc3BlYy5kb20pXG4gICAgICAgICAgICBzcGVjID0gRE9NU2VyaWFsaXplci5yZW5kZXJTcGVjKGRvY3VtZW50LCBtYXJrLnR5cGUuc3BlYy50b0RPTShtYXJrLCBpbmxpbmUpLCBudWxsLCBtYXJrLmF0dHJzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXJrVmlld0Rlc2MocGFyZW50LCBtYXJrLCBzcGVjLmRvbSwgc3BlYy5jb250ZW50RE9NIHx8IHNwZWMuZG9tLCBzcGVjKTtcbiAgICB9XG4gICAgcGFyc2VSdWxlKCkge1xuICAgICAgICBpZiAoKHRoaXMuZGlydHkgJiBOT0RFX0RJUlRZKSB8fCB0aGlzLm1hcmsudHlwZS5zcGVjLnJlcGFyc2VJblZpZXcpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIHsgbWFyazogdGhpcy5tYXJrLnR5cGUubmFtZSwgYXR0cnM6IHRoaXMubWFyay5hdHRycywgY29udGVudEVsZW1lbnQ6IHRoaXMuY29udGVudERPTSB9O1xuICAgIH1cbiAgICBtYXRjaGVzTWFyayhtYXJrKSB7IHJldHVybiB0aGlzLmRpcnR5ICE9IE5PREVfRElSVFkgJiYgdGhpcy5tYXJrLmVxKG1hcmspOyB9XG4gICAgbWFya0RpcnR5KGZyb20sIHRvKSB7XG4gICAgICAgIHN1cGVyLm1hcmtEaXJ0eShmcm9tLCB0byk7XG4gICAgICAgIC8vIE1vdmUgZGlydHkgaW5mbyB0byBuZWFyZXN0IG5vZGUgdmlld1xuICAgICAgICBpZiAodGhpcy5kaXJ0eSAhPSBOT1RfRElSVFkpIHtcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSB0aGlzLnBhcmVudDtcbiAgICAgICAgICAgIHdoaWxlICghcGFyZW50Lm5vZGUpXG4gICAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgICAgICAgIGlmIChwYXJlbnQuZGlydHkgPCB0aGlzLmRpcnR5KVxuICAgICAgICAgICAgICAgIHBhcmVudC5kaXJ0eSA9IHRoaXMuZGlydHk7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gTk9UX0RJUlRZO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNsaWNlKGZyb20sIHRvLCB2aWV3KSB7XG4gICAgICAgIGxldCBjb3B5ID0gTWFya1ZpZXdEZXNjLmNyZWF0ZSh0aGlzLnBhcmVudCwgdGhpcy5tYXJrLCB0cnVlLCB2aWV3KTtcbiAgICAgICAgbGV0IG5vZGVzID0gdGhpcy5jaGlsZHJlbiwgc2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICAgICAgaWYgKHRvIDwgc2l6ZSlcbiAgICAgICAgICAgIG5vZGVzID0gcmVwbGFjZU5vZGVzKG5vZGVzLCB0bywgc2l6ZSwgdmlldyk7XG4gICAgICAgIGlmIChmcm9tID4gMClcbiAgICAgICAgICAgIG5vZGVzID0gcmVwbGFjZU5vZGVzKG5vZGVzLCAwLCBmcm9tLCB2aWV3KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIG5vZGVzW2ldLnBhcmVudCA9IGNvcHk7XG4gICAgICAgIGNvcHkuY2hpbGRyZW4gPSBub2RlcztcbiAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfVxuICAgIGlnbm9yZU11dGF0aW9uKG11dGF0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNwZWMuaWdub3JlTXV0YXRpb24gPyB0aGlzLnNwZWMuaWdub3JlTXV0YXRpb24obXV0YXRpb24pIDogc3VwZXIuaWdub3JlTXV0YXRpb24obXV0YXRpb24pO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5zcGVjLmRlc3Ryb3kpXG4gICAgICAgICAgICB0aGlzLnNwZWMuZGVzdHJveSgpO1xuICAgICAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgfVxufVxuLy8gTm9kZSB2aWV3IGRlc2NzIGFyZSB0aGUgbWFpbiwgbW9zdCBjb21tb24gdHlwZSBvZiB2aWV3IGRlc2MsIGFuZFxuLy8gY29ycmVzcG9uZCB0byBhbiBhY3R1YWwgbm9kZSBpbiB0aGUgZG9jdW1lbnQuIFVubGlrZSBtYXJrIGRlc2NzLFxuLy8gdGhleSBwb3B1bGF0ZSB0aGVpciBjaGlsZCBhcnJheSB0aGVtc2VsdmVzLlxuY2xhc3MgTm9kZVZpZXdEZXNjIGV4dGVuZHMgVmlld0Rlc2Mge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGRvbSwgY29udGVudERPTSwgbm9kZURPTSwgdmlldywgcG9zKSB7XG4gICAgICAgIHN1cGVyKHBhcmVudCwgW10sIGRvbSwgY29udGVudERPTSk7XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgIHRoaXMub3V0ZXJEZWNvID0gb3V0ZXJEZWNvO1xuICAgICAgICB0aGlzLmlubmVyRGVjbyA9IGlubmVyRGVjbztcbiAgICAgICAgdGhpcy5ub2RlRE9NID0gbm9kZURPTTtcbiAgICB9XG4gICAgLy8gQnkgZGVmYXVsdCwgYSBub2RlIGlzIHJlbmRlcmVkIHVzaW5nIHRoZSBgdG9ET01gIG1ldGhvZCBmcm9tIHRoZVxuICAgIC8vIG5vZGUgdHlwZSBzcGVjLiBCdXQgY2xpZW50IGNvZGUgY2FuIHVzZSB0aGUgYG5vZGVWaWV3c2Agc3BlYyB0b1xuICAgIC8vIHN1cHBseSBhIGN1c3RvbSBub2RlIHZpZXcsIHdoaWNoIGNhbiBpbmZsdWVuY2UgdmFyaW91cyBhc3BlY3RzIG9mXG4gICAgLy8gdGhlIHdheSB0aGUgbm9kZSB3b3Jrcy5cbiAgICAvL1xuICAgIC8vIChVc2luZyBzdWJjbGFzc2luZyBmb3IgdGhpcyB3YXMgaW50ZW50aW9uYWxseSBkZWNpZGVkIGFnYWluc3QsXG4gICAgLy8gc2luY2UgaXQnZCByZXF1aXJlIGV4cG9zaW5nIGEgd2hvbGUgc2xldyBvZiBmaW5pY2t5XG4gICAgLy8gaW1wbGVtZW50YXRpb24gZGV0YWlscyB0byB0aGUgdXNlciBjb2RlIHRoYXQgdGhleSBwcm9iYWJseSB3aWxsXG4gICAgLy8gbmV2ZXIgbmVlZC4pXG4gICAgc3RhdGljIGNyZWF0ZShwYXJlbnQsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3LCBwb3MpIHtcbiAgICAgICAgbGV0IGN1c3RvbSA9IHZpZXcubm9kZVZpZXdzW25vZGUudHlwZS5uYW1lXSwgZGVzY09iajtcbiAgICAgICAgbGV0IHNwZWMgPSBjdXN0b20gJiYgY3VzdG9tKG5vZGUsIHZpZXcsICgpID0+IHtcbiAgICAgICAgICAgIC8vIChUaGlzIGlzIGEgZnVuY3Rpb24gdGhhdCBhbGxvd3MgdGhlIGN1c3RvbSB2aWV3IHRvIGZpbmQgaXRzXG4gICAgICAgICAgICAvLyBvd24gcG9zaXRpb24pXG4gICAgICAgICAgICBpZiAoIWRlc2NPYmopXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgICAgIGlmIChkZXNjT2JqLnBhcmVudClcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVzY09iai5wYXJlbnQucG9zQmVmb3JlQ2hpbGQoZGVzY09iaik7XG4gICAgICAgIH0sIG91dGVyRGVjbywgaW5uZXJEZWNvKTtcbiAgICAgICAgbGV0IGRvbSA9IHNwZWMgJiYgc3BlYy5kb20sIGNvbnRlbnRET00gPSBzcGVjICYmIHNwZWMuY29udGVudERPTTtcbiAgICAgICAgaWYgKG5vZGUuaXNUZXh0KSB7XG4gICAgICAgICAgICBpZiAoIWRvbSlcbiAgICAgICAgICAgICAgICBkb20gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShub2RlLnRleHQpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZG9tLm5vZGVUeXBlICE9IDMpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUZXh0IG11c3QgYmUgcmVuZGVyZWQgYXMgYSBET00gdGV4dCBub2RlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFkb20pIHtcbiAgICAgICAgICAgIGxldCBzcGVjID0gRE9NU2VyaWFsaXplci5yZW5kZXJTcGVjKGRvY3VtZW50LCBub2RlLnR5cGUuc3BlYy50b0RPTShub2RlKSwgbnVsbCwgbm9kZS5hdHRycyk7XG4gICAgICAgICAgICAoeyBkb20sIGNvbnRlbnRET00gfSA9IHNwZWMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29udGVudERPTSAmJiAhbm9kZS5pc1RleHQgJiYgZG9tLm5vZGVOYW1lICE9IFwiQlJcIikgeyAvLyBDaHJvbWUgZ2V0cyBjb25mdXNlZCBieSA8YnIgY29udGVudGVkaXRhYmxlPWZhbHNlPlxuICAgICAgICAgICAgaWYgKCFkb20uaGFzQXR0cmlidXRlKFwiY29udGVudGVkaXRhYmxlXCIpKVxuICAgICAgICAgICAgICAgIGRvbS5jb250ZW50RWRpdGFibGUgPSBcImZhbHNlXCI7XG4gICAgICAgICAgICBpZiAobm9kZS50eXBlLnNwZWMuZHJhZ2dhYmxlKVxuICAgICAgICAgICAgICAgIGRvbS5kcmFnZ2FibGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBub2RlRE9NID0gZG9tO1xuICAgICAgICBkb20gPSBhcHBseU91dGVyRGVjbyhkb20sIG91dGVyRGVjbywgbm9kZSk7XG4gICAgICAgIGlmIChzcGVjKVxuICAgICAgICAgICAgcmV0dXJuIGRlc2NPYmogPSBuZXcgQ3VzdG9tTm9kZVZpZXdEZXNjKHBhcmVudCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGRvbSwgY29udGVudERPTSB8fCBudWxsLCBub2RlRE9NLCBzcGVjLCB2aWV3LCBwb3MgKyAxKTtcbiAgICAgICAgZWxzZSBpZiAobm9kZS5pc1RleHQpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFRleHRWaWV3RGVzYyhwYXJlbnQsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBkb20sIG5vZGVET00sIHZpZXcpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gbmV3IE5vZGVWaWV3RGVzYyhwYXJlbnQsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBkb20sIGNvbnRlbnRET00gfHwgbnVsbCwgbm9kZURPTSwgdmlldywgcG9zICsgMSk7XG4gICAgfVxuICAgIHBhcnNlUnVsZSgpIHtcbiAgICAgICAgLy8gRXhwZXJpbWVudGFsIGtsdWRnZSB0byBhbGxvdyBvcHQtaW4gcmUtcGFyc2luZyBvZiBub2Rlc1xuICAgICAgICBpZiAodGhpcy5ub2RlLnR5cGUuc3BlYy5yZXBhcnNlSW5WaWV3KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIC8vIEZJWE1FIHRoZSBhc3N1bXB0aW9uIHRoYXQgdGhpcyBjYW4gYWx3YXlzIHJldHVybiB0aGUgY3VycmVudFxuICAgICAgICAvLyBhdHRycyBtZWFucyB0aGF0IGlmIHRoZSB1c2VyIHNvbWVob3cgbWFuYWdlcyB0byBjaGFuZ2UgdGhlXG4gICAgICAgIC8vIGF0dHJzIGluIHRoZSBkb20sIHRoYXQgd29uJ3QgYmUgcGlja2VkIHVwLiBOb3QgZW50aXJlbHkgc3VyZVxuICAgICAgICAvLyB3aGV0aGVyIHRoaXMgaXMgYSBwcm9ibGVtXG4gICAgICAgIGxldCBydWxlID0geyBub2RlOiB0aGlzLm5vZGUudHlwZS5uYW1lLCBhdHRyczogdGhpcy5ub2RlLmF0dHJzIH07XG4gICAgICAgIGlmICh0aGlzLm5vZGUudHlwZS53aGl0ZXNwYWNlID09IFwicHJlXCIpXG4gICAgICAgICAgICBydWxlLnByZXNlcnZlV2hpdGVzcGFjZSA9IFwiZnVsbFwiO1xuICAgICAgICBpZiAoIXRoaXMuY29udGVudERPTSkge1xuICAgICAgICAgICAgcnVsZS5nZXRDb250ZW50ID0gKCkgPT4gdGhpcy5ub2RlLmNvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuY29udGVudExvc3QpIHtcbiAgICAgICAgICAgIHJ1bGUuY29udGVudEVsZW1lbnQgPSB0aGlzLmNvbnRlbnRET007XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBDaHJvbWUgbGlrZXMgdG8gcmFuZG9tbHkgcmVjcmVhdGUgcGFyZW50IG5vZGVzIHdoZW5cbiAgICAgICAgICAgIC8vIGJhY2tzcGFjaW5nIHRoaW5ncy4gV2hlbiB0aGF0IGhhcHBlbnMsIHRoaXMgdHJpZXMgdG8gZmluZCB0aGVcbiAgICAgICAgICAgIC8vIG5ldyBwYXJlbnQuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZG9tLmNvbnRhaW5zKGNoaWxkLmRvbS5wYXJlbnROb2RlKSkge1xuICAgICAgICAgICAgICAgICAgICBydWxlLmNvbnRlbnRFbGVtZW50ID0gY2hpbGQuZG9tLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcnVsZS5jb250ZW50RWxlbWVudClcbiAgICAgICAgICAgICAgICBydWxlLmdldENvbnRlbnQgPSAoKSA9PiBGcmFnbWVudC5lbXB0eTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnVsZTtcbiAgICB9XG4gICAgbWF0Y2hlc05vZGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlydHkgPT0gTk9UX0RJUlRZICYmIG5vZGUuZXEodGhpcy5ub2RlKSAmJlxuICAgICAgICAgICAgc2FtZU91dGVyRGVjbyhvdXRlckRlY28sIHRoaXMub3V0ZXJEZWNvKSAmJiBpbm5lckRlY28uZXEodGhpcy5pbm5lckRlY28pO1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHsgcmV0dXJuIHRoaXMubm9kZS5ub2RlU2l6ZTsgfVxuICAgIGdldCBib3JkZXIoKSB7IHJldHVybiB0aGlzLm5vZGUuaXNMZWFmID8gMCA6IDE7IH1cbiAgICAvLyBTeW5jcyBgdGhpcy5jaGlsZHJlbmAgdG8gbWF0Y2ggYHRoaXMubm9kZS5jb250ZW50YCBhbmQgdGhlIGxvY2FsXG4gICAgLy8gZGVjb3JhdGlvbnMsIHBvc3NpYmx5IGludHJvZHVjaW5nIG5lc3RpbmcgZm9yIG1hcmtzLiBUaGVuLCBpbiBhXG4gICAgLy8gc2VwYXJhdGUgc3RlcCwgc3luY3MgdGhlIERPTSBpbnNpZGUgYHRoaXMuY29udGVudERPTWAgdG9cbiAgICAvLyBgdGhpcy5jaGlsZHJlbmAuXG4gICAgdXBkYXRlQ2hpbGRyZW4odmlldywgcG9zKSB7XG4gICAgICAgIGxldCBpbmxpbmUgPSB0aGlzLm5vZGUuaW5saW5lQ29udGVudCwgb2ZmID0gcG9zO1xuICAgICAgICBsZXQgY29tcG9zaXRpb24gPSB2aWV3LmNvbXBvc2luZyA/IHRoaXMubG9jYWxDb21wb3NpdGlvbkluZm8odmlldywgcG9zKSA6IG51bGw7XG4gICAgICAgIGxldCBsb2NhbENvbXBvc2l0aW9uID0gY29tcG9zaXRpb24gJiYgY29tcG9zaXRpb24ucG9zID4gLTEgPyBjb21wb3NpdGlvbiA6IG51bGw7XG4gICAgICAgIGxldCBjb21wb3NpdGlvbkluQ2hpbGQgPSBjb21wb3NpdGlvbiAmJiBjb21wb3NpdGlvbi5wb3MgPCAwO1xuICAgICAgICBsZXQgdXBkYXRlciA9IG5ldyBWaWV3VHJlZVVwZGF0ZXIodGhpcywgbG9jYWxDb21wb3NpdGlvbiAmJiBsb2NhbENvbXBvc2l0aW9uLm5vZGUsIHZpZXcpO1xuICAgICAgICBpdGVyRGVjbyh0aGlzLm5vZGUsIHRoaXMuaW5uZXJEZWNvLCAod2lkZ2V0LCBpLCBpbnNpZGVOb2RlKSA9PiB7XG4gICAgICAgICAgICBpZiAod2lkZ2V0LnNwZWMubWFya3MpXG4gICAgICAgICAgICAgICAgdXBkYXRlci5zeW5jVG9NYXJrcyh3aWRnZXQuc3BlYy5tYXJrcywgaW5saW5lLCB2aWV3KTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHdpZGdldC50eXBlLnNpZGUgPj0gMCAmJiAhaW5zaWRlTm9kZSlcbiAgICAgICAgICAgICAgICB1cGRhdGVyLnN5bmNUb01hcmtzKGkgPT0gdGhpcy5ub2RlLmNoaWxkQ291bnQgPyBNYXJrLm5vbmUgOiB0aGlzLm5vZGUuY2hpbGQoaSkubWFya3MsIGlubGluZSwgdmlldyk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgbmV4dCBub2RlIGlzIGEgZGVzYyBtYXRjaGluZyB0aGlzIHdpZGdldCwgcmV1c2UgaXQsXG4gICAgICAgICAgICAvLyBvdGhlcndpc2UgaW5zZXJ0IHRoZSB3aWRnZXQgYXMgYSBuZXcgdmlldyBkZXNjLlxuICAgICAgICAgICAgdXBkYXRlci5wbGFjZVdpZGdldCh3aWRnZXQsIHZpZXcsIG9mZik7XG4gICAgICAgIH0sIChjaGlsZCwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGkpID0+IHtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgd3JhcHBpbmcgbWFyayBkZXNjcyBtYXRjaCB0aGUgbm9kZSdzIG1hcmtzLlxuICAgICAgICAgICAgdXBkYXRlci5zeW5jVG9NYXJrcyhjaGlsZC5tYXJrcywgaW5saW5lLCB2aWV3KTtcbiAgICAgICAgICAgIC8vIFRyeSBzZXZlcmFsIHN0cmF0ZWdpZXMgZm9yIGRyYXdpbmcgdGhpcyBub2RlXG4gICAgICAgICAgICBsZXQgY29tcEluZGV4O1xuICAgICAgICAgICAgaWYgKHVwZGF0ZXIuZmluZE5vZGVNYXRjaChjaGlsZCwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGkpKSA7XG4gICAgICAgICAgICBlbHNlIGlmIChjb21wb3NpdGlvbkluQ2hpbGQgJiYgdmlldy5zdGF0ZS5zZWxlY3Rpb24uZnJvbSA+IG9mZiAmJlxuICAgICAgICAgICAgICAgIHZpZXcuc3RhdGUuc2VsZWN0aW9uLnRvIDwgb2ZmICsgY2hpbGQubm9kZVNpemUgJiZcbiAgICAgICAgICAgICAgICAoY29tcEluZGV4ID0gdXBkYXRlci5maW5kSW5kZXhXaXRoQ2hpbGQoY29tcG9zaXRpb24ubm9kZSkpID4gLTEgJiZcbiAgICAgICAgICAgICAgICB1cGRhdGVyLnVwZGF0ZU5vZGVBdChjaGlsZCwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGNvbXBJbmRleCwgdmlldykpIDtcbiAgICAgICAgICAgIGVsc2UgaWYgKHVwZGF0ZXIudXBkYXRlTmV4dE5vZGUoY2hpbGQsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3LCBpLCBvZmYpKSA7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBBZGQgaXQgYXMgYSBuZXcgdmlld1xuICAgICAgICAgICAgICAgIHVwZGF0ZXIuYWRkTm9kZShjaGlsZCwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcsIG9mZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmYgKz0gY2hpbGQubm9kZVNpemU7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBEcm9wIGFsbCByZW1haW5pbmcgZGVzY3MgYWZ0ZXIgdGhlIGN1cnJlbnQgcG9zaXRpb24uXG4gICAgICAgIHVwZGF0ZXIuc3luY1RvTWFya3MoW10sIGlubGluZSwgdmlldyk7XG4gICAgICAgIGlmICh0aGlzLm5vZGUuaXNUZXh0YmxvY2spXG4gICAgICAgICAgICB1cGRhdGVyLmFkZFRleHRibG9ja0hhY2tzKCk7XG4gICAgICAgIHVwZGF0ZXIuZGVzdHJveVJlc3QoKTtcbiAgICAgICAgLy8gU3luYyB0aGUgRE9NIGlmIGFueXRoaW5nIGNoYW5nZWRcbiAgICAgICAgaWYgKHVwZGF0ZXIuY2hhbmdlZCB8fCB0aGlzLmRpcnR5ID09IENPTlRFTlRfRElSVFkpIHtcbiAgICAgICAgICAgIC8vIE1heSBoYXZlIHRvIHByb3RlY3QgZm9jdXNlZCBET00gZnJvbSBiZWluZyBjaGFuZ2VkIGlmIGEgY29tcG9zaXRpb24gaXMgYWN0aXZlXG4gICAgICAgICAgICBpZiAobG9jYWxDb21wb3NpdGlvbilcbiAgICAgICAgICAgICAgICB0aGlzLnByb3RlY3RMb2NhbENvbXBvc2l0aW9uKHZpZXcsIGxvY2FsQ29tcG9zaXRpb24pO1xuICAgICAgICAgICAgcmVuZGVyRGVzY3ModGhpcy5jb250ZW50RE9NLCB0aGlzLmNoaWxkcmVuLCB2aWV3KTtcbiAgICAgICAgICAgIGlmIChpb3MpXG4gICAgICAgICAgICAgICAgaW9zSGFja3ModGhpcy5kb20pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxvY2FsQ29tcG9zaXRpb25JbmZvKHZpZXcsIHBvcykge1xuICAgICAgICAvLyBPbmx5IGRvIHNvbWV0aGluZyBpZiBib3RoIHRoZSBzZWxlY3Rpb24gYW5kIGEgZm9jdXNlZCB0ZXh0IG5vZGVcbiAgICAgICAgLy8gYXJlIGluc2lkZSBvZiB0aGlzIG5vZGVcbiAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBpZiAoISh2aWV3LnN0YXRlLnNlbGVjdGlvbiBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24pIHx8IGZyb20gPCBwb3MgfHwgdG8gPiBwb3MgKyB0aGlzLm5vZGUuY29udGVudC5zaXplKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCB0ZXh0Tm9kZSA9IHZpZXcuaW5wdXQuY29tcG9zaXRpb25Ob2RlO1xuICAgICAgICBpZiAoIXRleHROb2RlIHx8ICF0aGlzLmRvbS5jb250YWlucyh0ZXh0Tm9kZS5wYXJlbnROb2RlKSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpZiAodGhpcy5ub2RlLmlubGluZUNvbnRlbnQpIHtcbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIHRleHQgaW4gdGhlIGZvY3VzZWQgbm9kZSBpbiB0aGUgbm9kZSwgc3RvcCBpZiBpdCdzIG5vdFxuICAgICAgICAgICAgLy8gdGhlcmUgKG1heSBoYXZlIGJlZW4gbW9kaWZpZWQgdGhyb3VnaCBvdGhlciBtZWFucywgaW4gd2hpY2hcbiAgICAgICAgICAgIC8vIGNhc2UgaXQgc2hvdWxkIG92ZXJ3cml0dGVuKVxuICAgICAgICAgICAgbGV0IHRleHQgPSB0ZXh0Tm9kZS5ub2RlVmFsdWU7XG4gICAgICAgICAgICBsZXQgdGV4dFBvcyA9IGZpbmRUZXh0SW5GcmFnbWVudCh0aGlzLm5vZGUuY29udGVudCwgdGV4dCwgZnJvbSAtIHBvcywgdG8gLSBwb3MpO1xuICAgICAgICAgICAgcmV0dXJuIHRleHRQb3MgPCAwID8gbnVsbCA6IHsgbm9kZTogdGV4dE5vZGUsIHBvczogdGV4dFBvcywgdGV4dCB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHsgbm9kZTogdGV4dE5vZGUsIHBvczogLTEsIHRleHQ6IFwiXCIgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwcm90ZWN0TG9jYWxDb21wb3NpdGlvbih2aWV3LCB7IG5vZGUsIHBvcywgdGV4dCB9KSB7XG4gICAgICAgIC8vIFRoZSBub2RlIGlzIGFscmVhZHkgcGFydCBvZiBhIGxvY2FsIHZpZXcgZGVzYywgbGVhdmUgaXQgdGhlcmVcbiAgICAgICAgaWYgKHRoaXMuZ2V0RGVzYyhub2RlKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gQ3JlYXRlIGEgY29tcG9zaXRpb24gdmlldyBmb3IgdGhlIG9ycGhhbmVkIG5vZGVzXG4gICAgICAgIGxldCB0b3BOb2RlID0gbm9kZTtcbiAgICAgICAgZm9yICg7OyB0b3BOb2RlID0gdG9wTm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBpZiAodG9wTm9kZS5wYXJlbnROb2RlID09IHRoaXMuY29udGVudERPTSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHdoaWxlICh0b3BOb2RlLnByZXZpb3VzU2libGluZylcbiAgICAgICAgICAgICAgICB0b3BOb2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodG9wTm9kZS5wcmV2aW91c1NpYmxpbmcpO1xuICAgICAgICAgICAgd2hpbGUgKHRvcE5vZGUubmV4dFNpYmxpbmcpXG4gICAgICAgICAgICAgICAgdG9wTm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRvcE5vZGUubmV4dFNpYmxpbmcpO1xuICAgICAgICAgICAgaWYgKHRvcE5vZGUucG1WaWV3RGVzYylcbiAgICAgICAgICAgICAgICB0b3BOb2RlLnBtVmlld0Rlc2MgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRlc2MgPSBuZXcgQ29tcG9zaXRpb25WaWV3RGVzYyh0aGlzLCB0b3BOb2RlLCBub2RlLCB0ZXh0KTtcbiAgICAgICAgdmlldy5pbnB1dC5jb21wb3NpdGlvbk5vZGVzLnB1c2goZGVzYyk7XG4gICAgICAgIC8vIFBhdGNoIHVwIHRoaXMuY2hpbGRyZW4gdG8gY29udGFpbiB0aGUgY29tcG9zaXRpb24gdmlld1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gcmVwbGFjZU5vZGVzKHRoaXMuY2hpbGRyZW4sIHBvcywgcG9zICsgdGV4dC5sZW5ndGgsIHZpZXcsIGRlc2MpO1xuICAgIH1cbiAgICAvLyBJZiB0aGlzIGRlc2MgbXVzdCBiZSB1cGRhdGVkIHRvIG1hdGNoIHRoZSBnaXZlbiBub2RlIGRlY29yYXRpb24sXG4gICAgLy8gZG8gc28gYW5kIHJldHVybiB0cnVlLlxuICAgIHVwZGF0ZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldykge1xuICAgICAgICBpZiAodGhpcy5kaXJ0eSA9PSBOT0RFX0RJUlRZIHx8XG4gICAgICAgICAgICAhbm9kZS5zYW1lTWFya3VwKHRoaXMubm9kZSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMudXBkYXRlSW5uZXIobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdXBkYXRlSW5uZXIobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcpIHtcbiAgICAgICAgdGhpcy51cGRhdGVPdXRlckRlY28ob3V0ZXJEZWNvKTtcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgdGhpcy5pbm5lckRlY28gPSBpbm5lckRlY287XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnRET00pXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUNoaWxkcmVuKHZpZXcsIHRoaXMucG9zQXRTdGFydCk7XG4gICAgICAgIHRoaXMuZGlydHkgPSBOT1RfRElSVFk7XG4gICAgfVxuICAgIHVwZGF0ZU91dGVyRGVjbyhvdXRlckRlY28pIHtcbiAgICAgICAgaWYgKHNhbWVPdXRlckRlY28ob3V0ZXJEZWNvLCB0aGlzLm91dGVyRGVjbykpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBuZWVkc1dyYXAgPSB0aGlzLm5vZGVET00ubm9kZVR5cGUgIT0gMTtcbiAgICAgICAgbGV0IG9sZERPTSA9IHRoaXMuZG9tO1xuICAgICAgICB0aGlzLmRvbSA9IHBhdGNoT3V0ZXJEZWNvKHRoaXMuZG9tLCB0aGlzLm5vZGVET00sIGNvbXB1dGVPdXRlckRlY28odGhpcy5vdXRlckRlY28sIHRoaXMubm9kZSwgbmVlZHNXcmFwKSwgY29tcHV0ZU91dGVyRGVjbyhvdXRlckRlY28sIHRoaXMubm9kZSwgbmVlZHNXcmFwKSk7XG4gICAgICAgIGlmICh0aGlzLmRvbSAhPSBvbGRET00pIHtcbiAgICAgICAgICAgIG9sZERPTS5wbVZpZXdEZXNjID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5kb20ucG1WaWV3RGVzYyA9IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vdXRlckRlY28gPSBvdXRlckRlY287XG4gICAgfVxuICAgIC8vIE1hcmsgdGhpcyBub2RlIGFzIGJlaW5nIHRoZSBzZWxlY3RlZCBub2RlLlxuICAgIHNlbGVjdE5vZGUoKSB7XG4gICAgICAgIGlmICh0aGlzLm5vZGVET00ubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgdGhpcy5ub2RlRE9NLmNsYXNzTGlzdC5hZGQoXCJQcm9zZU1pcnJvci1zZWxlY3RlZG5vZGVcIik7XG4gICAgICAgICAgICBpZiAodGhpcy5jb250ZW50RE9NIHx8ICF0aGlzLm5vZGUudHlwZS5zcGVjLmRyYWdnYWJsZSlcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVET00uZHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBSZW1vdmUgc2VsZWN0ZWQgbm9kZSBtYXJraW5nIGZyb20gdGhpcyBub2RlLlxuICAgIGRlc2VsZWN0Tm9kZSgpIHtcbiAgICAgICAgaWYgKHRoaXMubm9kZURPTS5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICAgICAgICB0aGlzLm5vZGVET00uY2xhc3NMaXN0LnJlbW92ZShcIlByb3NlTWlycm9yLXNlbGVjdGVkbm9kZVwiKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRlbnRET00gfHwgIXRoaXMubm9kZS50eXBlLnNwZWMuZHJhZ2dhYmxlKVxuICAgICAgICAgICAgICAgIHRoaXMubm9kZURPTS5yZW1vdmVBdHRyaWJ1dGUoXCJkcmFnZ2FibGVcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGRvbUF0b20oKSB7IHJldHVybiB0aGlzLm5vZGUuaXNBdG9tOyB9XG59XG4vLyBDcmVhdGUgYSB2aWV3IGRlc2MgZm9yIHRoZSB0b3AtbGV2ZWwgZG9jdW1lbnQgbm9kZSwgdG8gYmUgZXhwb3J0ZWRcbi8vIGFuZCB1c2VkIGJ5IHRoZSB2aWV3IGNsYXNzLlxuZnVuY3Rpb24gZG9jVmlld0Rlc2MoZG9jLCBvdXRlckRlY28sIGlubmVyRGVjbywgZG9tLCB2aWV3KSB7XG4gICAgYXBwbHlPdXRlckRlY28oZG9tLCBvdXRlckRlY28sIGRvYyk7XG4gICAgbGV0IGRvY1ZpZXcgPSBuZXcgTm9kZVZpZXdEZXNjKHVuZGVmaW5lZCwgZG9jLCBvdXRlckRlY28sIGlubmVyRGVjbywgZG9tLCBkb20sIGRvbSwgdmlldywgMCk7XG4gICAgaWYgKGRvY1ZpZXcuY29udGVudERPTSlcbiAgICAgICAgZG9jVmlldy51cGRhdGVDaGlsZHJlbih2aWV3LCAwKTtcbiAgICByZXR1cm4gZG9jVmlldztcbn1cbmNsYXNzIFRleHRWaWV3RGVzYyBleHRlbmRzIE5vZGVWaWV3RGVzYyB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgZG9tLCBub2RlRE9NLCB2aWV3KSB7XG4gICAgICAgIHN1cGVyKHBhcmVudCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGRvbSwgbnVsbCwgbm9kZURPTSwgdmlldywgMCk7XG4gICAgfVxuICAgIHBhcnNlUnVsZSgpIHtcbiAgICAgICAgbGV0IHNraXAgPSB0aGlzLm5vZGVET00ucGFyZW50Tm9kZTtcbiAgICAgICAgd2hpbGUgKHNraXAgJiYgc2tpcCAhPSB0aGlzLmRvbSAmJiAhc2tpcC5wbUlzRGVjbylcbiAgICAgICAgICAgIHNraXAgPSBza2lwLnBhcmVudE5vZGU7XG4gICAgICAgIHJldHVybiB7IHNraXA6IChza2lwIHx8IHRydWUpIH07XG4gICAgfVxuICAgIHVwZGF0ZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldykge1xuICAgICAgICBpZiAodGhpcy5kaXJ0eSA9PSBOT0RFX0RJUlRZIHx8ICh0aGlzLmRpcnR5ICE9IE5PVF9ESVJUWSAmJiAhdGhpcy5pblBhcmVudCgpKSB8fFxuICAgICAgICAgICAgIW5vZGUuc2FtZU1hcmt1cCh0aGlzLm5vZGUpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLnVwZGF0ZU91dGVyRGVjbyhvdXRlckRlY28pO1xuICAgICAgICBpZiAoKHRoaXMuZGlydHkgIT0gTk9UX0RJUlRZIHx8IG5vZGUudGV4dCAhPSB0aGlzLm5vZGUudGV4dCkgJiYgbm9kZS50ZXh0ICE9IHRoaXMubm9kZURPTS5ub2RlVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMubm9kZURPTS5ub2RlVmFsdWUgPSBub2RlLnRleHQ7XG4gICAgICAgICAgICBpZiAodmlldy50cmFja1dyaXRlcyA9PSB0aGlzLm5vZGVET00pXG4gICAgICAgICAgICAgICAgdmlldy50cmFja1dyaXRlcyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IE5PVF9ESVJUWTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGluUGFyZW50KCkge1xuICAgICAgICBsZXQgcGFyZW50RE9NID0gdGhpcy5wYXJlbnQuY29udGVudERPTTtcbiAgICAgICAgZm9yIChsZXQgbiA9IHRoaXMubm9kZURPTTsgbjsgbiA9IG4ucGFyZW50Tm9kZSlcbiAgICAgICAgICAgIGlmIChuID09IHBhcmVudERPTSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBkb21Gcm9tUG9zKHBvcykge1xuICAgICAgICByZXR1cm4geyBub2RlOiB0aGlzLm5vZGVET00sIG9mZnNldDogcG9zIH07XG4gICAgfVxuICAgIGxvY2FsUG9zRnJvbURPTShkb20sIG9mZnNldCwgYmlhcykge1xuICAgICAgICBpZiAoZG9tID09IHRoaXMubm9kZURPTSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBvc0F0U3RhcnQgKyBNYXRoLm1pbihvZmZzZXQsIHRoaXMubm9kZS50ZXh0Lmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBzdXBlci5sb2NhbFBvc0Zyb21ET00oZG9tLCBvZmZzZXQsIGJpYXMpO1xuICAgIH1cbiAgICBpZ25vcmVNdXRhdGlvbihtdXRhdGlvbikge1xuICAgICAgICByZXR1cm4gbXV0YXRpb24udHlwZSAhPSBcImNoYXJhY3RlckRhdGFcIiAmJiBtdXRhdGlvbi50eXBlICE9IFwic2VsZWN0aW9uXCI7XG4gICAgfVxuICAgIHNsaWNlKGZyb20sIHRvLCB2aWV3KSB7XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5ub2RlLmN1dChmcm9tLCB0byksIGRvbSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKG5vZGUudGV4dCk7XG4gICAgICAgIHJldHVybiBuZXcgVGV4dFZpZXdEZXNjKHRoaXMucGFyZW50LCBub2RlLCB0aGlzLm91dGVyRGVjbywgdGhpcy5pbm5lckRlY28sIGRvbSwgZG9tLCB2aWV3KTtcbiAgICB9XG4gICAgbWFya0RpcnR5KGZyb20sIHRvKSB7XG4gICAgICAgIHN1cGVyLm1hcmtEaXJ0eShmcm9tLCB0byk7XG4gICAgICAgIGlmICh0aGlzLmRvbSAhPSB0aGlzLm5vZGVET00gJiYgKGZyb20gPT0gMCB8fCB0byA9PSB0aGlzLm5vZGVET00ubm9kZVZhbHVlLmxlbmd0aCkpXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gTk9ERV9ESVJUWTtcbiAgICB9XG4gICAgZ2V0IGRvbUF0b20oKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGlzVGV4dCh0ZXh0KSB7IHJldHVybiB0aGlzLm5vZGUudGV4dCA9PSB0ZXh0OyB9XG59XG4vLyBBIGR1bW15IGRlc2MgdXNlZCB0byB0YWcgdHJhaWxpbmcgQlIgb3IgSU1HIG5vZGVzIGNyZWF0ZWQgdG8gd29ya1xuLy8gYXJvdW5kIGNvbnRlbnRFZGl0YWJsZSB0ZXJyaWJsZW5lc3MuXG5jbGFzcyBUcmFpbGluZ0hhY2tWaWV3RGVzYyBleHRlbmRzIFZpZXdEZXNjIHtcbiAgICBwYXJzZVJ1bGUoKSB7IHJldHVybiB7IGlnbm9yZTogdHJ1ZSB9OyB9XG4gICAgbWF0Y2hlc0hhY2sobm9kZU5hbWUpIHsgcmV0dXJuIHRoaXMuZGlydHkgPT0gTk9UX0RJUlRZICYmIHRoaXMuZG9tLm5vZGVOYW1lID09IG5vZGVOYW1lOyB9XG4gICAgZ2V0IGRvbUF0b20oKSB7IHJldHVybiB0cnVlOyB9XG4gICAgZ2V0IGlnbm9yZUZvckNvb3JkcygpIHsgcmV0dXJuIHRoaXMuZG9tLm5vZGVOYW1lID09IFwiSU1HXCI7IH1cbn1cbi8vIEEgc2VwYXJhdGUgc3ViY2xhc3MgaXMgdXNlZCBmb3IgY3VzdG9taXplZCBub2RlIHZpZXdzLCBzbyB0aGF0IHRoZVxuLy8gZXh0cmEgY2hlY2tzIG9ubHkgaGF2ZSB0byBiZSBtYWRlIGZvciBub2RlcyB0aGF0IGFyZSBhY3R1YWxseVxuLy8gY3VzdG9taXplZC5cbmNsYXNzIEN1c3RvbU5vZGVWaWV3RGVzYyBleHRlbmRzIE5vZGVWaWV3RGVzYyB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgZG9tLCBjb250ZW50RE9NLCBub2RlRE9NLCBzcGVjLCB2aWV3LCBwb3MpIHtcbiAgICAgICAgc3VwZXIocGFyZW50LCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgZG9tLCBjb250ZW50RE9NLCBub2RlRE9NLCB2aWV3LCBwb3MpO1xuICAgICAgICB0aGlzLnNwZWMgPSBzcGVjO1xuICAgIH1cbiAgICAvLyBBIGN1c3RvbSBgdXBkYXRlYCBtZXRob2QgZ2V0cyB0byBkZWNpZGUgd2hldGhlciB0aGUgdXBkYXRlIGdvZXNcbiAgICAvLyB0aHJvdWdoLiBJZiBpdCBkb2VzLCBhbmQgdGhlcmUncyBhIGBjb250ZW50RE9NYCBub2RlLCBvdXIgbG9naWNcbiAgICAvLyB1cGRhdGVzIHRoZSBjaGlsZHJlbi5cbiAgICB1cGRhdGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlydHkgPT0gTk9ERV9ESVJUWSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuc3BlYy51cGRhdGUgJiYgKHRoaXMubm9kZS50eXBlID09IG5vZGUudHlwZSB8fCB0aGlzLnNwZWMubXVsdGlUeXBlKSkge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuc3BlYy51cGRhdGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28pO1xuICAgICAgICAgICAgaWYgKHJlc3VsdClcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUlubmVyKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuY29udGVudERPTSAmJiAhbm9kZS5pc0xlYWYpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzdXBlci51cGRhdGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNlbGVjdE5vZGUoKSB7XG4gICAgICAgIHRoaXMuc3BlYy5zZWxlY3ROb2RlID8gdGhpcy5zcGVjLnNlbGVjdE5vZGUoKSA6IHN1cGVyLnNlbGVjdE5vZGUoKTtcbiAgICB9XG4gICAgZGVzZWxlY3ROb2RlKCkge1xuICAgICAgICB0aGlzLnNwZWMuZGVzZWxlY3ROb2RlID8gdGhpcy5zcGVjLmRlc2VsZWN0Tm9kZSgpIDogc3VwZXIuZGVzZWxlY3ROb2RlKCk7XG4gICAgfVxuICAgIHNldFNlbGVjdGlvbihhbmNob3IsIGhlYWQsIHZpZXcsIGZvcmNlKSB7XG4gICAgICAgIHRoaXMuc3BlYy5zZXRTZWxlY3Rpb24gPyB0aGlzLnNwZWMuc2V0U2VsZWN0aW9uKGFuY2hvciwgaGVhZCwgdmlldy5yb290KVxuICAgICAgICAgICAgOiBzdXBlci5zZXRTZWxlY3Rpb24oYW5jaG9yLCBoZWFkLCB2aWV3LCBmb3JjZSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLnNwZWMuZGVzdHJveSlcbiAgICAgICAgICAgIHRoaXMuc3BlYy5kZXN0cm95KCk7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgc3RvcEV2ZW50KGV2ZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNwZWMuc3RvcEV2ZW50ID8gdGhpcy5zcGVjLnN0b3BFdmVudChldmVudCkgOiBmYWxzZTtcbiAgICB9XG4gICAgaWdub3JlTXV0YXRpb24obXV0YXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BlYy5pZ25vcmVNdXRhdGlvbiA/IHRoaXMuc3BlYy5pZ25vcmVNdXRhdGlvbihtdXRhdGlvbikgOiBzdXBlci5pZ25vcmVNdXRhdGlvbihtdXRhdGlvbik7XG4gICAgfVxufVxuLy8gU3luYyB0aGUgY29udGVudCBvZiB0aGUgZ2l2ZW4gRE9NIG5vZGUgd2l0aCB0aGUgbm9kZXMgYXNzb2NpYXRlZFxuLy8gd2l0aCB0aGUgZ2l2ZW4gYXJyYXkgb2YgdmlldyBkZXNjcywgcmVjdXJzaW5nIGludG8gbWFyayBkZXNjc1xuLy8gYmVjYXVzZSB0aGlzIHNob3VsZCBzeW5jIHRoZSBzdWJ0cmVlIGZvciBhIHdob2xlIG5vZGUgYXQgYSB0aW1lLlxuZnVuY3Rpb24gcmVuZGVyRGVzY3MocGFyZW50RE9NLCBkZXNjcywgdmlldykge1xuICAgIGxldCBkb20gPSBwYXJlbnRET00uZmlyc3RDaGlsZCwgd3JpdHRlbiA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVzY3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGRlc2MgPSBkZXNjc1tpXSwgY2hpbGRET00gPSBkZXNjLmRvbTtcbiAgICAgICAgaWYgKGNoaWxkRE9NLnBhcmVudE5vZGUgPT0gcGFyZW50RE9NKSB7XG4gICAgICAgICAgICB3aGlsZSAoY2hpbGRET00gIT0gZG9tKSB7XG4gICAgICAgICAgICAgICAgZG9tID0gcm0oZG9tKTtcbiAgICAgICAgICAgICAgICB3cml0dGVuID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbSA9IGRvbS5uZXh0U2libGluZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdyaXR0ZW4gPSB0cnVlO1xuICAgICAgICAgICAgcGFyZW50RE9NLmluc2VydEJlZm9yZShjaGlsZERPTSwgZG9tKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVzYyBpbnN0YW5jZW9mIE1hcmtWaWV3RGVzYykge1xuICAgICAgICAgICAgbGV0IHBvcyA9IGRvbSA/IGRvbS5wcmV2aW91c1NpYmxpbmcgOiBwYXJlbnRET00ubGFzdENoaWxkO1xuICAgICAgICAgICAgcmVuZGVyRGVzY3MoZGVzYy5jb250ZW50RE9NLCBkZXNjLmNoaWxkcmVuLCB2aWV3KTtcbiAgICAgICAgICAgIGRvbSA9IHBvcyA/IHBvcy5uZXh0U2libGluZyA6IHBhcmVudERPTS5maXJzdENoaWxkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdoaWxlIChkb20pIHtcbiAgICAgICAgZG9tID0gcm0oZG9tKTtcbiAgICAgICAgd3JpdHRlbiA9IHRydWU7XG4gICAgfVxuICAgIGlmICh3cml0dGVuICYmIHZpZXcudHJhY2tXcml0ZXMgPT0gcGFyZW50RE9NKVxuICAgICAgICB2aWV3LnRyYWNrV3JpdGVzID0gbnVsbDtcbn1cbmNvbnN0IE91dGVyRGVjb0xldmVsID0gZnVuY3Rpb24gKG5vZGVOYW1lKSB7XG4gICAgaWYgKG5vZGVOYW1lKVxuICAgICAgICB0aGlzLm5vZGVOYW1lID0gbm9kZU5hbWU7XG59O1xuT3V0ZXJEZWNvTGV2ZWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmNvbnN0IG5vRGVjbyA9IFtuZXcgT3V0ZXJEZWNvTGV2ZWxdO1xuZnVuY3Rpb24gY29tcHV0ZU91dGVyRGVjbyhvdXRlckRlY28sIG5vZGUsIG5lZWRzV3JhcCkge1xuICAgIGlmIChvdXRlckRlY28ubGVuZ3RoID09IDApXG4gICAgICAgIHJldHVybiBub0RlY287XG4gICAgbGV0IHRvcCA9IG5lZWRzV3JhcCA/IG5vRGVjb1swXSA6IG5ldyBPdXRlckRlY29MZXZlbCwgcmVzdWx0ID0gW3RvcF07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRlckRlY28ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGF0dHJzID0gb3V0ZXJEZWNvW2ldLnR5cGUuYXR0cnM7XG4gICAgICAgIGlmICghYXR0cnMpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKGF0dHJzLm5vZGVOYW1lKVxuICAgICAgICAgICAgcmVzdWx0LnB1c2godG9wID0gbmV3IE91dGVyRGVjb0xldmVsKGF0dHJzLm5vZGVOYW1lKSk7XG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gYXR0cnMpIHtcbiAgICAgICAgICAgIGxldCB2YWwgPSBhdHRyc1tuYW1lXTtcbiAgICAgICAgICAgIGlmICh2YWwgPT0gbnVsbClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChuZWVkc1dyYXAgJiYgcmVzdWx0Lmxlbmd0aCA9PSAxKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRvcCA9IG5ldyBPdXRlckRlY29MZXZlbChub2RlLmlzSW5saW5lID8gXCJzcGFuXCIgOiBcImRpdlwiKSk7XG4gICAgICAgICAgICBpZiAobmFtZSA9PSBcImNsYXNzXCIpXG4gICAgICAgICAgICAgICAgdG9wLmNsYXNzID0gKHRvcC5jbGFzcyA/IHRvcC5jbGFzcyArIFwiIFwiIDogXCJcIikgKyB2YWw7XG4gICAgICAgICAgICBlbHNlIGlmIChuYW1lID09IFwic3R5bGVcIilcbiAgICAgICAgICAgICAgICB0b3Auc3R5bGUgPSAodG9wLnN0eWxlID8gdG9wLnN0eWxlICsgXCI7XCIgOiBcIlwiKSArIHZhbDtcbiAgICAgICAgICAgIGVsc2UgaWYgKG5hbWUgIT0gXCJub2RlTmFtZVwiKVxuICAgICAgICAgICAgICAgIHRvcFtuYW1lXSA9IHZhbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcGF0Y2hPdXRlckRlY28ob3V0ZXJET00sIG5vZGVET00sIHByZXZDb21wdXRlZCwgY3VyQ29tcHV0ZWQpIHtcbiAgICAvLyBTaG9ydGN1dCBmb3IgdHJpdmlhbCBjYXNlXG4gICAgaWYgKHByZXZDb21wdXRlZCA9PSBub0RlY28gJiYgY3VyQ29tcHV0ZWQgPT0gbm9EZWNvKVxuICAgICAgICByZXR1cm4gbm9kZURPTTtcbiAgICBsZXQgY3VyRE9NID0gbm9kZURPTTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1ckNvbXB1dGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBkZWNvID0gY3VyQ29tcHV0ZWRbaV0sIHByZXYgPSBwcmV2Q29tcHV0ZWRbaV07XG4gICAgICAgIGlmIChpKSB7XG4gICAgICAgICAgICBsZXQgcGFyZW50O1xuICAgICAgICAgICAgaWYgKHByZXYgJiYgcHJldi5ub2RlTmFtZSA9PSBkZWNvLm5vZGVOYW1lICYmIGN1ckRPTSAhPSBvdXRlckRPTSAmJlxuICAgICAgICAgICAgICAgIChwYXJlbnQgPSBjdXJET00ucGFyZW50Tm9kZSkgJiYgcGFyZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT0gZGVjby5ub2RlTmFtZSkge1xuICAgICAgICAgICAgICAgIGN1ckRPTSA9IHBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcmVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZGVjby5ub2RlTmFtZSk7XG4gICAgICAgICAgICAgICAgcGFyZW50LnBtSXNEZWNvID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoY3VyRE9NKTtcbiAgICAgICAgICAgICAgICBwcmV2ID0gbm9EZWNvWzBdO1xuICAgICAgICAgICAgICAgIGN1ckRPTSA9IHBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwYXRjaEF0dHJpYnV0ZXMoY3VyRE9NLCBwcmV2IHx8IG5vRGVjb1swXSwgZGVjbyk7XG4gICAgfVxuICAgIHJldHVybiBjdXJET007XG59XG5mdW5jdGlvbiBwYXRjaEF0dHJpYnV0ZXMoZG9tLCBwcmV2LCBjdXIpIHtcbiAgICBmb3IgKGxldCBuYW1lIGluIHByZXYpXG4gICAgICAgIGlmIChuYW1lICE9IFwiY2xhc3NcIiAmJiBuYW1lICE9IFwic3R5bGVcIiAmJiBuYW1lICE9IFwibm9kZU5hbWVcIiAmJiAhKG5hbWUgaW4gY3VyKSlcbiAgICAgICAgICAgIGRvbS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgZm9yIChsZXQgbmFtZSBpbiBjdXIpXG4gICAgICAgIGlmIChuYW1lICE9IFwiY2xhc3NcIiAmJiBuYW1lICE9IFwic3R5bGVcIiAmJiBuYW1lICE9IFwibm9kZU5hbWVcIiAmJiBjdXJbbmFtZV0gIT0gcHJldltuYW1lXSlcbiAgICAgICAgICAgIGRvbS5zZXRBdHRyaWJ1dGUobmFtZSwgY3VyW25hbWVdKTtcbiAgICBpZiAocHJldi5jbGFzcyAhPSBjdXIuY2xhc3MpIHtcbiAgICAgICAgbGV0IHByZXZMaXN0ID0gcHJldi5jbGFzcyA/IHByZXYuY2xhc3Muc3BsaXQoXCIgXCIpLmZpbHRlcihCb29sZWFuKSA6IFtdO1xuICAgICAgICBsZXQgY3VyTGlzdCA9IGN1ci5jbGFzcyA/IGN1ci5jbGFzcy5zcGxpdChcIiBcIikuZmlsdGVyKEJvb2xlYW4pIDogW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJldkxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoY3VyTGlzdC5pbmRleE9mKHByZXZMaXN0W2ldKSA9PSAtMSlcbiAgICAgICAgICAgICAgICBkb20uY2xhc3NMaXN0LnJlbW92ZShwcmV2TGlzdFtpXSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VyTGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChwcmV2TGlzdC5pbmRleE9mKGN1ckxpc3RbaV0pID09IC0xKVxuICAgICAgICAgICAgICAgIGRvbS5jbGFzc0xpc3QuYWRkKGN1ckxpc3RbaV0pO1xuICAgICAgICBpZiAoZG9tLmNsYXNzTGlzdC5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIGRvbS5yZW1vdmVBdHRyaWJ1dGUoXCJjbGFzc1wiKTtcbiAgICB9XG4gICAgaWYgKHByZXYuc3R5bGUgIT0gY3VyLnN0eWxlKSB7XG4gICAgICAgIGlmIChwcmV2LnN0eWxlKSB7XG4gICAgICAgICAgICBsZXQgcHJvcCA9IC9cXHMqKFtcXHdcXC1cXHhhMS1cXHVmZmZmXSspXFxzKjooPzpcIig/OlxcXFwufFteXCJdKSpcInwnKD86XFxcXC58W14nXSkqJ3xcXCguKj9cXCl8W147XSkqL2csIG07XG4gICAgICAgICAgICB3aGlsZSAobSA9IHByb3AuZXhlYyhwcmV2LnN0eWxlKSlcbiAgICAgICAgICAgICAgICBkb20uc3R5bGUucmVtb3ZlUHJvcGVydHkobVsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1ci5zdHlsZSlcbiAgICAgICAgICAgIGRvbS5zdHlsZS5jc3NUZXh0ICs9IGN1ci5zdHlsZTtcbiAgICB9XG59XG5mdW5jdGlvbiBhcHBseU91dGVyRGVjbyhkb20sIGRlY28sIG5vZGUpIHtcbiAgICByZXR1cm4gcGF0Y2hPdXRlckRlY28oZG9tLCBkb20sIG5vRGVjbywgY29tcHV0ZU91dGVyRGVjbyhkZWNvLCBub2RlLCBkb20ubm9kZVR5cGUgIT0gMSkpO1xufVxuZnVuY3Rpb24gc2FtZU91dGVyRGVjbyhhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAoIWFbaV0udHlwZS5lcShiW2ldLnR5cGUpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuLy8gUmVtb3ZlIGEgRE9NIG5vZGUgYW5kIHJldHVybiBpdHMgbmV4dCBzaWJsaW5nLlxuZnVuY3Rpb24gcm0oZG9tKSB7XG4gICAgbGV0IG5leHQgPSBkb20ubmV4dFNpYmxpbmc7XG4gICAgZG9tLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZG9tKTtcbiAgICByZXR1cm4gbmV4dDtcbn1cbi8vIEhlbHBlciBjbGFzcyBmb3IgaW5jcmVtZW50YWxseSB1cGRhdGluZyBhIHRyZWUgb2YgbWFyayBkZXNjcyBhbmRcbi8vIHRoZSB3aWRnZXQgYW5kIG5vZGUgZGVzY3MgaW5zaWRlIG9mIHRoZW0uXG5jbGFzcyBWaWV3VHJlZVVwZGF0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHRvcCwgbG9jaywgdmlldykge1xuICAgICAgICB0aGlzLmxvY2sgPSBsb2NrO1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICAvLyBJbmRleCBpbnRvIGB0aGlzLnRvcGAncyBjaGlsZCBhcnJheSwgcmVwcmVzZW50cyB0aGUgY3VycmVudFxuICAgICAgICAvLyB1cGRhdGUgcG9zaXRpb24uXG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICAvLyBXaGVuIGVudGVyaW5nIGEgbWFyaywgdGhlIGN1cnJlbnQgdG9wIGFuZCBpbmRleCBhcmUgcHVzaGVkXG4gICAgICAgIC8vIG9udG8gdGhpcy5cbiAgICAgICAgdGhpcy5zdGFjayA9IFtdO1xuICAgICAgICAvLyBUcmFja3Mgd2hldGhlciBhbnl0aGluZyB3YXMgY2hhbmdlZFxuICAgICAgICB0aGlzLmNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy50b3AgPSB0b3A7XG4gICAgICAgIHRoaXMucHJlTWF0Y2ggPSBwcmVNYXRjaCh0b3Aubm9kZS5jb250ZW50LCB0b3ApO1xuICAgIH1cbiAgICAvLyBEZXN0cm95IGFuZCByZW1vdmUgdGhlIGNoaWxkcmVuIGJldHdlZW4gdGhlIGdpdmVuIGluZGljZXMgaW5cbiAgICAvLyBgdGhpcy50b3BgLlxuICAgIGRlc3Ryb3lCZXR3ZWVuKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09IGVuZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspXG4gICAgICAgICAgICB0aGlzLnRvcC5jaGlsZHJlbltpXS5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMudG9wLmNoaWxkcmVuLnNwbGljZShzdGFydCwgZW5kIC0gc3RhcnQpO1xuICAgICAgICB0aGlzLmNoYW5nZWQgPSB0cnVlO1xuICAgIH1cbiAgICAvLyBEZXN0cm95IGFsbCByZW1haW5pbmcgY2hpbGRyZW4gaW4gYHRoaXMudG9wYC5cbiAgICBkZXN0cm95UmVzdCgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95QmV0d2Vlbih0aGlzLmluZGV4LCB0aGlzLnRvcC5jaGlsZHJlbi5sZW5ndGgpO1xuICAgIH1cbiAgICAvLyBTeW5jIHRoZSBjdXJyZW50IHN0YWNrIG9mIG1hcmsgZGVzY3Mgd2l0aCB0aGUgZ2l2ZW4gYXJyYXkgb2ZcbiAgICAvLyBtYXJrcywgcmV1c2luZyBleGlzdGluZyBtYXJrIGRlc2NzIHdoZW4gcG9zc2libGUuXG4gICAgc3luY1RvTWFya3MobWFya3MsIGlubGluZSwgdmlldykge1xuICAgICAgICBsZXQga2VlcCA9IDAsIGRlcHRoID0gdGhpcy5zdGFjay5sZW5ndGggPj4gMTtcbiAgICAgICAgbGV0IG1heEtlZXAgPSBNYXRoLm1pbihkZXB0aCwgbWFya3MubGVuZ3RoKTtcbiAgICAgICAgd2hpbGUgKGtlZXAgPCBtYXhLZWVwICYmXG4gICAgICAgICAgICAoa2VlcCA9PSBkZXB0aCAtIDEgPyB0aGlzLnRvcCA6IHRoaXMuc3RhY2tbKGtlZXAgKyAxKSA8PCAxXSlcbiAgICAgICAgICAgICAgICAubWF0Y2hlc01hcmsobWFya3Nba2VlcF0pICYmIG1hcmtzW2tlZXBdLnR5cGUuc3BlYy5zcGFubmluZyAhPT0gZmFsc2UpXG4gICAgICAgICAgICBrZWVwKys7XG4gICAgICAgIHdoaWxlIChrZWVwIDwgZGVwdGgpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveVJlc3QoKTtcbiAgICAgICAgICAgIHRoaXMudG9wLmRpcnR5ID0gTk9UX0RJUlRZO1xuICAgICAgICAgICAgdGhpcy5pbmRleCA9IHRoaXMuc3RhY2sucG9wKCk7XG4gICAgICAgICAgICB0aGlzLnRvcCA9IHRoaXMuc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChkZXB0aCA8IG1hcmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKHRoaXMudG9wLCB0aGlzLmluZGV4ICsgMSk7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSAtMTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmluZGV4OyBpIDwgTWF0aC5taW4odGhpcy5pbmRleCArIDMsIHRoaXMudG9wLmNoaWxkcmVuLmxlbmd0aCk7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gdGhpcy50b3AuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKG5leHQubWF0Y2hlc01hcmsobWFya3NbZGVwdGhdKSAmJiAhdGhpcy5pc0xvY2tlZChuZXh0LmRvbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSBpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm91bmQgPiAtMSkge1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZCA+IHRoaXMuaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXN0cm95QmV0d2Vlbih0aGlzLmluZGV4LCBmb3VuZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudG9wID0gdGhpcy50b3AuY2hpbGRyZW5bdGhpcy5pbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgbWFya0Rlc2MgPSBNYXJrVmlld0Rlc2MuY3JlYXRlKHRoaXMudG9wLCBtYXJrc1tkZXB0aF0sIGlubGluZSwgdmlldyk7XG4gICAgICAgICAgICAgICAgdGhpcy50b3AuY2hpbGRyZW4uc3BsaWNlKHRoaXMuaW5kZXgsIDAsIG1hcmtEZXNjKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRvcCA9IG1hcmtEZXNjO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgICAgIGRlcHRoKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVHJ5IHRvIGZpbmQgYSBub2RlIGRlc2MgbWF0Y2hpbmcgdGhlIGdpdmVuIGRhdGEuIFNraXAgb3ZlciBpdCBhbmRcbiAgICAvLyByZXR1cm4gdHJ1ZSB3aGVuIHN1Y2Nlc3NmdWwuXG4gICAgZmluZE5vZGVNYXRjaChub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgaW5kZXgpIHtcbiAgICAgICAgbGV0IGZvdW5kID0gLTEsIHRhcmdldERlc2M7XG4gICAgICAgIGlmIChpbmRleCA+PSB0aGlzLnByZU1hdGNoLmluZGV4ICYmXG4gICAgICAgICAgICAodGFyZ2V0RGVzYyA9IHRoaXMucHJlTWF0Y2gubWF0Y2hlc1tpbmRleCAtIHRoaXMucHJlTWF0Y2guaW5kZXhdKS5wYXJlbnQgPT0gdGhpcy50b3AgJiZcbiAgICAgICAgICAgIHRhcmdldERlc2MubWF0Y2hlc05vZGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28pKSB7XG4gICAgICAgICAgICBmb3VuZCA9IHRoaXMudG9wLmNoaWxkcmVuLmluZGV4T2YodGFyZ2V0RGVzYywgdGhpcy5pbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5pbmRleCwgZSA9IE1hdGgubWluKHRoaXMudG9wLmNoaWxkcmVuLmxlbmd0aCwgaSArIDUpOyBpIDwgZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy50b3AuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLm1hdGNoZXNOb2RlKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvKSAmJiAhdGhpcy5wcmVNYXRjaC5tYXRjaGVkLmhhcyhjaGlsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSBpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvdW5kIDwgMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5kZXN0cm95QmV0d2Vlbih0aGlzLmluZGV4LCBmb3VuZCk7XG4gICAgICAgIHRoaXMuaW5kZXgrKztcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHVwZGF0ZU5vZGVBdChub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgaW5kZXgsIHZpZXcpIHtcbiAgICAgICAgbGV0IGNoaWxkID0gdGhpcy50b3AuY2hpbGRyZW5baW5kZXhdO1xuICAgICAgICBpZiAoY2hpbGQuZGlydHkgPT0gTk9ERV9ESVJUWSAmJiBjaGlsZC5kb20gPT0gY2hpbGQuY29udGVudERPTSlcbiAgICAgICAgICAgIGNoaWxkLmRpcnR5ID0gQ09OVEVOVF9ESVJUWTtcbiAgICAgICAgaWYgKCFjaGlsZC51cGRhdGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLmRlc3Ryb3lCZXR3ZWVuKHRoaXMuaW5kZXgsIGluZGV4KTtcbiAgICAgICAgdGhpcy5pbmRleCsrO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZmluZEluZGV4V2l0aENoaWxkKGRvbU5vZGUpIHtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IHBhcmVudCA9IGRvbU5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIGlmICghcGFyZW50KVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIGlmIChwYXJlbnQgPT0gdGhpcy50b3AuY29udGVudERPTSkge1xuICAgICAgICAgICAgICAgIGxldCBkZXNjID0gZG9tTm9kZS5wbVZpZXdEZXNjO1xuICAgICAgICAgICAgICAgIGlmIChkZXNjKVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5pbmRleDsgaSA8IHRoaXMudG9wLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50b3AuY2hpbGRyZW5baV0gPT0gZGVzYylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbU5vZGUgPSBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVHJ5IHRvIHVwZGF0ZSB0aGUgbmV4dCBub2RlLCBpZiBhbnksIHRvIHRoZSBnaXZlbiBkYXRhLiBDaGVja3NcbiAgICAvLyBwcmUtbWF0Y2hlcyB0byBhdm9pZCBvdmVyd3JpdGluZyBub2RlcyB0aGF0IGNvdWxkIHN0aWxsIGJlIHVzZWQuXG4gICAgdXBkYXRlTmV4dE5vZGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcsIGluZGV4LCBwb3MpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuaW5kZXg7IGkgPCB0aGlzLnRvcC5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IG5leHQgPSB0aGlzLnRvcC5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmIChuZXh0IGluc3RhbmNlb2YgTm9kZVZpZXdEZXNjKSB7XG4gICAgICAgICAgICAgICAgbGV0IHByZU1hdGNoID0gdGhpcy5wcmVNYXRjaC5tYXRjaGVkLmdldChuZXh0KTtcbiAgICAgICAgICAgICAgICBpZiAocHJlTWF0Y2ggIT0gbnVsbCAmJiBwcmVNYXRjaCAhPSBpbmRleClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIGxldCBuZXh0RE9NID0gbmV4dC5kb20sIHVwZGF0ZWQ7XG4gICAgICAgICAgICAgICAgLy8gQ2FuJ3QgdXBkYXRlIGlmIG5leHRET00gaXMgb3IgY29udGFpbnMgdGhpcy5sb2NrLCBleGNlcHQgaWZcbiAgICAgICAgICAgICAgICAvLyBpdCdzIGEgdGV4dCBub2RlIHdob3NlIGNvbnRlbnQgYWxyZWFkeSBtYXRjaGVzIHRoZSBuZXcgdGV4dFxuICAgICAgICAgICAgICAgIC8vIGFuZCB3aG9zZSBkZWNvcmF0aW9ucyBtYXRjaCB0aGUgbmV3IG9uZXMuXG4gICAgICAgICAgICAgICAgbGV0IGxvY2tlZCA9IHRoaXMuaXNMb2NrZWQobmV4dERPTSkgJiZcbiAgICAgICAgICAgICAgICAgICAgIShub2RlLmlzVGV4dCAmJiBuZXh0Lm5vZGUgJiYgbmV4dC5ub2RlLmlzVGV4dCAmJiBuZXh0Lm5vZGVET00ubm9kZVZhbHVlID09IG5vZGUudGV4dCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dC5kaXJ0eSAhPSBOT0RFX0RJUlRZICYmIHNhbWVPdXRlckRlY28ob3V0ZXJEZWNvLCBuZXh0Lm91dGVyRGVjbykpO1xuICAgICAgICAgICAgICAgIGlmICghbG9ja2VkICYmIG5leHQudXBkYXRlKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3KSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlc3Ryb3lCZXR3ZWVuKHRoaXMuaW5kZXgsIGkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dC5kb20gIT0gbmV4dERPTSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFsb2NrZWQgJiYgKHVwZGF0ZWQgPSB0aGlzLnJlY3JlYXRlV3JhcHBlcihuZXh0LCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldywgcG9zKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXN0cm95QmV0d2Vlbih0aGlzLmluZGV4LCBpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b3AuY2hpbGRyZW5bdGhpcy5pbmRleF0gPSB1cGRhdGVkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodXBkYXRlZC5jb250ZW50RE9NKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVkLmRpcnR5ID0gQ09OVEVOVF9ESVJUWTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZWQudXBkYXRlQ2hpbGRyZW4odmlldywgcG9zICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVkLmRpcnR5ID0gTk9UX0RJUlRZO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gV2hlbiBhIG5vZGUgd2l0aCBjb250ZW50IGlzIHJlcGxhY2VkIGJ5IGEgZGlmZmVyZW50IG5vZGUgd2l0aFxuICAgIC8vIGlkZW50aWNhbCBjb250ZW50LCBtb3ZlIG92ZXIgaXRzIGNoaWxkcmVuLlxuICAgIHJlY3JlYXRlV3JhcHBlcihuZXh0LCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldywgcG9zKSB7XG4gICAgICAgIGlmIChuZXh0LmRpcnR5IHx8IG5vZGUuaXNBdG9tIHx8ICFuZXh0LmNoaWxkcmVuLmxlbmd0aCB8fFxuICAgICAgICAgICAgIW5leHQubm9kZS5jb250ZW50LmVxKG5vZGUuY29udGVudCkgfHxcbiAgICAgICAgICAgICFzYW1lT3V0ZXJEZWNvKG91dGVyRGVjbywgbmV4dC5vdXRlckRlY28pIHx8ICFpbm5lckRlY28uZXEobmV4dC5pbm5lckRlY28pKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCB3cmFwcGVyID0gTm9kZVZpZXdEZXNjLmNyZWF0ZSh0aGlzLnRvcCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcsIHBvcyk7XG4gICAgICAgIGlmICh3cmFwcGVyLmNvbnRlbnRET00pIHtcbiAgICAgICAgICAgIHdyYXBwZXIuY2hpbGRyZW4gPSBuZXh0LmNoaWxkcmVuO1xuICAgICAgICAgICAgbmV4dC5jaGlsZHJlbiA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgY2ggb2Ygd3JhcHBlci5jaGlsZHJlbilcbiAgICAgICAgICAgICAgICBjaC5wYXJlbnQgPSB3cmFwcGVyO1xuICAgICAgICB9XG4gICAgICAgIG5leHQuZGVzdHJveSgpO1xuICAgICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9XG4gICAgLy8gSW5zZXJ0IHRoZSBub2RlIGFzIGEgbmV3bHkgY3JlYXRlZCBub2RlIGRlc2MuXG4gICAgYWRkTm9kZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldywgcG9zKSB7XG4gICAgICAgIGxldCBkZXNjID0gTm9kZVZpZXdEZXNjLmNyZWF0ZSh0aGlzLnRvcCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcsIHBvcyk7XG4gICAgICAgIGlmIChkZXNjLmNvbnRlbnRET00pXG4gICAgICAgICAgICBkZXNjLnVwZGF0ZUNoaWxkcmVuKHZpZXcsIHBvcyArIDEpO1xuICAgICAgICB0aGlzLnRvcC5jaGlsZHJlbi5zcGxpY2UodGhpcy5pbmRleCsrLCAwLCBkZXNjKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgcGxhY2VXaWRnZXQod2lkZ2V0LCB2aWV3LCBwb3MpIHtcbiAgICAgICAgbGV0IG5leHQgPSB0aGlzLmluZGV4IDwgdGhpcy50b3AuY2hpbGRyZW4ubGVuZ3RoID8gdGhpcy50b3AuY2hpbGRyZW5bdGhpcy5pbmRleF0gOiBudWxsO1xuICAgICAgICBpZiAobmV4dCAmJiBuZXh0Lm1hdGNoZXNXaWRnZXQod2lkZ2V0KSAmJlxuICAgICAgICAgICAgKHdpZGdldCA9PSBuZXh0LndpZGdldCB8fCAhbmV4dC53aWRnZXQudHlwZS50b0RPTS5wYXJlbnROb2RlKSkge1xuICAgICAgICAgICAgdGhpcy5pbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGRlc2MgPSBuZXcgV2lkZ2V0Vmlld0Rlc2ModGhpcy50b3AsIHdpZGdldCwgdmlldywgcG9zKTtcbiAgICAgICAgICAgIHRoaXMudG9wLmNoaWxkcmVuLnNwbGljZSh0aGlzLmluZGV4KyssIDAsIGRlc2MpO1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBNYWtlIHN1cmUgYSB0ZXh0YmxvY2sgbG9va3MgYW5kIGJlaGF2ZXMgY29ycmVjdGx5IGluXG4gICAgLy8gY29udGVudEVkaXRhYmxlLlxuICAgIGFkZFRleHRibG9ja0hhY2tzKCkge1xuICAgICAgICBsZXQgbGFzdENoaWxkID0gdGhpcy50b3AuY2hpbGRyZW5bdGhpcy5pbmRleCAtIDFdLCBwYXJlbnQgPSB0aGlzLnRvcDtcbiAgICAgICAgd2hpbGUgKGxhc3RDaGlsZCBpbnN0YW5jZW9mIE1hcmtWaWV3RGVzYykge1xuICAgICAgICAgICAgcGFyZW50ID0gbGFzdENoaWxkO1xuICAgICAgICAgICAgbGFzdENoaWxkID0gcGFyZW50LmNoaWxkcmVuW3BhcmVudC5jaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWxhc3RDaGlsZCB8fCAvLyBFbXB0eSB0ZXh0YmxvY2tcbiAgICAgICAgICAgICEobGFzdENoaWxkIGluc3RhbmNlb2YgVGV4dFZpZXdEZXNjKSB8fFxuICAgICAgICAgICAgL1xcbiQvLnRlc3QobGFzdENoaWxkLm5vZGUudGV4dCkgfHxcbiAgICAgICAgICAgICh0aGlzLnZpZXcucmVxdWlyZXNHZWNrb0hhY2tOb2RlICYmIC9cXHMkLy50ZXN0KGxhc3RDaGlsZC5ub2RlLnRleHQpKSkge1xuICAgICAgICAgICAgLy8gQXZvaWQgYnVncyBpbiBTYWZhcmkncyBjdXJzb3IgZHJhd2luZyAoIzExNjUpIGFuZCBDaHJvbWUncyBtb3VzZSBzZWxlY3Rpb24gKCMxMTUyKVxuICAgICAgICAgICAgaWYgKChzYWZhcmkgfHwgY2hyb21lKSAmJiBsYXN0Q2hpbGQgJiYgbGFzdENoaWxkLmRvbS5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKVxuICAgICAgICAgICAgICAgIHRoaXMuYWRkSGFja05vZGUoXCJJTUdcIiwgcGFyZW50KTtcbiAgICAgICAgICAgIHRoaXMuYWRkSGFja05vZGUoXCJCUlwiLCB0aGlzLnRvcCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkSGFja05vZGUobm9kZU5hbWUsIHBhcmVudCkge1xuICAgICAgICBpZiAocGFyZW50ID09IHRoaXMudG9wICYmIHRoaXMuaW5kZXggPCBwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoICYmIHBhcmVudC5jaGlsZHJlblt0aGlzLmluZGV4XS5tYXRjaGVzSGFjayhub2RlTmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMuaW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5vZGVOYW1lKTtcbiAgICAgICAgICAgIGlmIChub2RlTmFtZSA9PSBcIklNR1wiKSB7XG4gICAgICAgICAgICAgICAgZG9tLmNsYXNzTmFtZSA9IFwiUHJvc2VNaXJyb3Itc2VwYXJhdG9yXCI7XG4gICAgICAgICAgICAgICAgZG9tLmFsdCA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZU5hbWUgPT0gXCJCUlwiKVxuICAgICAgICAgICAgICAgIGRvbS5jbGFzc05hbWUgPSBcIlByb3NlTWlycm9yLXRyYWlsaW5nQnJlYWtcIjtcbiAgICAgICAgICAgIGxldCBoYWNrID0gbmV3IFRyYWlsaW5nSGFja1ZpZXdEZXNjKHRoaXMudG9wLCBbXSwgZG9tLCBudWxsKTtcbiAgICAgICAgICAgIGlmIChwYXJlbnQgIT0gdGhpcy50b3ApXG4gICAgICAgICAgICAgICAgcGFyZW50LmNoaWxkcmVuLnB1c2goaGFjayk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcGFyZW50LmNoaWxkcmVuLnNwbGljZSh0aGlzLmluZGV4KyssIDAsIGhhY2spO1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc0xvY2tlZChub2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2sgJiYgKG5vZGUgPT0gdGhpcy5sb2NrIHx8IG5vZGUubm9kZVR5cGUgPT0gMSAmJiBub2RlLmNvbnRhaW5zKHRoaXMubG9jay5wYXJlbnROb2RlKSk7XG4gICAgfVxufVxuLy8gSXRlcmF0ZSBmcm9tIHRoZSBlbmQgb2YgdGhlIGZyYWdtZW50IGFuZCBhcnJheSBvZiBkZXNjcyB0byBmaW5kXG4vLyBkaXJlY3RseSBtYXRjaGluZyBvbmVzLCBpbiBvcmRlciB0byBhdm9pZCBvdmVyZWFnZXJseSByZXVzaW5nIHRob3NlXG4vLyBmb3Igb3RoZXIgbm9kZXMuIFJldHVybnMgdGhlIGZyYWdtZW50IGluZGV4IG9mIHRoZSBmaXJzdCBub2RlIHRoYXRcbi8vIGlzIHBhcnQgb2YgdGhlIHNlcXVlbmNlIG9mIG1hdGNoZWQgbm9kZXMgYXQgdGhlIGVuZCBvZiB0aGVcbi8vIGZyYWdtZW50LlxuZnVuY3Rpb24gcHJlTWF0Y2goZnJhZywgcGFyZW50RGVzYykge1xuICAgIGxldCBjdXJEZXNjID0gcGFyZW50RGVzYywgZGVzY0kgPSBjdXJEZXNjLmNoaWxkcmVuLmxlbmd0aDtcbiAgICBsZXQgZkkgPSBmcmFnLmNoaWxkQ291bnQsIG1hdGNoZWQgPSBuZXcgTWFwLCBtYXRjaGVzID0gW107XG4gICAgb3V0ZXI6IHdoaWxlIChmSSA+IDApIHtcbiAgICAgICAgbGV0IGRlc2M7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGlmIChkZXNjSSkge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gY3VyRGVzYy5jaGlsZHJlbltkZXNjSSAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0IGluc3RhbmNlb2YgTWFya1ZpZXdEZXNjKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1ckRlc2MgPSBuZXh0O1xuICAgICAgICAgICAgICAgICAgICBkZXNjSSA9IG5leHQuY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVzYyA9IG5leHQ7XG4gICAgICAgICAgICAgICAgICAgIGRlc2NJLS07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGN1ckRlc2MgPT0gcGFyZW50RGVzYykge1xuICAgICAgICAgICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRklYTUVcbiAgICAgICAgICAgICAgICBkZXNjSSA9IGN1ckRlc2MucGFyZW50LmNoaWxkcmVuLmluZGV4T2YoY3VyRGVzYyk7XG4gICAgICAgICAgICAgICAgY3VyRGVzYyA9IGN1ckRlc2MucGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBub2RlID0gZGVzYy5ub2RlO1xuICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKG5vZGUgIT0gZnJhZy5jaGlsZChmSSAtIDEpKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC0tZkk7XG4gICAgICAgIG1hdGNoZWQuc2V0KGRlc2MsIGZJKTtcbiAgICAgICAgbWF0Y2hlcy5wdXNoKGRlc2MpO1xuICAgIH1cbiAgICByZXR1cm4geyBpbmRleDogZkksIG1hdGNoZWQsIG1hdGNoZXM6IG1hdGNoZXMucmV2ZXJzZSgpIH07XG59XG5mdW5jdGlvbiBjb21wYXJlU2lkZShhLCBiKSB7XG4gICAgcmV0dXJuIGEudHlwZS5zaWRlIC0gYi50eXBlLnNpZGU7XG59XG4vLyBUaGlzIGZ1bmN0aW9uIGFic3RyYWN0cyBpdGVyYXRpbmcgb3ZlciB0aGUgbm9kZXMgYW5kIGRlY29yYXRpb25zIGluXG4vLyBhIGZyYWdtZW50LiBDYWxscyBgb25Ob2RlYCBmb3IgZWFjaCBub2RlLCB3aXRoIGl0cyBsb2NhbCBhbmQgY2hpbGRcbi8vIGRlY29yYXRpb25zLiBTcGxpdHMgdGV4dCBub2RlcyB3aGVuIHRoZXJlIGlzIGEgZGVjb3JhdGlvbiBzdGFydGluZ1xuLy8gb3IgZW5kaW5nIGluc2lkZSBvZiB0aGVtLiBDYWxscyBgb25XaWRnZXRgIGZvciBlYWNoIHdpZGdldC5cbmZ1bmN0aW9uIGl0ZXJEZWNvKHBhcmVudCwgZGVjbywgb25XaWRnZXQsIG9uTm9kZSkge1xuICAgIGxldCBsb2NhbHMgPSBkZWNvLmxvY2FscyhwYXJlbnQpLCBvZmZzZXQgPSAwO1xuICAgIC8vIFNpbXBsZSwgY2hlYXAgdmFyaWFudCBmb3Igd2hlbiB0aGVyZSBhcmUgbm8gbG9jYWwgZGVjb3JhdGlvbnNcbiAgICBpZiAobG9jYWxzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyZW50LmNoaWxkQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gcGFyZW50LmNoaWxkKGkpO1xuICAgICAgICAgICAgb25Ob2RlKGNoaWxkLCBsb2NhbHMsIGRlY28uZm9yQ2hpbGQob2Zmc2V0LCBjaGlsZCksIGkpO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IGNoaWxkLm5vZGVTaXplO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGRlY29JbmRleCA9IDAsIGFjdGl2ZSA9IFtdLCByZXN0Tm9kZSA9IG51bGw7XG4gICAgZm9yIChsZXQgcGFyZW50SW5kZXggPSAwOzspIHtcbiAgICAgICAgbGV0IHdpZGdldCwgd2lkZ2V0cztcbiAgICAgICAgd2hpbGUgKGRlY29JbmRleCA8IGxvY2Fscy5sZW5ndGggJiYgbG9jYWxzW2RlY29JbmRleF0udG8gPT0gb2Zmc2V0KSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IGxvY2Fsc1tkZWNvSW5kZXgrK107XG4gICAgICAgICAgICBpZiAobmV4dC53aWRnZXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXdpZGdldClcbiAgICAgICAgICAgICAgICAgICAgd2lkZ2V0ID0gbmV4dDtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICh3aWRnZXRzIHx8ICh3aWRnZXRzID0gW3dpZGdldF0pKS5wdXNoKG5leHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh3aWRnZXQpIHtcbiAgICAgICAgICAgIGlmICh3aWRnZXRzKSB7XG4gICAgICAgICAgICAgICAgd2lkZ2V0cy5zb3J0KGNvbXBhcmVTaWRlKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdpZGdldHMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgICAgIG9uV2lkZ2V0KHdpZGdldHNbaV0sIHBhcmVudEluZGV4LCAhIXJlc3ROb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9uV2lkZ2V0KHdpZGdldCwgcGFyZW50SW5kZXgsICEhcmVzdE5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBjaGlsZCwgaW5kZXg7XG4gICAgICAgIGlmIChyZXN0Tm9kZSkge1xuICAgICAgICAgICAgaW5kZXggPSAtMTtcbiAgICAgICAgICAgIGNoaWxkID0gcmVzdE5vZGU7XG4gICAgICAgICAgICByZXN0Tm9kZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGFyZW50SW5kZXggPCBwYXJlbnQuY2hpbGRDb3VudCkge1xuICAgICAgICAgICAgaW5kZXggPSBwYXJlbnRJbmRleDtcbiAgICAgICAgICAgIGNoaWxkID0gcGFyZW50LmNoaWxkKHBhcmVudEluZGV4KyspO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhY3RpdmUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoYWN0aXZlW2ldLnRvIDw9IG9mZnNldClcbiAgICAgICAgICAgICAgICBhY3RpdmUuc3BsaWNlKGktLSwgMSk7XG4gICAgICAgIHdoaWxlIChkZWNvSW5kZXggPCBsb2NhbHMubGVuZ3RoICYmIGxvY2Fsc1tkZWNvSW5kZXhdLmZyb20gPD0gb2Zmc2V0ICYmIGxvY2Fsc1tkZWNvSW5kZXhdLnRvID4gb2Zmc2V0KVxuICAgICAgICAgICAgYWN0aXZlLnB1c2gobG9jYWxzW2RlY29JbmRleCsrXSk7XG4gICAgICAgIGxldCBlbmQgPSBvZmZzZXQgKyBjaGlsZC5ub2RlU2l6ZTtcbiAgICAgICAgaWYgKGNoaWxkLmlzVGV4dCkge1xuICAgICAgICAgICAgbGV0IGN1dEF0ID0gZW5kO1xuICAgICAgICAgICAgaWYgKGRlY29JbmRleCA8IGxvY2Fscy5sZW5ndGggJiYgbG9jYWxzW2RlY29JbmRleF0uZnJvbSA8IGN1dEF0KVxuICAgICAgICAgICAgICAgIGN1dEF0ID0gbG9jYWxzW2RlY29JbmRleF0uZnJvbTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWN0aXZlLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIGlmIChhY3RpdmVbaV0udG8gPCBjdXRBdClcbiAgICAgICAgICAgICAgICAgICAgY3V0QXQgPSBhY3RpdmVbaV0udG87XG4gICAgICAgICAgICBpZiAoY3V0QXQgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICByZXN0Tm9kZSA9IGNoaWxkLmN1dChjdXRBdCAtIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgY2hpbGQgPSBjaGlsZC5jdXQoMCwgY3V0QXQgLSBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIGVuZCA9IGN1dEF0O1xuICAgICAgICAgICAgICAgIGluZGV4ID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3aGlsZSAoZGVjb0luZGV4IDwgbG9jYWxzLmxlbmd0aCAmJiBsb2NhbHNbZGVjb0luZGV4XS50byA8IGVuZClcbiAgICAgICAgICAgICAgICBkZWNvSW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBsZXQgb3V0ZXJEZWNvID0gY2hpbGQuaXNJbmxpbmUgJiYgIWNoaWxkLmlzTGVhZiA/IGFjdGl2ZS5maWx0ZXIoZCA9PiAhZC5pbmxpbmUpIDogYWN0aXZlLnNsaWNlKCk7XG4gICAgICAgIG9uTm9kZShjaGlsZCwgb3V0ZXJEZWNvLCBkZWNvLmZvckNoaWxkKG9mZnNldCwgY2hpbGQpLCBpbmRleCk7XG4gICAgICAgIG9mZnNldCA9IGVuZDtcbiAgICB9XG59XG4vLyBMaXN0IG1hcmtlcnMgaW4gTW9iaWxlIFNhZmFyaSB3aWxsIG15c3RlcmlvdXNseSBkaXNhcHBlYXJcbi8vIHNvbWV0aW1lcy4gVGhpcyB3b3JrcyBhcm91bmQgdGhhdC5cbmZ1bmN0aW9uIGlvc0hhY2tzKGRvbSkge1xuICAgIGlmIChkb20ubm9kZU5hbWUgPT0gXCJVTFwiIHx8IGRvbS5ub2RlTmFtZSA9PSBcIk9MXCIpIHtcbiAgICAgICAgbGV0IG9sZENTUyA9IGRvbS5zdHlsZS5jc3NUZXh0O1xuICAgICAgICBkb20uc3R5bGUuY3NzVGV4dCA9IG9sZENTUyArIFwiOyBsaXN0LXN0eWxlOiBzcXVhcmUgIWltcG9ydGFudFwiO1xuICAgICAgICB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb20pLmxpc3RTdHlsZTtcbiAgICAgICAgZG9tLnN0eWxlLmNzc1RleHQgPSBvbGRDU1M7XG4gICAgfVxufVxuLy8gRmluZCBhIHBpZWNlIG9mIHRleHQgaW4gYW4gaW5saW5lIGZyYWdtZW50LCBvdmVybGFwcGluZyBmcm9tLXRvXG5mdW5jdGlvbiBmaW5kVGV4dEluRnJhZ21lbnQoZnJhZywgdGV4dCwgZnJvbSwgdG8pIHtcbiAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gMDsgaSA8IGZyYWcuY2hpbGRDb3VudCAmJiBwb3MgPD0gdG87KSB7XG4gICAgICAgIGxldCBjaGlsZCA9IGZyYWcuY2hpbGQoaSsrKSwgY2hpbGRTdGFydCA9IHBvcztcbiAgICAgICAgcG9zICs9IGNoaWxkLm5vZGVTaXplO1xuICAgICAgICBpZiAoIWNoaWxkLmlzVGV4dClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBsZXQgc3RyID0gY2hpbGQudGV4dDtcbiAgICAgICAgd2hpbGUgKGkgPCBmcmFnLmNoaWxkQ291bnQpIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gZnJhZy5jaGlsZChpKyspO1xuICAgICAgICAgICAgcG9zICs9IG5leHQubm9kZVNpemU7XG4gICAgICAgICAgICBpZiAoIW5leHQuaXNUZXh0KVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgc3RyICs9IG5leHQudGV4dDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zID49IGZyb20pIHtcbiAgICAgICAgICAgIGlmIChwb3MgPj0gdG8gJiYgc3RyLnNsaWNlKHRvIC0gdGV4dC5sZW5ndGggLSBjaGlsZFN0YXJ0LCB0byAtIGNoaWxkU3RhcnQpID09IHRleHQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvIC0gdGV4dC5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSBjaGlsZFN0YXJ0IDwgdG8gPyBzdHIubGFzdEluZGV4T2YodGV4dCwgdG8gLSBjaGlsZFN0YXJ0IC0gMSkgOiAtMTtcbiAgICAgICAgICAgIGlmIChmb3VuZCA+PSAwICYmIGZvdW5kICsgdGV4dC5sZW5ndGggKyBjaGlsZFN0YXJ0ID49IGZyb20pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkU3RhcnQgKyBmb3VuZDtcbiAgICAgICAgICAgIGlmIChmcm9tID09IHRvICYmIHN0ci5sZW5ndGggPj0gKHRvICsgdGV4dC5sZW5ndGgpIC0gY2hpbGRTdGFydCAmJlxuICAgICAgICAgICAgICAgIHN0ci5zbGljZSh0byAtIGNoaWxkU3RhcnQsIHRvIC0gY2hpbGRTdGFydCArIHRleHQubGVuZ3RoKSA9PSB0ZXh0KVxuICAgICAgICAgICAgICAgIHJldHVybiB0bztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG59XG4vLyBSZXBsYWNlIHJhbmdlIGZyb20tdG8gaW4gYW4gYXJyYXkgb2YgdmlldyBkZXNjcyB3aXRoIHJlcGxhY2VtZW50XG4vLyAobWF5IGJlIG51bGwgdG8ganVzdCBkZWxldGUpLiBUaGlzIGdvZXMgdmVyeSBtdWNoIGFnYWluc3QgdGhlIGdyYWluXG4vLyBvZiB0aGUgcmVzdCBvZiB0aGlzIGNvZGUsIHdoaWNoIHRlbmRzIHRvIGNyZWF0ZSBub2RlcyB3aXRoIHRoZVxuLy8gcmlnaHQgc2hhcGUgaW4gb25lIGdvLCByYXRoZXIgdGhhbiBtZXNzaW5nIHdpdGggdGhlbSBhZnRlclxuLy8gY3JlYXRpb24sIGJ1dCBpcyBuZWNlc3NhcnkgaW4gdGhlIGNvbXBvc2l0aW9uIGhhY2suXG5mdW5jdGlvbiByZXBsYWNlTm9kZXMobm9kZXMsIGZyb20sIHRvLCB2aWV3LCByZXBsYWNlbWVudCkge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgb2ZmID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBjaGlsZCA9IG5vZGVzW2ldLCBzdGFydCA9IG9mZiwgZW5kID0gb2ZmICs9IGNoaWxkLnNpemU7XG4gICAgICAgIGlmIChzdGFydCA+PSB0byB8fCBlbmQgPD0gZnJvbSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goY2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHN0YXJ0IDwgZnJvbSlcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjaGlsZC5zbGljZSgwLCBmcm9tIC0gc3RhcnQsIHZpZXcpKTtcbiAgICAgICAgICAgIGlmIChyZXBsYWNlbWVudCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHJlcGxhY2VtZW50KTtcbiAgICAgICAgICAgICAgICByZXBsYWNlbWVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbmQgPiB0bylcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjaGlsZC5zbGljZSh0byAtIHN0YXJ0LCBjaGlsZC5zaXplLCB2aWV3KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uRnJvbURPTSh2aWV3LCBvcmlnaW4gPSBudWxsKSB7XG4gICAgbGV0IGRvbVNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKSwgZG9jID0gdmlldy5zdGF0ZS5kb2M7XG4gICAgaWYgKCFkb21TZWwuZm9jdXNOb2RlKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgbmVhcmVzdERlc2MgPSB2aWV3LmRvY1ZpZXcubmVhcmVzdERlc2MoZG9tU2VsLmZvY3VzTm9kZSksIGluV2lkZ2V0ID0gbmVhcmVzdERlc2MgJiYgbmVhcmVzdERlc2Muc2l6ZSA9PSAwO1xuICAgIGxldCBoZWFkID0gdmlldy5kb2NWaWV3LnBvc0Zyb21ET00oZG9tU2VsLmZvY3VzTm9kZSwgZG9tU2VsLmZvY3VzT2Zmc2V0LCAxKTtcbiAgICBpZiAoaGVhZCA8IDApXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCAkaGVhZCA9IGRvYy5yZXNvbHZlKGhlYWQpLCBhbmNob3IsIHNlbGVjdGlvbjtcbiAgICBpZiAoc2VsZWN0aW9uQ29sbGFwc2VkKGRvbVNlbCkpIHtcbiAgICAgICAgYW5jaG9yID0gaGVhZDtcbiAgICAgICAgd2hpbGUgKG5lYXJlc3REZXNjICYmICFuZWFyZXN0RGVzYy5ub2RlKVxuICAgICAgICAgICAgbmVhcmVzdERlc2MgPSBuZWFyZXN0RGVzYy5wYXJlbnQ7XG4gICAgICAgIGxldCBuZWFyZXN0RGVzY05vZGUgPSBuZWFyZXN0RGVzYy5ub2RlO1xuICAgICAgICBpZiAobmVhcmVzdERlc2MgJiYgbmVhcmVzdERlc2NOb2RlLmlzQXRvbSAmJiBOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShuZWFyZXN0RGVzY05vZGUpICYmIG5lYXJlc3REZXNjLnBhcmVudFxuICAgICAgICAgICAgJiYgIShuZWFyZXN0RGVzY05vZGUuaXNJbmxpbmUgJiYgaXNPbkVkZ2UoZG9tU2VsLmZvY3VzTm9kZSwgZG9tU2VsLmZvY3VzT2Zmc2V0LCBuZWFyZXN0RGVzYy5kb20pKSkge1xuICAgICAgICAgICAgbGV0IHBvcyA9IG5lYXJlc3REZXNjLnBvc0JlZm9yZTtcbiAgICAgICAgICAgIHNlbGVjdGlvbiA9IG5ldyBOb2RlU2VsZWN0aW9uKGhlYWQgPT0gcG9zID8gJGhlYWQgOiBkb2MucmVzb2x2ZShwb3MpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGRvbVNlbCBpbnN0YW5jZW9mIHZpZXcuZG9tLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcuU2VsZWN0aW9uICYmIGRvbVNlbC5yYW5nZUNvdW50ID4gMSkge1xuICAgICAgICAgICAgbGV0IG1pbiA9IGhlYWQsIG1heCA9IGhlYWQ7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRvbVNlbC5yYW5nZUNvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgcmFuZ2UgPSBkb21TZWwuZ2V0UmFuZ2VBdChpKTtcbiAgICAgICAgICAgICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIHZpZXcuZG9jVmlldy5wb3NGcm9tRE9NKHJhbmdlLnN0YXJ0Q29udGFpbmVyLCByYW5nZS5zdGFydE9mZnNldCwgMSkpO1xuICAgICAgICAgICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgdmlldy5kb2NWaWV3LnBvc0Zyb21ET00ocmFuZ2UuZW5kQ29udGFpbmVyLCByYW5nZS5lbmRPZmZzZXQsIC0xKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWluIDwgMClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIFthbmNob3IsIGhlYWRdID0gbWF4ID09IHZpZXcuc3RhdGUuc2VsZWN0aW9uLmFuY2hvciA/IFttYXgsIG1pbl0gOiBbbWluLCBtYXhdO1xuICAgICAgICAgICAgJGhlYWQgPSBkb2MucmVzb2x2ZShoZWFkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFuY2hvciA9IHZpZXcuZG9jVmlldy5wb3NGcm9tRE9NKGRvbVNlbC5hbmNob3JOb2RlLCBkb21TZWwuYW5jaG9yT2Zmc2V0LCAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW5jaG9yIDwgMClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBsZXQgJGFuY2hvciA9IGRvYy5yZXNvbHZlKGFuY2hvcik7XG4gICAgaWYgKCFzZWxlY3Rpb24pIHtcbiAgICAgICAgbGV0IGJpYXMgPSBvcmlnaW4gPT0gXCJwb2ludGVyXCIgfHwgKHZpZXcuc3RhdGUuc2VsZWN0aW9uLmhlYWQgPCAkaGVhZC5wb3MgJiYgIWluV2lkZ2V0KSA/IDEgOiAtMTtcbiAgICAgICAgc2VsZWN0aW9uID0gc2VsZWN0aW9uQmV0d2Vlbih2aWV3LCAkYW5jaG9yLCAkaGVhZCwgYmlhcyk7XG4gICAgfVxuICAgIHJldHVybiBzZWxlY3Rpb247XG59XG5mdW5jdGlvbiBlZGl0b3JPd25zU2VsZWN0aW9uKHZpZXcpIHtcbiAgICByZXR1cm4gdmlldy5lZGl0YWJsZSA/IHZpZXcuaGFzRm9jdXMoKSA6XG4gICAgICAgIGhhc1NlbGVjdGlvbih2aWV3KSAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuY29udGFpbnModmlldy5kb20pO1xufVxuZnVuY3Rpb24gc2VsZWN0aW9uVG9ET00odmlldywgZm9yY2UgPSBmYWxzZSkge1xuICAgIGxldCBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICBzeW5jTm9kZVNlbGVjdGlvbih2aWV3LCBzZWwpO1xuICAgIGlmICghZWRpdG9yT3duc1NlbGVjdGlvbih2aWV3KSlcbiAgICAgICAgcmV0dXJuO1xuICAgIC8vIFRoZSBkZWxheWVkIGRyYWcgc2VsZWN0aW9uIGNhdXNlcyBpc3N1ZXMgd2l0aCBDZWxsIFNlbGVjdGlvbnNcbiAgICAvLyBpbiBTYWZhcmkuIEFuZCB0aGUgZHJhZyBzZWxlY3Rpb24gZGVsYXkgaXMgdG8gd29ya2Fyb25kIGlzc3Vlc1xuICAgIC8vIHdoaWNoIG9ubHkgcHJlc2VudCBpbiBDaHJvbWUuXG4gICAgaWYgKCFmb3JjZSAmJiB2aWV3LmlucHV0Lm1vdXNlRG93biAmJiB2aWV3LmlucHV0Lm1vdXNlRG93bi5hbGxvd0RlZmF1bHQgJiYgY2hyb21lKSB7XG4gICAgICAgIGxldCBkb21TZWwgPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCksIGN1clNlbCA9IHZpZXcuZG9tT2JzZXJ2ZXIuY3VycmVudFNlbGVjdGlvbjtcbiAgICAgICAgaWYgKGRvbVNlbC5hbmNob3JOb2RlICYmIGN1clNlbC5hbmNob3JOb2RlICYmXG4gICAgICAgICAgICBpc0VxdWl2YWxlbnRQb3NpdGlvbihkb21TZWwuYW5jaG9yTm9kZSwgZG9tU2VsLmFuY2hvck9mZnNldCwgY3VyU2VsLmFuY2hvck5vZGUsIGN1clNlbC5hbmNob3JPZmZzZXQpKSB7XG4gICAgICAgICAgICB2aWV3LmlucHV0Lm1vdXNlRG93bi5kZWxheWVkU2VsZWN0aW9uU3luYyA9IHRydWU7XG4gICAgICAgICAgICB2aWV3LmRvbU9ic2VydmVyLnNldEN1clNlbGVjdGlvbigpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZpZXcuZG9tT2JzZXJ2ZXIuZGlzY29ubmVjdFNlbGVjdGlvbigpO1xuICAgIGlmICh2aWV3LmN1cnNvcldyYXBwZXIpIHtcbiAgICAgICAgc2VsZWN0Q3Vyc29yV3JhcHBlcih2aWV3KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCB7IGFuY2hvciwgaGVhZCB9ID0gc2VsLCByZXNldEVkaXRhYmxlRnJvbSwgcmVzZXRFZGl0YWJsZVRvO1xuICAgICAgICBpZiAoYnJva2VuU2VsZWN0QmV0d2VlblVuZWRpdGFibGUgJiYgIShzZWwgaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgaWYgKCFzZWwuJGZyb20ucGFyZW50LmlubGluZUNvbnRlbnQpXG4gICAgICAgICAgICAgICAgcmVzZXRFZGl0YWJsZUZyb20gPSB0ZW1wb3JhcmlseUVkaXRhYmxlTmVhcih2aWV3LCBzZWwuZnJvbSk7XG4gICAgICAgICAgICBpZiAoIXNlbC5lbXB0eSAmJiAhc2VsLiRmcm9tLnBhcmVudC5pbmxpbmVDb250ZW50KVxuICAgICAgICAgICAgICAgIHJlc2V0RWRpdGFibGVUbyA9IHRlbXBvcmFyaWx5RWRpdGFibGVOZWFyKHZpZXcsIHNlbC50byk7XG4gICAgICAgIH1cbiAgICAgICAgdmlldy5kb2NWaWV3LnNldFNlbGVjdGlvbihhbmNob3IsIGhlYWQsIHZpZXcsIGZvcmNlKTtcbiAgICAgICAgaWYgKGJyb2tlblNlbGVjdEJldHdlZW5VbmVkaXRhYmxlKSB7XG4gICAgICAgICAgICBpZiAocmVzZXRFZGl0YWJsZUZyb20pXG4gICAgICAgICAgICAgICAgcmVzZXRFZGl0YWJsZShyZXNldEVkaXRhYmxlRnJvbSk7XG4gICAgICAgICAgICBpZiAocmVzZXRFZGl0YWJsZVRvKVxuICAgICAgICAgICAgICAgIHJlc2V0RWRpdGFibGUocmVzZXRFZGl0YWJsZVRvKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsLnZpc2libGUpIHtcbiAgICAgICAgICAgIHZpZXcuZG9tLmNsYXNzTGlzdC5yZW1vdmUoXCJQcm9zZU1pcnJvci1oaWRlc2VsZWN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmlldy5kb20uY2xhc3NMaXN0LmFkZChcIlByb3NlTWlycm9yLWhpZGVzZWxlY3Rpb25cIik7XG4gICAgICAgICAgICBpZiAoXCJvbnNlbGVjdGlvbmNoYW5nZVwiIGluIGRvY3VtZW50KVxuICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzT25TZWxlY3Rpb25DaGFuZ2Uodmlldyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmlldy5kb21PYnNlcnZlci5zZXRDdXJTZWxlY3Rpb24oKTtcbiAgICB2aWV3LmRvbU9ic2VydmVyLmNvbm5lY3RTZWxlY3Rpb24oKTtcbn1cbi8vIEtsdWRnZSB0byB3b3JrIGFyb3VuZCBXZWJraXQgbm90IGFsbG93aW5nIGEgc2VsZWN0aW9uIHRvIHN0YXJ0L2VuZFxuLy8gYmV0d2VlbiBub24tZWRpdGFibGUgYmxvY2sgbm9kZXMuIFdlIGJyaWVmbHkgbWFrZSBzb21ldGhpbmdcbi8vIGVkaXRhYmxlLCBzZXQgdGhlIHNlbGVjdGlvbiwgdGhlbiBzZXQgaXQgdW5lZGl0YWJsZSBhZ2Fpbi5cbmNvbnN0IGJyb2tlblNlbGVjdEJldHdlZW5VbmVkaXRhYmxlID0gc2FmYXJpIHx8IGNocm9tZSAmJiBjaHJvbWVfdmVyc2lvbiA8IDYzO1xuZnVuY3Rpb24gdGVtcG9yYXJpbHlFZGl0YWJsZU5lYXIodmlldywgcG9zKSB7XG4gICAgbGV0IHsgbm9kZSwgb2Zmc2V0IH0gPSB2aWV3LmRvY1ZpZXcuZG9tRnJvbVBvcyhwb3MsIDApO1xuICAgIGxldCBhZnRlciA9IG9mZnNldCA8IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggPyBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XSA6IG51bGw7XG4gICAgbGV0IGJlZm9yZSA9IG9mZnNldCA/IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXSA6IG51bGw7XG4gICAgaWYgKHNhZmFyaSAmJiBhZnRlciAmJiBhZnRlci5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKVxuICAgICAgICByZXR1cm4gc2V0RWRpdGFibGUoYWZ0ZXIpO1xuICAgIGlmICgoIWFmdGVyIHx8IGFmdGVyLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpICYmXG4gICAgICAgICghYmVmb3JlIHx8IGJlZm9yZS5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKSkge1xuICAgICAgICBpZiAoYWZ0ZXIpXG4gICAgICAgICAgICByZXR1cm4gc2V0RWRpdGFibGUoYWZ0ZXIpO1xuICAgICAgICBlbHNlIGlmIChiZWZvcmUpXG4gICAgICAgICAgICByZXR1cm4gc2V0RWRpdGFibGUoYmVmb3JlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzZXRFZGl0YWJsZShlbGVtZW50KSB7XG4gICAgZWxlbWVudC5jb250ZW50RWRpdGFibGUgPSBcInRydWVcIjtcbiAgICBpZiAoc2FmYXJpICYmIGVsZW1lbnQuZHJhZ2dhYmxlKSB7XG4gICAgICAgIGVsZW1lbnQuZHJhZ2dhYmxlID0gZmFsc2U7XG4gICAgICAgIGVsZW1lbnQud2FzRHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG59XG5mdW5jdGlvbiByZXNldEVkaXRhYmxlKGVsZW1lbnQpIHtcbiAgICBlbGVtZW50LmNvbnRlbnRFZGl0YWJsZSA9IFwiZmFsc2VcIjtcbiAgICBpZiAoZWxlbWVudC53YXNEcmFnZ2FibGUpIHtcbiAgICAgICAgZWxlbWVudC5kcmFnZ2FibGUgPSB0cnVlO1xuICAgICAgICBlbGVtZW50Lndhc0RyYWdnYWJsZSA9IG51bGw7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVtb3ZlQ2xhc3NPblNlbGVjdGlvbkNoYW5nZSh2aWV3KSB7XG4gICAgbGV0IGRvYyA9IHZpZXcuZG9tLm93bmVyRG9jdW1lbnQ7XG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzZWxlY3Rpb25jaGFuZ2VcIiwgdmlldy5pbnB1dC5oaWRlU2VsZWN0aW9uR3VhcmQpO1xuICAgIGxldCBkb21TZWwgPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgbGV0IG5vZGUgPSBkb21TZWwuYW5jaG9yTm9kZSwgb2Zmc2V0ID0gZG9tU2VsLmFuY2hvck9mZnNldDtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcihcInNlbGVjdGlvbmNoYW5nZVwiLCB2aWV3LmlucHV0LmhpZGVTZWxlY3Rpb25HdWFyZCA9ICgpID0+IHtcbiAgICAgICAgaWYgKGRvbVNlbC5hbmNob3JOb2RlICE9IG5vZGUgfHwgZG9tU2VsLmFuY2hvck9mZnNldCAhPSBvZmZzZXQpIHtcbiAgICAgICAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKFwic2VsZWN0aW9uY2hhbmdlXCIsIHZpZXcuaW5wdXQuaGlkZVNlbGVjdGlvbkd1YXJkKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghZWRpdG9yT3duc1NlbGVjdGlvbih2aWV3KSB8fCB2aWV3LnN0YXRlLnNlbGVjdGlvbi52aXNpYmxlKVxuICAgICAgICAgICAgICAgICAgICB2aWV3LmRvbS5jbGFzc0xpc3QucmVtb3ZlKFwiUHJvc2VNaXJyb3ItaGlkZXNlbGVjdGlvblwiKTtcbiAgICAgICAgICAgIH0sIDIwKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gc2VsZWN0Q3Vyc29yV3JhcHBlcih2aWV3KSB7XG4gICAgbGV0IGRvbVNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uKCk7XG4gICAgaWYgKCFkb21TZWwpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgbm9kZSA9IHZpZXcuY3Vyc29yV3JhcHBlci5kb20sIGltZyA9IG5vZGUubm9kZU5hbWUgPT0gXCJJTUdcIjtcbiAgICBpZiAoaW1nKVxuICAgICAgICBkb21TZWwuY29sbGFwc2Uobm9kZS5wYXJlbnROb2RlLCBkb21JbmRleChub2RlKSArIDEpO1xuICAgIGVsc2VcbiAgICAgICAgZG9tU2VsLmNvbGxhcHNlKG5vZGUsIDApO1xuICAgIC8vIEtsdWRnZSB0byBraWxsICdjb250cm9sIHNlbGVjdGlvbicgaW4gSUUxMSB3aGVuIHNlbGVjdGluZyBhblxuICAgIC8vIGludmlzaWJsZSBjdXJzb3Igd3JhcHBlciwgc2luY2UgdGhhdCB3b3VsZCByZXN1bHQgaW4gdGhvc2Ugd2VpcmRcbiAgICAvLyByZXNpemUgaGFuZGxlcyBhbmQgYSBzZWxlY3Rpb24gdGhhdCBjb25zaWRlcnMgdGhlIGFic29sdXRlbHlcbiAgICAvLyBwb3NpdGlvbmVkIHdyYXBwZXIsIHJhdGhlciB0aGFuIHRoZSByb290IGVkaXRhYmxlIG5vZGUsIHRoZVxuICAgIC8vIGZvY3VzZWQgZWxlbWVudC5cbiAgICBpZiAoIWltZyAmJiAhdmlldy5zdGF0ZS5zZWxlY3Rpb24udmlzaWJsZSAmJiBpZSAmJiBpZV92ZXJzaW9uIDw9IDExKSB7XG4gICAgICAgIG5vZGUuZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICBub2RlLmRpc2FibGVkID0gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gc3luY05vZGVTZWxlY3Rpb24odmlldywgc2VsKSB7XG4gICAgaWYgKHNlbCBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24pIHtcbiAgICAgICAgbGV0IGRlc2MgPSB2aWV3LmRvY1ZpZXcuZGVzY0F0KHNlbC5mcm9tKTtcbiAgICAgICAgaWYgKGRlc2MgIT0gdmlldy5sYXN0U2VsZWN0ZWRWaWV3RGVzYykge1xuICAgICAgICAgICAgY2xlYXJOb2RlU2VsZWN0aW9uKHZpZXcpO1xuICAgICAgICAgICAgaWYgKGRlc2MpXG4gICAgICAgICAgICAgICAgZGVzYy5zZWxlY3ROb2RlKCk7XG4gICAgICAgICAgICB2aWV3Lmxhc3RTZWxlY3RlZFZpZXdEZXNjID0gZGVzYztcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY2xlYXJOb2RlU2VsZWN0aW9uKHZpZXcpO1xuICAgIH1cbn1cbi8vIENsZWFyIGFsbCBET00gc3RhdGVmdWxuZXNzIG9mIHRoZSBsYXN0IG5vZGUgc2VsZWN0aW9uLlxuZnVuY3Rpb24gY2xlYXJOb2RlU2VsZWN0aW9uKHZpZXcpIHtcbiAgICBpZiAodmlldy5sYXN0U2VsZWN0ZWRWaWV3RGVzYykge1xuICAgICAgICBpZiAodmlldy5sYXN0U2VsZWN0ZWRWaWV3RGVzYy5wYXJlbnQpXG4gICAgICAgICAgICB2aWV3Lmxhc3RTZWxlY3RlZFZpZXdEZXNjLmRlc2VsZWN0Tm9kZSgpO1xuICAgICAgICB2aWV3Lmxhc3RTZWxlY3RlZFZpZXdEZXNjID0gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNlbGVjdGlvbkJldHdlZW4odmlldywgJGFuY2hvciwgJGhlYWQsIGJpYXMpIHtcbiAgICByZXR1cm4gdmlldy5zb21lUHJvcChcImNyZWF0ZVNlbGVjdGlvbkJldHdlZW5cIiwgZiA9PiBmKHZpZXcsICRhbmNob3IsICRoZWFkKSlcbiAgICAgICAgfHwgVGV4dFNlbGVjdGlvbi5iZXR3ZWVuKCRhbmNob3IsICRoZWFkLCBiaWFzKTtcbn1cbmZ1bmN0aW9uIGhhc0ZvY3VzQW5kU2VsZWN0aW9uKHZpZXcpIHtcbiAgICBpZiAodmlldy5lZGl0YWJsZSAmJiAhdmlldy5oYXNGb2N1cygpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIGhhc1NlbGVjdGlvbih2aWV3KTtcbn1cbmZ1bmN0aW9uIGhhc1NlbGVjdGlvbih2aWV3KSB7XG4gICAgbGV0IHNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICBpZiAoIXNlbC5hbmNob3JOb2RlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gRmlyZWZveCB3aWxsIHJhaXNlICdwZXJtaXNzaW9uIGRlbmllZCcgZXJyb3JzIHdoZW4gYWNjZXNzaW5nXG4gICAgICAgIC8vIHByb3BlcnRpZXMgb2YgYHNlbC5hbmNob3JOb2RlYCB3aGVuIGl0J3MgaW4gYSBnZW5lcmF0ZWQgQ1NTXG4gICAgICAgIC8vIGVsZW1lbnQuXG4gICAgICAgIHJldHVybiB2aWV3LmRvbS5jb250YWlucyhzZWwuYW5jaG9yTm9kZS5ub2RlVHlwZSA9PSAzID8gc2VsLmFuY2hvck5vZGUucGFyZW50Tm9kZSA6IHNlbC5hbmNob3JOb2RlKSAmJlxuICAgICAgICAgICAgKHZpZXcuZWRpdGFibGUgfHwgdmlldy5kb20uY29udGFpbnMoc2VsLmZvY3VzTm9kZS5ub2RlVHlwZSA9PSAzID8gc2VsLmZvY3VzTm9kZS5wYXJlbnROb2RlIDogc2VsLmZvY3VzTm9kZSkpO1xuICAgIH1cbiAgICBjYXRjaCAoXykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gYW5jaG9ySW5SaWdodFBsYWNlKHZpZXcpIHtcbiAgICBsZXQgYW5jaG9yRE9NID0gdmlldy5kb2NWaWV3LmRvbUZyb21Qb3Modmlldy5zdGF0ZS5zZWxlY3Rpb24uYW5jaG9yLCAwKTtcbiAgICBsZXQgZG9tU2VsID0gdmlldy5kb21TZWxlY3Rpb25SYW5nZSgpO1xuICAgIHJldHVybiBpc0VxdWl2YWxlbnRQb3NpdGlvbihhbmNob3JET00ubm9kZSwgYW5jaG9yRE9NLm9mZnNldCwgZG9tU2VsLmFuY2hvck5vZGUsIGRvbVNlbC5hbmNob3JPZmZzZXQpO1xufVxuXG5mdW5jdGlvbiBtb3ZlU2VsZWN0aW9uQmxvY2soc3RhdGUsIGRpcikge1xuICAgIGxldCB7ICRhbmNob3IsICRoZWFkIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgbGV0ICRzaWRlID0gZGlyID4gMCA/ICRhbmNob3IubWF4KCRoZWFkKSA6ICRhbmNob3IubWluKCRoZWFkKTtcbiAgICBsZXQgJHN0YXJ0ID0gISRzaWRlLnBhcmVudC5pbmxpbmVDb250ZW50ID8gJHNpZGUgOiAkc2lkZS5kZXB0aCA/IHN0YXRlLmRvYy5yZXNvbHZlKGRpciA+IDAgPyAkc2lkZS5hZnRlcigpIDogJHNpZGUuYmVmb3JlKCkpIDogbnVsbDtcbiAgICByZXR1cm4gJHN0YXJ0ICYmIFNlbGVjdGlvbi5maW5kRnJvbSgkc3RhcnQsIGRpcik7XG59XG5mdW5jdGlvbiBhcHBseSh2aWV3LCBzZWwpIHtcbiAgICB2aWV3LmRpc3BhdGNoKHZpZXcuc3RhdGUudHIuc2V0U2VsZWN0aW9uKHNlbCkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBzZWxlY3RIb3Jpem9udGFsbHkodmlldywgZGlyLCBtb2RzKSB7XG4gICAgbGV0IHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmIChzZWwgaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uKSB7XG4gICAgICAgIGlmIChtb2RzLmluZGV4T2YoXCJzXCIpID4gLTEpIHtcbiAgICAgICAgICAgIGxldCB7ICRoZWFkIH0gPSBzZWwsIG5vZGUgPSAkaGVhZC50ZXh0T2Zmc2V0ID8gbnVsbCA6IGRpciA8IDAgPyAkaGVhZC5ub2RlQmVmb3JlIDogJGhlYWQubm9kZUFmdGVyO1xuICAgICAgICAgICAgaWYgKCFub2RlIHx8IG5vZGUuaXNUZXh0IHx8ICFub2RlLmlzTGVhZilcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBsZXQgJG5ld0hlYWQgPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKCRoZWFkLnBvcyArIG5vZGUubm9kZVNpemUgKiAoZGlyIDwgMCA/IC0xIDogMSkpO1xuICAgICAgICAgICAgcmV0dXJuIGFwcGx5KHZpZXcsIG5ldyBUZXh0U2VsZWN0aW9uKHNlbC4kYW5jaG9yLCAkbmV3SGVhZCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFzZWwuZW1wdHkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2aWV3LmVuZE9mVGV4dGJsb2NrKGRpciA+IDAgPyBcImZvcndhcmRcIiA6IFwiYmFja3dhcmRcIikpIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gbW92ZVNlbGVjdGlvbkJsb2NrKHZpZXcuc3RhdGUsIGRpcik7XG4gICAgICAgICAgICBpZiAobmV4dCAmJiAobmV4dCBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24pKVxuICAgICAgICAgICAgICAgIHJldHVybiBhcHBseSh2aWV3LCBuZXh0KTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghKG1hYyAmJiBtb2RzLmluZGV4T2YoXCJtXCIpID4gLTEpKSB7XG4gICAgICAgICAgICBsZXQgJGhlYWQgPSBzZWwuJGhlYWQsIG5vZGUgPSAkaGVhZC50ZXh0T2Zmc2V0ID8gbnVsbCA6IGRpciA8IDAgPyAkaGVhZC5ub2RlQmVmb3JlIDogJGhlYWQubm9kZUFmdGVyLCBkZXNjO1xuICAgICAgICAgICAgaWYgKCFub2RlIHx8IG5vZGUuaXNUZXh0KVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGxldCBub2RlUG9zID0gZGlyIDwgMCA/ICRoZWFkLnBvcyAtIG5vZGUubm9kZVNpemUgOiAkaGVhZC5wb3M7XG4gICAgICAgICAgICBpZiAoIShub2RlLmlzQXRvbSB8fCAoZGVzYyA9IHZpZXcuZG9jVmlldy5kZXNjQXQobm9kZVBvcykpICYmICFkZXNjLmNvbnRlbnRET00pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmIChOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShub2RlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcHBseSh2aWV3LCBuZXcgTm9kZVNlbGVjdGlvbihkaXIgPCAwID8gdmlldy5zdGF0ZS5kb2MucmVzb2x2ZSgkaGVhZC5wb3MgLSBub2RlLm5vZGVTaXplKSA6ICRoZWFkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh3ZWJraXQpIHtcbiAgICAgICAgICAgICAgICAvLyBDaHJvbWUgYW5kIFNhZmFyaSB3aWxsIGludHJvZHVjZSBleHRyYSBwb2ludGxlc3MgY3Vyc29yXG4gICAgICAgICAgICAgICAgLy8gcG9zaXRpb25zIGFyb3VuZCBpbmxpbmUgdW5lZGl0YWJsZSBub2Rlcywgc28gd2UgaGF2ZSB0b1xuICAgICAgICAgICAgICAgIC8vIHRha2Ugb3ZlciBhbmQgbW92ZSB0aGUgY3Vyc29yIHBhc3QgdGhlbSAoIzkzNylcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBwbHkodmlldywgbmV3IFRleHRTZWxlY3Rpb24odmlldy5zdGF0ZS5kb2MucmVzb2x2ZShkaXIgPCAwID8gbm9kZVBvcyA6IG5vZGVQb3MgKyBub2RlLm5vZGVTaXplKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHNlbCBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24gJiYgc2VsLm5vZGUuaXNJbmxpbmUpIHtcbiAgICAgICAgcmV0dXJuIGFwcGx5KHZpZXcsIG5ldyBUZXh0U2VsZWN0aW9uKGRpciA+IDAgPyBzZWwuJHRvIDogc2VsLiRmcm9tKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgbmV4dCA9IG1vdmVTZWxlY3Rpb25CbG9jayh2aWV3LnN0YXRlLCBkaXIpO1xuICAgICAgICBpZiAobmV4dClcbiAgICAgICAgICAgIHJldHVybiBhcHBseSh2aWV3LCBuZXh0KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG5vZGVMZW4obm9kZSkge1xuICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09IDMgPyBub2RlLm5vZGVWYWx1ZS5sZW5ndGggOiBub2RlLmNoaWxkTm9kZXMubGVuZ3RoO1xufVxuZnVuY3Rpb24gaXNJZ25vcmFibGUoZG9tLCBkaXIpIHtcbiAgICBsZXQgZGVzYyA9IGRvbS5wbVZpZXdEZXNjO1xuICAgIHJldHVybiBkZXNjICYmIGRlc2Muc2l6ZSA9PSAwICYmIChkaXIgPCAwIHx8IGRvbS5uZXh0U2libGluZyB8fCBkb20ubm9kZU5hbWUgIT0gXCJCUlwiKTtcbn1cbmZ1bmN0aW9uIHNraXBJZ25vcmVkTm9kZXModmlldywgZGlyKSB7XG4gICAgcmV0dXJuIGRpciA8IDAgPyBza2lwSWdub3JlZE5vZGVzQmVmb3JlKHZpZXcpIDogc2tpcElnbm9yZWROb2Rlc0FmdGVyKHZpZXcpO1xufVxuLy8gTWFrZSBzdXJlIHRoZSBjdXJzb3IgaXNuJ3QgZGlyZWN0bHkgYWZ0ZXIgb25lIG9yIG1vcmUgaWdub3JlZFxuLy8gbm9kZXMsIHdoaWNoIHdpbGwgY29uZnVzZSB0aGUgYnJvd3NlcidzIGN1cnNvciBtb3Rpb24gbG9naWMuXG5mdW5jdGlvbiBza2lwSWdub3JlZE5vZGVzQmVmb3JlKHZpZXcpIHtcbiAgICBsZXQgc2VsID0gdmlldy5kb21TZWxlY3Rpb25SYW5nZSgpO1xuICAgIGxldCBub2RlID0gc2VsLmZvY3VzTm9kZSwgb2Zmc2V0ID0gc2VsLmZvY3VzT2Zmc2V0O1xuICAgIGlmICghbm9kZSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBtb3ZlTm9kZSwgbW92ZU9mZnNldCwgZm9yY2UgPSBmYWxzZTtcbiAgICAvLyBHZWNrbyB3aWxsIGRvIG9kZCB0aGluZ3Mgd2hlbiB0aGUgc2VsZWN0aW9uIGlzIGRpcmVjdGx5IGluIGZyb250XG4gICAgLy8gb2YgYSBub24tZWRpdGFibGUgbm9kZSwgc28gaW4gdGhhdCBjYXNlLCBtb3ZlIGl0IGludG8gdGhlIG5leHRcbiAgICAvLyBub2RlIGlmIHBvc3NpYmxlLiBJc3N1ZSBwcm9zZW1pcnJvci9wcm9zZW1pcnJvciM4MzIuXG4gICAgaWYgKGdlY2tvICYmIG5vZGUubm9kZVR5cGUgPT0gMSAmJiBvZmZzZXQgPCBub2RlTGVuKG5vZGUpICYmIGlzSWdub3JhYmxlKG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdLCAtMSkpXG4gICAgICAgIGZvcmNlID0gdHJ1ZTtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmIChvZmZzZXQgPiAwKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSAhPSAxKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgYmVmb3JlID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChpc0lnbm9yYWJsZShiZWZvcmUsIC0xKSkge1xuICAgICAgICAgICAgICAgICAgICBtb3ZlTm9kZSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgICAgIG1vdmVPZmZzZXQgPSAtLW9mZnNldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYmVmb3JlLm5vZGVUeXBlID09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGJlZm9yZTtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gbm9kZS5ub2RlVmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQmxvY2tOb2RlKG5vZGUpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBwcmV2ID0gbm9kZS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICB3aGlsZSAocHJldiAmJiBpc0lnbm9yYWJsZShwcmV2LCAtMSkpIHtcbiAgICAgICAgICAgICAgICBtb3ZlTm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICBtb3ZlT2Zmc2V0ID0gZG9tSW5kZXgocHJldik7XG4gICAgICAgICAgICAgICAgcHJldiA9IHByZXYucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFwcmV2KSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSA9PSB2aWV3LmRvbSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBwcmV2O1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IG5vZGVMZW4obm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZvcmNlKVxuICAgICAgICBzZXRTZWxGb2N1cyh2aWV3LCBub2RlLCBvZmZzZXQpO1xuICAgIGVsc2UgaWYgKG1vdmVOb2RlKVxuICAgICAgICBzZXRTZWxGb2N1cyh2aWV3LCBtb3ZlTm9kZSwgbW92ZU9mZnNldCk7XG59XG4vLyBNYWtlIHN1cmUgdGhlIGN1cnNvciBpc24ndCBkaXJlY3RseSBiZWZvcmUgb25lIG9yIG1vcmUgaWdub3JlZFxuLy8gbm9kZXMuXG5mdW5jdGlvbiBza2lwSWdub3JlZE5vZGVzQWZ0ZXIodmlldykge1xuICAgIGxldCBzZWwgPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgbGV0IG5vZGUgPSBzZWwuZm9jdXNOb2RlLCBvZmZzZXQgPSBzZWwuZm9jdXNPZmZzZXQ7XG4gICAgaWYgKCFub2RlKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IGxlbiA9IG5vZGVMZW4obm9kZSk7XG4gICAgbGV0IG1vdmVOb2RlLCBtb3ZlT2Zmc2V0O1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKG9mZnNldCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgIT0gMSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxldCBhZnRlciA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdO1xuICAgICAgICAgICAgaWYgKGlzSWdub3JhYmxlKGFmdGVyLCAxKSkge1xuICAgICAgICAgICAgICAgIG1vdmVOb2RlID0gbm9kZTtcbiAgICAgICAgICAgICAgICBtb3ZlT2Zmc2V0ID0gKytvZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNCbG9ja05vZGUobm9kZSkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgd2hpbGUgKG5leHQgJiYgaXNJZ25vcmFibGUobmV4dCwgMSkpIHtcbiAgICAgICAgICAgICAgICBtb3ZlTm9kZSA9IG5leHQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICBtb3ZlT2Zmc2V0ID0gZG9tSW5kZXgobmV4dCkgKyAxO1xuICAgICAgICAgICAgICAgIG5leHQgPSBuZXh0Lm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFuZXh0KSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSA9PSB2aWV3LmRvbSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gbGVuID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBuZXh0O1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgICAgICAgICAgbGVuID0gbm9kZUxlbihub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobW92ZU5vZGUpXG4gICAgICAgIHNldFNlbEZvY3VzKHZpZXcsIG1vdmVOb2RlLCBtb3ZlT2Zmc2V0KTtcbn1cbmZ1bmN0aW9uIGlzQmxvY2tOb2RlKGRvbSkge1xuICAgIGxldCBkZXNjID0gZG9tLnBtVmlld0Rlc2M7XG4gICAgcmV0dXJuIGRlc2MgJiYgZGVzYy5ub2RlICYmIGRlc2Mubm9kZS5pc0Jsb2NrO1xufVxuZnVuY3Rpb24gdGV4dE5vZGVBZnRlcihub2RlLCBvZmZzZXQpIHtcbiAgICB3aGlsZSAobm9kZSAmJiBvZmZzZXQgPT0gbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCAmJiAhaGFzQmxvY2tEZXNjKG5vZGUpKSB7XG4gICAgICAgIG9mZnNldCA9IGRvbUluZGV4KG5vZGUpICsgMTtcbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgd2hpbGUgKG5vZGUgJiYgb2Zmc2V0IDwgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICBsZXQgbmV4dCA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdO1xuICAgICAgICBpZiAobmV4dC5ub2RlVHlwZSA9PSAzKVxuICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIGlmIChuZXh0Lm5vZGVUeXBlID09IDEgJiYgbmV4dC5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIG5vZGUgPSBuZXh0O1xuICAgICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRleHROb2RlQmVmb3JlKG5vZGUsIG9mZnNldCkge1xuICAgIHdoaWxlIChub2RlICYmICFvZmZzZXQgJiYgIWhhc0Jsb2NrRGVzYyhub2RlKSkge1xuICAgICAgICBvZmZzZXQgPSBkb21JbmRleChub2RlKTtcbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgd2hpbGUgKG5vZGUgJiYgb2Zmc2V0KSB7XG4gICAgICAgIGxldCBuZXh0ID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdO1xuICAgICAgICBpZiAobmV4dC5ub2RlVHlwZSA9PSAzKVxuICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIGlmIChuZXh0Lm5vZGVUeXBlID09IDEgJiYgbmV4dC5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIG5vZGUgPSBuZXh0O1xuICAgICAgICBvZmZzZXQgPSBub2RlLmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNldFNlbEZvY3VzKHZpZXcsIG5vZGUsIG9mZnNldCkge1xuICAgIGlmIChub2RlLm5vZGVUeXBlICE9IDMpIHtcbiAgICAgICAgbGV0IGJlZm9yZSwgYWZ0ZXI7XG4gICAgICAgIGlmIChhZnRlciA9IHRleHROb2RlQWZ0ZXIobm9kZSwgb2Zmc2V0KSkge1xuICAgICAgICAgICAgbm9kZSA9IGFmdGVyO1xuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChiZWZvcmUgPSB0ZXh0Tm9kZUJlZm9yZShub2RlLCBvZmZzZXQpKSB7XG4gICAgICAgICAgICBub2RlID0gYmVmb3JlO1xuICAgICAgICAgICAgb2Zmc2V0ID0gYmVmb3JlLm5vZGVWYWx1ZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IHNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uKCk7XG4gICAgaWYgKCFzZWwpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoc2VsZWN0aW9uQ29sbGFwc2VkKHNlbCkpIHtcbiAgICAgICAgbGV0IHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgcmFuZ2Uuc2V0RW5kKG5vZGUsIG9mZnNldCk7XG4gICAgICAgIHJhbmdlLnNldFN0YXJ0KG5vZGUsIG9mZnNldCk7XG4gICAgICAgIHNlbC5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgc2VsLmFkZFJhbmdlKHJhbmdlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2VsLmV4dGVuZCkge1xuICAgICAgICBzZWwuZXh0ZW5kKG5vZGUsIG9mZnNldCk7XG4gICAgfVxuICAgIHZpZXcuZG9tT2JzZXJ2ZXIuc2V0Q3VyU2VsZWN0aW9uKCk7XG4gICAgbGV0IHsgc3RhdGUgfSA9IHZpZXc7XG4gICAgLy8gSWYgbm8gc3RhdGUgdXBkYXRlIGVuZHMgdXAgaGFwcGVuaW5nLCByZXNldCB0aGUgc2VsZWN0aW9uLlxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAodmlldy5zdGF0ZSA9PSBzdGF0ZSlcbiAgICAgICAgICAgIHNlbGVjdGlvblRvRE9NKHZpZXcpO1xuICAgIH0sIDUwKTtcbn1cbmZ1bmN0aW9uIGZpbmREaXJlY3Rpb24odmlldywgcG9zKSB7XG4gICAgbGV0ICRwb3MgPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKHBvcyk7XG4gICAgaWYgKCEoY2hyb21lIHx8IHdpbmRvd3MpICYmICRwb3MucGFyZW50LmlubGluZUNvbnRlbnQpIHtcbiAgICAgICAgbGV0IGNvb3JkcyA9IHZpZXcuY29vcmRzQXRQb3MocG9zKTtcbiAgICAgICAgaWYgKHBvcyA+ICRwb3Muc3RhcnQoKSkge1xuICAgICAgICAgICAgbGV0IGJlZm9yZSA9IHZpZXcuY29vcmRzQXRQb3MocG9zIC0gMSk7XG4gICAgICAgICAgICBsZXQgbWlkID0gKGJlZm9yZS50b3AgKyBiZWZvcmUuYm90dG9tKSAvIDI7XG4gICAgICAgICAgICBpZiAobWlkID4gY29vcmRzLnRvcCAmJiBtaWQgPCBjb29yZHMuYm90dG9tICYmIE1hdGguYWJzKGJlZm9yZS5sZWZ0IC0gY29vcmRzLmxlZnQpID4gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gYmVmb3JlLmxlZnQgPCBjb29yZHMubGVmdCA/IFwibHRyXCIgOiBcInJ0bFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3MgPCAkcG9zLmVuZCgpKSB7XG4gICAgICAgICAgICBsZXQgYWZ0ZXIgPSB2aWV3LmNvb3Jkc0F0UG9zKHBvcyArIDEpO1xuICAgICAgICAgICAgbGV0IG1pZCA9IChhZnRlci50b3AgKyBhZnRlci5ib3R0b20pIC8gMjtcbiAgICAgICAgICAgIGlmIChtaWQgPiBjb29yZHMudG9wICYmIG1pZCA8IGNvb3Jkcy5ib3R0b20gJiYgTWF0aC5hYnMoYWZ0ZXIubGVmdCAtIGNvb3Jkcy5sZWZ0KSA+IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFmdGVyLmxlZnQgPiBjb29yZHMubGVmdCA/IFwibHRyXCIgOiBcInJ0bFwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBjb21wdXRlZCA9IGdldENvbXB1dGVkU3R5bGUodmlldy5kb20pLmRpcmVjdGlvbjtcbiAgICByZXR1cm4gY29tcHV0ZWQgPT0gXCJydGxcIiA/IFwicnRsXCIgOiBcImx0clwiO1xufVxuLy8gQ2hlY2sgd2hldGhlciB2ZXJ0aWNhbCBzZWxlY3Rpb24gbW90aW9uIHdvdWxkIGludm9sdmUgbm9kZVxuLy8gc2VsZWN0aW9ucy4gSWYgc28sIGFwcGx5IGl0IChpZiBub3QsIHRoZSByZXN1bHQgaXMgbGVmdCB0byB0aGVcbi8vIGJyb3dzZXIpXG5mdW5jdGlvbiBzZWxlY3RWZXJ0aWNhbGx5KHZpZXcsIGRpciwgbW9kcykge1xuICAgIGxldCBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICBpZiAoc2VsIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbiAmJiAhc2VsLmVtcHR5IHx8IG1vZHMuaW5kZXhPZihcInNcIikgPiAtMSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChtYWMgJiYgbW9kcy5pbmRleE9mKFwibVwiKSA+IC0xKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHsgJGZyb20sICR0byB9ID0gc2VsO1xuICAgIGlmICghJGZyb20ucGFyZW50LmlubGluZUNvbnRlbnQgfHwgdmlldy5lbmRPZlRleHRibG9jayhkaXIgPCAwID8gXCJ1cFwiIDogXCJkb3duXCIpKSB7XG4gICAgICAgIGxldCBuZXh0ID0gbW92ZVNlbGVjdGlvbkJsb2NrKHZpZXcuc3RhdGUsIGRpcik7XG4gICAgICAgIGlmIChuZXh0ICYmIChuZXh0IGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbikpXG4gICAgICAgICAgICByZXR1cm4gYXBwbHkodmlldywgbmV4dCk7XG4gICAgfVxuICAgIGlmICghJGZyb20ucGFyZW50LmlubGluZUNvbnRlbnQpIHtcbiAgICAgICAgbGV0IHNpZGUgPSBkaXIgPCAwID8gJGZyb20gOiAkdG87XG4gICAgICAgIGxldCBiZXlvbmQgPSBzZWwgaW5zdGFuY2VvZiBBbGxTZWxlY3Rpb24gPyBTZWxlY3Rpb24ubmVhcihzaWRlLCBkaXIpIDogU2VsZWN0aW9uLmZpbmRGcm9tKHNpZGUsIGRpcik7XG4gICAgICAgIHJldHVybiBiZXlvbmQgPyBhcHBseSh2aWV3LCBiZXlvbmQpIDogZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHN0b3BOYXRpdmVIb3Jpem9udGFsRGVsZXRlKHZpZXcsIGRpcikge1xuICAgIGlmICghKHZpZXcuc3RhdGUuc2VsZWN0aW9uIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbikpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGxldCB7ICRoZWFkLCAkYW5jaG9yLCBlbXB0eSB9ID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKCEkaGVhZC5zYW1lUGFyZW50KCRhbmNob3IpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoIWVtcHR5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHZpZXcuZW5kT2ZUZXh0YmxvY2soZGlyID4gMCA/IFwiZm9yd2FyZFwiIDogXCJiYWNrd2FyZFwiKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgbGV0IG5leHROb2RlID0gISRoZWFkLnRleHRPZmZzZXQgJiYgKGRpciA8IDAgPyAkaGVhZC5ub2RlQmVmb3JlIDogJGhlYWQubm9kZUFmdGVyKTtcbiAgICBpZiAobmV4dE5vZGUgJiYgIW5leHROb2RlLmlzVGV4dCkge1xuICAgICAgICBsZXQgdHIgPSB2aWV3LnN0YXRlLnRyO1xuICAgICAgICBpZiAoZGlyIDwgMClcbiAgICAgICAgICAgIHRyLmRlbGV0ZSgkaGVhZC5wb3MgLSBuZXh0Tm9kZS5ub2RlU2l6ZSwgJGhlYWQucG9zKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdHIuZGVsZXRlKCRoZWFkLnBvcywgJGhlYWQucG9zICsgbmV4dE5vZGUubm9kZVNpemUpO1xuICAgICAgICB2aWV3LmRpc3BhdGNoKHRyKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHN3aXRjaEVkaXRhYmxlKHZpZXcsIG5vZGUsIHN0YXRlKSB7XG4gICAgdmlldy5kb21PYnNlcnZlci5zdG9wKCk7XG4gICAgbm9kZS5jb250ZW50RWRpdGFibGUgPSBzdGF0ZTtcbiAgICB2aWV3LmRvbU9ic2VydmVyLnN0YXJ0KCk7XG59XG4vLyBJc3N1ZSAjODY3IC8gIzEwOTAgLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD05MDM4MjFcbi8vIEluIHdoaWNoIFNhZmFyaSAoYW5kIGF0IHNvbWUgcG9pbnQgaW4gdGhlIHBhc3QsIENocm9tZSkgZG9lcyByZWFsbHlcbi8vIHdyb25nIHRoaW5ncyB3aGVuIHRoZSBkb3duIGFycm93IGlzIHByZXNzZWQgd2hlbiB0aGUgY3Vyc29yIGlzXG4vLyBkaXJlY3RseSBhdCB0aGUgc3RhcnQgb2YgYSB0ZXh0YmxvY2sgYW5kIGhhcyBhbiB1bmVkaXRhYmxlIG5vZGVcbi8vIGFmdGVyIGl0XG5mdW5jdGlvbiBzYWZhcmlEb3duQXJyb3dCdWcodmlldykge1xuICAgIGlmICghc2FmYXJpIHx8IHZpZXcuc3RhdGUuc2VsZWN0aW9uLiRoZWFkLnBhcmVudE9mZnNldCA+IDApXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgeyBmb2N1c05vZGUsIGZvY3VzT2Zmc2V0IH0gPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgaWYgKGZvY3VzTm9kZSAmJiBmb2N1c05vZGUubm9kZVR5cGUgPT0gMSAmJiBmb2N1c09mZnNldCA9PSAwICYmXG4gICAgICAgIGZvY3VzTm9kZS5maXJzdENoaWxkICYmIGZvY3VzTm9kZS5maXJzdENoaWxkLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpIHtcbiAgICAgICAgbGV0IGNoaWxkID0gZm9jdXNOb2RlLmZpcnN0Q2hpbGQ7XG4gICAgICAgIHN3aXRjaEVkaXRhYmxlKHZpZXcsIGNoaWxkLCBcInRydWVcIik7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gc3dpdGNoRWRpdGFibGUodmlldywgY2hpbGQsIFwiZmFsc2VcIiksIDIwKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLy8gQSBiYWNrZHJvcCBrZXkgbWFwcGluZyB1c2VkIHRvIG1ha2Ugc3VyZSB3ZSBhbHdheXMgc3VwcHJlc3Mga2V5c1xuLy8gdGhhdCBoYXZlIGEgZGFuZ2Vyb3VzIGRlZmF1bHQgZWZmZWN0LCBldmVuIGlmIHRoZSBjb21tYW5kcyB0aGV5IGFyZVxuLy8gYm91bmQgdG8gcmV0dXJuIGZhbHNlLCBhbmQgdG8gbWFrZSBzdXJlIHRoYXQgY3Vyc29yLW1vdGlvbiBrZXlzXG4vLyBmaW5kIGEgY3Vyc29yIChhcyBvcHBvc2VkIHRvIGEgbm9kZSBzZWxlY3Rpb24pIHdoZW4gcHJlc3NlZC4gRm9yXG4vLyBjdXJzb3ItbW90aW9uIGtleXMsIHRoZSBjb2RlIGluIHRoZSBoYW5kbGVycyBhbHNvIHRha2VzIGNhcmUgb2Zcbi8vIGJsb2NrIHNlbGVjdGlvbnMuXG5mdW5jdGlvbiBnZXRNb2RzKGV2ZW50KSB7XG4gICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgaWYgKGV2ZW50LmN0cmxLZXkpXG4gICAgICAgIHJlc3VsdCArPSBcImNcIjtcbiAgICBpZiAoZXZlbnQubWV0YUtleSlcbiAgICAgICAgcmVzdWx0ICs9IFwibVwiO1xuICAgIGlmIChldmVudC5hbHRLZXkpXG4gICAgICAgIHJlc3VsdCArPSBcImFcIjtcbiAgICBpZiAoZXZlbnQuc2hpZnRLZXkpXG4gICAgICAgIHJlc3VsdCArPSBcInNcIjtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY2FwdHVyZUtleURvd24odmlldywgZXZlbnQpIHtcbiAgICBsZXQgY29kZSA9IGV2ZW50LmtleUNvZGUsIG1vZHMgPSBnZXRNb2RzKGV2ZW50KTtcbiAgICBpZiAoY29kZSA9PSA4IHx8IChtYWMgJiYgY29kZSA9PSA3MiAmJiBtb2RzID09IFwiY1wiKSkgeyAvLyBCYWNrc3BhY2UsIEN0cmwtaCBvbiBNYWNcbiAgICAgICAgcmV0dXJuIHN0b3BOYXRpdmVIb3Jpem9udGFsRGVsZXRlKHZpZXcsIC0xKSB8fCBza2lwSWdub3JlZE5vZGVzKHZpZXcsIC0xKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKGNvZGUgPT0gNDYgJiYgIWV2ZW50LnNoaWZ0S2V5KSB8fCAobWFjICYmIGNvZGUgPT0gNjggJiYgbW9kcyA9PSBcImNcIikpIHsgLy8gRGVsZXRlLCBDdHJsLWQgb24gTWFjXG4gICAgICAgIHJldHVybiBzdG9wTmF0aXZlSG9yaXpvbnRhbERlbGV0ZSh2aWV3LCAxKSB8fCBza2lwSWdub3JlZE5vZGVzKHZpZXcsIDEpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb2RlID09IDEzIHx8IGNvZGUgPT0gMjcpIHsgLy8gRW50ZXIsIEVzY1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29kZSA9PSAzNyB8fCAobWFjICYmIGNvZGUgPT0gNjYgJiYgbW9kcyA9PSBcImNcIikpIHsgLy8gTGVmdCBhcnJvdywgQ3RybC1iIG9uIE1hY1xuICAgICAgICBsZXQgZGlyID0gY29kZSA9PSAzNyA/IChmaW5kRGlyZWN0aW9uKHZpZXcsIHZpZXcuc3RhdGUuc2VsZWN0aW9uLmZyb20pID09IFwibHRyXCIgPyAtMSA6IDEpIDogLTE7XG4gICAgICAgIHJldHVybiBzZWxlY3RIb3Jpem9udGFsbHkodmlldywgZGlyLCBtb2RzKSB8fCBza2lwSWdub3JlZE5vZGVzKHZpZXcsIGRpcik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvZGUgPT0gMzkgfHwgKG1hYyAmJiBjb2RlID09IDcwICYmIG1vZHMgPT0gXCJjXCIpKSB7IC8vIFJpZ2h0IGFycm93LCBDdHJsLWYgb24gTWFjXG4gICAgICAgIGxldCBkaXIgPSBjb2RlID09IDM5ID8gKGZpbmREaXJlY3Rpb24odmlldywgdmlldy5zdGF0ZS5zZWxlY3Rpb24uZnJvbSkgPT0gXCJsdHJcIiA/IDEgOiAtMSkgOiAxO1xuICAgICAgICByZXR1cm4gc2VsZWN0SG9yaXpvbnRhbGx5KHZpZXcsIGRpciwgbW9kcykgfHwgc2tpcElnbm9yZWROb2Rlcyh2aWV3LCBkaXIpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb2RlID09IDM4IHx8IChtYWMgJiYgY29kZSA9PSA4MCAmJiBtb2RzID09IFwiY1wiKSkgeyAvLyBVcCBhcnJvdywgQ3RybC1wIG9uIE1hY1xuICAgICAgICByZXR1cm4gc2VsZWN0VmVydGljYWxseSh2aWV3LCAtMSwgbW9kcykgfHwgc2tpcElnbm9yZWROb2Rlcyh2aWV3LCAtMSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvZGUgPT0gNDAgfHwgKG1hYyAmJiBjb2RlID09IDc4ICYmIG1vZHMgPT0gXCJjXCIpKSB7IC8vIERvd24gYXJyb3csIEN0cmwtbiBvbiBNYWNcbiAgICAgICAgcmV0dXJuIHNhZmFyaURvd25BcnJvd0J1Zyh2aWV3KSB8fCBzZWxlY3RWZXJ0aWNhbGx5KHZpZXcsIDEsIG1vZHMpIHx8IHNraXBJZ25vcmVkTm9kZXModmlldywgMSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG1vZHMgPT0gKG1hYyA/IFwibVwiIDogXCJjXCIpICYmXG4gICAgICAgIChjb2RlID09IDY2IHx8IGNvZGUgPT0gNzMgfHwgY29kZSA9PSA4OSB8fCBjb2RlID09IDkwKSkgeyAvLyBNb2QtW2JpeXpdXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZUZvckNsaXBib2FyZCh2aWV3LCBzbGljZSkge1xuICAgIHZpZXcuc29tZVByb3AoXCJ0cmFuc2Zvcm1Db3BpZWRcIiwgZiA9PiB7IHNsaWNlID0gZihzbGljZSwgdmlldyk7IH0pO1xuICAgIGxldCBjb250ZXh0ID0gW10sIHsgY29udGVudCwgb3BlblN0YXJ0LCBvcGVuRW5kIH0gPSBzbGljZTtcbiAgICB3aGlsZSAob3BlblN0YXJ0ID4gMSAmJiBvcGVuRW5kID4gMSAmJiBjb250ZW50LmNoaWxkQ291bnQgPT0gMSAmJiBjb250ZW50LmZpcnN0Q2hpbGQuY2hpbGRDb3VudCA9PSAxKSB7XG4gICAgICAgIG9wZW5TdGFydC0tO1xuICAgICAgICBvcGVuRW5kLS07XG4gICAgICAgIGxldCBub2RlID0gY29udGVudC5maXJzdENoaWxkO1xuICAgICAgICBjb250ZXh0LnB1c2gobm9kZS50eXBlLm5hbWUsIG5vZGUuYXR0cnMgIT0gbm9kZS50eXBlLmRlZmF1bHRBdHRycyA/IG5vZGUuYXR0cnMgOiBudWxsKTtcbiAgICAgICAgY29udGVudCA9IG5vZGUuY29udGVudDtcbiAgICB9XG4gICAgbGV0IHNlcmlhbGl6ZXIgPSB2aWV3LnNvbWVQcm9wKFwiY2xpcGJvYXJkU2VyaWFsaXplclwiKSB8fCBET01TZXJpYWxpemVyLmZyb21TY2hlbWEodmlldy5zdGF0ZS5zY2hlbWEpO1xuICAgIGxldCBkb2MgPSBkZXRhY2hlZERvYygpLCB3cmFwID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgd3JhcC5hcHBlbmRDaGlsZChzZXJpYWxpemVyLnNlcmlhbGl6ZUZyYWdtZW50KGNvbnRlbnQsIHsgZG9jdW1lbnQ6IGRvYyB9KSk7XG4gICAgbGV0IGZpcnN0Q2hpbGQgPSB3cmFwLmZpcnN0Q2hpbGQsIG5lZWRzV3JhcCwgd3JhcHBlcnMgPSAwO1xuICAgIHdoaWxlIChmaXJzdENoaWxkICYmIGZpcnN0Q2hpbGQubm9kZVR5cGUgPT0gMSAmJiAobmVlZHNXcmFwID0gd3JhcE1hcFtmaXJzdENoaWxkLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCldKSkge1xuICAgICAgICBmb3IgKGxldCBpID0gbmVlZHNXcmFwLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgd3JhcHBlciA9IGRvYy5jcmVhdGVFbGVtZW50KG5lZWRzV3JhcFtpXSk7XG4gICAgICAgICAgICB3aGlsZSAod3JhcC5maXJzdENoaWxkKVxuICAgICAgICAgICAgICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQod3JhcC5maXJzdENoaWxkKTtcbiAgICAgICAgICAgIHdyYXAuYXBwZW5kQ2hpbGQod3JhcHBlcik7XG4gICAgICAgICAgICB3cmFwcGVycysrO1xuICAgICAgICB9XG4gICAgICAgIGZpcnN0Q2hpbGQgPSB3cmFwLmZpcnN0Q2hpbGQ7XG4gICAgfVxuICAgIGlmIChmaXJzdENoaWxkICYmIGZpcnN0Q2hpbGQubm9kZVR5cGUgPT0gMSlcbiAgICAgICAgZmlyc3RDaGlsZC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXBtLXNsaWNlXCIsIGAke29wZW5TdGFydH0gJHtvcGVuRW5kfSR7d3JhcHBlcnMgPyBgIC0ke3dyYXBwZXJzfWAgOiBcIlwifSAke0pTT04uc3RyaW5naWZ5KGNvbnRleHQpfWApO1xuICAgIGxldCB0ZXh0ID0gdmlldy5zb21lUHJvcChcImNsaXBib2FyZFRleHRTZXJpYWxpemVyXCIsIGYgPT4gZihzbGljZSwgdmlldykpIHx8XG4gICAgICAgIHNsaWNlLmNvbnRlbnQudGV4dEJldHdlZW4oMCwgc2xpY2UuY29udGVudC5zaXplLCBcIlxcblxcblwiKTtcbiAgICByZXR1cm4geyBkb206IHdyYXAsIHRleHQsIHNsaWNlIH07XG59XG4vLyBSZWFkIGEgc2xpY2Ugb2YgY29udGVudCBmcm9tIHRoZSBjbGlwYm9hcmQgKG9yIGRyb3AgZGF0YSkuXG5mdW5jdGlvbiBwYXJzZUZyb21DbGlwYm9hcmQodmlldywgdGV4dCwgaHRtbCwgcGxhaW5UZXh0LCAkY29udGV4dCkge1xuICAgIGxldCBpbkNvZGUgPSAkY29udGV4dC5wYXJlbnQudHlwZS5zcGVjLmNvZGU7XG4gICAgbGV0IGRvbSwgc2xpY2U7XG4gICAgaWYgKCFodG1sICYmICF0ZXh0KVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgYXNUZXh0ID0gISF0ZXh0ICYmIChwbGFpblRleHQgfHwgaW5Db2RlIHx8ICFodG1sKTtcbiAgICBpZiAoYXNUZXh0KSB7XG4gICAgICAgIHZpZXcuc29tZVByb3AoXCJ0cmFuc2Zvcm1QYXN0ZWRUZXh0XCIsIGYgPT4geyB0ZXh0ID0gZih0ZXh0LCBpbkNvZGUgfHwgcGxhaW5UZXh0LCB2aWV3KTsgfSk7XG4gICAgICAgIGlmIChpbkNvZGUpIHtcbiAgICAgICAgICAgIHNsaWNlID0gbmV3IFNsaWNlKEZyYWdtZW50LmZyb20odmlldy5zdGF0ZS5zY2hlbWEudGV4dCh0ZXh0LnJlcGxhY2UoL1xcclxcbj8vZywgXCJcXG5cIikpKSwgMCwgMCk7XG4gICAgICAgICAgICB2aWV3LnNvbWVQcm9wKFwidHJhbnNmb3JtUGFzdGVkXCIsIGYgPT4geyBzbGljZSA9IGYoc2xpY2UsIHZpZXcsIHRydWUpOyB9KTtcbiAgICAgICAgICAgIHJldHVybiBzbGljZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcGFyc2VkID0gdmlldy5zb21lUHJvcChcImNsaXBib2FyZFRleHRQYXJzZXJcIiwgZiA9PiBmKHRleHQsICRjb250ZXh0LCBwbGFpblRleHQsIHZpZXcpKTtcbiAgICAgICAgaWYgKHBhcnNlZCkge1xuICAgICAgICAgICAgc2xpY2UgPSBwYXJzZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbWFya3MgPSAkY29udGV4dC5tYXJrcygpO1xuICAgICAgICAgICAgbGV0IHsgc2NoZW1hIH0gPSB2aWV3LnN0YXRlLCBzZXJpYWxpemVyID0gRE9NU2VyaWFsaXplci5mcm9tU2NoZW1hKHNjaGVtYSk7XG4gICAgICAgICAgICBkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgdGV4dC5zcGxpdCgvKD86XFxyXFxuP3xcXG4pKy8pLmZvckVhY2goYmxvY2sgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBwID0gZG9tLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJwXCIpKTtcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2spXG4gICAgICAgICAgICAgICAgICAgIHAuYXBwZW5kQ2hpbGQoc2VyaWFsaXplci5zZXJpYWxpemVOb2RlKHNjaGVtYS50ZXh0KGJsb2NrLCBtYXJrcykpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2aWV3LnNvbWVQcm9wKFwidHJhbnNmb3JtUGFzdGVkSFRNTFwiLCBmID0+IHsgaHRtbCA9IGYoaHRtbCwgdmlldyk7IH0pO1xuICAgICAgICBkb20gPSByZWFkSFRNTChodG1sKTtcbiAgICAgICAgaWYgKHdlYmtpdClcbiAgICAgICAgICAgIHJlc3RvcmVSZXBsYWNlZFNwYWNlcyhkb20pO1xuICAgIH1cbiAgICBsZXQgY29udGV4dE5vZGUgPSBkb20gJiYgZG9tLnF1ZXJ5U2VsZWN0b3IoXCJbZGF0YS1wbS1zbGljZV1cIik7XG4gICAgbGV0IHNsaWNlRGF0YSA9IGNvbnRleHROb2RlICYmIC9eKFxcZCspIChcXGQrKSg/OiAtKFxcZCspKT8gKC4qKS8uZXhlYyhjb250ZXh0Tm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXBtLXNsaWNlXCIpIHx8IFwiXCIpO1xuICAgIGlmIChzbGljZURhdGEgJiYgc2xpY2VEYXRhWzNdKVxuICAgICAgICBmb3IgKGxldCBpID0gK3NsaWNlRGF0YVszXTsgaSA+IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gZG9tLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICB3aGlsZSAoY2hpbGQgJiYgY2hpbGQubm9kZVR5cGUgIT0gMSlcbiAgICAgICAgICAgICAgICBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgaWYgKCFjaGlsZClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRvbSA9IGNoaWxkO1xuICAgICAgICB9XG4gICAgaWYgKCFzbGljZSkge1xuICAgICAgICBsZXQgcGFyc2VyID0gdmlldy5zb21lUHJvcChcImNsaXBib2FyZFBhcnNlclwiKSB8fCB2aWV3LnNvbWVQcm9wKFwiZG9tUGFyc2VyXCIpIHx8IERPTVBhcnNlci5mcm9tU2NoZW1hKHZpZXcuc3RhdGUuc2NoZW1hKTtcbiAgICAgICAgc2xpY2UgPSBwYXJzZXIucGFyc2VTbGljZShkb20sIHtcbiAgICAgICAgICAgIHByZXNlcnZlV2hpdGVzcGFjZTogISEoYXNUZXh0IHx8IHNsaWNlRGF0YSksXG4gICAgICAgICAgICBjb250ZXh0OiAkY29udGV4dCxcbiAgICAgICAgICAgIHJ1bGVGcm9tTm9kZShkb20pIHtcbiAgICAgICAgICAgICAgICBpZiAoZG9tLm5vZGVOYW1lID09IFwiQlJcIiAmJiAhZG9tLm5leHRTaWJsaW5nICYmXG4gICAgICAgICAgICAgICAgICAgIGRvbS5wYXJlbnROb2RlICYmICFpbmxpbmVQYXJlbnRzLnRlc3QoZG9tLnBhcmVudE5vZGUubm9kZU5hbWUpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBpZ25vcmU6IHRydWUgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzbGljZURhdGEpIHtcbiAgICAgICAgc2xpY2UgPSBhZGRDb250ZXh0KGNsb3NlU2xpY2Uoc2xpY2UsICtzbGljZURhdGFbMV0sICtzbGljZURhdGFbMl0pLCBzbGljZURhdGFbNF0pO1xuICAgIH1cbiAgICBlbHNlIHsgLy8gSFRNTCB3YXNuJ3QgY3JlYXRlZCBieSBQcm9zZU1pcnJvci4gTWFrZSBzdXJlIHRvcC1sZXZlbCBzaWJsaW5ncyBhcmUgY29oZXJlbnRcbiAgICAgICAgc2xpY2UgPSBTbGljZS5tYXhPcGVuKG5vcm1hbGl6ZVNpYmxpbmdzKHNsaWNlLmNvbnRlbnQsICRjb250ZXh0KSwgdHJ1ZSk7XG4gICAgICAgIGlmIChzbGljZS5vcGVuU3RhcnQgfHwgc2xpY2Uub3BlbkVuZCkge1xuICAgICAgICAgICAgbGV0IG9wZW5TdGFydCA9IDAsIG9wZW5FbmQgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgbm9kZSA9IHNsaWNlLmNvbnRlbnQuZmlyc3RDaGlsZDsgb3BlblN0YXJ0IDwgc2xpY2Uub3BlblN0YXJ0ICYmICFub2RlLnR5cGUuc3BlYy5pc29sYXRpbmc7IG9wZW5TdGFydCsrLCBub2RlID0gbm9kZS5maXJzdENoaWxkKSB7IH1cbiAgICAgICAgICAgIGZvciAobGV0IG5vZGUgPSBzbGljZS5jb250ZW50Lmxhc3RDaGlsZDsgb3BlbkVuZCA8IHNsaWNlLm9wZW5FbmQgJiYgIW5vZGUudHlwZS5zcGVjLmlzb2xhdGluZzsgb3BlbkVuZCsrLCBub2RlID0gbm9kZS5sYXN0Q2hpbGQpIHsgfVxuICAgICAgICAgICAgc2xpY2UgPSBjbG9zZVNsaWNlKHNsaWNlLCBvcGVuU3RhcnQsIG9wZW5FbmQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZpZXcuc29tZVByb3AoXCJ0cmFuc2Zvcm1QYXN0ZWRcIiwgZiA9PiB7IHNsaWNlID0gZihzbGljZSwgdmlldywgYXNUZXh0KTsgfSk7XG4gICAgcmV0dXJuIHNsaWNlO1xufVxuY29uc3QgaW5saW5lUGFyZW50cyA9IC9eKGF8YWJicnxhY3JvbnltfGJ8Y2l0ZXxjb2RlfGRlbHxlbXxpfGluc3xrYmR8bGFiZWx8b3V0cHV0fHF8cnVieXxzfHNhbXB8c3BhbnxzdHJvbmd8c3VifHN1cHx0aW1lfHV8dHR8dmFyKSQvaTtcbi8vIFRha2VzIGEgc2xpY2UgcGFyc2VkIHdpdGggcGFyc2VTbGljZSwgd2hpY2ggbWVhbnMgdGhlcmUgaGFzbid0IGJlZW5cbi8vIGFueSBjb250ZW50LWV4cHJlc3Npb24gY2hlY2tpbmcgZG9uZSBvbiB0aGUgdG9wIG5vZGVzLCB0cmllcyB0b1xuLy8gZmluZCBhIHBhcmVudCBub2RlIGluIHRoZSBjdXJyZW50IGNvbnRleHQgdGhhdCBtaWdodCBmaXQgdGhlIG5vZGVzLFxuLy8gYW5kIGlmIHN1Y2Nlc3NmdWwsIHJlYnVpbGRzIHRoZSBzbGljZSBzbyB0aGF0IGl0IGZpdHMgaW50byB0aGF0IHBhcmVudC5cbi8vXG4vLyBUaGlzIGFkZHJlc3NlcyB0aGUgcHJvYmxlbSB0aGF0IFRyYW5zZm9ybS5yZXBsYWNlIGV4cGVjdHMgYVxuLy8gY29oZXJlbnQgc2xpY2UsIGFuZCB3aWxsIGZhaWwgdG8gcGxhY2UgYSBzZXQgb2Ygc2libGluZ3MgdGhhdCBkb24ndFxuLy8gZml0IGFueXdoZXJlIGluIHRoZSBzY2hlbWEuXG5mdW5jdGlvbiBub3JtYWxpemVTaWJsaW5ncyhmcmFnbWVudCwgJGNvbnRleHQpIHtcbiAgICBpZiAoZnJhZ21lbnQuY2hpbGRDb3VudCA8IDIpXG4gICAgICAgIHJldHVybiBmcmFnbWVudDtcbiAgICBmb3IgKGxldCBkID0gJGNvbnRleHQuZGVwdGg7IGQgPj0gMDsgZC0tKSB7XG4gICAgICAgIGxldCBwYXJlbnQgPSAkY29udGV4dC5ub2RlKGQpO1xuICAgICAgICBsZXQgbWF0Y2ggPSBwYXJlbnQuY29udGVudE1hdGNoQXQoJGNvbnRleHQuaW5kZXgoZCkpO1xuICAgICAgICBsZXQgbGFzdFdyYXAsIHJlc3VsdCA9IFtdO1xuICAgICAgICBmcmFnbWVudC5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IHdyYXAgPSBtYXRjaC5maW5kV3JhcHBpbmcobm9kZS50eXBlKSwgaW5MYXN0O1xuICAgICAgICAgICAgaWYgKCF3cmFwKVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgPSBudWxsO1xuICAgICAgICAgICAgaWYgKGluTGFzdCA9IHJlc3VsdC5sZW5ndGggJiYgbGFzdFdyYXAubGVuZ3RoICYmIGFkZFRvU2libGluZyh3cmFwLCBsYXN0V3JhcCwgbm9kZSwgcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSwgMCkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdID0gaW5MYXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0gPSBjbG9zZVJpZ2h0KHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0sIGxhc3RXcmFwLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgbGV0IHdyYXBwZWQgPSB3aXRoV3JhcHBlcnMobm9kZSwgd3JhcCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2god3JhcHBlZCk7XG4gICAgICAgICAgICAgICAgbWF0Y2ggPSBtYXRjaC5tYXRjaFR5cGUod3JhcHBlZC50eXBlKTtcbiAgICAgICAgICAgICAgICBsYXN0V3JhcCA9IHdyYXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocmVzdWx0KVxuICAgICAgICAgICAgcmV0dXJuIEZyYWdtZW50LmZyb20ocmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIGZyYWdtZW50O1xufVxuZnVuY3Rpb24gd2l0aFdyYXBwZXJzKG5vZGUsIHdyYXAsIGZyb20gPSAwKSB7XG4gICAgZm9yIChsZXQgaSA9IHdyYXAubGVuZ3RoIC0gMTsgaSA+PSBmcm9tOyBpLS0pXG4gICAgICAgIG5vZGUgPSB3cmFwW2ldLmNyZWF0ZShudWxsLCBGcmFnbWVudC5mcm9tKG5vZGUpKTtcbiAgICByZXR1cm4gbm9kZTtcbn1cbi8vIFVzZWQgdG8gZ3JvdXAgYWRqYWNlbnQgbm9kZXMgd3JhcHBlZCBpbiBzaW1pbGFyIHBhcmVudHMgYnlcbi8vIG5vcm1hbGl6ZVNpYmxpbmdzIGludG8gdGhlIHNhbWUgcGFyZW50IG5vZGVcbmZ1bmN0aW9uIGFkZFRvU2libGluZyh3cmFwLCBsYXN0V3JhcCwgbm9kZSwgc2libGluZywgZGVwdGgpIHtcbiAgICBpZiAoZGVwdGggPCB3cmFwLmxlbmd0aCAmJiBkZXB0aCA8IGxhc3RXcmFwLmxlbmd0aCAmJiB3cmFwW2RlcHRoXSA9PSBsYXN0V3JhcFtkZXB0aF0pIHtcbiAgICAgICAgbGV0IGlubmVyID0gYWRkVG9TaWJsaW5nKHdyYXAsIGxhc3RXcmFwLCBub2RlLCBzaWJsaW5nLmxhc3RDaGlsZCwgZGVwdGggKyAxKTtcbiAgICAgICAgaWYgKGlubmVyKVxuICAgICAgICAgICAgcmV0dXJuIHNpYmxpbmcuY29weShzaWJsaW5nLmNvbnRlbnQucmVwbGFjZUNoaWxkKHNpYmxpbmcuY2hpbGRDb3VudCAtIDEsIGlubmVyKSk7XG4gICAgICAgIGxldCBtYXRjaCA9IHNpYmxpbmcuY29udGVudE1hdGNoQXQoc2libGluZy5jaGlsZENvdW50KTtcbiAgICAgICAgaWYgKG1hdGNoLm1hdGNoVHlwZShkZXB0aCA9PSB3cmFwLmxlbmd0aCAtIDEgPyBub2RlLnR5cGUgOiB3cmFwW2RlcHRoICsgMV0pKVxuICAgICAgICAgICAgcmV0dXJuIHNpYmxpbmcuY29weShzaWJsaW5nLmNvbnRlbnQuYXBwZW5kKEZyYWdtZW50LmZyb20od2l0aFdyYXBwZXJzKG5vZGUsIHdyYXAsIGRlcHRoICsgMSkpKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY2xvc2VSaWdodChub2RlLCBkZXB0aCkge1xuICAgIGlmIChkZXB0aCA9PSAwKVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICBsZXQgZnJhZ21lbnQgPSBub2RlLmNvbnRlbnQucmVwbGFjZUNoaWxkKG5vZGUuY2hpbGRDb3VudCAtIDEsIGNsb3NlUmlnaHQobm9kZS5sYXN0Q2hpbGQsIGRlcHRoIC0gMSkpO1xuICAgIGxldCBmaWxsID0gbm9kZS5jb250ZW50TWF0Y2hBdChub2RlLmNoaWxkQ291bnQpLmZpbGxCZWZvcmUoRnJhZ21lbnQuZW1wdHksIHRydWUpO1xuICAgIHJldHVybiBub2RlLmNvcHkoZnJhZ21lbnQuYXBwZW5kKGZpbGwpKTtcbn1cbmZ1bmN0aW9uIGNsb3NlUmFuZ2UoZnJhZ21lbnQsIHNpZGUsIGZyb20sIHRvLCBkZXB0aCwgb3BlbkVuZCkge1xuICAgIGxldCBub2RlID0gc2lkZSA8IDAgPyBmcmFnbWVudC5maXJzdENoaWxkIDogZnJhZ21lbnQubGFzdENoaWxkLCBpbm5lciA9IG5vZGUuY29udGVudDtcbiAgICBpZiAoZnJhZ21lbnQuY2hpbGRDb3VudCA+IDEpXG4gICAgICAgIG9wZW5FbmQgPSAwO1xuICAgIGlmIChkZXB0aCA8IHRvIC0gMSlcbiAgICAgICAgaW5uZXIgPSBjbG9zZVJhbmdlKGlubmVyLCBzaWRlLCBmcm9tLCB0bywgZGVwdGggKyAxLCBvcGVuRW5kKTtcbiAgICBpZiAoZGVwdGggPj0gZnJvbSlcbiAgICAgICAgaW5uZXIgPSBzaWRlIDwgMCA/IG5vZGUuY29udGVudE1hdGNoQXQoMCkuZmlsbEJlZm9yZShpbm5lciwgb3BlbkVuZCA8PSBkZXB0aCkuYXBwZW5kKGlubmVyKVxuICAgICAgICAgICAgOiBpbm5lci5hcHBlbmQobm9kZS5jb250ZW50TWF0Y2hBdChub2RlLmNoaWxkQ291bnQpLmZpbGxCZWZvcmUoRnJhZ21lbnQuZW1wdHksIHRydWUpKTtcbiAgICByZXR1cm4gZnJhZ21lbnQucmVwbGFjZUNoaWxkKHNpZGUgPCAwID8gMCA6IGZyYWdtZW50LmNoaWxkQ291bnQgLSAxLCBub2RlLmNvcHkoaW5uZXIpKTtcbn1cbmZ1bmN0aW9uIGNsb3NlU2xpY2Uoc2xpY2UsIG9wZW5TdGFydCwgb3BlbkVuZCkge1xuICAgIGlmIChvcGVuU3RhcnQgPCBzbGljZS5vcGVuU3RhcnQpXG4gICAgICAgIHNsaWNlID0gbmV3IFNsaWNlKGNsb3NlUmFuZ2Uoc2xpY2UuY29udGVudCwgLTEsIG9wZW5TdGFydCwgc2xpY2Uub3BlblN0YXJ0LCAwLCBzbGljZS5vcGVuRW5kKSwgb3BlblN0YXJ0LCBzbGljZS5vcGVuRW5kKTtcbiAgICBpZiAob3BlbkVuZCA8IHNsaWNlLm9wZW5FbmQpXG4gICAgICAgIHNsaWNlID0gbmV3IFNsaWNlKGNsb3NlUmFuZ2Uoc2xpY2UuY29udGVudCwgMSwgb3BlbkVuZCwgc2xpY2Uub3BlbkVuZCwgMCwgMCksIHNsaWNlLm9wZW5TdGFydCwgb3BlbkVuZCk7XG4gICAgcmV0dXJuIHNsaWNlO1xufVxuLy8gVHJpY2sgZnJvbSBqUXVlcnkgLS0gc29tZSBlbGVtZW50cyBtdXN0IGJlIHdyYXBwZWQgaW4gb3RoZXJcbi8vIGVsZW1lbnRzIGZvciBpbm5lckhUTUwgdG8gd29yay4gSS5lLiBpZiB5b3UgZG8gYGRpdi5pbm5lckhUTUwgPVxuLy8gXCI8dGQ+Li48L3RkPlwiYCB0aGUgdGFibGUgY2VsbHMgYXJlIGlnbm9yZWQuXG5jb25zdCB3cmFwTWFwID0ge1xuICAgIHRoZWFkOiBbXCJ0YWJsZVwiXSxcbiAgICB0Ym9keTogW1widGFibGVcIl0sXG4gICAgdGZvb3Q6IFtcInRhYmxlXCJdLFxuICAgIGNhcHRpb246IFtcInRhYmxlXCJdLFxuICAgIGNvbGdyb3VwOiBbXCJ0YWJsZVwiXSxcbiAgICBjb2w6IFtcInRhYmxlXCIsIFwiY29sZ3JvdXBcIl0sXG4gICAgdHI6IFtcInRhYmxlXCIsIFwidGJvZHlcIl0sXG4gICAgdGQ6IFtcInRhYmxlXCIsIFwidGJvZHlcIiwgXCJ0clwiXSxcbiAgICB0aDogW1widGFibGVcIiwgXCJ0Ym9keVwiLCBcInRyXCJdXG59O1xubGV0IF9kZXRhY2hlZERvYyA9IG51bGw7XG5mdW5jdGlvbiBkZXRhY2hlZERvYygpIHtcbiAgICByZXR1cm4gX2RldGFjaGVkRG9jIHx8IChfZGV0YWNoZWREb2MgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoXCJ0aXRsZVwiKSk7XG59XG5sZXQgX3BvbGljeSA9IG51bGw7XG5mdW5jdGlvbiBtYXliZVdyYXBUcnVzdGVkKGh0bWwpIHtcbiAgICBsZXQgdHJ1c3RlZFR5cGVzID0gd2luZG93LnRydXN0ZWRUeXBlcztcbiAgICBpZiAoIXRydXN0ZWRUeXBlcylcbiAgICAgICAgcmV0dXJuIGh0bWw7XG4gICAgLy8gV2l0aCB0aGUgcmVxdWlyZS10cnVzdGVkLXR5cGVzLWZvciBDU1AsIENocm9tZSB3aWxsIGJsb2NrXG4gICAgLy8gaW5uZXJIVE1MLCBldmVuIG9uIGEgZGV0YWNoZWQgZG9jdW1lbnQuIFRoaXMgd3JhcHMgdGhlIHN0cmluZyBpblxuICAgIC8vIGEgd2F5IHRoYXQgbWFrZXMgdGhlIGJyb3dzZXIgYWxsb3cgdXMgdG8gdXNlIGl0cyBwYXJzZXIgYWdhaW4uXG4gICAgaWYgKCFfcG9saWN5KVxuICAgICAgICBfcG9saWN5ID0gdHJ1c3RlZFR5cGVzLmRlZmF1bHRQb2xpY3kgfHwgdHJ1c3RlZFR5cGVzLmNyZWF0ZVBvbGljeShcIlByb3NlTWlycm9yQ2xpcGJvYXJkXCIsIHsgY3JlYXRlSFRNTDogKHMpID0+IHMgfSk7XG4gICAgcmV0dXJuIF9wb2xpY3kuY3JlYXRlSFRNTChodG1sKTtcbn1cbmZ1bmN0aW9uIHJlYWRIVE1MKGh0bWwpIHtcbiAgICBsZXQgbWV0YXMgPSAvXihcXHMqPG1ldGEgW14+XSo+KSovLmV4ZWMoaHRtbCk7XG4gICAgaWYgKG1ldGFzKVxuICAgICAgICBodG1sID0gaHRtbC5zbGljZShtZXRhc1swXS5sZW5ndGgpO1xuICAgIGxldCBlbHQgPSBkZXRhY2hlZERvYygpLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgbGV0IGZpcnN0VGFnID0gLzwoW2Etel1bXj5cXHNdKykvaS5leGVjKGh0bWwpLCB3cmFwO1xuICAgIGlmICh3cmFwID0gZmlyc3RUYWcgJiYgd3JhcE1hcFtmaXJzdFRhZ1sxXS50b0xvd2VyQ2FzZSgpXSlcbiAgICAgICAgaHRtbCA9IHdyYXAubWFwKG4gPT4gXCI8XCIgKyBuICsgXCI+XCIpLmpvaW4oXCJcIikgKyBodG1sICsgd3JhcC5tYXAobiA9PiBcIjwvXCIgKyBuICsgXCI+XCIpLnJldmVyc2UoKS5qb2luKFwiXCIpO1xuICAgIGVsdC5pbm5lckhUTUwgPSBtYXliZVdyYXBUcnVzdGVkKGh0bWwpO1xuICAgIGlmICh3cmFwKVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdyYXAubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBlbHQgPSBlbHQucXVlcnlTZWxlY3Rvcih3cmFwW2ldKSB8fCBlbHQ7XG4gICAgcmV0dXJuIGVsdDtcbn1cbi8vIFdlYmtpdCBicm93c2VycyBkbyBzb21lIGhhcmQtdG8tcHJlZGljdCByZXBsYWNlbWVudCBvZiByZWd1bGFyXG4vLyBzcGFjZXMgd2l0aCBub24tYnJlYWtpbmcgc3BhY2VzIHdoZW4gcHV0dGluZyBjb250ZW50IG9uIHRoZVxuLy8gY2xpcGJvYXJkLiBUaGlzIHRyaWVzIHRvIGNvbnZlcnQgc3VjaCBub24tYnJlYWtpbmcgc3BhY2VzICh3aGljaFxuLy8gd2lsbCBiZSB3cmFwcGVkIGluIGEgcGxhaW4gc3BhbiBvbiBDaHJvbWUsIGEgc3BhbiB3aXRoIGNsYXNzXG4vLyBBcHBsZS1jb252ZXJ0ZWQtc3BhY2Ugb24gU2FmYXJpKSBiYWNrIHRvIHJlZ3VsYXIgc3BhY2VzLlxuZnVuY3Rpb24gcmVzdG9yZVJlcGxhY2VkU3BhY2VzKGRvbSkge1xuICAgIGxldCBub2RlcyA9IGRvbS5xdWVyeVNlbGVjdG9yQWxsKGNocm9tZSA/IFwic3Bhbjpub3QoW2NsYXNzXSk6bm90KFtzdHlsZV0pXCIgOiBcInNwYW4uQXBwbGUtY29udmVydGVkLXNwYWNlXCIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgaWYgKG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggPT0gMSAmJiBub2RlLnRleHRDb250ZW50ID09IFwiXFx1MDBhMFwiICYmIG5vZGUucGFyZW50Tm9kZSlcbiAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoZG9tLm93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCIgXCIpLCBub2RlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhZGRDb250ZXh0KHNsaWNlLCBjb250ZXh0KSB7XG4gICAgaWYgKCFzbGljZS5zaXplKVxuICAgICAgICByZXR1cm4gc2xpY2U7XG4gICAgbGV0IHNjaGVtYSA9IHNsaWNlLmNvbnRlbnQuZmlyc3RDaGlsZC50eXBlLnNjaGVtYSwgYXJyYXk7XG4gICAgdHJ5IHtcbiAgICAgICAgYXJyYXkgPSBKU09OLnBhcnNlKGNvbnRleHQpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gc2xpY2U7XG4gICAgfVxuICAgIGxldCB7IGNvbnRlbnQsIG9wZW5TdGFydCwgb3BlbkVuZCB9ID0gc2xpY2U7XG4gICAgZm9yIChsZXQgaSA9IGFycmF5Lmxlbmd0aCAtIDI7IGkgPj0gMDsgaSAtPSAyKSB7XG4gICAgICAgIGxldCB0eXBlID0gc2NoZW1hLm5vZGVzW2FycmF5W2ldXTtcbiAgICAgICAgaWYgKCF0eXBlIHx8IHR5cGUuaGFzUmVxdWlyZWRBdHRycygpKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNvbnRlbnQgPSBGcmFnbWVudC5mcm9tKHR5cGUuY3JlYXRlKGFycmF5W2kgKyAxXSwgY29udGVudCkpO1xuICAgICAgICBvcGVuU3RhcnQrKztcbiAgICAgICAgb3BlbkVuZCsrO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFNsaWNlKGNvbnRlbnQsIG9wZW5TdGFydCwgb3BlbkVuZCk7XG59XG5cbi8vIEEgY29sbGVjdGlvbiBvZiBET00gZXZlbnRzIHRoYXQgb2NjdXIgd2l0aGluIHRoZSBlZGl0b3IsIGFuZCBjYWxsYmFjayBmdW5jdGlvbnNcbi8vIHRvIGludm9rZSB3aGVuIHRoZSBldmVudCBmaXJlcy5cbmNvbnN0IGhhbmRsZXJzID0ge307XG5jb25zdCBlZGl0SGFuZGxlcnMgPSB7fTtcbmNvbnN0IHBhc3NpdmVIYW5kbGVycyA9IHsgdG91Y2hzdGFydDogdHJ1ZSwgdG91Y2htb3ZlOiB0cnVlIH07XG5jbGFzcyBJbnB1dFN0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5zaGlmdEtleSA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1vdXNlRG93biA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdEtleUNvZGUgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RLZXlDb2RlVGltZSA9IDA7XG4gICAgICAgIHRoaXMubGFzdENsaWNrID0geyB0aW1lOiAwLCB4OiAwLCB5OiAwLCB0eXBlOiBcIlwiLCBidXR0b246IDAgfTtcbiAgICAgICAgdGhpcy5sYXN0U2VsZWN0aW9uT3JpZ2luID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0U2VsZWN0aW9uVGltZSA9IDA7XG4gICAgICAgIHRoaXMubGFzdElPU0VudGVyID0gMDtcbiAgICAgICAgdGhpcy5sYXN0SU9TRW50ZXJGYWxsYmFja1RpbWVvdXQgPSAtMTtcbiAgICAgICAgdGhpcy5sYXN0Rm9jdXMgPSAwO1xuICAgICAgICB0aGlzLmxhc3RUb3VjaCA9IDA7XG4gICAgICAgIHRoaXMubGFzdENocm9tZURlbGV0ZSA9IDA7XG4gICAgICAgIHRoaXMuY29tcG9zaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY29tcG9zaXRpb25Ob2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5jb21wb3NpbmdUaW1lb3V0ID0gLTE7XG4gICAgICAgIHRoaXMuY29tcG9zaXRpb25Ob2RlcyA9IFtdO1xuICAgICAgICB0aGlzLmNvbXBvc2l0aW9uRW5kZWRBdCA9IC0yZTg7XG4gICAgICAgIHRoaXMuY29tcG9zaXRpb25JRCA9IDE7XG4gICAgICAgIC8vIFNldCB0byBhIGNvbXBvc2l0aW9uIElEIHdoZW4gdGhlcmUgYXJlIHBlbmRpbmcgY2hhbmdlcyBhdCBjb21wb3NpdGlvbmVuZFxuICAgICAgICB0aGlzLmNvbXBvc2l0aW9uUGVuZGluZ0NoYW5nZXMgPSAwO1xuICAgICAgICB0aGlzLmRvbUNoYW5nZUNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5ldmVudEhhbmRsZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5oaWRlU2VsZWN0aW9uR3VhcmQgPSBudWxsO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGluaXRJbnB1dCh2aWV3KSB7XG4gICAgZm9yIChsZXQgZXZlbnQgaW4gaGFuZGxlcnMpIHtcbiAgICAgICAgbGV0IGhhbmRsZXIgPSBoYW5kbGVyc1tldmVudF07XG4gICAgICAgIHZpZXcuZG9tLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIHZpZXcuaW5wdXQuZXZlbnRIYW5kbGVyc1tldmVudF0gPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudEJlbG9uZ3NUb1ZpZXcodmlldywgZXZlbnQpICYmICFydW5DdXN0b21IYW5kbGVyKHZpZXcsIGV2ZW50KSAmJlxuICAgICAgICAgICAgICAgICh2aWV3LmVkaXRhYmxlIHx8ICEoZXZlbnQudHlwZSBpbiBlZGl0SGFuZGxlcnMpKSlcbiAgICAgICAgICAgICAgICBoYW5kbGVyKHZpZXcsIGV2ZW50KTtcbiAgICAgICAgfSwgcGFzc2l2ZUhhbmRsZXJzW2V2ZW50XSA/IHsgcGFzc2l2ZTogdHJ1ZSB9IDogdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgLy8gT24gU2FmYXJpLCBmb3IgcmVhc29ucyBiZXlvbmQgbXkgdW5kZXJzdGFuZGluZywgYWRkaW5nIGFuIGlucHV0XG4gICAgLy8gZXZlbnQgaGFuZGxlciBtYWtlcyBhbiBpc3N1ZSB3aGVyZSB0aGUgY29tcG9zaXRpb24gdmFuaXNoZXMgd2hlblxuICAgIC8vIHlvdSBwcmVzcyBlbnRlciBnbyBhd2F5LlxuICAgIGlmIChzYWZhcmkpXG4gICAgICAgIHZpZXcuZG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCAoKSA9PiBudWxsKTtcbiAgICBlbnN1cmVMaXN0ZW5lcnModmlldyk7XG59XG5mdW5jdGlvbiBzZXRTZWxlY3Rpb25PcmlnaW4odmlldywgb3JpZ2luKSB7XG4gICAgdmlldy5pbnB1dC5sYXN0U2VsZWN0aW9uT3JpZ2luID0gb3JpZ2luO1xuICAgIHZpZXcuaW5wdXQubGFzdFNlbGVjdGlvblRpbWUgPSBEYXRlLm5vdygpO1xufVxuZnVuY3Rpb24gZGVzdHJveUlucHV0KHZpZXcpIHtcbiAgICB2aWV3LmRvbU9ic2VydmVyLnN0b3AoKTtcbiAgICBmb3IgKGxldCB0eXBlIGluIHZpZXcuaW5wdXQuZXZlbnRIYW5kbGVycylcbiAgICAgICAgdmlldy5kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCB2aWV3LmlucHV0LmV2ZW50SGFuZGxlcnNbdHlwZV0pO1xuICAgIGNsZWFyVGltZW91dCh2aWV3LmlucHV0LmNvbXBvc2luZ1RpbWVvdXQpO1xuICAgIGNsZWFyVGltZW91dCh2aWV3LmlucHV0Lmxhc3RJT1NFbnRlckZhbGxiYWNrVGltZW91dCk7XG59XG5mdW5jdGlvbiBlbnN1cmVMaXN0ZW5lcnModmlldykge1xuICAgIHZpZXcuc29tZVByb3AoXCJoYW5kbGVET01FdmVudHNcIiwgY3VycmVudEhhbmRsZXJzID0+IHtcbiAgICAgICAgZm9yIChsZXQgdHlwZSBpbiBjdXJyZW50SGFuZGxlcnMpXG4gICAgICAgICAgICBpZiAoIXZpZXcuaW5wdXQuZXZlbnRIYW5kbGVyc1t0eXBlXSlcbiAgICAgICAgICAgICAgICB2aWV3LmRvbS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIHZpZXcuaW5wdXQuZXZlbnRIYW5kbGVyc1t0eXBlXSA9IGV2ZW50ID0+IHJ1bkN1c3RvbUhhbmRsZXIodmlldywgZXZlbnQpKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHJ1bkN1c3RvbUhhbmRsZXIodmlldywgZXZlbnQpIHtcbiAgICByZXR1cm4gdmlldy5zb21lUHJvcChcImhhbmRsZURPTUV2ZW50c1wiLCBoYW5kbGVycyA9PiB7XG4gICAgICAgIGxldCBoYW5kbGVyID0gaGFuZGxlcnNbZXZlbnQudHlwZV07XG4gICAgICAgIHJldHVybiBoYW5kbGVyID8gaGFuZGxlcih2aWV3LCBldmVudCkgfHwgZXZlbnQuZGVmYXVsdFByZXZlbnRlZCA6IGZhbHNlO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZXZlbnRCZWxvbmdzVG9WaWV3KHZpZXcsIGV2ZW50KSB7XG4gICAgaWYgKCFldmVudC5idWJibGVzKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IG5vZGUgPSBldmVudC50YXJnZXQ7IG5vZGUgIT0gdmlldy5kb207IG5vZGUgPSBub2RlLnBhcmVudE5vZGUpXG4gICAgICAgIGlmICghbm9kZSB8fCBub2RlLm5vZGVUeXBlID09IDExIHx8XG4gICAgICAgICAgICAobm9kZS5wbVZpZXdEZXNjICYmIG5vZGUucG1WaWV3RGVzYy5zdG9wRXZlbnQoZXZlbnQpKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQodmlldywgZXZlbnQpIHtcbiAgICBpZiAoIXJ1bkN1c3RvbUhhbmRsZXIodmlldywgZXZlbnQpICYmIGhhbmRsZXJzW2V2ZW50LnR5cGVdICYmXG4gICAgICAgICh2aWV3LmVkaXRhYmxlIHx8ICEoZXZlbnQudHlwZSBpbiBlZGl0SGFuZGxlcnMpKSlcbiAgICAgICAgaGFuZGxlcnNbZXZlbnQudHlwZV0odmlldywgZXZlbnQpO1xufVxuZWRpdEhhbmRsZXJzLmtleWRvd24gPSAodmlldywgX2V2ZW50KSA9PiB7XG4gICAgbGV0IGV2ZW50ID0gX2V2ZW50O1xuICAgIHZpZXcuaW5wdXQuc2hpZnRLZXkgPSBldmVudC5rZXlDb2RlID09IDE2IHx8IGV2ZW50LnNoaWZ0S2V5O1xuICAgIGlmIChpbk9yTmVhckNvbXBvc2l0aW9uKHZpZXcsIGV2ZW50KSlcbiAgICAgICAgcmV0dXJuO1xuICAgIHZpZXcuaW5wdXQubGFzdEtleUNvZGUgPSBldmVudC5rZXlDb2RlO1xuICAgIHZpZXcuaW5wdXQubGFzdEtleUNvZGVUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAvLyBTdXBwcmVzcyBlbnRlciBrZXkgZXZlbnRzIG9uIENocm9tZSBBbmRyb2lkLCBiZWNhdXNlIHRob3NlIHRlbmRcbiAgICAvLyB0byBiZSBwYXJ0IG9mIGEgY29uZnVzZWQgc2VxdWVuY2Ugb2YgY29tcG9zaXRpb24gZXZlbnRzIGZpcmVkLFxuICAgIC8vIGFuZCBoYW5kbGluZyB0aGVtIGVhZ2VybHkgdGVuZHMgdG8gY29ycnVwdCB0aGUgaW5wdXQuXG4gICAgaWYgKGFuZHJvaWQgJiYgY2hyb21lICYmIGV2ZW50LmtleUNvZGUgPT0gMTMpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoZXZlbnQua2V5Q29kZSAhPSAyMjkpXG4gICAgICAgIHZpZXcuZG9tT2JzZXJ2ZXIuZm9yY2VGbHVzaCgpO1xuICAgIC8vIE9uIGlPUywgaWYgd2UgcHJldmVudERlZmF1bHQgZW50ZXIga2V5IHByZXNzZXMsIHRoZSB2aXJ0dWFsXG4gICAgLy8ga2V5Ym9hcmQgZ2V0cyBjb25mdXNlZC4gU28gdGhlIGhhY2sgaGVyZSBpcyB0byBzZXQgYSBmbGFnIHRoYXRcbiAgICAvLyBtYWtlcyB0aGUgRE9NIGNoYW5nZSBjb2RlIHJlY29nbml6ZSB0aGF0IHdoYXQganVzdCBoYXBwZW5zIHNob3VsZFxuICAgIC8vIGJlIHJlcGxhY2VkIGJ5IHdoYXRldmVyIHRoZSBFbnRlciBrZXkgaGFuZGxlcnMgZG8uXG4gICAgaWYgKGlvcyAmJiBldmVudC5rZXlDb2RlID09IDEzICYmICFldmVudC5jdHJsS2V5ICYmICFldmVudC5hbHRLZXkgJiYgIWV2ZW50Lm1ldGFLZXkpIHtcbiAgICAgICAgbGV0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIHZpZXcuaW5wdXQubGFzdElPU0VudGVyID0gbm93O1xuICAgICAgICB2aWV3LmlucHV0Lmxhc3RJT1NFbnRlckZhbGxiYWNrVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHZpZXcuaW5wdXQubGFzdElPU0VudGVyID09IG5vdykge1xuICAgICAgICAgICAgICAgIHZpZXcuc29tZVByb3AoXCJoYW5kbGVLZXlEb3duXCIsIGYgPT4gZih2aWV3LCBrZXlFdmVudCgxMywgXCJFbnRlclwiKSkpO1xuICAgICAgICAgICAgICAgIHZpZXcuaW5wdXQubGFzdElPU0VudGVyID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgMjAwKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodmlldy5zb21lUHJvcChcImhhbmRsZUtleURvd25cIiwgZiA9PiBmKHZpZXcsIGV2ZW50KSkgfHwgY2FwdHVyZUtleURvd24odmlldywgZXZlbnQpKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzZXRTZWxlY3Rpb25PcmlnaW4odmlldywgXCJrZXlcIik7XG4gICAgfVxufTtcbmVkaXRIYW5kbGVycy5rZXl1cCA9ICh2aWV3LCBldmVudCkgPT4ge1xuICAgIGlmIChldmVudC5rZXlDb2RlID09IDE2KVxuICAgICAgICB2aWV3LmlucHV0LnNoaWZ0S2V5ID0gZmFsc2U7XG59O1xuZWRpdEhhbmRsZXJzLmtleXByZXNzID0gKHZpZXcsIF9ldmVudCkgPT4ge1xuICAgIGxldCBldmVudCA9IF9ldmVudDtcbiAgICBpZiAoaW5Pck5lYXJDb21wb3NpdGlvbih2aWV3LCBldmVudCkgfHwgIWV2ZW50LmNoYXJDb2RlIHx8XG4gICAgICAgIGV2ZW50LmN0cmxLZXkgJiYgIWV2ZW50LmFsdEtleSB8fCBtYWMgJiYgZXZlbnQubWV0YUtleSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICh2aWV3LnNvbWVQcm9wKFwiaGFuZGxlS2V5UHJlc3NcIiwgZiA9PiBmKHZpZXcsIGV2ZW50KSkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgc2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKCEoc2VsIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbikgfHwgIXNlbC4kZnJvbS5zYW1lUGFyZW50KHNlbC4kdG8pKSB7XG4gICAgICAgIGxldCB0ZXh0ID0gU3RyaW5nLmZyb21DaGFyQ29kZShldmVudC5jaGFyQ29kZSk7XG4gICAgICAgIGxldCBkZWZsdCA9ICgpID0+IHZpZXcuc3RhdGUudHIuaW5zZXJ0VGV4dCh0ZXh0KS5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICBpZiAoIS9bXFxyXFxuXS8udGVzdCh0ZXh0KSAmJiAhdmlldy5zb21lUHJvcChcImhhbmRsZVRleHRJbnB1dFwiLCBmID0+IGYodmlldywgc2VsLiRmcm9tLnBvcywgc2VsLiR0by5wb3MsIHRleHQsIGRlZmx0KSkpXG4gICAgICAgICAgICB2aWV3LmRpc3BhdGNoKGRlZmx0KCkpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbn07XG5mdW5jdGlvbiBldmVudENvb3JkcyhldmVudCkgeyByZXR1cm4geyBsZWZ0OiBldmVudC5jbGllbnRYLCB0b3A6IGV2ZW50LmNsaWVudFkgfTsgfVxuZnVuY3Rpb24gaXNOZWFyKGV2ZW50LCBjbGljaykge1xuICAgIGxldCBkeCA9IGNsaWNrLnggLSBldmVudC5jbGllbnRYLCBkeSA9IGNsaWNrLnkgLSBldmVudC5jbGllbnRZO1xuICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeSA8IDEwMDtcbn1cbmZ1bmN0aW9uIHJ1bkhhbmRsZXJPbkNvbnRleHQodmlldywgcHJvcE5hbWUsIHBvcywgaW5zaWRlLCBldmVudCkge1xuICAgIGlmIChpbnNpZGUgPT0gLTEpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgJHBvcyA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoaW5zaWRlKTtcbiAgICBmb3IgKGxldCBpID0gJHBvcy5kZXB0aCArIDE7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgaWYgKHZpZXcuc29tZVByb3AocHJvcE5hbWUsIGYgPT4gaSA+ICRwb3MuZGVwdGggPyBmKHZpZXcsIHBvcywgJHBvcy5ub2RlQWZ0ZXIsICRwb3MuYmVmb3JlKGkpLCBldmVudCwgdHJ1ZSlcbiAgICAgICAgICAgIDogZih2aWV3LCBwb3MsICRwb3Mubm9kZShpKSwgJHBvcy5iZWZvcmUoaSksIGV2ZW50LCBmYWxzZSkpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZVNlbGVjdGlvbih2aWV3LCBzZWxlY3Rpb24sIG9yaWdpbikge1xuICAgIGlmICghdmlldy5mb2N1c2VkKVxuICAgICAgICB2aWV3LmZvY3VzKCk7XG4gICAgaWYgKHZpZXcuc3RhdGUuc2VsZWN0aW9uLmVxKHNlbGVjdGlvbikpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgdHIgPSB2aWV3LnN0YXRlLnRyLnNldFNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICAgIGlmIChvcmlnaW4gPT0gXCJwb2ludGVyXCIpXG4gICAgICAgIHRyLnNldE1ldGEoXCJwb2ludGVyXCIsIHRydWUpO1xuICAgIHZpZXcuZGlzcGF0Y2godHIpO1xufVxuZnVuY3Rpb24gc2VsZWN0Q2xpY2tlZExlYWYodmlldywgaW5zaWRlKSB7XG4gICAgaWYgKGluc2lkZSA9PSAtMSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCAkcG9zID0gdmlldy5zdGF0ZS5kb2MucmVzb2x2ZShpbnNpZGUpLCBub2RlID0gJHBvcy5ub2RlQWZ0ZXI7XG4gICAgaWYgKG5vZGUgJiYgbm9kZS5pc0F0b20gJiYgTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUobm9kZSkpIHtcbiAgICAgICAgdXBkYXRlU2VsZWN0aW9uKHZpZXcsIG5ldyBOb2RlU2VsZWN0aW9uKCRwb3MpLCBcInBvaW50ZXJcIik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBzZWxlY3RDbGlja2VkTm9kZSh2aWV3LCBpbnNpZGUpIHtcbiAgICBpZiAoaW5zaWRlID09IC0xKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLCBzZWxlY3RlZE5vZGUsIHNlbGVjdEF0O1xuICAgIGlmIChzZWwgaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uKVxuICAgICAgICBzZWxlY3RlZE5vZGUgPSBzZWwubm9kZTtcbiAgICBsZXQgJHBvcyA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoaW5zaWRlKTtcbiAgICBmb3IgKGxldCBpID0gJHBvcy5kZXB0aCArIDE7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgbGV0IG5vZGUgPSBpID4gJHBvcy5kZXB0aCA/ICRwb3Mubm9kZUFmdGVyIDogJHBvcy5ub2RlKGkpO1xuICAgICAgICBpZiAoTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUobm9kZSkpIHtcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZE5vZGUgJiYgc2VsLiRmcm9tLmRlcHRoID4gMCAmJlxuICAgICAgICAgICAgICAgIGkgPj0gc2VsLiRmcm9tLmRlcHRoICYmICRwb3MuYmVmb3JlKHNlbC4kZnJvbS5kZXB0aCArIDEpID09IHNlbC4kZnJvbS5wb3MpXG4gICAgICAgICAgICAgICAgc2VsZWN0QXQgPSAkcG9zLmJlZm9yZShzZWwuJGZyb20uZGVwdGgpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHNlbGVjdEF0ID0gJHBvcy5iZWZvcmUoaSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2VsZWN0QXQgIT0gbnVsbCkge1xuICAgICAgICB1cGRhdGVTZWxlY3Rpb24odmlldywgTm9kZVNlbGVjdGlvbi5jcmVhdGUodmlldy5zdGF0ZS5kb2MsIHNlbGVjdEF0KSwgXCJwb2ludGVyXCIpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBoYW5kbGVTaW5nbGVDbGljayh2aWV3LCBwb3MsIGluc2lkZSwgZXZlbnQsIHNlbGVjdE5vZGUpIHtcbiAgICByZXR1cm4gcnVuSGFuZGxlck9uQ29udGV4dCh2aWV3LCBcImhhbmRsZUNsaWNrT25cIiwgcG9zLCBpbnNpZGUsIGV2ZW50KSB8fFxuICAgICAgICB2aWV3LnNvbWVQcm9wKFwiaGFuZGxlQ2xpY2tcIiwgZiA9PiBmKHZpZXcsIHBvcywgZXZlbnQpKSB8fFxuICAgICAgICAoc2VsZWN0Tm9kZSA/IHNlbGVjdENsaWNrZWROb2RlKHZpZXcsIGluc2lkZSkgOiBzZWxlY3RDbGlja2VkTGVhZih2aWV3LCBpbnNpZGUpKTtcbn1cbmZ1bmN0aW9uIGhhbmRsZURvdWJsZUNsaWNrKHZpZXcsIHBvcywgaW5zaWRlLCBldmVudCkge1xuICAgIHJldHVybiBydW5IYW5kbGVyT25Db250ZXh0KHZpZXcsIFwiaGFuZGxlRG91YmxlQ2xpY2tPblwiLCBwb3MsIGluc2lkZSwgZXZlbnQpIHx8XG4gICAgICAgIHZpZXcuc29tZVByb3AoXCJoYW5kbGVEb3VibGVDbGlja1wiLCBmID0+IGYodmlldywgcG9zLCBldmVudCkpO1xufVxuZnVuY3Rpb24gaGFuZGxlVHJpcGxlQ2xpY2sodmlldywgcG9zLCBpbnNpZGUsIGV2ZW50KSB7XG4gICAgcmV0dXJuIHJ1bkhhbmRsZXJPbkNvbnRleHQodmlldywgXCJoYW5kbGVUcmlwbGVDbGlja09uXCIsIHBvcywgaW5zaWRlLCBldmVudCkgfHxcbiAgICAgICAgdmlldy5zb21lUHJvcChcImhhbmRsZVRyaXBsZUNsaWNrXCIsIGYgPT4gZih2aWV3LCBwb3MsIGV2ZW50KSkgfHxcbiAgICAgICAgZGVmYXVsdFRyaXBsZUNsaWNrKHZpZXcsIGluc2lkZSwgZXZlbnQpO1xufVxuZnVuY3Rpb24gZGVmYXVsdFRyaXBsZUNsaWNrKHZpZXcsIGluc2lkZSwgZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuYnV0dG9uICE9IDApXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgZG9jID0gdmlldy5zdGF0ZS5kb2M7XG4gICAgaWYgKGluc2lkZSA9PSAtMSkge1xuICAgICAgICBpZiAoZG9jLmlubGluZUNvbnRlbnQpIHtcbiAgICAgICAgICAgIHVwZGF0ZVNlbGVjdGlvbih2aWV3LCBUZXh0U2VsZWN0aW9uLmNyZWF0ZShkb2MsIDAsIGRvYy5jb250ZW50LnNpemUpLCBcInBvaW50ZXJcIik7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCAkcG9zID0gZG9jLnJlc29sdmUoaW5zaWRlKTtcbiAgICBmb3IgKGxldCBpID0gJHBvcy5kZXB0aCArIDE7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgbGV0IG5vZGUgPSBpID4gJHBvcy5kZXB0aCA/ICRwb3Mubm9kZUFmdGVyIDogJHBvcy5ub2RlKGkpO1xuICAgICAgICBsZXQgbm9kZVBvcyA9ICRwb3MuYmVmb3JlKGkpO1xuICAgICAgICBpZiAobm9kZS5pbmxpbmVDb250ZW50KVxuICAgICAgICAgICAgdXBkYXRlU2VsZWN0aW9uKHZpZXcsIFRleHRTZWxlY3Rpb24uY3JlYXRlKGRvYywgbm9kZVBvcyArIDEsIG5vZGVQb3MgKyAxICsgbm9kZS5jb250ZW50LnNpemUpLCBcInBvaW50ZXJcIik7XG4gICAgICAgIGVsc2UgaWYgKE5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKG5vZGUpKVxuICAgICAgICAgICAgdXBkYXRlU2VsZWN0aW9uKHZpZXcsIE5vZGVTZWxlY3Rpb24uY3JlYXRlKGRvYywgbm9kZVBvcyksIFwicG9pbnRlclwiKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZvcmNlRE9NRmx1c2godmlldykge1xuICAgIHJldHVybiBlbmRDb21wb3NpdGlvbih2aWV3KTtcbn1cbmNvbnN0IHNlbGVjdE5vZGVNb2RpZmllciA9IG1hYyA/IFwibWV0YUtleVwiIDogXCJjdHJsS2V5XCI7XG5oYW5kbGVycy5tb3VzZWRvd24gPSAodmlldywgX2V2ZW50KSA9PiB7XG4gICAgbGV0IGV2ZW50ID0gX2V2ZW50O1xuICAgIHZpZXcuaW5wdXQuc2hpZnRLZXkgPSBldmVudC5zaGlmdEtleTtcbiAgICBsZXQgZmx1c2hlZCA9IGZvcmNlRE9NRmx1c2godmlldyk7XG4gICAgbGV0IG5vdyA9IERhdGUubm93KCksIHR5cGUgPSBcInNpbmdsZUNsaWNrXCI7XG4gICAgaWYgKG5vdyAtIHZpZXcuaW5wdXQubGFzdENsaWNrLnRpbWUgPCA1MDAgJiYgaXNOZWFyKGV2ZW50LCB2aWV3LmlucHV0Lmxhc3RDbGljaykgJiYgIWV2ZW50W3NlbGVjdE5vZGVNb2RpZmllcl0gJiZcbiAgICAgICAgdmlldy5pbnB1dC5sYXN0Q2xpY2suYnV0dG9uID09IGV2ZW50LmJ1dHRvbikge1xuICAgICAgICBpZiAodmlldy5pbnB1dC5sYXN0Q2xpY2sudHlwZSA9PSBcInNpbmdsZUNsaWNrXCIpXG4gICAgICAgICAgICB0eXBlID0gXCJkb3VibGVDbGlja1wiO1xuICAgICAgICBlbHNlIGlmICh2aWV3LmlucHV0Lmxhc3RDbGljay50eXBlID09IFwiZG91YmxlQ2xpY2tcIilcbiAgICAgICAgICAgIHR5cGUgPSBcInRyaXBsZUNsaWNrXCI7XG4gICAgfVxuICAgIHZpZXcuaW5wdXQubGFzdENsaWNrID0geyB0aW1lOiBub3csIHg6IGV2ZW50LmNsaWVudFgsIHk6IGV2ZW50LmNsaWVudFksIHR5cGUsIGJ1dHRvbjogZXZlbnQuYnV0dG9uIH07XG4gICAgbGV0IHBvcyA9IHZpZXcucG9zQXRDb29yZHMoZXZlbnRDb29yZHMoZXZlbnQpKTtcbiAgICBpZiAoIXBvcylcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICh0eXBlID09IFwic2luZ2xlQ2xpY2tcIikge1xuICAgICAgICBpZiAodmlldy5pbnB1dC5tb3VzZURvd24pXG4gICAgICAgICAgICB2aWV3LmlucHV0Lm1vdXNlRG93bi5kb25lKCk7XG4gICAgICAgIHZpZXcuaW5wdXQubW91c2VEb3duID0gbmV3IE1vdXNlRG93bih2aWV3LCBwb3MsIGV2ZW50LCAhIWZsdXNoZWQpO1xuICAgIH1cbiAgICBlbHNlIGlmICgodHlwZSA9PSBcImRvdWJsZUNsaWNrXCIgPyBoYW5kbGVEb3VibGVDbGljayA6IGhhbmRsZVRyaXBsZUNsaWNrKSh2aWV3LCBwb3MucG9zLCBwb3MuaW5zaWRlLCBldmVudCkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHNldFNlbGVjdGlvbk9yaWdpbih2aWV3LCBcInBvaW50ZXJcIik7XG4gICAgfVxufTtcbmNsYXNzIE1vdXNlRG93biB7XG4gICAgY29uc3RydWN0b3IodmlldywgcG9zLCBldmVudCwgZmx1c2hlZCkge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5ldmVudCA9IGV2ZW50O1xuICAgICAgICB0aGlzLmZsdXNoZWQgPSBmbHVzaGVkO1xuICAgICAgICB0aGlzLmRlbGF5ZWRTZWxlY3Rpb25TeW5jID0gZmFsc2U7XG4gICAgICAgIHRoaXMubWlnaHREcmFnID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGFydERvYyA9IHZpZXcuc3RhdGUuZG9jO1xuICAgICAgICB0aGlzLnNlbGVjdE5vZGUgPSAhIWV2ZW50W3NlbGVjdE5vZGVNb2RpZmllcl07XG4gICAgICAgIHRoaXMuYWxsb3dEZWZhdWx0ID0gZXZlbnQuc2hpZnRLZXk7XG4gICAgICAgIGxldCB0YXJnZXROb2RlLCB0YXJnZXRQb3M7XG4gICAgICAgIGlmIChwb3MuaW5zaWRlID4gLTEpIHtcbiAgICAgICAgICAgIHRhcmdldE5vZGUgPSB2aWV3LnN0YXRlLmRvYy5ub2RlQXQocG9zLmluc2lkZSk7XG4gICAgICAgICAgICB0YXJnZXRQb3MgPSBwb3MuaW5zaWRlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0ICRwb3MgPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKHBvcy5wb3MpO1xuICAgICAgICAgICAgdGFyZ2V0Tm9kZSA9ICRwb3MucGFyZW50O1xuICAgICAgICAgICAgdGFyZ2V0UG9zID0gJHBvcy5kZXB0aCA/ICRwb3MuYmVmb3JlKCkgOiAwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGZsdXNoZWQgPyBudWxsIDogZXZlbnQudGFyZ2V0O1xuICAgICAgICBjb25zdCB0YXJnZXREZXNjID0gdGFyZ2V0ID8gdmlldy5kb2NWaWV3Lm5lYXJlc3REZXNjKHRhcmdldCwgdHJ1ZSkgOiBudWxsO1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldERlc2MgJiYgdGFyZ2V0RGVzYy5ub2RlRE9NLm5vZGVUeXBlID09IDEgPyB0YXJnZXREZXNjLm5vZGVET00gOiBudWxsO1xuICAgICAgICBsZXQgeyBzZWxlY3Rpb24gfSA9IHZpZXcuc3RhdGU7XG4gICAgICAgIGlmIChldmVudC5idXR0b24gPT0gMCAmJlxuICAgICAgICAgICAgdGFyZ2V0Tm9kZS50eXBlLnNwZWMuZHJhZ2dhYmxlICYmIHRhcmdldE5vZGUudHlwZS5zcGVjLnNlbGVjdGFibGUgIT09IGZhbHNlIHx8XG4gICAgICAgICAgICBzZWxlY3Rpb24gaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uICYmIHNlbGVjdGlvbi5mcm9tIDw9IHRhcmdldFBvcyAmJiBzZWxlY3Rpb24udG8gPiB0YXJnZXRQb3MpXG4gICAgICAgICAgICB0aGlzLm1pZ2h0RHJhZyA9IHtcbiAgICAgICAgICAgICAgICBub2RlOiB0YXJnZXROb2RlLFxuICAgICAgICAgICAgICAgIHBvczogdGFyZ2V0UG9zLFxuICAgICAgICAgICAgICAgIGFkZEF0dHI6ICEhKHRoaXMudGFyZ2V0ICYmICF0aGlzLnRhcmdldC5kcmFnZ2FibGUpLFxuICAgICAgICAgICAgICAgIHNldFVuZWRpdGFibGU6ICEhKHRoaXMudGFyZ2V0ICYmIGdlY2tvICYmICF0aGlzLnRhcmdldC5oYXNBdHRyaWJ1dGUoXCJjb250ZW50RWRpdGFibGVcIikpXG4gICAgICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy50YXJnZXQgJiYgdGhpcy5taWdodERyYWcgJiYgKHRoaXMubWlnaHREcmFnLmFkZEF0dHIgfHwgdGhpcy5taWdodERyYWcuc2V0VW5lZGl0YWJsZSkpIHtcbiAgICAgICAgICAgIHRoaXMudmlldy5kb21PYnNlcnZlci5zdG9wKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5taWdodERyYWcuYWRkQXR0cilcbiAgICAgICAgICAgICAgICB0aGlzLnRhcmdldC5kcmFnZ2FibGUgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMubWlnaHREcmFnLnNldFVuZWRpdGFibGUpXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnZpZXcuaW5wdXQubW91c2VEb3duID09IHRoaXMpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRhcmdldC5zZXRBdHRyaWJ1dGUoXCJjb250ZW50RWRpdGFibGVcIiwgXCJmYWxzZVwiKTtcbiAgICAgICAgICAgICAgICB9LCAyMCk7XG4gICAgICAgICAgICB0aGlzLnZpZXcuZG9tT2JzZXJ2ZXIuc3RhcnQoKTtcbiAgICAgICAgfVxuICAgICAgICB2aWV3LnJvb3QuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdGhpcy51cCA9IHRoaXMudXAuYmluZCh0aGlzKSk7XG4gICAgICAgIHZpZXcucm9vdC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMubW92ZSA9IHRoaXMubW92ZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgc2V0U2VsZWN0aW9uT3JpZ2luKHZpZXcsIFwicG9pbnRlclwiKTtcbiAgICB9XG4gICAgZG9uZSgpIHtcbiAgICAgICAgdGhpcy52aWV3LnJvb3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdGhpcy51cCk7XG4gICAgICAgIHRoaXMudmlldy5yb290LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5tb3ZlKTtcbiAgICAgICAgaWYgKHRoaXMubWlnaHREcmFnICYmIHRoaXMudGFyZ2V0KSB7XG4gICAgICAgICAgICB0aGlzLnZpZXcuZG9tT2JzZXJ2ZXIuc3RvcCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMubWlnaHREcmFnLmFkZEF0dHIpXG4gICAgICAgICAgICAgICAgdGhpcy50YXJnZXQucmVtb3ZlQXR0cmlidXRlKFwiZHJhZ2dhYmxlXCIpO1xuICAgICAgICAgICAgaWYgKHRoaXMubWlnaHREcmFnLnNldFVuZWRpdGFibGUpXG4gICAgICAgICAgICAgICAgdGhpcy50YXJnZXQucmVtb3ZlQXR0cmlidXRlKFwiY29udGVudEVkaXRhYmxlXCIpO1xuICAgICAgICAgICAgdGhpcy52aWV3LmRvbU9ic2VydmVyLnN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGVsYXllZFNlbGVjdGlvblN5bmMpXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHNlbGVjdGlvblRvRE9NKHRoaXMudmlldykpO1xuICAgICAgICB0aGlzLnZpZXcuaW5wdXQubW91c2VEb3duID0gbnVsbDtcbiAgICB9XG4gICAgdXAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5kb25lKCk7XG4gICAgICAgIGlmICghdGhpcy52aWV3LmRvbS5jb250YWlucyhldmVudC50YXJnZXQpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgcG9zID0gdGhpcy5wb3M7XG4gICAgICAgIGlmICh0aGlzLnZpZXcuc3RhdGUuZG9jICE9IHRoaXMuc3RhcnREb2MpXG4gICAgICAgICAgICBwb3MgPSB0aGlzLnZpZXcucG9zQXRDb29yZHMoZXZlbnRDb29yZHMoZXZlbnQpKTtcbiAgICAgICAgdGhpcy51cGRhdGVBbGxvd0RlZmF1bHQoZXZlbnQpO1xuICAgICAgICBpZiAodGhpcy5hbGxvd0RlZmF1bHQgfHwgIXBvcykge1xuICAgICAgICAgICAgc2V0U2VsZWN0aW9uT3JpZ2luKHRoaXMudmlldywgXCJwb2ludGVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGhhbmRsZVNpbmdsZUNsaWNrKHRoaXMudmlldywgcG9zLnBvcywgcG9zLmluc2lkZSwgZXZlbnQsIHRoaXMuc2VsZWN0Tm9kZSkpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXZlbnQuYnV0dG9uID09IDAgJiZcbiAgICAgICAgICAgICh0aGlzLmZsdXNoZWQgfHxcbiAgICAgICAgICAgICAgICAvLyBTYWZhcmkgaWdub3JlcyBjbGlja3Mgb24gZHJhZ2dhYmxlIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgKHNhZmFyaSAmJiB0aGlzLm1pZ2h0RHJhZyAmJiAhdGhpcy5taWdodERyYWcubm9kZS5pc0F0b20pIHx8XG4gICAgICAgICAgICAgICAgLy8gQ2hyb21lIHdpbGwgc29tZXRpbWVzIHRyZWF0IGEgbm9kZSBzZWxlY3Rpb24gYXMgYVxuICAgICAgICAgICAgICAgIC8vIGN1cnNvciwgYnV0IHN0aWxsIHJlcG9ydCB0aGF0IHRoZSBub2RlIGlzIHNlbGVjdGVkXG4gICAgICAgICAgICAgICAgLy8gd2hlbiBhc2tlZCB0aHJvdWdoIGdldFNlbGVjdGlvbi4gWW91J2xsIHRoZW4gZ2V0IGFcbiAgICAgICAgICAgICAgICAvLyBzaXR1YXRpb24gd2hlcmUgY2xpY2tpbmcgYXQgdGhlIHBvaW50IHdoZXJlIHRoYXRcbiAgICAgICAgICAgICAgICAvLyAoaGlkZGVuKSBjdXJzb3IgaXMgZG9lc24ndCBjaGFuZ2UgdGhlIHNlbGVjdGlvbiwgYW5kXG4gICAgICAgICAgICAgICAgLy8gdGh1cyBkb2Vzbid0IGdldCBhIHJlYWN0aW9uIGZyb20gUHJvc2VNaXJyb3IuIFRoaXNcbiAgICAgICAgICAgICAgICAvLyB3b3JrcyBhcm91bmQgdGhhdC5cbiAgICAgICAgICAgICAgICAoY2hyb21lICYmICF0aGlzLnZpZXcuc3RhdGUuc2VsZWN0aW9uLnZpc2libGUgJiZcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5taW4oTWF0aC5hYnMocG9zLnBvcyAtIHRoaXMudmlldy5zdGF0ZS5zZWxlY3Rpb24uZnJvbSksIE1hdGguYWJzKHBvcy5wb3MgLSB0aGlzLnZpZXcuc3RhdGUuc2VsZWN0aW9uLnRvKSkgPD0gMikpKSB7XG4gICAgICAgICAgICB1cGRhdGVTZWxlY3Rpb24odGhpcy52aWV3LCBTZWxlY3Rpb24ubmVhcih0aGlzLnZpZXcuc3RhdGUuZG9jLnJlc29sdmUocG9zLnBvcykpLCBcInBvaW50ZXJcIik7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0U2VsZWN0aW9uT3JpZ2luKHRoaXMudmlldywgXCJwb2ludGVyXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1vdmUoZXZlbnQpIHtcbiAgICAgICAgdGhpcy51cGRhdGVBbGxvd0RlZmF1bHQoZXZlbnQpO1xuICAgICAgICBzZXRTZWxlY3Rpb25PcmlnaW4odGhpcy52aWV3LCBcInBvaW50ZXJcIik7XG4gICAgICAgIGlmIChldmVudC5idXR0b25zID09IDApXG4gICAgICAgICAgICB0aGlzLmRvbmUoKTtcbiAgICB9XG4gICAgdXBkYXRlQWxsb3dEZWZhdWx0KGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5hbGxvd0RlZmF1bHQgJiYgKE1hdGguYWJzKHRoaXMuZXZlbnQueCAtIGV2ZW50LmNsaWVudFgpID4gNCB8fFxuICAgICAgICAgICAgTWF0aC5hYnModGhpcy5ldmVudC55IC0gZXZlbnQuY2xpZW50WSkgPiA0KSlcbiAgICAgICAgICAgIHRoaXMuYWxsb3dEZWZhdWx0ID0gdHJ1ZTtcbiAgICB9XG59XG5oYW5kbGVycy50b3VjaHN0YXJ0ID0gdmlldyA9PiB7XG4gICAgdmlldy5pbnB1dC5sYXN0VG91Y2ggPSBEYXRlLm5vdygpO1xuICAgIGZvcmNlRE9NRmx1c2godmlldyk7XG4gICAgc2V0U2VsZWN0aW9uT3JpZ2luKHZpZXcsIFwicG9pbnRlclwiKTtcbn07XG5oYW5kbGVycy50b3VjaG1vdmUgPSB2aWV3ID0+IHtcbiAgICB2aWV3LmlucHV0Lmxhc3RUb3VjaCA9IERhdGUubm93KCk7XG4gICAgc2V0U2VsZWN0aW9uT3JpZ2luKHZpZXcsIFwicG9pbnRlclwiKTtcbn07XG5oYW5kbGVycy5jb250ZXh0bWVudSA9IHZpZXcgPT4gZm9yY2VET01GbHVzaCh2aWV3KTtcbmZ1bmN0aW9uIGluT3JOZWFyQ29tcG9zaXRpb24odmlldywgZXZlbnQpIHtcbiAgICBpZiAodmlldy5jb21wb3NpbmcpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIC8vIFNlZSBodHRwczovL3d3dy5zdHVtLmRlLzIwMTYvMDYvMjQvaGFuZGxpbmctaW1lLWV2ZW50cy1pbi1qYXZhc2NyaXB0Ly5cbiAgICAvLyBPbiBKYXBhbmVzZSBpbnB1dCBtZXRob2QgZWRpdG9ycyAoSU1FcyksIHRoZSBFbnRlciBrZXkgaXMgdXNlZCB0byBjb25maXJtIGNoYXJhY3RlclxuICAgIC8vIHNlbGVjdGlvbi4gT24gU2FmYXJpLCB3aGVuIEVudGVyIGlzIHByZXNzZWQsIGNvbXBvc2l0aW9uZW5kIGFuZCBrZXlkb3duIGV2ZW50cyBhcmVcbiAgICAvLyBlbWl0dGVkLiBUaGUga2V5ZG93biBldmVudCB0cmlnZ2VycyBuZXdsaW5lIGluc2VydGlvbiwgd2hpY2ggd2UgZG9uJ3Qgd2FudC5cbiAgICAvLyBUaGlzIG1ldGhvZCByZXR1cm5zIHRydWUgaWYgdGhlIGtleWRvd24gZXZlbnQgc2hvdWxkIGJlIGlnbm9yZWQuXG4gICAgLy8gV2Ugb25seSBpZ25vcmUgaXQgb25jZSwgYXMgcHJlc3NpbmcgRW50ZXIgYSBzZWNvbmQgdGltZSAqc2hvdWxkKiBpbnNlcnQgYSBuZXdsaW5lLlxuICAgIC8vIEZ1cnRoZXJtb3JlLCB0aGUga2V5ZG93biBldmVudCB0aW1lc3RhbXAgbXVzdCBiZSBjbG9zZSB0byB0aGUgY29tcG9zaXRpb25FbmRlZEF0IHRpbWVzdGFtcC5cbiAgICAvLyBUaGlzIGd1YXJkcyBhZ2FpbnN0IHRoZSBjYXNlIHdoZXJlIGNvbXBvc2l0aW9uZW5kIGlzIHRyaWdnZXJlZCB3aXRob3V0IHRoZSBrZXlib2FyZFxuICAgIC8vIChlLmcuIGNoYXJhY3RlciBjb25maXJtYXRpb24gbWF5IGJlIGRvbmUgd2l0aCB0aGUgbW91c2UpLCBhbmQga2V5ZG93biBpcyB0cmlnZ2VyZWRcbiAgICAvLyBhZnRlcndhcmRzLSB3ZSB3b3VsZG4ndCB3YW50IHRvIGlnbm9yZSB0aGUga2V5ZG93biBldmVudCBpbiB0aGlzIGNhc2UuXG4gICAgaWYgKHNhZmFyaSAmJiBNYXRoLmFicyhldmVudC50aW1lU3RhbXAgLSB2aWV3LmlucHV0LmNvbXBvc2l0aW9uRW5kZWRBdCkgPCA1MDApIHtcbiAgICAgICAgdmlldy5pbnB1dC5jb21wb3NpdGlvbkVuZGVkQXQgPSAtMmU4O1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLy8gRHJvcCBhY3RpdmUgY29tcG9zaXRpb24gYWZ0ZXIgNSBzZWNvbmRzIG9mIGluYWN0aXZpdHkgb24gQW5kcm9pZFxuY29uc3QgdGltZW91dENvbXBvc2l0aW9uID0gYW5kcm9pZCA/IDUwMDAgOiAtMTtcbmVkaXRIYW5kbGVycy5jb21wb3NpdGlvbnN0YXJ0ID0gZWRpdEhhbmRsZXJzLmNvbXBvc2l0aW9udXBkYXRlID0gdmlldyA9PiB7XG4gICAgaWYgKCF2aWV3LmNvbXBvc2luZykge1xuICAgICAgICB2aWV3LmRvbU9ic2VydmVyLmZsdXNoKCk7XG4gICAgICAgIGxldCB7IHN0YXRlIH0gPSB2aWV3LCAkcG9zID0gc3RhdGUuc2VsZWN0aW9uLiR0bztcbiAgICAgICAgaWYgKHN0YXRlLnNlbGVjdGlvbiBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24gJiZcbiAgICAgICAgICAgIChzdGF0ZS5zdG9yZWRNYXJrcyB8fFxuICAgICAgICAgICAgICAgICghJHBvcy50ZXh0T2Zmc2V0ICYmICRwb3MucGFyZW50T2Zmc2V0ICYmICRwb3Mubm9kZUJlZm9yZS5tYXJrcy5zb21lKG0gPT4gbS50eXBlLnNwZWMuaW5jbHVzaXZlID09PSBmYWxzZSkpIHx8XG4gICAgICAgICAgICAgICAgY2hyb21lICYmIHdpbmRvd3MgJiYgc2VsZWN0aW9uQmVmb3JlVW5lZGl0YWJsZSh2aWV3KSkpIHsgLy8gSXNzdWUgIzE1MDBcbiAgICAgICAgICAgIC8vIE5lZWQgdG8gd3JhcCB0aGUgY3Vyc29yIGluIG1hcmsgbm9kZXMgZGlmZmVyZW50IGZyb20gdGhlIG9uZXMgaW4gdGhlIERPTSBjb250ZXh0XG4gICAgICAgICAgICB2aWV3Lm1hcmtDdXJzb3IgPSB2aWV3LnN0YXRlLnN0b3JlZE1hcmtzIHx8ICRwb3MubWFya3MoKTtcbiAgICAgICAgICAgIGVuZENvbXBvc2l0aW9uKHZpZXcsIHRydWUpO1xuICAgICAgICAgICAgdmlldy5tYXJrQ3Vyc29yID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVuZENvbXBvc2l0aW9uKHZpZXcsICFzdGF0ZS5zZWxlY3Rpb24uZW1wdHkpO1xuICAgICAgICAgICAgLy8gSW4gZmlyZWZveCwgaWYgdGhlIGN1cnNvciBpcyBhZnRlciBidXQgb3V0c2lkZSBhIG1hcmtlZCBub2RlLFxuICAgICAgICAgICAgLy8gdGhlIGluc2VydGVkIHRleHQgd29uJ3QgaW5oZXJpdCB0aGUgbWFya3MuIFNvIHRoaXMgbW92ZXMgaXRcbiAgICAgICAgICAgIC8vIGluc2lkZSBpZiBuZWNlc3NhcnkuXG4gICAgICAgICAgICBpZiAoZ2Vja28gJiYgc3RhdGUuc2VsZWN0aW9uLmVtcHR5ICYmICRwb3MucGFyZW50T2Zmc2V0ICYmICEkcG9zLnRleHRPZmZzZXQgJiYgJHBvcy5ub2RlQmVmb3JlLm1hcmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxldCBzZWwgPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgbm9kZSA9IHNlbC5mb2N1c05vZGUsIG9mZnNldCA9IHNlbC5mb2N1c09mZnNldDsgbm9kZSAmJiBub2RlLm5vZGVUeXBlID09IDEgJiYgb2Zmc2V0ICE9IDA7KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBiZWZvcmUgPSBvZmZzZXQgPCAwID8gbm9kZS5sYXN0Q2hpbGQgOiBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghYmVmb3JlKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiZWZvcmUubm9kZVR5cGUgPT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbC5jb2xsYXBzZShiZWZvcmUsIGJlZm9yZS5ub2RlVmFsdWUubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGJlZm9yZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IC0xO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZpZXcuaW5wdXQuY29tcG9zaW5nID0gdHJ1ZTtcbiAgICB9XG4gICAgc2NoZWR1bGVDb21wb3NlRW5kKHZpZXcsIHRpbWVvdXRDb21wb3NpdGlvbik7XG59O1xuZnVuY3Rpb24gc2VsZWN0aW9uQmVmb3JlVW5lZGl0YWJsZSh2aWV3KSB7XG4gICAgbGV0IHsgZm9jdXNOb2RlLCBmb2N1c09mZnNldCB9ID0gdmlldy5kb21TZWxlY3Rpb25SYW5nZSgpO1xuICAgIGlmICghZm9jdXNOb2RlIHx8IGZvY3VzTm9kZS5ub2RlVHlwZSAhPSAxIHx8IGZvY3VzT2Zmc2V0ID49IGZvY3VzTm9kZS5jaGlsZE5vZGVzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBuZXh0ID0gZm9jdXNOb2RlLmNoaWxkTm9kZXNbZm9jdXNPZmZzZXRdO1xuICAgIHJldHVybiBuZXh0Lm5vZGVUeXBlID09IDEgJiYgbmV4dC5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiO1xufVxuZWRpdEhhbmRsZXJzLmNvbXBvc2l0aW9uZW5kID0gKHZpZXcsIGV2ZW50KSA9PiB7XG4gICAgaWYgKHZpZXcuY29tcG9zaW5nKSB7XG4gICAgICAgIHZpZXcuaW5wdXQuY29tcG9zaW5nID0gZmFsc2U7XG4gICAgICAgIHZpZXcuaW5wdXQuY29tcG9zaXRpb25FbmRlZEF0ID0gZXZlbnQudGltZVN0YW1wO1xuICAgICAgICB2aWV3LmlucHV0LmNvbXBvc2l0aW9uUGVuZGluZ0NoYW5nZXMgPSB2aWV3LmRvbU9ic2VydmVyLnBlbmRpbmdSZWNvcmRzKCkubGVuZ3RoID8gdmlldy5pbnB1dC5jb21wb3NpdGlvbklEIDogMDtcbiAgICAgICAgdmlldy5pbnB1dC5jb21wb3NpdGlvbk5vZGUgPSBudWxsO1xuICAgICAgICBpZiAodmlldy5pbnB1dC5jb21wb3NpdGlvblBlbmRpbmdDaGFuZ2VzKVxuICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB2aWV3LmRvbU9ic2VydmVyLmZsdXNoKCkpO1xuICAgICAgICB2aWV3LmlucHV0LmNvbXBvc2l0aW9uSUQrKztcbiAgICAgICAgc2NoZWR1bGVDb21wb3NlRW5kKHZpZXcsIDIwKTtcbiAgICB9XG59O1xuZnVuY3Rpb24gc2NoZWR1bGVDb21wb3NlRW5kKHZpZXcsIGRlbGF5KSB7XG4gICAgY2xlYXJUaW1lb3V0KHZpZXcuaW5wdXQuY29tcG9zaW5nVGltZW91dCk7XG4gICAgaWYgKGRlbGF5ID4gLTEpXG4gICAgICAgIHZpZXcuaW5wdXQuY29tcG9zaW5nVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4gZW5kQ29tcG9zaXRpb24odmlldyksIGRlbGF5KTtcbn1cbmZ1bmN0aW9uIGNsZWFyQ29tcG9zaXRpb24odmlldykge1xuICAgIGlmICh2aWV3LmNvbXBvc2luZykge1xuICAgICAgICB2aWV3LmlucHV0LmNvbXBvc2luZyA9IGZhbHNlO1xuICAgICAgICB2aWV3LmlucHV0LmNvbXBvc2l0aW9uRW5kZWRBdCA9IHRpbWVzdGFtcEZyb21DdXN0b21FdmVudCgpO1xuICAgIH1cbiAgICB3aGlsZSAodmlldy5pbnB1dC5jb21wb3NpdGlvbk5vZGVzLmxlbmd0aCA+IDApXG4gICAgICAgIHZpZXcuaW5wdXQuY29tcG9zaXRpb25Ob2Rlcy5wb3AoKS5tYXJrUGFyZW50c0RpcnR5KCk7XG59XG5mdW5jdGlvbiBmaW5kQ29tcG9zaXRpb25Ob2RlKHZpZXcpIHtcbiAgICBsZXQgc2VsID0gdmlldy5kb21TZWxlY3Rpb25SYW5nZSgpO1xuICAgIGlmICghc2VsLmZvY3VzTm9kZSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IHRleHRCZWZvcmUgPSB0ZXh0Tm9kZUJlZm9yZSQxKHNlbC5mb2N1c05vZGUsIHNlbC5mb2N1c09mZnNldCk7XG4gICAgbGV0IHRleHRBZnRlciA9IHRleHROb2RlQWZ0ZXIkMShzZWwuZm9jdXNOb2RlLCBzZWwuZm9jdXNPZmZzZXQpO1xuICAgIGlmICh0ZXh0QmVmb3JlICYmIHRleHRBZnRlciAmJiB0ZXh0QmVmb3JlICE9IHRleHRBZnRlcikge1xuICAgICAgICBsZXQgZGVzY0FmdGVyID0gdGV4dEFmdGVyLnBtVmlld0Rlc2MsIGxhc3RDaGFuZ2VkID0gdmlldy5kb21PYnNlcnZlci5sYXN0Q2hhbmdlZFRleHROb2RlO1xuICAgICAgICBpZiAodGV4dEJlZm9yZSA9PSBsYXN0Q2hhbmdlZCB8fCB0ZXh0QWZ0ZXIgPT0gbGFzdENoYW5nZWQpXG4gICAgICAgICAgICByZXR1cm4gbGFzdENoYW5nZWQ7XG4gICAgICAgIGlmICghZGVzY0FmdGVyIHx8ICFkZXNjQWZ0ZXIuaXNUZXh0KHRleHRBZnRlci5ub2RlVmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGV4dEFmdGVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZpZXcuaW5wdXQuY29tcG9zaXRpb25Ob2RlID09IHRleHRBZnRlcikge1xuICAgICAgICAgICAgbGV0IGRlc2NCZWZvcmUgPSB0ZXh0QmVmb3JlLnBtVmlld0Rlc2M7XG4gICAgICAgICAgICBpZiAoISghZGVzY0JlZm9yZSB8fCAhZGVzY0JlZm9yZS5pc1RleHQodGV4dEJlZm9yZS5ub2RlVmFsdWUpKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGV4dEFmdGVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0ZXh0QmVmb3JlIHx8IHRleHRBZnRlcjtcbn1cbmZ1bmN0aW9uIHRpbWVzdGFtcEZyb21DdXN0b21FdmVudCgpIHtcbiAgICBsZXQgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkV2ZW50XCIpO1xuICAgIGV2ZW50LmluaXRFdmVudChcImV2ZW50XCIsIHRydWUsIHRydWUpO1xuICAgIHJldHVybiBldmVudC50aW1lU3RhbXA7XG59XG4vKipcbkBpbnRlcm5hbFxuKi9cbmZ1bmN0aW9uIGVuZENvbXBvc2l0aW9uKHZpZXcsIHJlc3RhcnRpbmcgPSBmYWxzZSkge1xuICAgIGlmIChhbmRyb2lkICYmIHZpZXcuZG9tT2JzZXJ2ZXIuZmx1c2hpbmdTb29uID49IDApXG4gICAgICAgIHJldHVybjtcbiAgICB2aWV3LmRvbU9ic2VydmVyLmZvcmNlRmx1c2goKTtcbiAgICBjbGVhckNvbXBvc2l0aW9uKHZpZXcpO1xuICAgIGlmIChyZXN0YXJ0aW5nIHx8IHZpZXcuZG9jVmlldyAmJiB2aWV3LmRvY1ZpZXcuZGlydHkpIHtcbiAgICAgICAgbGV0IHNlbCA9IHNlbGVjdGlvbkZyb21ET00odmlldyksIGN1ciA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBpZiAoc2VsICYmICFzZWwuZXEoY3VyKSlcbiAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2godmlldy5zdGF0ZS50ci5zZXRTZWxlY3Rpb24oc2VsKSk7XG4gICAgICAgIGVsc2UgaWYgKCh2aWV3Lm1hcmtDdXJzb3IgfHwgcmVzdGFydGluZykgJiYgIWN1ci4kZnJvbS5ub2RlKGN1ci4kZnJvbS5zaGFyZWREZXB0aChjdXIudG8pKS5pbmxpbmVDb250ZW50KVxuICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh2aWV3LnN0YXRlLnRyLmRlbGV0ZVNlbGVjdGlvbigpKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdmlldy51cGRhdGVTdGF0ZSh2aWV3LnN0YXRlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNhcHR1cmVDb3B5KHZpZXcsIGRvbSkge1xuICAgIC8vIFRoZSBleHRyYSB3cmFwcGVyIGlzIHNvbWVob3cgbmVjZXNzYXJ5IG9uIElFL0VkZ2UgdG8gcHJldmVudCB0aGVcbiAgICAvLyBjb250ZW50IGZyb20gYmVpbmcgbWFuZ2xlZCB3aGVuIGl0IGlzIHB1dCBvbnRvIHRoZSBjbGlwYm9hcmRcbiAgICBpZiAoIXZpZXcuZG9tLnBhcmVudE5vZGUpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgd3JhcCA9IHZpZXcuZG9tLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7XG4gICAgd3JhcC5hcHBlbmRDaGlsZChkb20pO1xuICAgIHdyYXAuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246IGZpeGVkOyBsZWZ0OiAtMTAwMDBweDsgdG9wOiAxMHB4XCI7XG4gICAgbGV0IHNlbCA9IGdldFNlbGVjdGlvbigpLCByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgcmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKGRvbSk7XG4gICAgLy8gRG9uZSBiZWNhdXNlIElFIHdpbGwgZmlyZSBhIHNlbGVjdGlvbmNoYW5nZSBtb3ZpbmcgdGhlIHNlbGVjdGlvblxuICAgIC8vIHRvIGl0cyBzdGFydCB3aGVuIHJlbW92ZUFsbFJhbmdlcyBpcyBjYWxsZWQgYW5kIHRoZSBlZGl0b3Igc3RpbGxcbiAgICAvLyBoYXMgZm9jdXMgKHdoaWNoIHdpbGwgbWVzcyB1cCB0aGUgZWRpdG9yJ3Mgc2VsZWN0aW9uIHN0YXRlKS5cbiAgICB2aWV3LmRvbS5ibHVyKCk7XG4gICAgc2VsLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgIHNlbC5hZGRSYW5nZShyYW5nZSk7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICh3cmFwLnBhcmVudE5vZGUpXG4gICAgICAgICAgICB3cmFwLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQod3JhcCk7XG4gICAgICAgIHZpZXcuZm9jdXMoKTtcbiAgICB9LCA1MCk7XG59XG4vLyBUaGlzIGlzIHZlcnkgY3J1ZGUsIGJ1dCB1bmZvcnR1bmF0ZWx5IGJvdGggdGhlc2UgYnJvd3NlcnMgX3ByZXRlbmRfXG4vLyB0aGF0IHRoZXkgaGF2ZSBhIGNsaXBib2FyZCBBUEnigJRhbGwgdGhlIG9iamVjdHMgYW5kIG1ldGhvZHMgYXJlXG4vLyB0aGVyZSwgdGhleSBqdXN0IGRvbid0IHdvcmssIGFuZCB0aGV5IGFyZSBoYXJkIHRvIHRlc3QuXG5jb25zdCBicm9rZW5DbGlwYm9hcmRBUEkgPSAoaWUgJiYgaWVfdmVyc2lvbiA8IDE1KSB8fFxuICAgIChpb3MgJiYgd2Via2l0X3ZlcnNpb24gPCA2MDQpO1xuaGFuZGxlcnMuY29weSA9IGVkaXRIYW5kbGVycy5jdXQgPSAodmlldywgX2V2ZW50KSA9PiB7XG4gICAgbGV0IGV2ZW50ID0gX2V2ZW50O1xuICAgIGxldCBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbiwgY3V0ID0gZXZlbnQudHlwZSA9PSBcImN1dFwiO1xuICAgIGlmIChzZWwuZW1wdHkpXG4gICAgICAgIHJldHVybjtcbiAgICAvLyBJRSBhbmQgRWRnZSdzIGNsaXBib2FyZCBpbnRlcmZhY2UgaXMgY29tcGxldGVseSBicm9rZW5cbiAgICBsZXQgZGF0YSA9IGJyb2tlbkNsaXBib2FyZEFQSSA/IG51bGwgOiBldmVudC5jbGlwYm9hcmREYXRhO1xuICAgIGxldCBzbGljZSA9IHNlbC5jb250ZW50KCksIHsgZG9tLCB0ZXh0IH0gPSBzZXJpYWxpemVGb3JDbGlwYm9hcmQodmlldywgc2xpY2UpO1xuICAgIGlmIChkYXRhKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGRhdGEuY2xlYXJEYXRhKCk7XG4gICAgICAgIGRhdGEuc2V0RGF0YShcInRleHQvaHRtbFwiLCBkb20uaW5uZXJIVE1MKTtcbiAgICAgICAgZGF0YS5zZXREYXRhKFwidGV4dC9wbGFpblwiLCB0ZXh0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNhcHR1cmVDb3B5KHZpZXcsIGRvbSk7XG4gICAgfVxuICAgIGlmIChjdXQpXG4gICAgICAgIHZpZXcuZGlzcGF0Y2godmlldy5zdGF0ZS50ci5kZWxldGVTZWxlY3Rpb24oKS5zY3JvbGxJbnRvVmlldygpLnNldE1ldGEoXCJ1aUV2ZW50XCIsIFwiY3V0XCIpKTtcbn07XG5mdW5jdGlvbiBzbGljZVNpbmdsZU5vZGUoc2xpY2UpIHtcbiAgICByZXR1cm4gc2xpY2Uub3BlblN0YXJ0ID09IDAgJiYgc2xpY2Uub3BlbkVuZCA9PSAwICYmIHNsaWNlLmNvbnRlbnQuY2hpbGRDb3VudCA9PSAxID8gc2xpY2UuY29udGVudC5maXJzdENoaWxkIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGNhcHR1cmVQYXN0ZSh2aWV3LCBldmVudCkge1xuICAgIGlmICghdmlldy5kb20ucGFyZW50Tm9kZSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBwbGFpblRleHQgPSB2aWV3LmlucHV0LnNoaWZ0S2V5IHx8IHZpZXcuc3RhdGUuc2VsZWN0aW9uLiRmcm9tLnBhcmVudC50eXBlLnNwZWMuY29kZTtcbiAgICBsZXQgdGFyZ2V0ID0gdmlldy5kb20ucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KHBsYWluVGV4dCA/IFwidGV4dGFyZWFcIiA6IFwiZGl2XCIpKTtcbiAgICBpZiAoIXBsYWluVGV4dClcbiAgICAgICAgdGFyZ2V0LmNvbnRlbnRFZGl0YWJsZSA9IFwidHJ1ZVwiO1xuICAgIHRhcmdldC5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjogZml4ZWQ7IGxlZnQ6IC0xMDAwMHB4OyB0b3A6IDEwcHhcIjtcbiAgICB0YXJnZXQuZm9jdXMoKTtcbiAgICBsZXQgcGxhaW4gPSB2aWV3LmlucHV0LnNoaWZ0S2V5ICYmIHZpZXcuaW5wdXQubGFzdEtleUNvZGUgIT0gNDU7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHZpZXcuZm9jdXMoKTtcbiAgICAgICAgaWYgKHRhcmdldC5wYXJlbnROb2RlKVxuICAgICAgICAgICAgdGFyZ2V0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGFyZ2V0KTtcbiAgICAgICAgaWYgKHBsYWluVGV4dClcbiAgICAgICAgICAgIGRvUGFzdGUodmlldywgdGFyZ2V0LnZhbHVlLCBudWxsLCBwbGFpbiwgZXZlbnQpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBkb1Bhc3RlKHZpZXcsIHRhcmdldC50ZXh0Q29udGVudCwgdGFyZ2V0LmlubmVySFRNTCwgcGxhaW4sIGV2ZW50KTtcbiAgICB9LCA1MCk7XG59XG5mdW5jdGlvbiBkb1Bhc3RlKHZpZXcsIHRleHQsIGh0bWwsIHByZWZlclBsYWluLCBldmVudCkge1xuICAgIGxldCBzbGljZSA9IHBhcnNlRnJvbUNsaXBib2FyZCh2aWV3LCB0ZXh0LCBodG1sLCBwcmVmZXJQbGFpbiwgdmlldy5zdGF0ZS5zZWxlY3Rpb24uJGZyb20pO1xuICAgIGlmICh2aWV3LnNvbWVQcm9wKFwiaGFuZGxlUGFzdGVcIiwgZiA9PiBmKHZpZXcsIGV2ZW50LCBzbGljZSB8fCBTbGljZS5lbXB0eSkpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoIXNsaWNlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHNpbmdsZU5vZGUgPSBzbGljZVNpbmdsZU5vZGUoc2xpY2UpO1xuICAgIGxldCB0ciA9IHNpbmdsZU5vZGVcbiAgICAgICAgPyB2aWV3LnN0YXRlLnRyLnJlcGxhY2VTZWxlY3Rpb25XaXRoKHNpbmdsZU5vZGUsIHByZWZlclBsYWluKVxuICAgICAgICA6IHZpZXcuc3RhdGUudHIucmVwbGFjZVNlbGVjdGlvbihzbGljZSk7XG4gICAgdmlldy5kaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpLnNldE1ldGEoXCJwYXN0ZVwiLCB0cnVlKS5zZXRNZXRhKFwidWlFdmVudFwiLCBcInBhc3RlXCIpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGdldFRleHQoY2xpcGJvYXJkRGF0YSkge1xuICAgIGxldCB0ZXh0ID0gY2xpcGJvYXJkRGF0YS5nZXREYXRhKFwidGV4dC9wbGFpblwiKSB8fCBjbGlwYm9hcmREYXRhLmdldERhdGEoXCJUZXh0XCIpO1xuICAgIGlmICh0ZXh0KVxuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICBsZXQgdXJpcyA9IGNsaXBib2FyZERhdGEuZ2V0RGF0YShcInRleHQvdXJpLWxpc3RcIik7XG4gICAgcmV0dXJuIHVyaXMgPyB1cmlzLnJlcGxhY2UoL1xccj9cXG4vZywgXCIgXCIpIDogXCJcIjtcbn1cbmVkaXRIYW5kbGVycy5wYXN0ZSA9ICh2aWV3LCBfZXZlbnQpID0+IHtcbiAgICBsZXQgZXZlbnQgPSBfZXZlbnQ7XG4gICAgLy8gSGFuZGxpbmcgcGFzdGUgZnJvbSBKYXZhU2NyaXB0IGR1cmluZyBjb21wb3NpdGlvbiBpcyB2ZXJ5IHBvb3JseVxuICAgIC8vIGhhbmRsZWQgYnkgYnJvd3NlcnMsIHNvIGFzIGEgZG9kZ3kgYnV0IHByZWZlcmFibGUga2x1ZGdlLCB3ZSBqdXN0XG4gICAgLy8gbGV0IHRoZSBicm93c2VyIGRvIGl0cyBuYXRpdmUgdGhpbmcgdGhlcmUsIGV4Y2VwdCBvbiBBbmRyb2lkLFxuICAgIC8vIHdoZXJlIHRoZSBlZGl0b3IgaXMgYWxtb3N0IGFsd2F5cyBjb21wb3NpbmcuXG4gICAgaWYgKHZpZXcuY29tcG9zaW5nICYmICFhbmRyb2lkKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IGRhdGEgPSBicm9rZW5DbGlwYm9hcmRBUEkgPyBudWxsIDogZXZlbnQuY2xpcGJvYXJkRGF0YTtcbiAgICBsZXQgcGxhaW4gPSB2aWV3LmlucHV0LnNoaWZ0S2V5ICYmIHZpZXcuaW5wdXQubGFzdEtleUNvZGUgIT0gNDU7XG4gICAgaWYgKGRhdGEgJiYgZG9QYXN0ZSh2aWV3LCBnZXRUZXh0KGRhdGEpLCBkYXRhLmdldERhdGEoXCJ0ZXh0L2h0bWxcIiksIHBsYWluLCBldmVudCkpXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgZWxzZVxuICAgICAgICBjYXB0dXJlUGFzdGUodmlldywgZXZlbnQpO1xufTtcbmNsYXNzIERyYWdnaW5nIHtcbiAgICBjb25zdHJ1Y3RvcihzbGljZSwgbW92ZSwgbm9kZSkge1xuICAgICAgICB0aGlzLnNsaWNlID0gc2xpY2U7XG4gICAgICAgIHRoaXMubW92ZSA9IG1vdmU7XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgfVxufVxuY29uc3QgZHJhZ0NvcHlNb2RpZmllciA9IG1hYyA/IFwiYWx0S2V5XCIgOiBcImN0cmxLZXlcIjtcbmZ1bmN0aW9uIGRyYWdNb3Zlcyh2aWV3LCBldmVudCkge1xuICAgIGxldCBtb3ZlcyA9IHZpZXcuc29tZVByb3AoXCJkcmFnQ29waWVzXCIsIHRlc3QgPT4gIXRlc3QoZXZlbnQpKTtcbiAgICByZXR1cm4gbW92ZXMgIT0gbnVsbCA/IG1vdmVzIDogIWV2ZW50W2RyYWdDb3B5TW9kaWZpZXJdO1xufVxuaGFuZGxlcnMuZHJhZ3N0YXJ0ID0gKHZpZXcsIF9ldmVudCkgPT4ge1xuICAgIGxldCBldmVudCA9IF9ldmVudDtcbiAgICBsZXQgbW91c2VEb3duID0gdmlldy5pbnB1dC5tb3VzZURvd247XG4gICAgaWYgKG1vdXNlRG93bilcbiAgICAgICAgbW91c2VEb3duLmRvbmUoKTtcbiAgICBpZiAoIWV2ZW50LmRhdGFUcmFuc2ZlcilcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICBsZXQgcG9zID0gc2VsLmVtcHR5ID8gbnVsbCA6IHZpZXcucG9zQXRDb29yZHMoZXZlbnRDb29yZHMoZXZlbnQpKTtcbiAgICBsZXQgbm9kZTtcbiAgICBpZiAocG9zICYmIHBvcy5wb3MgPj0gc2VsLmZyb20gJiYgcG9zLnBvcyA8PSAoc2VsIGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbiA/IHNlbC50byAtIDEgOiBzZWwudG8pKSA7XG4gICAgZWxzZSBpZiAobW91c2VEb3duICYmIG1vdXNlRG93bi5taWdodERyYWcpIHtcbiAgICAgICAgbm9kZSA9IE5vZGVTZWxlY3Rpb24uY3JlYXRlKHZpZXcuc3RhdGUuZG9jLCBtb3VzZURvd24ubWlnaHREcmFnLnBvcyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV2ZW50LnRhcmdldCAmJiBldmVudC50YXJnZXQubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICBsZXQgZGVzYyA9IHZpZXcuZG9jVmlldy5uZWFyZXN0RGVzYyhldmVudC50YXJnZXQsIHRydWUpO1xuICAgICAgICBpZiAoZGVzYyAmJiBkZXNjLm5vZGUudHlwZS5zcGVjLmRyYWdnYWJsZSAmJiBkZXNjICE9IHZpZXcuZG9jVmlldylcbiAgICAgICAgICAgIG5vZGUgPSBOb2RlU2VsZWN0aW9uLmNyZWF0ZSh2aWV3LnN0YXRlLmRvYywgZGVzYy5wb3NCZWZvcmUpO1xuICAgIH1cbiAgICBsZXQgZHJhZ2dlZFNsaWNlID0gKG5vZGUgfHwgdmlldy5zdGF0ZS5zZWxlY3Rpb24pLmNvbnRlbnQoKTtcbiAgICBsZXQgeyBkb20sIHRleHQsIHNsaWNlIH0gPSBzZXJpYWxpemVGb3JDbGlwYm9hcmQodmlldywgZHJhZ2dlZFNsaWNlKTtcbiAgICAvLyBQcmUtMTIwIENocm9tZSB2ZXJzaW9ucyBjbGVhciBmaWxlcyB3aGVuIGNhbGxpbmcgYGNsZWFyRGF0YWAgKCMxNDcyKVxuICAgIGlmICghZXZlbnQuZGF0YVRyYW5zZmVyLmZpbGVzLmxlbmd0aCB8fCAhY2hyb21lIHx8IGNocm9tZV92ZXJzaW9uID4gMTIwKVxuICAgICAgICBldmVudC5kYXRhVHJhbnNmZXIuY2xlYXJEYXRhKCk7XG4gICAgZXZlbnQuZGF0YVRyYW5zZmVyLnNldERhdGEoYnJva2VuQ2xpcGJvYXJkQVBJID8gXCJUZXh0XCIgOiBcInRleHQvaHRtbFwiLCBkb20uaW5uZXJIVE1MKTtcbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL1Byb3NlTWlycm9yL3Byb3NlbWlycm9yL2lzc3Vlcy8xMTU2XG4gICAgZXZlbnQuZGF0YVRyYW5zZmVyLmVmZmVjdEFsbG93ZWQgPSBcImNvcHlNb3ZlXCI7XG4gICAgaWYgKCFicm9rZW5DbGlwYm9hcmRBUEkpXG4gICAgICAgIGV2ZW50LmRhdGFUcmFuc2Zlci5zZXREYXRhKFwidGV4dC9wbGFpblwiLCB0ZXh0KTtcbiAgICB2aWV3LmRyYWdnaW5nID0gbmV3IERyYWdnaW5nKHNsaWNlLCBkcmFnTW92ZXModmlldywgZXZlbnQpLCBub2RlKTtcbn07XG5oYW5kbGVycy5kcmFnZW5kID0gdmlldyA9PiB7XG4gICAgbGV0IGRyYWdnaW5nID0gdmlldy5kcmFnZ2luZztcbiAgICB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICh2aWV3LmRyYWdnaW5nID09IGRyYWdnaW5nKVxuICAgICAgICAgICAgdmlldy5kcmFnZ2luZyA9IG51bGw7XG4gICAgfSwgNTApO1xufTtcbmVkaXRIYW5kbGVycy5kcmFnb3ZlciA9IGVkaXRIYW5kbGVycy5kcmFnZW50ZXIgPSAoXywgZSkgPT4gZS5wcmV2ZW50RGVmYXVsdCgpO1xuZWRpdEhhbmRsZXJzLmRyb3AgPSAodmlldywgZXZlbnQpID0+IHtcbiAgICB0cnkge1xuICAgICAgICBoYW5kbGVEcm9wKHZpZXcsIGV2ZW50LCB2aWV3LmRyYWdnaW5nKTtcbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHZpZXcuZHJhZ2dpbmcgPSBudWxsO1xuICAgIH1cbn07XG5mdW5jdGlvbiBoYW5kbGVEcm9wKHZpZXcsIGV2ZW50LCBkcmFnZ2luZykge1xuICAgIGlmICghZXZlbnQuZGF0YVRyYW5zZmVyKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IGV2ZW50UG9zID0gdmlldy5wb3NBdENvb3JkcyhldmVudENvb3JkcyhldmVudCkpO1xuICAgIGlmICghZXZlbnRQb3MpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgJG1vdXNlID0gdmlldy5zdGF0ZS5kb2MucmVzb2x2ZShldmVudFBvcy5wb3MpO1xuICAgIGxldCBzbGljZSA9IGRyYWdnaW5nICYmIGRyYWdnaW5nLnNsaWNlO1xuICAgIGlmIChzbGljZSkge1xuICAgICAgICB2aWV3LnNvbWVQcm9wKFwidHJhbnNmb3JtUGFzdGVkXCIsIGYgPT4geyBzbGljZSA9IGYoc2xpY2UsIHZpZXcsIGZhbHNlKTsgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzbGljZSA9IHBhcnNlRnJvbUNsaXBib2FyZCh2aWV3LCBnZXRUZXh0KGV2ZW50LmRhdGFUcmFuc2ZlciksIGJyb2tlbkNsaXBib2FyZEFQSSA/IG51bGwgOiBldmVudC5kYXRhVHJhbnNmZXIuZ2V0RGF0YShcInRleHQvaHRtbFwiKSwgZmFsc2UsICRtb3VzZSk7XG4gICAgfVxuICAgIGxldCBtb3ZlID0gISEoZHJhZ2dpbmcgJiYgZHJhZ01vdmVzKHZpZXcsIGV2ZW50KSk7XG4gICAgaWYgKHZpZXcuc29tZVByb3AoXCJoYW5kbGVEcm9wXCIsIGYgPT4gZih2aWV3LCBldmVudCwgc2xpY2UgfHwgU2xpY2UuZW1wdHksIG1vdmUpKSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghc2xpY2UpXG4gICAgICAgIHJldHVybjtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGxldCBpbnNlcnRQb3MgPSBzbGljZSA/IGRyb3BQb2ludCh2aWV3LnN0YXRlLmRvYywgJG1vdXNlLnBvcywgc2xpY2UpIDogJG1vdXNlLnBvcztcbiAgICBpZiAoaW5zZXJ0UG9zID09IG51bGwpXG4gICAgICAgIGluc2VydFBvcyA9ICRtb3VzZS5wb3M7XG4gICAgbGV0IHRyID0gdmlldy5zdGF0ZS50cjtcbiAgICBpZiAobW92ZSkge1xuICAgICAgICBsZXQgeyBub2RlIH0gPSBkcmFnZ2luZztcbiAgICAgICAgaWYgKG5vZGUpXG4gICAgICAgICAgICBub2RlLnJlcGxhY2UodHIpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0ci5kZWxldGVTZWxlY3Rpb24oKTtcbiAgICB9XG4gICAgbGV0IHBvcyA9IHRyLm1hcHBpbmcubWFwKGluc2VydFBvcyk7XG4gICAgbGV0IGlzTm9kZSA9IHNsaWNlLm9wZW5TdGFydCA9PSAwICYmIHNsaWNlLm9wZW5FbmQgPT0gMCAmJiBzbGljZS5jb250ZW50LmNoaWxkQ291bnQgPT0gMTtcbiAgICBsZXQgYmVmb3JlSW5zZXJ0ID0gdHIuZG9jO1xuICAgIGlmIChpc05vZGUpXG4gICAgICAgIHRyLnJlcGxhY2VSYW5nZVdpdGgocG9zLCBwb3MsIHNsaWNlLmNvbnRlbnQuZmlyc3RDaGlsZCk7XG4gICAgZWxzZVxuICAgICAgICB0ci5yZXBsYWNlUmFuZ2UocG9zLCBwb3MsIHNsaWNlKTtcbiAgICBpZiAodHIuZG9jLmVxKGJlZm9yZUluc2VydCkpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgJHBvcyA9IHRyLmRvYy5yZXNvbHZlKHBvcyk7XG4gICAgaWYgKGlzTm9kZSAmJiBOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShzbGljZS5jb250ZW50LmZpcnN0Q2hpbGQpICYmXG4gICAgICAgICRwb3Mubm9kZUFmdGVyICYmICRwb3Mubm9kZUFmdGVyLnNhbWVNYXJrdXAoc2xpY2UuY29udGVudC5maXJzdENoaWxkKSkge1xuICAgICAgICB0ci5zZXRTZWxlY3Rpb24obmV3IE5vZGVTZWxlY3Rpb24oJHBvcykpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IGVuZCA9IHRyLm1hcHBpbmcubWFwKGluc2VydFBvcyk7XG4gICAgICAgIHRyLm1hcHBpbmcubWFwc1t0ci5tYXBwaW5nLm1hcHMubGVuZ3RoIC0gMV0uZm9yRWFjaCgoX2Zyb20sIF90bywgX25ld0Zyb20sIG5ld1RvKSA9PiBlbmQgPSBuZXdUbyk7XG4gICAgICAgIHRyLnNldFNlbGVjdGlvbihzZWxlY3Rpb25CZXR3ZWVuKHZpZXcsICRwb3MsIHRyLmRvYy5yZXNvbHZlKGVuZCkpKTtcbiAgICB9XG4gICAgdmlldy5mb2N1cygpO1xuICAgIHZpZXcuZGlzcGF0Y2godHIuc2V0TWV0YShcInVpRXZlbnRcIiwgXCJkcm9wXCIpKTtcbn1cbmhhbmRsZXJzLmZvY3VzID0gdmlldyA9PiB7XG4gICAgdmlldy5pbnB1dC5sYXN0Rm9jdXMgPSBEYXRlLm5vdygpO1xuICAgIGlmICghdmlldy5mb2N1c2VkKSB7XG4gICAgICAgIHZpZXcuZG9tT2JzZXJ2ZXIuc3RvcCgpO1xuICAgICAgICB2aWV3LmRvbS5jbGFzc0xpc3QuYWRkKFwiUHJvc2VNaXJyb3ItZm9jdXNlZFwiKTtcbiAgICAgICAgdmlldy5kb21PYnNlcnZlci5zdGFydCgpO1xuICAgICAgICB2aWV3LmZvY3VzZWQgPSB0cnVlO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICh2aWV3LmRvY1ZpZXcgJiYgdmlldy5oYXNGb2N1cygpICYmICF2aWV3LmRvbU9ic2VydmVyLmN1cnJlbnRTZWxlY3Rpb24uZXEodmlldy5kb21TZWxlY3Rpb25SYW5nZSgpKSlcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25Ub0RPTSh2aWV3KTtcbiAgICAgICAgfSwgMjApO1xuICAgIH1cbn07XG5oYW5kbGVycy5ibHVyID0gKHZpZXcsIF9ldmVudCkgPT4ge1xuICAgIGxldCBldmVudCA9IF9ldmVudDtcbiAgICBpZiAodmlldy5mb2N1c2VkKSB7XG4gICAgICAgIHZpZXcuZG9tT2JzZXJ2ZXIuc3RvcCgpO1xuICAgICAgICB2aWV3LmRvbS5jbGFzc0xpc3QucmVtb3ZlKFwiUHJvc2VNaXJyb3ItZm9jdXNlZFwiKTtcbiAgICAgICAgdmlldy5kb21PYnNlcnZlci5zdGFydCgpO1xuICAgICAgICBpZiAoZXZlbnQucmVsYXRlZFRhcmdldCAmJiB2aWV3LmRvbS5jb250YWlucyhldmVudC5yZWxhdGVkVGFyZ2V0KSlcbiAgICAgICAgICAgIHZpZXcuZG9tT2JzZXJ2ZXIuY3VycmVudFNlbGVjdGlvbi5jbGVhcigpO1xuICAgICAgICB2aWV3LmZvY3VzZWQgPSBmYWxzZTtcbiAgICB9XG59O1xuaGFuZGxlcnMuYmVmb3JlaW5wdXQgPSAodmlldywgX2V2ZW50KSA9PiB7XG4gICAgbGV0IGV2ZW50ID0gX2V2ZW50O1xuICAgIC8vIFdlIHNob3VsZCBwcm9iYWJseSBkbyBtb3JlIHdpdGggYmVmb3JlaW5wdXQgZXZlbnRzLCBidXQgc3VwcG9ydFxuICAgIC8vIGlzIHNvIHNwb3R0eSB0aGF0IEknbSBzdGlsbCB3YWl0aW5nIHRvIHNlZSB3aGVyZSB0aGV5IGFyZSBnb2luZy5cbiAgICAvLyBWZXJ5IHNwZWNpZmljIGhhY2sgdG8gZGVhbCB3aXRoIGJhY2tzcGFjZSBzb21ldGltZXMgZmFpbGluZyBvblxuICAgIC8vIENocm9tZSBBbmRyb2lkIHdoZW4gYWZ0ZXIgYW4gdW5lZGl0YWJsZSBub2RlLlxuICAgIGlmIChjaHJvbWUgJiYgYW5kcm9pZCAmJiBldmVudC5pbnB1dFR5cGUgPT0gXCJkZWxldGVDb250ZW50QmFja3dhcmRcIikge1xuICAgICAgICB2aWV3LmRvbU9ic2VydmVyLmZsdXNoU29vbigpO1xuICAgICAgICBsZXQgeyBkb21DaGFuZ2VDb3VudCB9ID0gdmlldy5pbnB1dDtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodmlldy5pbnB1dC5kb21DaGFuZ2VDb3VudCAhPSBkb21DaGFuZ2VDb3VudClcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIEV2ZW50IGFscmVhZHkgaGFkIHNvbWUgZWZmZWN0XG4gICAgICAgICAgICAvLyBUaGlzIGJ1ZyB0ZW5kcyB0byBjbG9zZSB0aGUgdmlydHVhbCBrZXlib2FyZCwgc28gd2UgcmVmb2N1c1xuICAgICAgICAgICAgdmlldy5kb20uYmx1cigpO1xuICAgICAgICAgICAgdmlldy5mb2N1cygpO1xuICAgICAgICAgICAgaWYgKHZpZXcuc29tZVByb3AoXCJoYW5kbGVLZXlEb3duXCIsIGYgPT4gZih2aWV3LCBrZXlFdmVudCg4LCBcIkJhY2tzcGFjZVwiKSkpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGxldCB7ICRjdXJzb3IgfSA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICAgICAgLy8gQ3J1ZGUgYXBwcm94aW1hdGlvbiBvZiBiYWNrc3BhY2UgYmVoYXZpb3Igd2hlbiBubyBjb21tYW5kIGhhbmRsZWQgaXRcbiAgICAgICAgICAgIGlmICgkY3Vyc29yICYmICRjdXJzb3IucG9zID4gMClcbiAgICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHZpZXcuc3RhdGUudHIuZGVsZXRlKCRjdXJzb3IucG9zIC0gMSwgJGN1cnNvci5wb3MpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICB9LCA1MCk7XG4gICAgfVxufTtcbi8vIE1ha2Ugc3VyZSBhbGwgaGFuZGxlcnMgZ2V0IHJlZ2lzdGVyZWRcbmZvciAobGV0IHByb3AgaW4gZWRpdEhhbmRsZXJzKVxuICAgIGhhbmRsZXJzW3Byb3BdID0gZWRpdEhhbmRsZXJzW3Byb3BdO1xuXG5mdW5jdGlvbiBjb21wYXJlT2JqcyhhLCBiKSB7XG4gICAgaWYgKGEgPT0gYilcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgZm9yIChsZXQgcCBpbiBhKVxuICAgICAgICBpZiAoYVtwXSAhPT0gYltwXSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBwIGluIGIpXG4gICAgICAgIGlmICghKHAgaW4gYSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59XG5jbGFzcyBXaWRnZXRUeXBlIHtcbiAgICBjb25zdHJ1Y3Rvcih0b0RPTSwgc3BlYykge1xuICAgICAgICB0aGlzLnRvRE9NID0gdG9ET007XG4gICAgICAgIHRoaXMuc3BlYyA9IHNwZWMgfHwgbm9TcGVjO1xuICAgICAgICB0aGlzLnNpZGUgPSB0aGlzLnNwZWMuc2lkZSB8fCAwO1xuICAgIH1cbiAgICBtYXAobWFwcGluZywgc3Bhbiwgb2Zmc2V0LCBvbGRPZmZzZXQpIHtcbiAgICAgICAgbGV0IHsgcG9zLCBkZWxldGVkIH0gPSBtYXBwaW5nLm1hcFJlc3VsdChzcGFuLmZyb20gKyBvbGRPZmZzZXQsIHRoaXMuc2lkZSA8IDAgPyAtMSA6IDEpO1xuICAgICAgICByZXR1cm4gZGVsZXRlZCA/IG51bGwgOiBuZXcgRGVjb3JhdGlvbihwb3MgLSBvZmZzZXQsIHBvcyAtIG9mZnNldCwgdGhpcyk7XG4gICAgfVxuICAgIHZhbGlkKCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzID09IG90aGVyIHx8XG4gICAgICAgICAgICAob3RoZXIgaW5zdGFuY2VvZiBXaWRnZXRUeXBlICYmXG4gICAgICAgICAgICAgICAgKHRoaXMuc3BlYy5rZXkgJiYgdGhpcy5zcGVjLmtleSA9PSBvdGhlci5zcGVjLmtleSB8fFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvRE9NID09IG90aGVyLnRvRE9NICYmIGNvbXBhcmVPYmpzKHRoaXMuc3BlYywgb3RoZXIuc3BlYykpKTtcbiAgICB9XG4gICAgZGVzdHJveShub2RlKSB7XG4gICAgICAgIGlmICh0aGlzLnNwZWMuZGVzdHJveSlcbiAgICAgICAgICAgIHRoaXMuc3BlYy5kZXN0cm95KG5vZGUpO1xuICAgIH1cbn1cbmNsYXNzIElubGluZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKGF0dHJzLCBzcGVjKSB7XG4gICAgICAgIHRoaXMuYXR0cnMgPSBhdHRycztcbiAgICAgICAgdGhpcy5zcGVjID0gc3BlYyB8fCBub1NwZWM7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nLCBzcGFuLCBvZmZzZXQsIG9sZE9mZnNldCkge1xuICAgICAgICBsZXQgZnJvbSA9IG1hcHBpbmcubWFwKHNwYW4uZnJvbSArIG9sZE9mZnNldCwgdGhpcy5zcGVjLmluY2x1c2l2ZVN0YXJ0ID8gLTEgOiAxKSAtIG9mZnNldDtcbiAgICAgICAgbGV0IHRvID0gbWFwcGluZy5tYXAoc3Bhbi50byArIG9sZE9mZnNldCwgdGhpcy5zcGVjLmluY2x1c2l2ZUVuZCA/IDEgOiAtMSkgLSBvZmZzZXQ7XG4gICAgICAgIHJldHVybiBmcm9tID49IHRvID8gbnVsbCA6IG5ldyBEZWNvcmF0aW9uKGZyb20sIHRvLCB0aGlzKTtcbiAgICB9XG4gICAgdmFsaWQoXywgc3BhbikgeyByZXR1cm4gc3Bhbi5mcm9tIDwgc3Bhbi50bzsgfVxuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzID09IG90aGVyIHx8XG4gICAgICAgICAgICAob3RoZXIgaW5zdGFuY2VvZiBJbmxpbmVUeXBlICYmIGNvbXBhcmVPYmpzKHRoaXMuYXR0cnMsIG90aGVyLmF0dHJzKSAmJlxuICAgICAgICAgICAgICAgIGNvbXBhcmVPYmpzKHRoaXMuc3BlYywgb3RoZXIuc3BlYykpO1xuICAgIH1cbiAgICBzdGF0aWMgaXMoc3BhbikgeyByZXR1cm4gc3Bhbi50eXBlIGluc3RhbmNlb2YgSW5saW5lVHlwZTsgfVxuICAgIGRlc3Ryb3koKSB7IH1cbn1cbmNsYXNzIE5vZGVUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcihhdHRycywgc3BlYykge1xuICAgICAgICB0aGlzLmF0dHJzID0gYXR0cnM7XG4gICAgICAgIHRoaXMuc3BlYyA9IHNwZWMgfHwgbm9TcGVjO1xuICAgIH1cbiAgICBtYXAobWFwcGluZywgc3Bhbiwgb2Zmc2V0LCBvbGRPZmZzZXQpIHtcbiAgICAgICAgbGV0IGZyb20gPSBtYXBwaW5nLm1hcFJlc3VsdChzcGFuLmZyb20gKyBvbGRPZmZzZXQsIDEpO1xuICAgICAgICBpZiAoZnJvbS5kZWxldGVkKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCB0byA9IG1hcHBpbmcubWFwUmVzdWx0KHNwYW4udG8gKyBvbGRPZmZzZXQsIC0xKTtcbiAgICAgICAgaWYgKHRvLmRlbGV0ZWQgfHwgdG8ucG9zIDw9IGZyb20ucG9zKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBuZXcgRGVjb3JhdGlvbihmcm9tLnBvcyAtIG9mZnNldCwgdG8ucG9zIC0gb2Zmc2V0LCB0aGlzKTtcbiAgICB9XG4gICAgdmFsaWQobm9kZSwgc3Bhbikge1xuICAgICAgICBsZXQgeyBpbmRleCwgb2Zmc2V0IH0gPSBub2RlLmNvbnRlbnQuZmluZEluZGV4KHNwYW4uZnJvbSksIGNoaWxkO1xuICAgICAgICByZXR1cm4gb2Zmc2V0ID09IHNwYW4uZnJvbSAmJiAhKGNoaWxkID0gbm9kZS5jaGlsZChpbmRleCkpLmlzVGV4dCAmJiBvZmZzZXQgKyBjaGlsZC5ub2RlU2l6ZSA9PSBzcGFuLnRvO1xuICAgIH1cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcyA9PSBvdGhlciB8fFxuICAgICAgICAgICAgKG90aGVyIGluc3RhbmNlb2YgTm9kZVR5cGUgJiYgY29tcGFyZU9ianModGhpcy5hdHRycywgb3RoZXIuYXR0cnMpICYmXG4gICAgICAgICAgICAgICAgY29tcGFyZU9ianModGhpcy5zcGVjLCBvdGhlci5zcGVjKSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7IH1cbn1cbi8qKlxuRGVjb3JhdGlvbiBvYmplY3RzIGNhbiBiZSBwcm92aWRlZCB0byB0aGUgdmlldyB0aHJvdWdoIHRoZVxuW2BkZWNvcmF0aW9uc2AgcHJvcF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yUHJvcHMuZGVjb3JhdGlvbnMpLiBUaGV5IGNvbWUgaW5cbnNldmVyYWwgdmFyaWFudHPigJRzZWUgdGhlIHN0YXRpYyBtZW1iZXJzIG9mIHRoaXMgY2xhc3MgZm9yIGRldGFpbHMuXG4qL1xuY2xhc3MgRGVjb3JhdGlvbiB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIGRlY29yYXRpb24uXG4gICAgKi9cbiAgICBmcm9tLCBcbiAgICAvKipcbiAgICBUaGUgZW5kIHBvc2l0aW9uLiBXaWxsIGJlIHRoZSBzYW1lIGFzIGBmcm9tYCBmb3IgW3dpZGdldFxuICAgIGRlY29yYXRpb25zXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5EZWNvcmF0aW9uXndpZGdldCkuXG4gICAgKi9cbiAgICB0bywgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0eXBlKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb3B5KGZyb20sIHRvKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGVjb3JhdGlvbihmcm9tLCB0bywgdGhpcy50eXBlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBlcShvdGhlciwgb2Zmc2V0ID0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlLmVxKG90aGVyLnR5cGUpICYmIHRoaXMuZnJvbSArIG9mZnNldCA9PSBvdGhlci5mcm9tICYmIHRoaXMudG8gKyBvZmZzZXQgPT0gb3RoZXIudG87XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgbWFwKG1hcHBpbmcsIG9mZnNldCwgb2xkT2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUubWFwKG1hcHBpbmcsIHRoaXMsIG9mZnNldCwgb2xkT2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlcyBhIHdpZGdldCBkZWNvcmF0aW9uLCB3aGljaCBpcyBhIERPTSBub2RlIHRoYXQncyBzaG93biBpblxuICAgIHRoZSBkb2N1bWVudCBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uIEl0IGlzIHJlY29tbWVuZGVkIHRoYXQgeW91XG4gICAgZGVsYXkgcmVuZGVyaW5nIHRoZSB3aWRnZXQgYnkgcGFzc2luZyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZVxuICAgIGNhbGxlZCB3aGVuIHRoZSB3aWRnZXQgaXMgYWN0dWFsbHkgZHJhd24gaW4gYSB2aWV3LCBidXQgeW91IGNhblxuICAgIGFsc28gZGlyZWN0bHkgcGFzcyBhIERPTSBub2RlLiBgZ2V0UG9zYCBjYW4gYmUgdXNlZCB0byBmaW5kIHRoZVxuICAgIHdpZGdldCdzIGN1cnJlbnQgZG9jdW1lbnQgcG9zaXRpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgd2lkZ2V0KHBvcywgdG9ET00sIHNwZWMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWNvcmF0aW9uKHBvcywgcG9zLCBuZXcgV2lkZ2V0VHlwZSh0b0RPTSwgc3BlYykpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGVzIGFuIGlubGluZSBkZWNvcmF0aW9uLCB3aGljaCBhZGRzIHRoZSBnaXZlbiBhdHRyaWJ1dGVzIHRvXG4gICAgZWFjaCBpbmxpbmUgbm9kZSBiZXR3ZWVuIGBmcm9tYCBhbmQgYHRvYC5cbiAgICAqL1xuICAgIHN0YXRpYyBpbmxpbmUoZnJvbSwgdG8sIGF0dHJzLCBzcGVjKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGVjb3JhdGlvbihmcm9tLCB0bywgbmV3IElubGluZVR5cGUoYXR0cnMsIHNwZWMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlcyBhIG5vZGUgZGVjb3JhdGlvbi4gYGZyb21gIGFuZCBgdG9gIHNob3VsZCBwb2ludCBwcmVjaXNlbHlcbiAgICBiZWZvcmUgYW5kIGFmdGVyIGEgbm9kZSBpbiB0aGUgZG9jdW1lbnQuIFRoYXQgbm9kZSwgYW5kIG9ubHkgdGhhdFxuICAgIG5vZGUsIHdpbGwgcmVjZWl2ZSB0aGUgZ2l2ZW4gYXR0cmlidXRlcy5cbiAgICAqL1xuICAgIHN0YXRpYyBub2RlKGZyb20sIHRvLCBhdHRycywgc3BlYykge1xuICAgICAgICByZXR1cm4gbmV3IERlY29yYXRpb24oZnJvbSwgdG8sIG5ldyBOb2RlVHlwZShhdHRycywgc3BlYykpO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgc3BlYyBwcm92aWRlZCB3aGVuIGNyZWF0aW5nIHRoaXMgZGVjb3JhdGlvbi4gQ2FuIGJlIHVzZWZ1bFxuICAgIGlmIHlvdSd2ZSBzdG9yZWQgZXh0cmEgaW5mb3JtYXRpb24gaW4gdGhhdCBvYmplY3QuXG4gICAgKi9cbiAgICBnZXQgc3BlYygpIHsgcmV0dXJuIHRoaXMudHlwZS5zcGVjOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBnZXQgaW5saW5lKCkgeyByZXR1cm4gdGhpcy50eXBlIGluc3RhbmNlb2YgSW5saW5lVHlwZTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IHdpZGdldCgpIHsgcmV0dXJuIHRoaXMudHlwZSBpbnN0YW5jZW9mIFdpZGdldFR5cGU7IH1cbn1cbmNvbnN0IG5vbmUgPSBbXSwgbm9TcGVjID0ge307XG4vKipcbkEgY29sbGVjdGlvbiBvZiBbZGVjb3JhdGlvbnNdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN2aWV3LkRlY29yYXRpb24pLCBvcmdhbml6ZWQgaW4gc3VjaFxuYSB3YXkgdGhhdCB0aGUgZHJhd2luZyBhbGdvcml0aG0gY2FuIGVmZmljaWVudGx5IHVzZSBhbmQgY29tcGFyZVxudGhlbS4gVGhpcyBpcyBhIHBlcnNpc3RlbnQgZGF0YSBzdHJ1Y3R1cmXigJRpdCBpcyBub3QgbW9kaWZpZWQsXG51cGRhdGVzIGNyZWF0ZSBhIG5ldyB2YWx1ZS5cbiovXG5jbGFzcyBEZWNvcmF0aW9uU2V0IHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsLCBjaGlsZHJlbikge1xuICAgICAgICB0aGlzLmxvY2FsID0gbG9jYWwubGVuZ3RoID8gbG9jYWwgOiBub25lO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW4ubGVuZ3RoID8gY2hpbGRyZW4gOiBub25lO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBzZXQgb2YgZGVjb3JhdGlvbnMsIHVzaW5nIHRoZSBzdHJ1Y3R1cmUgb2YgdGhlIGdpdmVuXG4gICAgZG9jdW1lbnQuIFRoaXMgd2lsbCBjb25zdW1lIChtb2RpZnkpIHRoZSBgZGVjb3JhdGlvbnNgIGFycmF5LCBzb1xuICAgIHlvdSBtdXN0IG1ha2UgYSBjb3B5IGlmIHlvdSB3YW50IG5lZWQgdG8gcHJlc2VydmUgdGhhdC5cbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoZG9jLCBkZWNvcmF0aW9ucykge1xuICAgICAgICByZXR1cm4gZGVjb3JhdGlvbnMubGVuZ3RoID8gYnVpbGRUcmVlKGRlY29yYXRpb25zLCBkb2MsIDAsIG5vU3BlYykgOiBlbXB0eTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCBhbGwgZGVjb3JhdGlvbnMgaW4gdGhpcyBzZXQgd2hpY2ggdG91Y2ggdGhlIGdpdmVuIHJhbmdlXG4gICAgKGluY2x1ZGluZyBkZWNvcmF0aW9ucyB0aGF0IHN0YXJ0IG9yIGVuZCBkaXJlY3RseSBhdCB0aGVcbiAgICBib3VuZGFyaWVzKSBhbmQgbWF0Y2ggdGhlIGdpdmVuIHByZWRpY2F0ZSBvbiB0aGVpciBzcGVjLiBXaGVuXG4gICAgYHN0YXJ0YCBhbmQgYGVuZGAgYXJlIG9taXR0ZWQsIGFsbCBkZWNvcmF0aW9ucyBpbiB0aGUgc2V0IGFyZVxuICAgIGNvbnNpZGVyZWQuIFdoZW4gYHByZWRpY2F0ZWAgaXNuJ3QgZ2l2ZW4sIGFsbCBkZWNvcmF0aW9ucyBhcmVcbiAgICBhc3N1bWVkIHRvIG1hdGNoLlxuICAgICovXG4gICAgZmluZChzdGFydCwgZW5kLCBwcmVkaWNhdGUpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICB0aGlzLmZpbmRJbm5lcihzdGFydCA9PSBudWxsID8gMCA6IHN0YXJ0LCBlbmQgPT0gbnVsbCA/IDFlOSA6IGVuZCwgcmVzdWx0LCAwLCBwcmVkaWNhdGUpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBmaW5kSW5uZXIoc3RhcnQsIGVuZCwgcmVzdWx0LCBvZmZzZXQsIHByZWRpY2F0ZSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubG9jYWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzcGFuID0gdGhpcy5sb2NhbFtpXTtcbiAgICAgICAgICAgIGlmIChzcGFuLmZyb20gPD0gZW5kICYmIHNwYW4udG8gPj0gc3RhcnQgJiYgKCFwcmVkaWNhdGUgfHwgcHJlZGljYXRlKHNwYW4uc3BlYykpKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHNwYW4uY29weShzcGFuLmZyb20gKyBvZmZzZXQsIHNwYW4udG8gKyBvZmZzZXQpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNoaWxkcmVuW2ldIDwgZW5kICYmIHRoaXMuY2hpbGRyZW5baSArIDFdID4gc3RhcnQpIHtcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGRPZmYgPSB0aGlzLmNoaWxkcmVuW2ldICsgMTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuW2kgKyAyXS5maW5kSW5uZXIoc3RhcnQgLSBjaGlsZE9mZiwgZW5kIC0gY2hpbGRPZmYsIHJlc3VsdCwgb2Zmc2V0ICsgY2hpbGRPZmYsIHByZWRpY2F0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgTWFwIHRoZSBzZXQgb2YgZGVjb3JhdGlvbnMgaW4gcmVzcG9uc2UgdG8gYSBjaGFuZ2UgaW4gdGhlXG4gICAgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBtYXAobWFwcGluZywgZG9jLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICh0aGlzID09IGVtcHR5IHx8IG1hcHBpbmcubWFwcy5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5tYXBJbm5lcihtYXBwaW5nLCBkb2MsIDAsIDAsIG9wdGlvbnMgfHwgbm9TcGVjKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBtYXBJbm5lcihtYXBwaW5nLCBub2RlLCBvZmZzZXQsIG9sZE9mZnNldCwgb3B0aW9ucykge1xuICAgICAgICBsZXQgbmV3TG9jYWw7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sb2NhbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IG1hcHBlZCA9IHRoaXMubG9jYWxbaV0ubWFwKG1hcHBpbmcsIG9mZnNldCwgb2xkT2Zmc2V0KTtcbiAgICAgICAgICAgIGlmIChtYXBwZWQgJiYgbWFwcGVkLnR5cGUudmFsaWQobm9kZSwgbWFwcGVkKSlcbiAgICAgICAgICAgICAgICAobmV3TG9jYWwgfHwgKG5ld0xvY2FsID0gW10pKS5wdXNoKG1hcHBlZCk7XG4gICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zLm9uUmVtb3ZlKVxuICAgICAgICAgICAgICAgIG9wdGlvbnMub25SZW1vdmUodGhpcy5sb2NhbFtpXS5zcGVjKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jaGlsZHJlbi5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gbWFwQ2hpbGRyZW4odGhpcy5jaGlsZHJlbiwgbmV3TG9jYWwgfHwgW10sIG1hcHBpbmcsIG5vZGUsIG9mZnNldCwgb2xkT2Zmc2V0LCBvcHRpb25zKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIG5ld0xvY2FsID8gbmV3IERlY29yYXRpb25TZXQobmV3TG9jYWwuc29ydChieVBvcyksIG5vbmUpIDogZW1wdHk7XG4gICAgfVxuICAgIC8qKlxuICAgIEFkZCB0aGUgZ2l2ZW4gYXJyYXkgb2YgZGVjb3JhdGlvbnMgdG8gdGhlIG9uZXMgaW4gdGhlIHNldCxcbiAgICBwcm9kdWNpbmcgYSBuZXcgc2V0LiBDb25zdW1lcyB0aGUgYGRlY29yYXRpb25zYCBhcnJheS4gTmVlZHNcbiAgICBhY2Nlc3MgdG8gdGhlIGN1cnJlbnQgZG9jdW1lbnQgdG8gY3JlYXRlIHRoZSBhcHByb3ByaWF0ZSB0cmVlXG4gICAgc3RydWN0dXJlLlxuICAgICovXG4gICAgYWRkKGRvYywgZGVjb3JhdGlvbnMpIHtcbiAgICAgICAgaWYgKCFkZWNvcmF0aW9ucy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgaWYgKHRoaXMgPT0gZW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvblNldC5jcmVhdGUoZG9jLCBkZWNvcmF0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZElubmVyKGRvYywgZGVjb3JhdGlvbnMsIDApO1xuICAgIH1cbiAgICBhZGRJbm5lcihkb2MsIGRlY29yYXRpb25zLCBvZmZzZXQpIHtcbiAgICAgICAgbGV0IGNoaWxkcmVuLCBjaGlsZEluZGV4ID0gMDtcbiAgICAgICAgZG9jLmZvckVhY2goKGNoaWxkTm9kZSwgY2hpbGRPZmZzZXQpID0+IHtcbiAgICAgICAgICAgIGxldCBiYXNlT2Zmc2V0ID0gY2hpbGRPZmZzZXQgKyBvZmZzZXQsIGZvdW5kO1xuICAgICAgICAgICAgaWYgKCEoZm91bmQgPSB0YWtlU3BhbnNGb3JOb2RlKGRlY29yYXRpb25zLCBjaGlsZE5vZGUsIGJhc2VPZmZzZXQpKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAoIWNoaWxkcmVuKVxuICAgICAgICAgICAgICAgIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbi5zbGljZSgpO1xuICAgICAgICAgICAgd2hpbGUgKGNoaWxkSW5kZXggPCBjaGlsZHJlbi5sZW5ndGggJiYgY2hpbGRyZW5bY2hpbGRJbmRleF0gPCBjaGlsZE9mZnNldClcbiAgICAgICAgICAgICAgICBjaGlsZEluZGV4ICs9IDM7XG4gICAgICAgICAgICBpZiAoY2hpbGRyZW5bY2hpbGRJbmRleF0gPT0gY2hpbGRPZmZzZXQpXG4gICAgICAgICAgICAgICAgY2hpbGRyZW5bY2hpbGRJbmRleCArIDJdID0gY2hpbGRyZW5bY2hpbGRJbmRleCArIDJdLmFkZElubmVyKGNoaWxkTm9kZSwgZm91bmQsIGJhc2VPZmZzZXQgKyAxKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5zcGxpY2UoY2hpbGRJbmRleCwgMCwgY2hpbGRPZmZzZXQsIGNoaWxkT2Zmc2V0ICsgY2hpbGROb2RlLm5vZGVTaXplLCBidWlsZFRyZWUoZm91bmQsIGNoaWxkTm9kZSwgYmFzZU9mZnNldCArIDEsIG5vU3BlYykpO1xuICAgICAgICAgICAgY2hpbGRJbmRleCArPSAzO1xuICAgICAgICB9KTtcbiAgICAgICAgbGV0IGxvY2FsID0gbW92ZVNwYW5zKGNoaWxkSW5kZXggPyB3aXRob3V0TnVsbHMoZGVjb3JhdGlvbnMpIDogZGVjb3JhdGlvbnMsIC1vZmZzZXQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxvY2FsLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKCFsb2NhbFtpXS50eXBlLnZhbGlkKGRvYywgbG9jYWxbaV0pKVxuICAgICAgICAgICAgICAgIGxvY2FsLnNwbGljZShpLS0sIDEpO1xuICAgICAgICByZXR1cm4gbmV3IERlY29yYXRpb25TZXQobG9jYWwubGVuZ3RoID8gdGhpcy5sb2NhbC5jb25jYXQobG9jYWwpLnNvcnQoYnlQb3MpIDogdGhpcy5sb2NhbCwgY2hpbGRyZW4gfHwgdGhpcy5jaGlsZHJlbik7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5ldyBzZXQgdGhhdCBjb250YWlucyB0aGUgZGVjb3JhdGlvbnMgaW4gdGhpcyBzZXQsIG1pbnVzXG4gICAgdGhlIG9uZXMgaW4gdGhlIGdpdmVuIGFycmF5LlxuICAgICovXG4gICAgcmVtb3ZlKGRlY29yYXRpb25zKSB7XG4gICAgICAgIGlmIChkZWNvcmF0aW9ucy5sZW5ndGggPT0gMCB8fCB0aGlzID09IGVtcHR5KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbW92ZUlubmVyKGRlY29yYXRpb25zLCAwKTtcbiAgICB9XG4gICAgcmVtb3ZlSW5uZXIoZGVjb3JhdGlvbnMsIG9mZnNldCkge1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLCBsb2NhbCA9IHRoaXMubG9jYWw7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgICAgIGxldCBmb3VuZDtcbiAgICAgICAgICAgIGxldCBmcm9tID0gY2hpbGRyZW5baV0gKyBvZmZzZXQsIHRvID0gY2hpbGRyZW5baSArIDFdICsgb2Zmc2V0O1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDAsIHNwYW47IGogPCBkZWNvcmF0aW9ucy5sZW5ndGg7IGorKylcbiAgICAgICAgICAgICAgICBpZiAoc3BhbiA9IGRlY29yYXRpb25zW2pdKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzcGFuLmZyb20gPiBmcm9tICYmIHNwYW4udG8gPCB0bykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVjb3JhdGlvbnNbal0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgKGZvdW5kIHx8IChmb3VuZCA9IFtdKSkucHVzaChzcGFuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZm91bmQpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAoY2hpbGRyZW4gPT0gdGhpcy5jaGlsZHJlbilcbiAgICAgICAgICAgICAgICBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4uc2xpY2UoKTtcbiAgICAgICAgICAgIGxldCByZW1vdmVkID0gY2hpbGRyZW5baSArIDJdLnJlbW92ZUlubmVyKGZvdW5kLCBmcm9tICsgMSk7XG4gICAgICAgICAgICBpZiAocmVtb3ZlZCAhPSBlbXB0eSkge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuW2kgKyAyXSA9IHJlbW92ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5zcGxpY2UoaSwgMyk7XG4gICAgICAgICAgICAgICAgaSAtPSAzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsb2NhbC5sZW5ndGgpXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgc3BhbjsgaSA8IGRlY29yYXRpb25zLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIGlmIChzcGFuID0gZGVjb3JhdGlvbnNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBsb2NhbC5sZW5ndGg7IGorKylcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2NhbFtqXS5lcShzcGFuLCBvZmZzZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvY2FsID09IHRoaXMubG9jYWwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsID0gdGhpcy5sb2NhbC5zbGljZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsLnNwbGljZShqLS0sIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgaWYgKGNoaWxkcmVuID09IHRoaXMuY2hpbGRyZW4gJiYgbG9jYWwgPT0gdGhpcy5sb2NhbClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICByZXR1cm4gbG9jYWwubGVuZ3RoIHx8IGNoaWxkcmVuLmxlbmd0aCA/IG5ldyBEZWNvcmF0aW9uU2V0KGxvY2FsLCBjaGlsZHJlbikgOiBlbXB0eTtcbiAgICB9XG4gICAgZm9yQ2hpbGQob2Zmc2V0LCBub2RlKSB7XG4gICAgICAgIGlmICh0aGlzID09IGVtcHR5KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGlmIChub2RlLmlzTGVhZilcbiAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uU2V0LmVtcHR5O1xuICAgICAgICBsZXQgY2hpbGQsIGxvY2FsO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDMpXG4gICAgICAgICAgICBpZiAodGhpcy5jaGlsZHJlbltpXSA+PSBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGlsZHJlbltpXSA9PSBvZmZzZXQpXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpICsgMl07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIGxldCBzdGFydCA9IG9mZnNldCArIDEsIGVuZCA9IHN0YXJ0ICsgbm9kZS5jb250ZW50LnNpemU7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sb2NhbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGRlYyA9IHRoaXMubG9jYWxbaV07XG4gICAgICAgICAgICBpZiAoZGVjLmZyb20gPCBlbmQgJiYgZGVjLnRvID4gc3RhcnQgJiYgKGRlYy50eXBlIGluc3RhbmNlb2YgSW5saW5lVHlwZSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IE1hdGgubWF4KHN0YXJ0LCBkZWMuZnJvbSkgLSBzdGFydCwgdG8gPSBNYXRoLm1pbihlbmQsIGRlYy50bykgLSBzdGFydDtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA8IHRvKVxuICAgICAgICAgICAgICAgICAgICAobG9jYWwgfHwgKGxvY2FsID0gW10pKS5wdXNoKGRlYy5jb3B5KGZyb20sIHRvKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvY2FsKSB7XG4gICAgICAgICAgICBsZXQgbG9jYWxTZXQgPSBuZXcgRGVjb3JhdGlvblNldChsb2NhbC5zb3J0KGJ5UG9zKSwgbm9uZSk7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGQgPyBuZXcgRGVjb3JhdGlvbkdyb3VwKFtsb2NhbFNldCwgY2hpbGRdKSA6IGxvY2FsU2V0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGlsZCB8fCBlbXB0eTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBlcShvdGhlcikge1xuICAgICAgICBpZiAodGhpcyA9PSBvdGhlcilcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIERlY29yYXRpb25TZXQpIHx8XG4gICAgICAgICAgICB0aGlzLmxvY2FsLmxlbmd0aCAhPSBvdGhlci5sb2NhbC5sZW5ndGggfHxcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4ubGVuZ3RoICE9IG90aGVyLmNoaWxkcmVuLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxvY2FsLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKCF0aGlzLmxvY2FsW2ldLmVxKG90aGVyLmxvY2FsW2ldKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgKz0gMylcbiAgICAgICAgICAgIGlmICh0aGlzLmNoaWxkcmVuW2ldICE9IG90aGVyLmNoaWxkcmVuW2ldIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbltpICsgMV0gIT0gb3RoZXIuY2hpbGRyZW5baSArIDFdIHx8XG4gICAgICAgICAgICAgICAgIXRoaXMuY2hpbGRyZW5baSArIDJdLmVxKG90aGVyLmNoaWxkcmVuW2kgKyAyXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBsb2NhbHMobm9kZSkge1xuICAgICAgICByZXR1cm4gcmVtb3ZlT3ZlcmxhcCh0aGlzLmxvY2Fsc0lubmVyKG5vZGUpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBsb2NhbHNJbm5lcihub2RlKSB7XG4gICAgICAgIGlmICh0aGlzID09IGVtcHR5KVxuICAgICAgICAgICAgcmV0dXJuIG5vbmU7XG4gICAgICAgIGlmIChub2RlLmlubGluZUNvbnRlbnQgfHwgIXRoaXMubG9jYWwuc29tZShJbmxpbmVUeXBlLmlzKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sb2NhbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCEodGhpcy5sb2NhbFtpXS50eXBlIGluc3RhbmNlb2YgSW5saW5lVHlwZSkpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5sb2NhbFtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZm9yRWFjaFNldChmKSB7IGYodGhpcyk7IH1cbn1cbi8qKlxuVGhlIGVtcHR5IHNldCBvZiBkZWNvcmF0aW9ucy5cbiovXG5EZWNvcmF0aW9uU2V0LmVtcHR5ID0gbmV3IERlY29yYXRpb25TZXQoW10sIFtdKTtcbi8qKlxuQGludGVybmFsXG4qL1xuRGVjb3JhdGlvblNldC5yZW1vdmVPdmVybGFwID0gcmVtb3ZlT3ZlcmxhcDtcbmNvbnN0IGVtcHR5ID0gRGVjb3JhdGlvblNldC5lbXB0eTtcbi8vIEFuIGFic3RyYWN0aW9uIHRoYXQgYWxsb3dzIHRoZSBjb2RlIGRlYWxpbmcgd2l0aCBkZWNvcmF0aW9ucyB0b1xuLy8gdHJlYXQgbXVsdGlwbGUgRGVjb3JhdGlvblNldCBvYmplY3RzIGFzIGlmIGl0IHdlcmUgYSBzaW5nbGUgb2JqZWN0XG4vLyB3aXRoIChhIHN1YnNldCBvZikgdGhlIHNhbWUgaW50ZXJmYWNlLlxuY2xhc3MgRGVjb3JhdGlvbkdyb3VwIHtcbiAgICBjb25zdHJ1Y3RvcihtZW1iZXJzKSB7XG4gICAgICAgIHRoaXMubWVtYmVycyA9IG1lbWJlcnM7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nLCBkb2MpIHtcbiAgICAgICAgY29uc3QgbWFwcGVkRGVjb3MgPSB0aGlzLm1lbWJlcnMubWFwKG1lbWJlciA9PiBtZW1iZXIubWFwKG1hcHBpbmcsIGRvYywgbm9TcGVjKSk7XG4gICAgICAgIHJldHVybiBEZWNvcmF0aW9uR3JvdXAuZnJvbShtYXBwZWREZWNvcyk7XG4gICAgfVxuICAgIGZvckNoaWxkKG9mZnNldCwgY2hpbGQpIHtcbiAgICAgICAgaWYgKGNoaWxkLmlzTGVhZilcbiAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uU2V0LmVtcHR5O1xuICAgICAgICBsZXQgZm91bmQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1lbWJlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSB0aGlzLm1lbWJlcnNbaV0uZm9yQ2hpbGQob2Zmc2V0LCBjaGlsZCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09IGVtcHR5KVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIERlY29yYXRpb25Hcm91cClcbiAgICAgICAgICAgICAgICBmb3VuZCA9IGZvdW5kLmNvbmNhdChyZXN1bHQubWVtYmVycyk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZm91bmQucHVzaChyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBEZWNvcmF0aW9uR3JvdXAuZnJvbShmb3VuZCk7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgRGVjb3JhdGlvbkdyb3VwKSB8fFxuICAgICAgICAgICAgb3RoZXIubWVtYmVycy5sZW5ndGggIT0gdGhpcy5tZW1iZXJzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1lbWJlcnMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoIXRoaXMubWVtYmVyc1tpXS5lcShvdGhlci5tZW1iZXJzW2ldKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBsb2NhbHMobm9kZSkge1xuICAgICAgICBsZXQgcmVzdWx0LCBzb3J0ZWQgPSB0cnVlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWVtYmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGxvY2FscyA9IHRoaXMubWVtYmVyc1tpXS5sb2NhbHNJbm5lcihub2RlKTtcbiAgICAgICAgICAgIGlmICghbG9jYWxzLmxlbmd0aClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbG9jYWxzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHNvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgc29ydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbG9jYWxzLmxlbmd0aDsgaisrKVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChsb2NhbHNbal0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQgPyByZW1vdmVPdmVybGFwKHNvcnRlZCA/IHJlc3VsdCA6IHJlc3VsdC5zb3J0KGJ5UG9zKSkgOiBub25lO1xuICAgIH1cbiAgICAvLyBDcmVhdGUgYSBncm91cCBmb3IgdGhlIGdpdmVuIGFycmF5IG9mIGRlY29yYXRpb24gc2V0cywgb3IgcmV0dXJuXG4gICAgLy8gYSBzaW5nbGUgc2V0IHdoZW4gcG9zc2libGUuXG4gICAgc3RhdGljIGZyb20obWVtYmVycykge1xuICAgICAgICBzd2l0Y2ggKG1lbWJlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiBlbXB0eTtcbiAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIG1lbWJlcnNbMF07XG4gICAgICAgICAgICBkZWZhdWx0OiByZXR1cm4gbmV3IERlY29yYXRpb25Hcm91cChtZW1iZXJzLmV2ZXJ5KG0gPT4gbSBpbnN0YW5jZW9mIERlY29yYXRpb25TZXQpID8gbWVtYmVycyA6XG4gICAgICAgICAgICAgICAgbWVtYmVycy5yZWR1Y2UoKHIsIG0pID0+IHIuY29uY2F0KG0gaW5zdGFuY2VvZiBEZWNvcmF0aW9uU2V0ID8gbSA6IG0ubWVtYmVycyksIFtdKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yRWFjaFNldChmKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tZW1iZXJzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgdGhpcy5tZW1iZXJzW2ldLmZvckVhY2hTZXQoZik7XG4gICAgfVxufVxuZnVuY3Rpb24gbWFwQ2hpbGRyZW4ob2xkQ2hpbGRyZW4sIG5ld0xvY2FsLCBtYXBwaW5nLCBub2RlLCBvZmZzZXQsIG9sZE9mZnNldCwgb3B0aW9ucykge1xuICAgIGxldCBjaGlsZHJlbiA9IG9sZENoaWxkcmVuLnNsaWNlKCk7XG4gICAgLy8gTWFyayB0aGUgY2hpbGRyZW4gdGhhdCBhcmUgZGlyZWN0bHkgdG91Y2hlZCBieSBjaGFuZ2VzLCBhbmRcbiAgICAvLyBtb3ZlIHRob3NlIHRoYXQgYXJlIGFmdGVyIHRoZSBjaGFuZ2VzLlxuICAgIGZvciAobGV0IGkgPSAwLCBiYXNlT2Zmc2V0ID0gb2xkT2Zmc2V0OyBpIDwgbWFwcGluZy5tYXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBtb3ZlZCA9IDA7XG4gICAgICAgIG1hcHBpbmcubWFwc1tpXS5mb3JFYWNoKChvbGRTdGFydCwgb2xkRW5kLCBuZXdTdGFydCwgbmV3RW5kKSA9PiB7XG4gICAgICAgICAgICBsZXQgZFNpemUgPSAobmV3RW5kIC0gbmV3U3RhcnQpIC0gKG9sZEVuZCAtIG9sZFN0YXJ0KTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgICAgICAgICBsZXQgZW5kID0gY2hpbGRyZW5baSArIDFdO1xuICAgICAgICAgICAgICAgIGlmIChlbmQgPCAwIHx8IG9sZFN0YXJ0ID4gZW5kICsgYmFzZU9mZnNldCAtIG1vdmVkKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnQgPSBjaGlsZHJlbltpXSArIGJhc2VPZmZzZXQgLSBtb3ZlZDtcbiAgICAgICAgICAgICAgICBpZiAob2xkRW5kID49IHN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuW2kgKyAxXSA9IG9sZFN0YXJ0IDw9IHN0YXJ0ID8gLTIgOiAtMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob2xkU3RhcnQgPj0gYmFzZU9mZnNldCAmJiBkU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbltpXSArPSBkU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5baSArIDFdICs9IGRTaXplO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1vdmVkICs9IGRTaXplO1xuICAgICAgICB9KTtcbiAgICAgICAgYmFzZU9mZnNldCA9IG1hcHBpbmcubWFwc1tpXS5tYXAoYmFzZU9mZnNldCwgLTEpO1xuICAgIH1cbiAgICAvLyBGaW5kIHRoZSBjaGlsZCBub2RlcyB0aGF0IHN0aWxsIGNvcnJlc3BvbmQgdG8gYSBzaW5nbGUgbm9kZSxcbiAgICAvLyByZWN1cnNpdmVseSBjYWxsIG1hcElubmVyIG9uIHRoZW0gYW5kIHVwZGF0ZSB0aGVpciBwb3NpdGlvbnMuXG4gICAgbGV0IG11c3RSZWJ1aWxkID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkgKz0gMylcbiAgICAgICAgaWYgKGNoaWxkcmVuW2kgKyAxXSA8IDApIHsgLy8gVG91Y2hlZCBub2Rlc1xuICAgICAgICAgICAgaWYgKGNoaWxkcmVuW2kgKyAxXSA9PSAtMikge1xuICAgICAgICAgICAgICAgIG11c3RSZWJ1aWxkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbltpICsgMV0gPSAtMTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBmcm9tID0gbWFwcGluZy5tYXAob2xkQ2hpbGRyZW5baV0gKyBvbGRPZmZzZXQpLCBmcm9tTG9jYWwgPSBmcm9tIC0gb2Zmc2V0O1xuICAgICAgICAgICAgaWYgKGZyb21Mb2NhbCA8IDAgfHwgZnJvbUxvY2FsID49IG5vZGUuY29udGVudC5zaXplKSB7XG4gICAgICAgICAgICAgICAgbXVzdFJlYnVpbGQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTXVzdCByZWFkIG9sZENoaWxkcmVuIGJlY2F1c2UgY2hpbGRyZW4gd2FzIHRhZ2dlZCB3aXRoIC0xXG4gICAgICAgICAgICBsZXQgdG8gPSBtYXBwaW5nLm1hcChvbGRDaGlsZHJlbltpICsgMV0gKyBvbGRPZmZzZXQsIC0xKSwgdG9Mb2NhbCA9IHRvIC0gb2Zmc2V0O1xuICAgICAgICAgICAgbGV0IHsgaW5kZXgsIG9mZnNldDogY2hpbGRPZmZzZXQgfSA9IG5vZGUuY29udGVudC5maW5kSW5kZXgoZnJvbUxvY2FsKTtcbiAgICAgICAgICAgIGxldCBjaGlsZE5vZGUgPSBub2RlLm1heWJlQ2hpbGQoaW5kZXgpO1xuICAgICAgICAgICAgaWYgKGNoaWxkTm9kZSAmJiBjaGlsZE9mZnNldCA9PSBmcm9tTG9jYWwgJiYgY2hpbGRPZmZzZXQgKyBjaGlsZE5vZGUubm9kZVNpemUgPT0gdG9Mb2NhbCkge1xuICAgICAgICAgICAgICAgIGxldCBtYXBwZWQgPSBjaGlsZHJlbltpICsgMl1cbiAgICAgICAgICAgICAgICAgICAgLm1hcElubmVyKG1hcHBpbmcsIGNoaWxkTm9kZSwgZnJvbSArIDEsIG9sZENoaWxkcmVuW2ldICsgb2xkT2Zmc2V0ICsgMSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgaWYgKG1hcHBlZCAhPSBlbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbltpXSA9IGZyb21Mb2NhbDtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5baSArIDFdID0gdG9Mb2NhbDtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5baSArIDJdID0gbWFwcGVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5baSArIDFdID0gLTI7XG4gICAgICAgICAgICAgICAgICAgIG11c3RSZWJ1aWxkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtdXN0UmVidWlsZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAvLyBSZW1haW5pbmcgY2hpbGRyZW4gbXVzdCBiZSBjb2xsZWN0ZWQgYW5kIHJlYnVpbHQgaW50byB0aGUgYXBwcm9wcmlhdGUgc3RydWN0dXJlXG4gICAgaWYgKG11c3RSZWJ1aWxkKSB7XG4gICAgICAgIGxldCBkZWNvcmF0aW9ucyA9IG1hcEFuZEdhdGhlclJlbWFpbmluZ0RlY29yYXRpb25zKGNoaWxkcmVuLCBvbGRDaGlsZHJlbiwgbmV3TG9jYWwsIG1hcHBpbmcsIG9mZnNldCwgb2xkT2Zmc2V0LCBvcHRpb25zKTtcbiAgICAgICAgbGV0IGJ1aWx0ID0gYnVpbGRUcmVlKGRlY29yYXRpb25zLCBub2RlLCAwLCBvcHRpb25zKTtcbiAgICAgICAgbmV3TG9jYWwgPSBidWlsdC5sb2NhbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkgKz0gMylcbiAgICAgICAgICAgIGlmIChjaGlsZHJlbltpICsgMV0gPCAwKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4uc3BsaWNlKGksIDMpO1xuICAgICAgICAgICAgICAgIGkgLT0gMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGogPSAwOyBpIDwgYnVpbHQuY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgICAgIGxldCBmcm9tID0gYnVpbHQuY2hpbGRyZW5baV07XG4gICAgICAgICAgICB3aGlsZSAoaiA8IGNoaWxkcmVuLmxlbmd0aCAmJiBjaGlsZHJlbltqXSA8IGZyb20pXG4gICAgICAgICAgICAgICAgaiArPSAzO1xuICAgICAgICAgICAgY2hpbGRyZW4uc3BsaWNlKGosIDAsIGJ1aWx0LmNoaWxkcmVuW2ldLCBidWlsdC5jaGlsZHJlbltpICsgMV0sIGJ1aWx0LmNoaWxkcmVuW2kgKyAyXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBEZWNvcmF0aW9uU2V0KG5ld0xvY2FsLnNvcnQoYnlQb3MpLCBjaGlsZHJlbik7XG59XG5mdW5jdGlvbiBtb3ZlU3BhbnMoc3BhbnMsIG9mZnNldCkge1xuICAgIGlmICghb2Zmc2V0IHx8ICFzcGFucy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBzcGFucztcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcGFucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgc3BhbiA9IHNwYW5zW2ldO1xuICAgICAgICByZXN1bHQucHVzaChuZXcgRGVjb3JhdGlvbihzcGFuLmZyb20gKyBvZmZzZXQsIHNwYW4udG8gKyBvZmZzZXQsIHNwYW4udHlwZSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbWFwQW5kR2F0aGVyUmVtYWluaW5nRGVjb3JhdGlvbnMoY2hpbGRyZW4sIG9sZENoaWxkcmVuLCBkZWNvcmF0aW9ucywgbWFwcGluZywgb2Zmc2V0LCBvbGRPZmZzZXQsIG9wdGlvbnMpIHtcbiAgICAvLyBHYXRoZXIgYWxsIGRlY29yYXRpb25zIGZyb20gdGhlIHJlbWFpbmluZyBtYXJrZWQgY2hpbGRyZW5cbiAgICBmdW5jdGlvbiBnYXRoZXIoc2V0LCBvbGRPZmZzZXQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXQubG9jYWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBtYXBwZWQgPSBzZXQubG9jYWxbaV0ubWFwKG1hcHBpbmcsIG9mZnNldCwgb2xkT2Zmc2V0KTtcbiAgICAgICAgICAgIGlmIChtYXBwZWQpXG4gICAgICAgICAgICAgICAgZGVjb3JhdGlvbnMucHVzaChtYXBwZWQpO1xuICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5vblJlbW92ZSlcbiAgICAgICAgICAgICAgICBvcHRpb25zLm9uUmVtb3ZlKHNldC5sb2NhbFtpXS5zcGVjKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldC5jaGlsZHJlbi5sZW5ndGg7IGkgKz0gMylcbiAgICAgICAgICAgIGdhdGhlcihzZXQuY2hpbGRyZW5baSArIDJdLCBzZXQuY2hpbGRyZW5baV0gKyBvbGRPZmZzZXQgKyAxKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkgKz0gMylcbiAgICAgICAgaWYgKGNoaWxkcmVuW2kgKyAxXSA9PSAtMSlcbiAgICAgICAgICAgIGdhdGhlcihjaGlsZHJlbltpICsgMl0sIG9sZENoaWxkcmVuW2ldICsgb2xkT2Zmc2V0ICsgMSk7XG4gICAgcmV0dXJuIGRlY29yYXRpb25zO1xufVxuZnVuY3Rpb24gdGFrZVNwYW5zRm9yTm9kZShzcGFucywgbm9kZSwgb2Zmc2V0KSB7XG4gICAgaWYgKG5vZGUuaXNMZWFmKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgZW5kID0gb2Zmc2V0ICsgbm9kZS5ub2RlU2l6ZSwgZm91bmQgPSBudWxsO1xuICAgIGZvciAobGV0IGkgPSAwLCBzcGFuOyBpIDwgc3BhbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKChzcGFuID0gc3BhbnNbaV0pICYmIHNwYW4uZnJvbSA+IG9mZnNldCAmJiBzcGFuLnRvIDwgZW5kKSB7XG4gICAgICAgICAgICAoZm91bmQgfHwgKGZvdW5kID0gW10pKS5wdXNoKHNwYW4pO1xuICAgICAgICAgICAgc3BhbnNbaV0gPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmb3VuZDtcbn1cbmZ1bmN0aW9uIHdpdGhvdXROdWxscyhhcnJheSkge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAoYXJyYXlbaV0gIT0gbnVsbClcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFycmF5W2ldKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8gQnVpbGQgdXAgYSB0cmVlIHRoYXQgY29ycmVzcG9uZHMgdG8gYSBzZXQgb2YgZGVjb3JhdGlvbnMuIGBvZmZzZXRgXG4vLyBpcyBhIGJhc2Ugb2Zmc2V0IHRoYXQgc2hvdWxkIGJlIHN1YnRyYWN0ZWQgZnJvbSB0aGUgYGZyb21gIGFuZCBgdG9gXG4vLyBwb3NpdGlvbnMgaW4gdGhlIHNwYW5zIChzbyB0aGF0IHdlIGRvbid0IGhhdmUgdG8gYWxsb2NhdGUgbmV3IHNwYW5zXG4vLyBmb3IgcmVjdXJzaXZlIGNhbGxzKS5cbmZ1bmN0aW9uIGJ1aWxkVHJlZShzcGFucywgbm9kZSwgb2Zmc2V0LCBvcHRpb25zKSB7XG4gICAgbGV0IGNoaWxkcmVuID0gW10sIGhhc051bGxzID0gZmFsc2U7XG4gICAgbm9kZS5mb3JFYWNoKChjaGlsZE5vZGUsIGxvY2FsU3RhcnQpID0+IHtcbiAgICAgICAgbGV0IGZvdW5kID0gdGFrZVNwYW5zRm9yTm9kZShzcGFucywgY2hpbGROb2RlLCBsb2NhbFN0YXJ0ICsgb2Zmc2V0KTtcbiAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgICBoYXNOdWxscyA9IHRydWU7XG4gICAgICAgICAgICBsZXQgc3VidHJlZSA9IGJ1aWxkVHJlZShmb3VuZCwgY2hpbGROb2RlLCBvZmZzZXQgKyBsb2NhbFN0YXJ0ICsgMSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAoc3VidHJlZSAhPSBlbXB0eSlcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGxvY2FsU3RhcnQsIGxvY2FsU3RhcnQgKyBjaGlsZE5vZGUubm9kZVNpemUsIHN1YnRyZWUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgbGV0IGxvY2FscyA9IG1vdmVTcGFucyhoYXNOdWxscyA/IHdpdGhvdXROdWxscyhzcGFucykgOiBzcGFucywgLW9mZnNldCkuc29ydChieVBvcyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb2NhbHMubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmICghbG9jYWxzW2ldLnR5cGUudmFsaWQobm9kZSwgbG9jYWxzW2ldKSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMub25SZW1vdmUpXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5vblJlbW92ZShsb2NhbHNbaV0uc3BlYyk7XG4gICAgICAgICAgICBsb2NhbHMuc3BsaWNlKGktLSwgMSk7XG4gICAgICAgIH1cbiAgICByZXR1cm4gbG9jYWxzLmxlbmd0aCB8fCBjaGlsZHJlbi5sZW5ndGggPyBuZXcgRGVjb3JhdGlvblNldChsb2NhbHMsIGNoaWxkcmVuKSA6IGVtcHR5O1xufVxuLy8gVXNlZCB0byBzb3J0IGRlY29yYXRpb25zIHNvIHRoYXQgb25lcyB3aXRoIGEgbG93IHN0YXJ0IHBvc2l0aW9uXG4vLyBjb21lIGZpcnN0LCBhbmQgd2l0aGluIGEgc2V0IHdpdGggdGhlIHNhbWUgc3RhcnQgcG9zaXRpb24sIHRob3NlXG4vLyB3aXRoIGFuIHNtYWxsZXIgZW5kIHBvc2l0aW9uIGNvbWUgZmlyc3QuXG5mdW5jdGlvbiBieVBvcyhhLCBiKSB7XG4gICAgcmV0dXJuIGEuZnJvbSAtIGIuZnJvbSB8fCBhLnRvIC0gYi50bztcbn1cbi8vIFNjYW4gYSBzb3J0ZWQgYXJyYXkgb2YgZGVjb3JhdGlvbnMgZm9yIHBhcnRpYWxseSBvdmVybGFwcGluZyBzcGFucyxcbi8vIGFuZCBzcGxpdCB0aG9zZSBzbyB0aGF0IG9ubHkgZnVsbHkgb3ZlcmxhcHBpbmcgc3BhbnMgYXJlIGxlZnQgKHRvXG4vLyBtYWtlIHN1YnNlcXVlbnQgcmVuZGVyaW5nIGVhc2llcikuIFdpbGwgcmV0dXJuIHRoZSBpbnB1dCBhcnJheSBpZlxuLy8gbm8gcGFydGlhbGx5IG92ZXJsYXBwaW5nIHNwYW5zIGFyZSBmb3VuZCAodGhlIGNvbW1vbiBjYXNlKS5cbmZ1bmN0aW9uIHJlbW92ZU92ZXJsYXAoc3BhbnMpIHtcbiAgICBsZXQgd29ya2luZyA9IHNwYW5zO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd29ya2luZy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgbGV0IHNwYW4gPSB3b3JraW5nW2ldO1xuICAgICAgICBpZiAoc3Bhbi5mcm9tICE9IHNwYW4udG8pXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCB3b3JraW5nLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSB3b3JraW5nW2pdO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0LmZyb20gPT0gc3Bhbi5mcm9tKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0LnRvICE9IHNwYW4udG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3b3JraW5nID09IHNwYW5zKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtpbmcgPSBzcGFucy5zbGljZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRm9sbG93ZWQgYnkgYSBwYXJ0aWFsbHkgb3ZlcmxhcHBpbmcgbGFyZ2VyIHNwYW4uIFNwbGl0IHRoYXRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNwYW4uXG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JraW5nW2pdID0gbmV4dC5jb3B5KG5leHQuZnJvbSwgc3Bhbi50byk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRBaGVhZCh3b3JraW5nLCBqICsgMSwgbmV4dC5jb3B5KHNwYW4udG8sIG5leHQudG8pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0LmZyb20gPCBzcGFuLnRvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAod29ya2luZyA9PSBzcGFucylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3b3JraW5nID0gc3BhbnMuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBlbmQgb2YgdGhpcyBvbmUgb3ZlcmxhcHMgd2l0aCBhIHN1YnNlcXVlbnQgc3Bhbi4gU3BsaXRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgb25lLlxuICAgICAgICAgICAgICAgICAgICAgICAgd29ya2luZ1tpXSA9IHNwYW4uY29weShzcGFuLmZyb20sIG5leHQuZnJvbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRBaGVhZCh3b3JraW5nLCBqLCBzcGFuLmNvcHkobmV4dC5mcm9tLCBzcGFuLnRvKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gd29ya2luZztcbn1cbmZ1bmN0aW9uIGluc2VydEFoZWFkKGFycmF5LCBpLCBkZWNvKSB7XG4gICAgd2hpbGUgKGkgPCBhcnJheS5sZW5ndGggJiYgYnlQb3MoZGVjbywgYXJyYXlbaV0pID4gMClcbiAgICAgICAgaSsrO1xuICAgIGFycmF5LnNwbGljZShpLCAwLCBkZWNvKTtcbn1cbi8vIEdldCB0aGUgZGVjb3JhdGlvbnMgYXNzb2NpYXRlZCB3aXRoIHRoZSBjdXJyZW50IHByb3BzIG9mIGEgdmlldy5cbmZ1bmN0aW9uIHZpZXdEZWNvcmF0aW9ucyh2aWV3KSB7XG4gICAgbGV0IGZvdW5kID0gW107XG4gICAgdmlldy5zb21lUHJvcChcImRlY29yYXRpb25zXCIsIGYgPT4ge1xuICAgICAgICBsZXQgcmVzdWx0ID0gZih2aWV3LnN0YXRlKTtcbiAgICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQgIT0gZW1wdHkpXG4gICAgICAgICAgICBmb3VuZC5wdXNoKHJlc3VsdCk7XG4gICAgfSk7XG4gICAgaWYgKHZpZXcuY3Vyc29yV3JhcHBlcilcbiAgICAgICAgZm91bmQucHVzaChEZWNvcmF0aW9uU2V0LmNyZWF0ZSh2aWV3LnN0YXRlLmRvYywgW3ZpZXcuY3Vyc29yV3JhcHBlci5kZWNvXSkpO1xuICAgIHJldHVybiBEZWNvcmF0aW9uR3JvdXAuZnJvbShmb3VuZCk7XG59XG5cbmNvbnN0IG9ic2VydmVPcHRpb25zID0ge1xuICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlLFxuICAgIGNoYXJhY3RlckRhdGFPbGRWYWx1ZTogdHJ1ZSxcbiAgICBhdHRyaWJ1dGVzOiB0cnVlLFxuICAgIGF0dHJpYnV0ZU9sZFZhbHVlOiB0cnVlLFxuICAgIHN1YnRyZWU6IHRydWVcbn07XG4vLyBJRTExIGhhcyB2ZXJ5IGJyb2tlbiBtdXRhdGlvbiBvYnNlcnZlcnMsIHNvIHdlIGFsc28gbGlzdGVuIHRvIERPTUNoYXJhY3RlckRhdGFNb2RpZmllZFxuY29uc3QgdXNlQ2hhckRhdGEgPSBpZSAmJiBpZV92ZXJzaW9uIDw9IDExO1xuY2xhc3MgU2VsZWN0aW9uU3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmFuY2hvck5vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLmFuY2hvck9mZnNldCA9IDA7XG4gICAgICAgIHRoaXMuZm9jdXNOb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5mb2N1c09mZnNldCA9IDA7XG4gICAgfVxuICAgIHNldChzZWwpIHtcbiAgICAgICAgdGhpcy5hbmNob3JOb2RlID0gc2VsLmFuY2hvck5vZGU7XG4gICAgICAgIHRoaXMuYW5jaG9yT2Zmc2V0ID0gc2VsLmFuY2hvck9mZnNldDtcbiAgICAgICAgdGhpcy5mb2N1c05vZGUgPSBzZWwuZm9jdXNOb2RlO1xuICAgICAgICB0aGlzLmZvY3VzT2Zmc2V0ID0gc2VsLmZvY3VzT2Zmc2V0O1xuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5hbmNob3JOb2RlID0gdGhpcy5mb2N1c05vZGUgPSBudWxsO1xuICAgIH1cbiAgICBlcShzZWwpIHtcbiAgICAgICAgcmV0dXJuIHNlbC5hbmNob3JOb2RlID09IHRoaXMuYW5jaG9yTm9kZSAmJiBzZWwuYW5jaG9yT2Zmc2V0ID09IHRoaXMuYW5jaG9yT2Zmc2V0ICYmXG4gICAgICAgICAgICBzZWwuZm9jdXNOb2RlID09IHRoaXMuZm9jdXNOb2RlICYmIHNlbC5mb2N1c09mZnNldCA9PSB0aGlzLmZvY3VzT2Zmc2V0O1xuICAgIH1cbn1cbmNsYXNzIERPTU9ic2VydmVyIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCBoYW5kbGVET01DaGFuZ2UpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5oYW5kbGVET01DaGFuZ2UgPSBoYW5kbGVET01DaGFuZ2U7XG4gICAgICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICAgICAgdGhpcy5mbHVzaGluZ1Nvb24gPSAtMTtcbiAgICAgICAgdGhpcy5vYnNlcnZlciA9IG51bGw7XG4gICAgICAgIHRoaXMuY3VycmVudFNlbGVjdGlvbiA9IG5ldyBTZWxlY3Rpb25TdGF0ZTtcbiAgICAgICAgdGhpcy5vbkNoYXJEYXRhID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdXBwcmVzc2luZ1NlbGVjdGlvblVwZGF0ZXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sYXN0Q2hhbmdlZFRleHROb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5vYnNlcnZlciA9IHdpbmRvdy5NdXRhdGlvbk9ic2VydmVyICYmXG4gICAgICAgICAgICBuZXcgd2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIobXV0YXRpb25zID0+IHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG11dGF0aW9ucy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKG11dGF0aW9uc1tpXSk7XG4gICAgICAgICAgICAgICAgLy8gSUUxMSB3aWxsIHNvbWV0aW1lcyAob24gYmFja3NwYWNpbmcgb3V0IGEgc2luZ2xlIGNoYXJhY3RlclxuICAgICAgICAgICAgICAgIC8vIHRleHQgbm9kZSBhZnRlciBhIEJSIG5vZGUpIGNhbGwgdGhlIG9ic2VydmVyIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgLy8gYmVmb3JlIGFjdHVhbGx5IHVwZGF0aW5nIHRoZSBET00sIHdoaWNoIHdpbGwgY2F1c2VcbiAgICAgICAgICAgICAgICAvLyBQcm9zZU1pcnJvciB0byBtaXNzIHRoZSBjaGFuZ2UgKHNlZSAjOTMwKVxuICAgICAgICAgICAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDw9IDExICYmIG11dGF0aW9ucy5zb21lKG0gPT4gbS50eXBlID09IFwiY2hpbGRMaXN0XCIgJiYgbS5yZW1vdmVkTm9kZXMubGVuZ3RoIHx8XG4gICAgICAgICAgICAgICAgICAgIG0udHlwZSA9PSBcImNoYXJhY3RlckRhdGFcIiAmJiBtLm9sZFZhbHVlLmxlbmd0aCA+IG0udGFyZ2V0Lm5vZGVWYWx1ZS5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZsdXNoU29vbigpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIGlmICh1c2VDaGFyRGF0YSkge1xuICAgICAgICAgICAgdGhpcy5vbkNoYXJEYXRhID0gZSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKHsgdGFyZ2V0OiBlLnRhcmdldCwgdHlwZTogXCJjaGFyYWN0ZXJEYXRhXCIsIG9sZFZhbHVlOiBlLnByZXZWYWx1ZSB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmZsdXNoU29vbigpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlID0gdGhpcy5vblNlbGVjdGlvbkNoYW5nZS5iaW5kKHRoaXMpO1xuICAgIH1cbiAgICBmbHVzaFNvb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmZsdXNoaW5nU29vbiA8IDApXG4gICAgICAgICAgICB0aGlzLmZsdXNoaW5nU29vbiA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHsgdGhpcy5mbHVzaGluZ1Nvb24gPSAtMTsgdGhpcy5mbHVzaCgpOyB9LCAyMCk7XG4gICAgfVxuICAgIGZvcmNlRmx1c2goKSB7XG4gICAgICAgIGlmICh0aGlzLmZsdXNoaW5nU29vbiA+IC0xKSB7XG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuZmx1c2hpbmdTb29uKTtcbiAgICAgICAgICAgIHRoaXMuZmx1c2hpbmdTb29uID0gLTE7XG4gICAgICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLm9ic2VydmVyKSB7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyLnRha2VSZWNvcmRzKCk7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyLm9ic2VydmUodGhpcy52aWV3LmRvbSwgb2JzZXJ2ZU9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9uQ2hhckRhdGEpXG4gICAgICAgICAgICB0aGlzLnZpZXcuZG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJET01DaGFyYWN0ZXJEYXRhTW9kaWZpZWRcIiwgdGhpcy5vbkNoYXJEYXRhKTtcbiAgICAgICAgdGhpcy5jb25uZWN0U2VsZWN0aW9uKCk7XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIGlmICh0aGlzLm9ic2VydmVyKSB7XG4gICAgICAgICAgICBsZXQgdGFrZSA9IHRoaXMub2JzZXJ2ZXIudGFrZVJlY29yZHMoKTtcbiAgICAgICAgICAgIGlmICh0YWtlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFrZS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKHRha2VbaV0pO1xuICAgICAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHRoaXMuZmx1c2goKSwgMjApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub25DaGFyRGF0YSlcbiAgICAgICAgICAgIHRoaXMudmlldy5kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIkRPTUNoYXJhY3RlckRhdGFNb2RpZmllZFwiLCB0aGlzLm9uQ2hhckRhdGEpO1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3RTZWxlY3Rpb24oKTtcbiAgICB9XG4gICAgY29ubmVjdFNlbGVjdGlvbigpIHtcbiAgICAgICAgdGhpcy52aWV3LmRvbS5vd25lckRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJzZWxlY3Rpb25jaGFuZ2VcIiwgdGhpcy5vblNlbGVjdGlvbkNoYW5nZSk7XG4gICAgfVxuICAgIGRpc2Nvbm5lY3RTZWxlY3Rpb24oKSB7XG4gICAgICAgIHRoaXMudmlldy5kb20ub3duZXJEb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwic2VsZWN0aW9uY2hhbmdlXCIsIHRoaXMub25TZWxlY3Rpb25DaGFuZ2UpO1xuICAgIH1cbiAgICBzdXBwcmVzc1NlbGVjdGlvblVwZGF0ZXMoKSB7XG4gICAgICAgIHRoaXMuc3VwcHJlc3NpbmdTZWxlY3Rpb25VcGRhdGVzID0gdHJ1ZTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnN1cHByZXNzaW5nU2VsZWN0aW9uVXBkYXRlcyA9IGZhbHNlLCA1MCk7XG4gICAgfVxuICAgIG9uU2VsZWN0aW9uQ2hhbmdlKCkge1xuICAgICAgICBpZiAoIWhhc0ZvY3VzQW5kU2VsZWN0aW9uKHRoaXMudmlldykpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLnN1cHByZXNzaW5nU2VsZWN0aW9uVXBkYXRlcylcbiAgICAgICAgICAgIHJldHVybiBzZWxlY3Rpb25Ub0RPTSh0aGlzLnZpZXcpO1xuICAgICAgICAvLyBEZWxldGlvbnMgb24gSUUxMSBmaXJlIHRoZWlyIGV2ZW50cyBpbiB0aGUgd3Jvbmcgb3JkZXIsIGdpdmluZ1xuICAgICAgICAvLyB1cyBhIHNlbGVjdGlvbiBjaGFuZ2UgZXZlbnQgYmVmb3JlIHRoZSBET00gY2hhbmdlcyBhcmVcbiAgICAgICAgLy8gcmVwb3J0ZWQuXG4gICAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDw9IDExICYmICF0aGlzLnZpZXcuc3RhdGUuc2VsZWN0aW9uLmVtcHR5KSB7XG4gICAgICAgICAgICBsZXQgc2VsID0gdGhpcy52aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgICAgICAvLyBTZWxlY3Rpb24uaXNDb2xsYXBzZWQgaXNuJ3QgcmVsaWFibGUgb24gSUVcbiAgICAgICAgICAgIGlmIChzZWwuZm9jdXNOb2RlICYmIGlzRXF1aXZhbGVudFBvc2l0aW9uKHNlbC5mb2N1c05vZGUsIHNlbC5mb2N1c09mZnNldCwgc2VsLmFuY2hvck5vZGUsIHNlbC5hbmNob3JPZmZzZXQpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZsdXNoU29vbigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICB9XG4gICAgc2V0Q3VyU2VsZWN0aW9uKCkge1xuICAgICAgICB0aGlzLmN1cnJlbnRTZWxlY3Rpb24uc2V0KHRoaXMudmlldy5kb21TZWxlY3Rpb25SYW5nZSgpKTtcbiAgICB9XG4gICAgaWdub3JlU2VsZWN0aW9uQ2hhbmdlKHNlbCkge1xuICAgICAgICBpZiAoIXNlbC5mb2N1c05vZGUpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgbGV0IGFuY2VzdG9ycyA9IG5ldyBTZXQsIGNvbnRhaW5lcjtcbiAgICAgICAgZm9yIChsZXQgc2NhbiA9IHNlbC5mb2N1c05vZGU7IHNjYW47IHNjYW4gPSBwYXJlbnROb2RlKHNjYW4pKVxuICAgICAgICAgICAgYW5jZXN0b3JzLmFkZChzY2FuKTtcbiAgICAgICAgZm9yIChsZXQgc2NhbiA9IHNlbC5hbmNob3JOb2RlOyBzY2FuOyBzY2FuID0gcGFyZW50Tm9kZShzY2FuKSlcbiAgICAgICAgICAgIGlmIChhbmNlc3RvcnMuaGFzKHNjYW4pKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyID0gc2NhbjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgbGV0IGRlc2MgPSBjb250YWluZXIgJiYgdGhpcy52aWV3LmRvY1ZpZXcubmVhcmVzdERlc2MoY29udGFpbmVyKTtcbiAgICAgICAgaWYgKGRlc2MgJiYgZGVzYy5pZ25vcmVNdXRhdGlvbih7XG4gICAgICAgICAgICB0eXBlOiBcInNlbGVjdGlvblwiLFxuICAgICAgICAgICAgdGFyZ2V0OiBjb250YWluZXIubm9kZVR5cGUgPT0gMyA/IGNvbnRhaW5lci5wYXJlbnROb2RlIDogY29udGFpbmVyXG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgICB0aGlzLnNldEN1clNlbGVjdGlvbigpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGVuZGluZ1JlY29yZHMoKSB7XG4gICAgICAgIGlmICh0aGlzLm9ic2VydmVyKVxuICAgICAgICAgICAgZm9yIChsZXQgbXV0IG9mIHRoaXMub2JzZXJ2ZXIudGFrZVJlY29yZHMoKSlcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLnB1c2gobXV0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVldWU7XG4gICAgfVxuICAgIGZsdXNoKCkge1xuICAgICAgICBsZXQgeyB2aWV3IH0gPSB0aGlzO1xuICAgICAgICBpZiAoIXZpZXcuZG9jVmlldyB8fCB0aGlzLmZsdXNoaW5nU29vbiA+IC0xKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgbXV0YXRpb25zID0gdGhpcy5wZW5kaW5nUmVjb3JkcygpO1xuICAgICAgICBpZiAobXV0YXRpb25zLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICAgICAgbGV0IHNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICAgICAgbGV0IG5ld1NlbCA9ICF0aGlzLnN1cHByZXNzaW5nU2VsZWN0aW9uVXBkYXRlcyAmJiAhdGhpcy5jdXJyZW50U2VsZWN0aW9uLmVxKHNlbCkgJiYgaGFzRm9jdXNBbmRTZWxlY3Rpb24odmlldykgJiYgIXRoaXMuaWdub3JlU2VsZWN0aW9uQ2hhbmdlKHNlbCk7XG4gICAgICAgIGxldCBmcm9tID0gLTEsIHRvID0gLTEsIHR5cGVPdmVyID0gZmFsc2UsIGFkZGVkID0gW107XG4gICAgICAgIGlmICh2aWV3LmVkaXRhYmxlKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG11dGF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSB0aGlzLnJlZ2lzdGVyTXV0YXRpb24obXV0YXRpb25zW2ldLCBhZGRlZCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBmcm9tID0gZnJvbSA8IDAgPyByZXN1bHQuZnJvbSA6IE1hdGgubWluKHJlc3VsdC5mcm9tLCBmcm9tKTtcbiAgICAgICAgICAgICAgICAgICAgdG8gPSB0byA8IDAgPyByZXN1bHQudG8gOiBNYXRoLm1heChyZXN1bHQudG8sIHRvKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC50eXBlT3ZlcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVPdmVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdlY2tvICYmIGFkZGVkLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IGJycyA9IGFkZGVkLmZpbHRlcihuID0+IG4ubm9kZU5hbWUgPT0gXCJCUlwiKTtcbiAgICAgICAgICAgIGlmIChicnMubGVuZ3RoID09IDIpIHtcbiAgICAgICAgICAgICAgICBsZXQgW2EsIGJdID0gYnJzO1xuICAgICAgICAgICAgICAgIGlmIChhLnBhcmVudE5vZGUgJiYgYS5wYXJlbnROb2RlLnBhcmVudE5vZGUgPT0gYi5wYXJlbnROb2RlKVxuICAgICAgICAgICAgICAgICAgICBiLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgYS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCB7IGZvY3VzTm9kZSB9ID0gdGhpcy5jdXJyZW50U2VsZWN0aW9uO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGJyIG9mIGJycykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcGFyZW50ID0gYnIucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudCAmJiBwYXJlbnQubm9kZU5hbWUgPT0gXCJMSVwiICYmICghZm9jdXNOb2RlIHx8IGJsb2NrUGFyZW50KHZpZXcsIGZvY3VzTm9kZSkgIT0gcGFyZW50KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoY2hyb21lIHx8IHNhZmFyaSkgJiYgYWRkZWQuc29tZShuID0+IG4ubm9kZU5hbWUgPT0gXCJCUlwiKSAmJlxuICAgICAgICAgICAgKHZpZXcuaW5wdXQubGFzdEtleUNvZGUgPT0gOCB8fCB2aWV3LmlucHV0Lmxhc3RLZXlDb2RlID09IDQ2KSkge1xuICAgICAgICAgICAgLy8gQ2hyb21lL1NhZmFyaSBzb21ldGltZXMgaW5zZXJ0IGEgYm9ndXMgYnJlYWsgbm9kZSBpZiB5b3VcbiAgICAgICAgICAgIC8vIGJhY2tzcGFjZSBvdXQgdGhlIGxhc3QgYml0IG9mIHRleHQgYmVmb3JlIGFuIGlubGluZS1mbGV4IG5vZGUgKCMxNTUyKVxuICAgICAgICAgICAgZm9yIChsZXQgbm9kZSBvZiBhZGRlZClcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5ub2RlTmFtZSA9PSBcIkJSXCIgJiYgbm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBhZnRlciA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhZnRlciAmJiBhZnRlci5ub2RlVHlwZSA9PSAxICYmIGFmdGVyLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCByZWFkU2VsID0gbnVsbDtcbiAgICAgICAgLy8gSWYgaXQgbG9va3MgbGlrZSB0aGUgYnJvd3NlciBoYXMgcmVzZXQgdGhlIHNlbGVjdGlvbiB0byB0aGVcbiAgICAgICAgLy8gc3RhcnQgb2YgdGhlIGRvY3VtZW50IGFmdGVyIGZvY3VzLCByZXN0b3JlIHRoZSBzZWxlY3Rpb24gZnJvbVxuICAgICAgICAvLyB0aGUgc3RhdGVcbiAgICAgICAgaWYgKGZyb20gPCAwICYmIG5ld1NlbCAmJiB2aWV3LmlucHV0Lmxhc3RGb2N1cyA+IERhdGUubm93KCkgLSAyMDAgJiZcbiAgICAgICAgICAgIE1hdGgubWF4KHZpZXcuaW5wdXQubGFzdFRvdWNoLCB2aWV3LmlucHV0Lmxhc3RDbGljay50aW1lKSA8IERhdGUubm93KCkgLSAzMDAgJiZcbiAgICAgICAgICAgIHNlbGVjdGlvbkNvbGxhcHNlZChzZWwpICYmIChyZWFkU2VsID0gc2VsZWN0aW9uRnJvbURPTSh2aWV3KSkgJiZcbiAgICAgICAgICAgIHJlYWRTZWwuZXEoU2VsZWN0aW9uLm5lYXIodmlldy5zdGF0ZS5kb2MucmVzb2x2ZSgwKSwgMSkpKSB7XG4gICAgICAgICAgICB2aWV3LmlucHV0Lmxhc3RGb2N1cyA9IDA7XG4gICAgICAgICAgICBzZWxlY3Rpb25Ub0RPTSh2aWV3KTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNlbGVjdGlvbi5zZXQoc2VsKTtcbiAgICAgICAgICAgIHZpZXcuc2Nyb2xsVG9TZWxlY3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmcm9tID4gLTEgfHwgbmV3U2VsKSB7XG4gICAgICAgICAgICBpZiAoZnJvbSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgdmlldy5kb2NWaWV3Lm1hcmtEaXJ0eShmcm9tLCB0byk7XG4gICAgICAgICAgICAgICAgY2hlY2tDU1Modmlldyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhhbmRsZURPTUNoYW5nZShmcm9tLCB0bywgdHlwZU92ZXIsIGFkZGVkKTtcbiAgICAgICAgICAgIGlmICh2aWV3LmRvY1ZpZXcgJiYgdmlldy5kb2NWaWV3LmRpcnR5KVxuICAgICAgICAgICAgICAgIHZpZXcudXBkYXRlU3RhdGUodmlldy5zdGF0ZSk7XG4gICAgICAgICAgICBlbHNlIGlmICghdGhpcy5jdXJyZW50U2VsZWN0aW9uLmVxKHNlbCkpXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uVG9ET00odmlldyk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTZWxlY3Rpb24uc2V0KHNlbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVnaXN0ZXJNdXRhdGlvbihtdXQsIGFkZGVkKSB7XG4gICAgICAgIC8vIElnbm9yZSBtdXRhdGlvbnMgaW5zaWRlIG5vZGVzIHRoYXQgd2VyZSBhbHJlYWR5IG5vdGVkIGFzIGluc2VydGVkXG4gICAgICAgIGlmIChhZGRlZC5pbmRleE9mKG11dC50YXJnZXQpID4gLTEpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IGRlc2MgPSB0aGlzLnZpZXcuZG9jVmlldy5uZWFyZXN0RGVzYyhtdXQudGFyZ2V0KTtcbiAgICAgICAgaWYgKG11dC50eXBlID09IFwiYXR0cmlidXRlc1wiICYmXG4gICAgICAgICAgICAoZGVzYyA9PSB0aGlzLnZpZXcuZG9jVmlldyB8fCBtdXQuYXR0cmlidXRlTmFtZSA9PSBcImNvbnRlbnRlZGl0YWJsZVwiIHx8XG4gICAgICAgICAgICAgICAgLy8gRmlyZWZveCBzb21ldGltZXMgZmlyZXMgc3B1cmlvdXMgZXZlbnRzIGZvciBudWxsL2VtcHR5IHN0eWxlc1xuICAgICAgICAgICAgICAgIChtdXQuYXR0cmlidXRlTmFtZSA9PSBcInN0eWxlXCIgJiYgIW11dC5vbGRWYWx1ZSAmJiAhbXV0LnRhcmdldC5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKSkpKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmICghZGVzYyB8fCBkZXNjLmlnbm9yZU11dGF0aW9uKG11dCkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKG11dC50eXBlID09IFwiY2hpbGRMaXN0XCIpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXV0LmFkZGVkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IG11dC5hZGRlZE5vZGVzW2ldO1xuICAgICAgICAgICAgICAgIGFkZGVkLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0Q2hhbmdlZFRleHROb2RlID0gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZXNjLmNvbnRlbnRET00gJiYgZGVzYy5jb250ZW50RE9NICE9IGRlc2MuZG9tICYmICFkZXNjLmNvbnRlbnRET00uY29udGFpbnMobXV0LnRhcmdldCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZnJvbTogZGVzYy5wb3NCZWZvcmUsIHRvOiBkZXNjLnBvc0FmdGVyIH07XG4gICAgICAgICAgICBsZXQgcHJldiA9IG11dC5wcmV2aW91c1NpYmxpbmcsIG5leHQgPSBtdXQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8PSAxMSAmJiBtdXQuYWRkZWROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBJRTExIGdpdmVzIHVzIGluY29ycmVjdCBuZXh0L3ByZXYgc2libGluZ3MgZm9yIHNvbWVcbiAgICAgICAgICAgICAgICAvLyBpbnNlcnRpb25zLCBzbyBpZiB0aGVyZSBhcmUgYWRkZWQgbm9kZXMsIHJlY29tcHV0ZSB0aG9zZVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXV0LmFkZGVkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHsgcHJldmlvdXNTaWJsaW5nLCBuZXh0U2libGluZyB9ID0gbXV0LmFkZGVkTm9kZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghcHJldmlvdXNTaWJsaW5nIHx8IEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwobXV0LmFkZGVkTm9kZXMsIHByZXZpb3VzU2libGluZykgPCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldiA9IHByZXZpb3VzU2libGluZztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXh0U2libGluZyB8fCBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKG11dC5hZGRlZE5vZGVzLCBuZXh0U2libGluZykgPCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IG5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBmcm9tT2Zmc2V0ID0gcHJldiAmJiBwcmV2LnBhcmVudE5vZGUgPT0gbXV0LnRhcmdldFxuICAgICAgICAgICAgICAgID8gZG9tSW5kZXgocHJldikgKyAxIDogMDtcbiAgICAgICAgICAgIGxldCBmcm9tID0gZGVzYy5sb2NhbFBvc0Zyb21ET00obXV0LnRhcmdldCwgZnJvbU9mZnNldCwgLTEpO1xuICAgICAgICAgICAgbGV0IHRvT2Zmc2V0ID0gbmV4dCAmJiBuZXh0LnBhcmVudE5vZGUgPT0gbXV0LnRhcmdldFxuICAgICAgICAgICAgICAgID8gZG9tSW5kZXgobmV4dCkgOiBtdXQudGFyZ2V0LmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IHRvID0gZGVzYy5sb2NhbFBvc0Zyb21ET00obXV0LnRhcmdldCwgdG9PZmZzZXQsIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHsgZnJvbSwgdG8gfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtdXQudHlwZSA9PSBcImF0dHJpYnV0ZXNcIikge1xuICAgICAgICAgICAgcmV0dXJuIHsgZnJvbTogZGVzYy5wb3NBdFN0YXJ0IC0gZGVzYy5ib3JkZXIsIHRvOiBkZXNjLnBvc0F0RW5kICsgZGVzYy5ib3JkZXIgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gXCJjaGFyYWN0ZXJEYXRhXCJcbiAgICAgICAgICAgIHRoaXMubGFzdENoYW5nZWRUZXh0Tm9kZSA9IG11dC50YXJnZXQ7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGZyb206IGRlc2MucG9zQXRTdGFydCxcbiAgICAgICAgICAgICAgICB0bzogZGVzYy5wb3NBdEVuZCxcbiAgICAgICAgICAgICAgICAvLyBBbiBldmVudCB3YXMgZ2VuZXJhdGVkIGZvciBhIHRleHQgY2hhbmdlIHRoYXQgZGlkbid0IGNoYW5nZVxuICAgICAgICAgICAgICAgIC8vIGFueSB0ZXh0LiBNYXJrIHRoZSBkb20gY2hhbmdlIHRvIGZhbGwgYmFjayB0byBhc3N1bWluZyB0aGVcbiAgICAgICAgICAgICAgICAvLyBzZWxlY3Rpb24gd2FzIHR5cGVkIG92ZXIgd2l0aCBhbiBpZGVudGljYWwgdmFsdWUgaWYgaXQgY2FuJ3RcbiAgICAgICAgICAgICAgICAvLyBmaW5kIGFub3RoZXIgY2hhbmdlLlxuICAgICAgICAgICAgICAgIHR5cGVPdmVyOiBtdXQudGFyZ2V0Lm5vZGVWYWx1ZSA9PSBtdXQub2xkVmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG59XG5sZXQgY3NzQ2hlY2tlZCA9IG5ldyBXZWFrTWFwKCk7XG5sZXQgY3NzQ2hlY2tXYXJuZWQgPSBmYWxzZTtcbmZ1bmN0aW9uIGNoZWNrQ1NTKHZpZXcpIHtcbiAgICBpZiAoY3NzQ2hlY2tlZC5oYXModmlldykpXG4gICAgICAgIHJldHVybjtcbiAgICBjc3NDaGVja2VkLnNldCh2aWV3LCBudWxsKTtcbiAgICBpZiAoWydub3JtYWwnLCAnbm93cmFwJywgJ3ByZS1saW5lJ10uaW5kZXhPZihnZXRDb21wdXRlZFN0eWxlKHZpZXcuZG9tKS53aGl0ZVNwYWNlKSAhPT0gLTEpIHtcbiAgICAgICAgdmlldy5yZXF1aXJlc0dlY2tvSGFja05vZGUgPSBnZWNrbztcbiAgICAgICAgaWYgKGNzc0NoZWNrV2FybmVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zb2xlW1wid2FyblwiXShcIlByb3NlTWlycm9yIGV4cGVjdHMgdGhlIENTUyB3aGl0ZS1zcGFjZSBwcm9wZXJ0eSB0byBiZSBzZXQsIHByZWZlcmFibHkgdG8gJ3ByZS13cmFwJy4gSXQgaXMgcmVjb21tZW5kZWQgdG8gbG9hZCBzdHlsZS9wcm9zZW1pcnJvci5jc3MgZnJvbSB0aGUgcHJvc2VtaXJyb3ItdmlldyBwYWNrYWdlLlwiKTtcbiAgICAgICAgY3NzQ2hlY2tXYXJuZWQgPSB0cnVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJhbmdlVG9TZWxlY3Rpb25SYW5nZSh2aWV3LCByYW5nZSkge1xuICAgIGxldCBhbmNob3JOb2RlID0gcmFuZ2Uuc3RhcnRDb250YWluZXIsIGFuY2hvck9mZnNldCA9IHJhbmdlLnN0YXJ0T2Zmc2V0O1xuICAgIGxldCBmb2N1c05vZGUgPSByYW5nZS5lbmRDb250YWluZXIsIGZvY3VzT2Zmc2V0ID0gcmFuZ2UuZW5kT2Zmc2V0O1xuICAgIGxldCBjdXJyZW50QW5jaG9yID0gdmlldy5kb21BdFBvcyh2aWV3LnN0YXRlLnNlbGVjdGlvbi5hbmNob3IpO1xuICAgIC8vIFNpbmNlIHN1Y2ggYSByYW5nZSBkb2Vzbid0IGRpc3Rpbmd1aXNoIGJldHdlZW4gYW5jaG9yIGFuZCBoZWFkLFxuICAgIC8vIHVzZSBhIGhldXJpc3RpYyB0aGF0IGZsaXBzIGl0IGFyb3VuZCBpZiBpdHMgZW5kIG1hdGNoZXMgdGhlXG4gICAgLy8gY3VycmVudCBhbmNob3IuXG4gICAgaWYgKGlzRXF1aXZhbGVudFBvc2l0aW9uKGN1cnJlbnRBbmNob3Iubm9kZSwgY3VycmVudEFuY2hvci5vZmZzZXQsIGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQpKVxuICAgICAgICBbYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCBmb2N1c05vZGUsIGZvY3VzT2Zmc2V0XSA9IFtmb2N1c05vZGUsIGZvY3VzT2Zmc2V0LCBhbmNob3JOb2RlLCBhbmNob3JPZmZzZXRdO1xuICAgIHJldHVybiB7IGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldCB9O1xufVxuLy8gVXNlZCB0byB3b3JrIGFyb3VuZCBhIFNhZmFyaSBTZWxlY3Rpb24vc2hhZG93IERPTSBidWdcbi8vIEJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9jb2RlbWlycm9yL2Rldi9pc3N1ZXMvNDE0IGZpeFxuZnVuY3Rpb24gc2FmYXJpU2hhZG93U2VsZWN0aW9uUmFuZ2Uodmlldywgc2VsZWN0aW9uKSB7XG4gICAgaWYgKHNlbGVjdGlvbi5nZXRDb21wb3NlZFJhbmdlcykge1xuICAgICAgICBsZXQgcmFuZ2UgPSBzZWxlY3Rpb24uZ2V0Q29tcG9zZWRSYW5nZXModmlldy5yb290KVswXTtcbiAgICAgICAgaWYgKHJhbmdlKVxuICAgICAgICAgICAgcmV0dXJuIHJhbmdlVG9TZWxlY3Rpb25SYW5nZSh2aWV3LCByYW5nZSk7XG4gICAgfVxuICAgIGxldCBmb3VuZDtcbiAgICBmdW5jdGlvbiByZWFkKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICBmb3VuZCA9IGV2ZW50LmdldFRhcmdldFJhbmdlcygpWzBdO1xuICAgIH1cbiAgICAvLyBCZWNhdXNlIFNhZmFyaSAoYXQgbGVhc3QgaW4gMjAxOC0yMDIyKSBkb2Vzbid0IHByb3ZpZGUgcmVndWxhclxuICAgIC8vIGFjY2VzcyB0byB0aGUgc2VsZWN0aW9uIGluc2lkZSBhIHNoYWRvd1Jvb3QsIHdlIGhhdmUgdG8gcGVyZm9ybSBhXG4gICAgLy8gcmlkaWN1bG91cyBoYWNrIHRvIGdldCBhdCBpdOKAlHVzaW5nIGBleGVjQ29tbWFuZGAgdG8gdHJpZ2dlciBhXG4gICAgLy8gYGJlZm9yZUlucHV0YCBldmVudCBzbyB0aGF0IHdlIGNhbiByZWFkIHRoZSB0YXJnZXQgcmFuZ2UgZnJvbSB0aGVcbiAgICAvLyBldmVudC5cbiAgICB2aWV3LmRvbS5hZGRFdmVudExpc3RlbmVyKFwiYmVmb3JlaW5wdXRcIiwgcmVhZCwgdHJ1ZSk7XG4gICAgZG9jdW1lbnQuZXhlY0NvbW1hbmQoXCJpbmRlbnRcIik7XG4gICAgdmlldy5kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJlZm9yZWlucHV0XCIsIHJlYWQsIHRydWUpO1xuICAgIHJldHVybiBmb3VuZCA/IHJhbmdlVG9TZWxlY3Rpb25SYW5nZSh2aWV3LCBmb3VuZCkgOiBudWxsO1xufVxuZnVuY3Rpb24gYmxvY2tQYXJlbnQodmlldywgbm9kZSkge1xuICAgIGZvciAobGV0IHAgPSBub2RlLnBhcmVudE5vZGU7IHAgJiYgcCAhPSB2aWV3LmRvbTsgcCA9IHAucGFyZW50Tm9kZSkge1xuICAgICAgICBsZXQgZGVzYyA9IHZpZXcuZG9jVmlldy5uZWFyZXN0RGVzYyhwLCB0cnVlKTtcbiAgICAgICAgaWYgKGRlc2MgJiYgZGVzYy5ub2RlLmlzQmxvY2spXG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbi8vIE5vdGUgdGhhdCBhbGwgcmVmZXJlbmNpbmcgYW5kIHBhcnNpbmcgaXMgZG9uZSB3aXRoIHRoZVxuLy8gc3RhcnQtb2Ytb3BlcmF0aW9uIHNlbGVjdGlvbiBhbmQgZG9jdW1lbnQsIHNpbmNlIHRoYXQncyB0aGUgb25lXG4vLyB0aGF0IHRoZSBET00gcmVwcmVzZW50cy4gSWYgYW55IGNoYW5nZXMgY2FtZSBpbiBpbiB0aGUgbWVhbnRpbWUsXG4vLyB0aGUgbW9kaWZpY2F0aW9uIGlzIG1hcHBlZCBvdmVyIHRob3NlIGJlZm9yZSBpdCBpcyBhcHBsaWVkLCBpblxuLy8gcmVhZERPTUNoYW5nZS5cbmZ1bmN0aW9uIHBhcnNlQmV0d2Vlbih2aWV3LCBmcm9tXywgdG9fKSB7XG4gICAgbGV0IHsgbm9kZTogcGFyZW50LCBmcm9tT2Zmc2V0LCB0b09mZnNldCwgZnJvbSwgdG8gfSA9IHZpZXcuZG9jVmlldy5wYXJzZVJhbmdlKGZyb21fLCB0b18pO1xuICAgIGxldCBkb21TZWwgPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgbGV0IGZpbmQ7XG4gICAgbGV0IGFuY2hvciA9IGRvbVNlbC5hbmNob3JOb2RlO1xuICAgIGlmIChhbmNob3IgJiYgdmlldy5kb20uY29udGFpbnMoYW5jaG9yLm5vZGVUeXBlID09IDEgPyBhbmNob3IgOiBhbmNob3IucGFyZW50Tm9kZSkpIHtcbiAgICAgICAgZmluZCA9IFt7IG5vZGU6IGFuY2hvciwgb2Zmc2V0OiBkb21TZWwuYW5jaG9yT2Zmc2V0IH1dO1xuICAgICAgICBpZiAoIXNlbGVjdGlvbkNvbGxhcHNlZChkb21TZWwpKVxuICAgICAgICAgICAgZmluZC5wdXNoKHsgbm9kZTogZG9tU2VsLmZvY3VzTm9kZSwgb2Zmc2V0OiBkb21TZWwuZm9jdXNPZmZzZXQgfSk7XG4gICAgfVxuICAgIC8vIFdvcmsgYXJvdW5kIGlzc3VlIGluIENocm9tZSB3aGVyZSBiYWNrc3BhY2luZyBzb21ldGltZXMgcmVwbGFjZXNcbiAgICAvLyB0aGUgZGVsZXRlZCBjb250ZW50IHdpdGggYSByYW5kb20gQlIgbm9kZSAoaXNzdWVzICM3OTksICM4MzEpXG4gICAgaWYgKGNocm9tZSAmJiB2aWV3LmlucHV0Lmxhc3RLZXlDb2RlID09PSA4KSB7XG4gICAgICAgIGZvciAobGV0IG9mZiA9IHRvT2Zmc2V0OyBvZmYgPiBmcm9tT2Zmc2V0OyBvZmYtLSkge1xuICAgICAgICAgICAgbGV0IG5vZGUgPSBwYXJlbnQuY2hpbGROb2Rlc1tvZmYgLSAxXSwgZGVzYyA9IG5vZGUucG1WaWV3RGVzYztcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVOYW1lID09IFwiQlJcIiAmJiAhZGVzYykge1xuICAgICAgICAgICAgICAgIHRvT2Zmc2V0ID0gb2ZmO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkZXNjIHx8IGRlc2Muc2l6ZSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgc3RhcnREb2MgPSB2aWV3LnN0YXRlLmRvYztcbiAgICBsZXQgcGFyc2VyID0gdmlldy5zb21lUHJvcChcImRvbVBhcnNlclwiKSB8fCBET01QYXJzZXIuZnJvbVNjaGVtYSh2aWV3LnN0YXRlLnNjaGVtYSk7XG4gICAgbGV0ICRmcm9tID0gc3RhcnREb2MucmVzb2x2ZShmcm9tKTtcbiAgICBsZXQgc2VsID0gbnVsbCwgZG9jID0gcGFyc2VyLnBhcnNlKHBhcmVudCwge1xuICAgICAgICB0b3BOb2RlOiAkZnJvbS5wYXJlbnQsXG4gICAgICAgIHRvcE1hdGNoOiAkZnJvbS5wYXJlbnQuY29udGVudE1hdGNoQXQoJGZyb20uaW5kZXgoKSksXG4gICAgICAgIHRvcE9wZW46IHRydWUsXG4gICAgICAgIGZyb206IGZyb21PZmZzZXQsXG4gICAgICAgIHRvOiB0b09mZnNldCxcbiAgICAgICAgcHJlc2VydmVXaGl0ZXNwYWNlOiAkZnJvbS5wYXJlbnQudHlwZS53aGl0ZXNwYWNlID09IFwicHJlXCIgPyBcImZ1bGxcIiA6IHRydWUsXG4gICAgICAgIGZpbmRQb3NpdGlvbnM6IGZpbmQsXG4gICAgICAgIHJ1bGVGcm9tTm9kZSxcbiAgICAgICAgY29udGV4dDogJGZyb21cbiAgICB9KTtcbiAgICBpZiAoZmluZCAmJiBmaW5kWzBdLnBvcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCBhbmNob3IgPSBmaW5kWzBdLnBvcywgaGVhZCA9IGZpbmRbMV0gJiYgZmluZFsxXS5wb3M7XG4gICAgICAgIGlmIChoZWFkID09IG51bGwpXG4gICAgICAgICAgICBoZWFkID0gYW5jaG9yO1xuICAgICAgICBzZWwgPSB7IGFuY2hvcjogYW5jaG9yICsgZnJvbSwgaGVhZDogaGVhZCArIGZyb20gfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgZG9jLCBzZWwsIGZyb20sIHRvIH07XG59XG5mdW5jdGlvbiBydWxlRnJvbU5vZGUoZG9tKSB7XG4gICAgbGV0IGRlc2MgPSBkb20ucG1WaWV3RGVzYztcbiAgICBpZiAoZGVzYykge1xuICAgICAgICByZXR1cm4gZGVzYy5wYXJzZVJ1bGUoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZG9tLm5vZGVOYW1lID09IFwiQlJcIiAmJiBkb20ucGFyZW50Tm9kZSkge1xuICAgICAgICAvLyBTYWZhcmkgcmVwbGFjZXMgdGhlIGxpc3QgaXRlbSBvciB0YWJsZSBjZWxsIHdpdGggYSBCUlxuICAgICAgICAvLyBkaXJlY3RseSBpbiB0aGUgbGlzdCBub2RlICg/ISkgaWYgeW91IGRlbGV0ZSB0aGUgbGFzdFxuICAgICAgICAvLyBjaGFyYWN0ZXIgaW4gYSBsaXN0IGl0ZW0gb3IgdGFibGUgY2VsbCAoIzcwOCwgIzg2MilcbiAgICAgICAgaWYgKHNhZmFyaSAmJiAvXih1bHxvbCkkL2kudGVzdChkb20ucGFyZW50Tm9kZS5ub2RlTmFtZSkpIHtcbiAgICAgICAgICAgIGxldCBza2lwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIHNraXAuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpXCIpKTtcbiAgICAgICAgICAgIHJldHVybiB7IHNraXAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkb20ucGFyZW50Tm9kZS5sYXN0Q2hpbGQgPT0gZG9tIHx8IHNhZmFyaSAmJiAvXih0cnx0YWJsZSkkL2kudGVzdChkb20ucGFyZW50Tm9kZS5ub2RlTmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGlnbm9yZTogdHJ1ZSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGRvbS5ub2RlTmFtZSA9PSBcIklNR1wiICYmIGRvbS5nZXRBdHRyaWJ1dGUoXCJtYXJrLXBsYWNlaG9sZGVyXCIpKSB7XG4gICAgICAgIHJldHVybiB7IGlnbm9yZTogdHJ1ZSB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmNvbnN0IGlzSW5saW5lID0gL14oYXxhYmJyfGFjcm9ueW18YnxiZFtpb118YmlnfGJyfGJ1dHRvbnxjaXRlfGNvZGV8ZGF0YShsaXN0KT98ZGVsfGRmbnxlbXxpfGltZ3xpbnN8a2JkfGxhYmVsfG1hcHxtYXJrfG1ldGVyfG91dHB1dHxxfHJ1Ynl8c3xzYW1wfHNtYWxsfHNwYW58c3Ryb25nfHN1W2JwXXx0aW1lfHV8dHR8dmFyKSQvaTtcbmZ1bmN0aW9uIHJlYWRET01DaGFuZ2UodmlldywgZnJvbSwgdG8sIHR5cGVPdmVyLCBhZGRlZE5vZGVzKSB7XG4gICAgbGV0IGNvbXBvc2l0aW9uSUQgPSB2aWV3LmlucHV0LmNvbXBvc2l0aW9uUGVuZGluZ0NoYW5nZXMgfHwgKHZpZXcuY29tcG9zaW5nID8gdmlldy5pbnB1dC5jb21wb3NpdGlvbklEIDogMCk7XG4gICAgdmlldy5pbnB1dC5jb21wb3NpdGlvblBlbmRpbmdDaGFuZ2VzID0gMDtcbiAgICBpZiAoZnJvbSA8IDApIHtcbiAgICAgICAgbGV0IG9yaWdpbiA9IHZpZXcuaW5wdXQubGFzdFNlbGVjdGlvblRpbWUgPiBEYXRlLm5vdygpIC0gNTAgPyB2aWV3LmlucHV0Lmxhc3RTZWxlY3Rpb25PcmlnaW4gOiBudWxsO1xuICAgICAgICBsZXQgbmV3U2VsID0gc2VsZWN0aW9uRnJvbURPTSh2aWV3LCBvcmlnaW4pO1xuICAgICAgICBpZiAobmV3U2VsICYmICF2aWV3LnN0YXRlLnNlbGVjdGlvbi5lcShuZXdTZWwpKSB7XG4gICAgICAgICAgICBpZiAoY2hyb21lICYmIGFuZHJvaWQgJiZcbiAgICAgICAgICAgICAgICB2aWV3LmlucHV0Lmxhc3RLZXlDb2RlID09PSAxMyAmJiBEYXRlLm5vdygpIC0gMTAwIDwgdmlldy5pbnB1dC5sYXN0S2V5Q29kZVRpbWUgJiZcbiAgICAgICAgICAgICAgICB2aWV3LnNvbWVQcm9wKFwiaGFuZGxlS2V5RG93blwiLCBmID0+IGYodmlldywga2V5RXZlbnQoMTMsIFwiRW50ZXJcIikpKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgdHIgPSB2aWV3LnN0YXRlLnRyLnNldFNlbGVjdGlvbihuZXdTZWwpO1xuICAgICAgICAgICAgaWYgKG9yaWdpbiA9PSBcInBvaW50ZXJcIilcbiAgICAgICAgICAgICAgICB0ci5zZXRNZXRhKFwicG9pbnRlclwiLCB0cnVlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKG9yaWdpbiA9PSBcImtleVwiKVxuICAgICAgICAgICAgICAgIHRyLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICAgICAgICBpZiAoY29tcG9zaXRpb25JRClcbiAgICAgICAgICAgICAgICB0ci5zZXRNZXRhKFwiY29tcG9zaXRpb25cIiwgY29tcG9zaXRpb25JRCk7XG4gICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHRyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCAkYmVmb3JlID0gdmlldy5zdGF0ZS5kb2MucmVzb2x2ZShmcm9tKTtcbiAgICBsZXQgc2hhcmVkID0gJGJlZm9yZS5zaGFyZWREZXB0aCh0byk7XG4gICAgZnJvbSA9ICRiZWZvcmUuYmVmb3JlKHNoYXJlZCArIDEpO1xuICAgIHRvID0gdmlldy5zdGF0ZS5kb2MucmVzb2x2ZSh0bykuYWZ0ZXIoc2hhcmVkICsgMSk7XG4gICAgbGV0IHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgIGxldCBwYXJzZSA9IHBhcnNlQmV0d2Vlbih2aWV3LCBmcm9tLCB0byk7XG4gICAgbGV0IGRvYyA9IHZpZXcuc3RhdGUuZG9jLCBjb21wYXJlID0gZG9jLnNsaWNlKHBhcnNlLmZyb20sIHBhcnNlLnRvKTtcbiAgICBsZXQgcHJlZmVycmVkUG9zLCBwcmVmZXJyZWRTaWRlO1xuICAgIC8vIFByZWZlciBhbmNob3JpbmcgdG8gZW5kIHdoZW4gQmFja3NwYWNlIGlzIHByZXNzZWRcbiAgICBpZiAodmlldy5pbnB1dC5sYXN0S2V5Q29kZSA9PT0gOCAmJiBEYXRlLm5vdygpIC0gMTAwIDwgdmlldy5pbnB1dC5sYXN0S2V5Q29kZVRpbWUpIHtcbiAgICAgICAgcHJlZmVycmVkUG9zID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24udG87XG4gICAgICAgIHByZWZlcnJlZFNpZGUgPSBcImVuZFwiO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcHJlZmVycmVkUG9zID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24uZnJvbTtcbiAgICAgICAgcHJlZmVycmVkU2lkZSA9IFwic3RhcnRcIjtcbiAgICB9XG4gICAgdmlldy5pbnB1dC5sYXN0S2V5Q29kZSA9IG51bGw7XG4gICAgbGV0IGNoYW5nZSA9IGZpbmREaWZmKGNvbXBhcmUuY29udGVudCwgcGFyc2UuZG9jLmNvbnRlbnQsIHBhcnNlLmZyb20sIHByZWZlcnJlZFBvcywgcHJlZmVycmVkU2lkZSk7XG4gICAgaWYgKGNoYW5nZSlcbiAgICAgICAgdmlldy5pbnB1dC5kb21DaGFuZ2VDb3VudCsrO1xuICAgIGlmICgoaW9zICYmIHZpZXcuaW5wdXQubGFzdElPU0VudGVyID4gRGF0ZS5ub3coKSAtIDIyNSB8fCBhbmRyb2lkKSAmJlxuICAgICAgICBhZGRlZE5vZGVzLnNvbWUobiA9PiBuLm5vZGVUeXBlID09IDEgJiYgIWlzSW5saW5lLnRlc3Qobi5ub2RlTmFtZSkpICYmXG4gICAgICAgICghY2hhbmdlIHx8IGNoYW5nZS5lbmRBID49IGNoYW5nZS5lbmRCKSAmJlxuICAgICAgICB2aWV3LnNvbWVQcm9wKFwiaGFuZGxlS2V5RG93blwiLCBmID0+IGYodmlldywga2V5RXZlbnQoMTMsIFwiRW50ZXJcIikpKSkge1xuICAgICAgICB2aWV3LmlucHV0Lmxhc3RJT1NFbnRlciA9IDA7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFjaGFuZ2UpIHtcbiAgICAgICAgaWYgKHR5cGVPdmVyICYmIHNlbCBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24gJiYgIXNlbC5lbXB0eSAmJiBzZWwuJGhlYWQuc2FtZVBhcmVudChzZWwuJGFuY2hvcikgJiZcbiAgICAgICAgICAgICF2aWV3LmNvbXBvc2luZyAmJiAhKHBhcnNlLnNlbCAmJiBwYXJzZS5zZWwuYW5jaG9yICE9IHBhcnNlLnNlbC5oZWFkKSkge1xuICAgICAgICAgICAgY2hhbmdlID0geyBzdGFydDogc2VsLmZyb20sIGVuZEE6IHNlbC50bywgZW5kQjogc2VsLnRvIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAocGFyc2Uuc2VsKSB7XG4gICAgICAgICAgICAgICAgbGV0IHNlbCA9IHJlc29sdmVTZWxlY3Rpb24odmlldywgdmlldy5zdGF0ZS5kb2MsIHBhcnNlLnNlbCk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbCAmJiAhc2VsLmVxKHZpZXcuc3RhdGUuc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdHIgPSB2aWV3LnN0YXRlLnRyLnNldFNlbGVjdGlvbihzZWwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcG9zaXRpb25JRClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyLnNldE1ldGEoXCJjb21wb3NpdGlvblwiLCBjb21wb3NpdGlvbklEKTtcbiAgICAgICAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh0cik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEhhbmRsZSB0aGUgY2FzZSB3aGVyZSBvdmVyd3JpdGluZyBhIHNlbGVjdGlvbiBieSB0eXBpbmcgbWF0Y2hlc1xuICAgIC8vIHRoZSBzdGFydCBvciBlbmQgb2YgdGhlIHNlbGVjdGVkIGNvbnRlbnQsIGNyZWF0aW5nIGEgY2hhbmdlXG4gICAgLy8gdGhhdCdzIHNtYWxsZXIgdGhhbiB3aGF0IHdhcyBhY3R1YWxseSBvdmVyd3JpdHRlbi5cbiAgICBpZiAodmlldy5zdGF0ZS5zZWxlY3Rpb24uZnJvbSA8IHZpZXcuc3RhdGUuc2VsZWN0aW9uLnRvICYmXG4gICAgICAgIGNoYW5nZS5zdGFydCA9PSBjaGFuZ2UuZW5kQiAmJlxuICAgICAgICB2aWV3LnN0YXRlLnNlbGVjdGlvbiBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24pIHtcbiAgICAgICAgaWYgKGNoYW5nZS5zdGFydCA+IHZpZXcuc3RhdGUuc2VsZWN0aW9uLmZyb20gJiYgY2hhbmdlLnN0YXJ0IDw9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLmZyb20gKyAyICYmXG4gICAgICAgICAgICB2aWV3LnN0YXRlLnNlbGVjdGlvbi5mcm9tID49IHBhcnNlLmZyb20pIHtcbiAgICAgICAgICAgIGNoYW5nZS5zdGFydCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLmZyb207XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2hhbmdlLmVuZEEgPCB2aWV3LnN0YXRlLnNlbGVjdGlvbi50byAmJiBjaGFuZ2UuZW5kQSA+PSB2aWV3LnN0YXRlLnNlbGVjdGlvbi50byAtIDIgJiZcbiAgICAgICAgICAgIHZpZXcuc3RhdGUuc2VsZWN0aW9uLnRvIDw9IHBhcnNlLnRvKSB7XG4gICAgICAgICAgICBjaGFuZ2UuZW5kQiArPSAodmlldy5zdGF0ZS5zZWxlY3Rpb24udG8gLSBjaGFuZ2UuZW5kQSk7XG4gICAgICAgICAgICBjaGFuZ2UuZW5kQSA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLnRvO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIElFMTEgd2lsbCBpbnNlcnQgYSBub24tYnJlYWtpbmcgc3BhY2UgX2FoZWFkXyBvZiB0aGUgc3BhY2UgYWZ0ZXJcbiAgICAvLyB0aGUgY3Vyc29yIHNwYWNlIHdoZW4gYWRkaW5nIGEgc3BhY2UgYmVmb3JlIGFub3RoZXIgc3BhY2UuIFdoZW5cbiAgICAvLyB0aGF0IGhhcHBlbmVkLCBhZGp1c3QgdGhlIGNoYW5nZSB0byBjb3ZlciB0aGUgc3BhY2UgaW5zdGVhZC5cbiAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8PSAxMSAmJiBjaGFuZ2UuZW5kQiA9PSBjaGFuZ2Uuc3RhcnQgKyAxICYmXG4gICAgICAgIGNoYW5nZS5lbmRBID09IGNoYW5nZS5zdGFydCAmJiBjaGFuZ2Uuc3RhcnQgPiBwYXJzZS5mcm9tICYmXG4gICAgICAgIHBhcnNlLmRvYy50ZXh0QmV0d2VlbihjaGFuZ2Uuc3RhcnQgLSBwYXJzZS5mcm9tIC0gMSwgY2hhbmdlLnN0YXJ0IC0gcGFyc2UuZnJvbSArIDEpID09IFwiIFxcdTAwYTBcIikge1xuICAgICAgICBjaGFuZ2Uuc3RhcnQtLTtcbiAgICAgICAgY2hhbmdlLmVuZEEtLTtcbiAgICAgICAgY2hhbmdlLmVuZEItLTtcbiAgICB9XG4gICAgbGV0ICRmcm9tID0gcGFyc2UuZG9jLnJlc29sdmVOb0NhY2hlKGNoYW5nZS5zdGFydCAtIHBhcnNlLmZyb20pO1xuICAgIGxldCAkdG8gPSBwYXJzZS5kb2MucmVzb2x2ZU5vQ2FjaGUoY2hhbmdlLmVuZEIgLSBwYXJzZS5mcm9tKTtcbiAgICBsZXQgJGZyb21BID0gZG9jLnJlc29sdmUoY2hhbmdlLnN0YXJ0KTtcbiAgICBsZXQgaW5saW5lQ2hhbmdlID0gJGZyb20uc2FtZVBhcmVudCgkdG8pICYmICRmcm9tLnBhcmVudC5pbmxpbmVDb250ZW50ICYmICRmcm9tQS5lbmQoKSA+PSBjaGFuZ2UuZW5kQTtcbiAgICAvLyBJZiB0aGlzIGxvb2tzIGxpa2UgdGhlIGVmZmVjdCBvZiBwcmVzc2luZyBFbnRlciAob3Igd2FzIHJlY29yZGVkXG4gICAgLy8gYXMgYmVpbmcgYW4gaU9TIGVudGVyIHByZXNzKSwganVzdCBkaXNwYXRjaCBhbiBFbnRlciBrZXkgaW5zdGVhZC5cbiAgICBpZiAoKChpb3MgJiYgdmlldy5pbnB1dC5sYXN0SU9TRW50ZXIgPiBEYXRlLm5vdygpIC0gMjI1ICYmXG4gICAgICAgICghaW5saW5lQ2hhbmdlIHx8IGFkZGVkTm9kZXMuc29tZShuID0+IG4ubm9kZU5hbWUgPT0gXCJESVZcIiB8fCBuLm5vZGVOYW1lID09IFwiUFwiKSkpIHx8XG4gICAgICAgICghaW5saW5lQ2hhbmdlICYmICRmcm9tLnBvcyA8IHBhcnNlLmRvYy5jb250ZW50LnNpemUgJiZcbiAgICAgICAgICAgICghJGZyb20uc2FtZVBhcmVudCgkdG8pIHx8ICEkZnJvbS5wYXJlbnQuaW5saW5lQ29udGVudCkgJiZcbiAgICAgICAgICAgICRmcm9tLnBvcyA8ICR0by5wb3MgJiYgIS9cXFMvLnRlc3QocGFyc2UuZG9jLnRleHRCZXR3ZWVuKCRmcm9tLnBvcywgJHRvLnBvcywgXCJcIiwgXCJcIikpKSkgJiZcbiAgICAgICAgdmlldy5zb21lUHJvcChcImhhbmRsZUtleURvd25cIiwgZiA9PiBmKHZpZXcsIGtleUV2ZW50KDEzLCBcIkVudGVyXCIpKSkpIHtcbiAgICAgICAgdmlldy5pbnB1dC5sYXN0SU9TRW50ZXIgPSAwO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFNhbWUgZm9yIGJhY2tzcGFjZVxuICAgIGlmICh2aWV3LnN0YXRlLnNlbGVjdGlvbi5hbmNob3IgPiBjaGFuZ2Uuc3RhcnQgJiZcbiAgICAgICAgbG9va3NMaWtlQmFja3NwYWNlKGRvYywgY2hhbmdlLnN0YXJ0LCBjaGFuZ2UuZW5kQSwgJGZyb20sICR0bykgJiZcbiAgICAgICAgdmlldy5zb21lUHJvcChcImhhbmRsZUtleURvd25cIiwgZiA9PiBmKHZpZXcsIGtleUV2ZW50KDgsIFwiQmFja3NwYWNlXCIpKSkpIHtcbiAgICAgICAgaWYgKGFuZHJvaWQgJiYgY2hyb21lKVxuICAgICAgICAgICAgdmlldy5kb21PYnNlcnZlci5zdXBwcmVzc1NlbGVjdGlvblVwZGF0ZXMoKTsgLy8gIzgyMFxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIENocm9tZSB3aWxsIG9jY2FzaW9uYWxseSwgZHVyaW5nIGNvbXBvc2l0aW9uLCBkZWxldGUgdGhlXG4gICAgLy8gZW50aXJlIGNvbXBvc2l0aW9uIGFuZCB0aGVuIGltbWVkaWF0ZWx5IGluc2VydCBpdCBhZ2Fpbi4gVGhpcyBpc1xuICAgIC8vIHVzZWQgdG8gZGV0ZWN0IHRoYXQgc2l0dWF0aW9uLlxuICAgIGlmIChjaHJvbWUgJiYgY2hhbmdlLmVuZEIgPT0gY2hhbmdlLnN0YXJ0KVxuICAgICAgICB2aWV3LmlucHV0Lmxhc3RDaHJvbWVEZWxldGUgPSBEYXRlLm5vdygpO1xuICAgIC8vIFRoaXMgdHJpZXMgdG8gZGV0ZWN0IEFuZHJvaWQgdmlydHVhbCBrZXlib2FyZFxuICAgIC8vIGVudGVyLWFuZC1waWNrLXN1Z2dlc3Rpb24gYWN0aW9uLiBUaGF0IHNvbWV0aW1lcyAoc2VlIGlzc3VlXG4gICAgLy8gIzEwNTkpIGZpcnN0IGZpcmVzIGEgRE9NIG11dGF0aW9uLCBiZWZvcmUgbW92aW5nIHRoZSBzZWxlY3Rpb24gdG9cbiAgICAvLyB0aGUgbmV3bHkgY3JlYXRlZCBibG9jay4gQW5kIHRoZW4sIGJlY2F1c2UgUHJvc2VNaXJyb3IgY2xlYW5zIHVwXG4gICAgLy8gdGhlIERPTSBzZWxlY3Rpb24sIGl0IGdpdmVzIHVwIG1vdmluZyB0aGUgc2VsZWN0aW9uIGVudGlyZWx5LFxuICAgIC8vIGxlYXZpbmcgdGhlIGN1cnNvciBpbiB0aGUgd3JvbmcgcGxhY2UuIFdoZW4gdGhhdCBoYXBwZW5zLCB3ZSBkcm9wXG4gICAgLy8gdGhlIG5ldyBwYXJhZ3JhcGggZnJvbSB0aGUgaW5pdGlhbCBjaGFuZ2UsIGFuZCBmaXJlIGEgc2ltdWxhdGVkXG4gICAgLy8gZW50ZXIga2V5IGFmdGVyd2FyZHMuXG4gICAgaWYgKGFuZHJvaWQgJiYgIWlubGluZUNoYW5nZSAmJiAkZnJvbS5zdGFydCgpICE9ICR0by5zdGFydCgpICYmICR0by5wYXJlbnRPZmZzZXQgPT0gMCAmJiAkZnJvbS5kZXB0aCA9PSAkdG8uZGVwdGggJiZcbiAgICAgICAgcGFyc2Uuc2VsICYmIHBhcnNlLnNlbC5hbmNob3IgPT0gcGFyc2Uuc2VsLmhlYWQgJiYgcGFyc2Uuc2VsLmhlYWQgPT0gY2hhbmdlLmVuZEEpIHtcbiAgICAgICAgY2hhbmdlLmVuZEIgLT0gMjtcbiAgICAgICAgJHRvID0gcGFyc2UuZG9jLnJlc29sdmVOb0NhY2hlKGNoYW5nZS5lbmRCIC0gcGFyc2UuZnJvbSk7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdmlldy5zb21lUHJvcChcImhhbmRsZUtleURvd25cIiwgZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGYodmlldywga2V5RXZlbnQoMTMsIFwiRW50ZXJcIikpOyB9KTtcbiAgICAgICAgfSwgMjApO1xuICAgIH1cbiAgICBsZXQgY2hGcm9tID0gY2hhbmdlLnN0YXJ0LCBjaFRvID0gY2hhbmdlLmVuZEE7XG4gICAgbGV0IG1rVHIgPSAoYmFzZSkgPT4ge1xuICAgICAgICBsZXQgdHIgPSBiYXNlIHx8IHZpZXcuc3RhdGUudHIucmVwbGFjZShjaEZyb20sIGNoVG8sIHBhcnNlLmRvYy5zbGljZShjaGFuZ2Uuc3RhcnQgLSBwYXJzZS5mcm9tLCBjaGFuZ2UuZW5kQiAtIHBhcnNlLmZyb20pKTtcbiAgICAgICAgaWYgKHBhcnNlLnNlbCkge1xuICAgICAgICAgICAgbGV0IHNlbCA9IHJlc29sdmVTZWxlY3Rpb24odmlldywgdHIuZG9jLCBwYXJzZS5zZWwpO1xuICAgICAgICAgICAgLy8gQ2hyb21lIHdpbGwgc29tZXRpbWVzLCBkdXJpbmcgY29tcG9zaXRpb24sIHJlcG9ydCB0aGVcbiAgICAgICAgICAgIC8vIHNlbGVjdGlvbiBpbiB0aGUgd3JvbmcgcGxhY2UuIElmIGl0IGxvb2tzIGxpa2UgdGhhdCBpc1xuICAgICAgICAgICAgLy8gaGFwcGVuaW5nLCBkb24ndCB1cGRhdGUgdGhlIHNlbGVjdGlvbi5cbiAgICAgICAgICAgIC8vIEVkZ2UganVzdCBkb2Vzbid0IG1vdmUgdGhlIGN1cnNvciBmb3J3YXJkIHdoZW4geW91IHN0YXJ0IHR5cGluZ1xuICAgICAgICAgICAgLy8gaW4gYW4gZW1wdHkgYmxvY2sgb3IgYmV0d2VlbiBiciBub2Rlcy5cbiAgICAgICAgICAgIGlmIChzZWwgJiYgIShjaHJvbWUgJiYgdmlldy5jb21wb3NpbmcgJiYgc2VsLmVtcHR5ICYmXG4gICAgICAgICAgICAgICAgKGNoYW5nZS5zdGFydCAhPSBjaGFuZ2UuZW5kQiB8fCB2aWV3LmlucHV0Lmxhc3RDaHJvbWVEZWxldGUgPCBEYXRlLm5vdygpIC0gMTAwKSAmJlxuICAgICAgICAgICAgICAgIChzZWwuaGVhZCA9PSBjaEZyb20gfHwgc2VsLmhlYWQgPT0gdHIubWFwcGluZy5tYXAoY2hUbykgLSAxKSB8fFxuICAgICAgICAgICAgICAgIGllICYmIHNlbC5lbXB0eSAmJiBzZWwuaGVhZCA9PSBjaEZyb20pKVxuICAgICAgICAgICAgICAgIHRyLnNldFNlbGVjdGlvbihzZWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wb3NpdGlvbklEKVxuICAgICAgICAgICAgdHIuc2V0TWV0YShcImNvbXBvc2l0aW9uXCIsIGNvbXBvc2l0aW9uSUQpO1xuICAgICAgICByZXR1cm4gdHIuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICB9O1xuICAgIGxldCBtYXJrQ2hhbmdlO1xuICAgIGlmIChpbmxpbmVDaGFuZ2UpIHtcbiAgICAgICAgaWYgKCRmcm9tLnBvcyA9PSAkdG8ucG9zKSB7IC8vIERlbGV0aW9uXG4gICAgICAgICAgICAvLyBJRTExIHNvbWV0aW1lcyB3ZWlyZGx5IG1vdmVzIHRoZSBET00gc2VsZWN0aW9uIGFyb3VuZCBhZnRlclxuICAgICAgICAgICAgLy8gYmFja3NwYWNpbmcgb3V0IHRoZSBmaXJzdCBlbGVtZW50IGluIGEgdGV4dGJsb2NrXG4gICAgICAgICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8PSAxMSAmJiAkZnJvbS5wYXJlbnRPZmZzZXQgPT0gMCkge1xuICAgICAgICAgICAgICAgIHZpZXcuZG9tT2JzZXJ2ZXIuc3VwcHJlc3NTZWxlY3Rpb25VcGRhdGVzKCk7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBzZWxlY3Rpb25Ub0RPTSh2aWV3KSwgMjApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHRyID0gbWtUcih2aWV3LnN0YXRlLnRyLmRlbGV0ZShjaEZyb20sIGNoVG8pKTtcbiAgICAgICAgICAgIGxldCBtYXJrcyA9IGRvYy5yZXNvbHZlKGNoYW5nZS5zdGFydCkubWFya3NBY3Jvc3MoZG9jLnJlc29sdmUoY2hhbmdlLmVuZEEpKTtcbiAgICAgICAgICAgIGlmIChtYXJrcylcbiAgICAgICAgICAgICAgICB0ci5lbnN1cmVNYXJrcyhtYXJrcyk7XG4gICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHRyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggLy8gQWRkaW5nIG9yIHJlbW92aW5nIGEgbWFya1xuICAgICAgICBjaGFuZ2UuZW5kQSA9PSBjaGFuZ2UuZW5kQiAmJlxuICAgICAgICAgICAgKG1hcmtDaGFuZ2UgPSBpc01hcmtDaGFuZ2UoJGZyb20ucGFyZW50LmNvbnRlbnQuY3V0KCRmcm9tLnBhcmVudE9mZnNldCwgJHRvLnBhcmVudE9mZnNldCksICRmcm9tQS5wYXJlbnQuY29udGVudC5jdXQoJGZyb21BLnBhcmVudE9mZnNldCwgY2hhbmdlLmVuZEEgLSAkZnJvbUEuc3RhcnQoKSkpKSkge1xuICAgICAgICAgICAgbGV0IHRyID0gbWtUcih2aWV3LnN0YXRlLnRyKTtcbiAgICAgICAgICAgIGlmIChtYXJrQ2hhbmdlLnR5cGUgPT0gXCJhZGRcIilcbiAgICAgICAgICAgICAgICB0ci5hZGRNYXJrKGNoRnJvbSwgY2hUbywgbWFya0NoYW5nZS5tYXJrKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0ci5yZW1vdmVNYXJrKGNoRnJvbSwgY2hUbywgbWFya0NoYW5nZS5tYXJrKTtcbiAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2godHIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCRmcm9tLnBhcmVudC5jaGlsZCgkZnJvbS5pbmRleCgpKS5pc1RleHQgJiYgJGZyb20uaW5kZXgoKSA9PSAkdG8uaW5kZXgoKSAtICgkdG8udGV4dE9mZnNldCA/IDAgOiAxKSkge1xuICAgICAgICAgICAgLy8gQm90aCBwb3NpdGlvbnMgaW4gdGhlIHNhbWUgdGV4dCBub2RlIC0tIHNpbXBseSBpbnNlcnQgdGV4dFxuICAgICAgICAgICAgbGV0IHRleHQgPSAkZnJvbS5wYXJlbnQudGV4dEJldHdlZW4oJGZyb20ucGFyZW50T2Zmc2V0LCAkdG8ucGFyZW50T2Zmc2V0KTtcbiAgICAgICAgICAgIGxldCBkZWZsdCA9ICgpID0+IG1rVHIodmlldy5zdGF0ZS50ci5pbnNlcnRUZXh0KHRleHQsIGNoRnJvbSwgY2hUbykpO1xuICAgICAgICAgICAgaWYgKCF2aWV3LnNvbWVQcm9wKFwiaGFuZGxlVGV4dElucHV0XCIsIGYgPT4gZih2aWV3LCBjaEZyb20sIGNoVG8sIHRleHQsIGRlZmx0KSkpXG4gICAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaChkZWZsdCgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2gobWtUcigpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmlldy5kaXNwYXRjaChta1RyKCkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlc29sdmVTZWxlY3Rpb24odmlldywgZG9jLCBwYXJzZWRTZWwpIHtcbiAgICBpZiAoTWF0aC5tYXgocGFyc2VkU2VsLmFuY2hvciwgcGFyc2VkU2VsLmhlYWQpID4gZG9jLmNvbnRlbnQuc2l6ZSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHNlbGVjdGlvbkJldHdlZW4odmlldywgZG9jLnJlc29sdmUocGFyc2VkU2VsLmFuY2hvciksIGRvYy5yZXNvbHZlKHBhcnNlZFNlbC5oZWFkKSk7XG59XG4vLyBHaXZlbiB0d28gc2FtZS1sZW5ndGgsIG5vbi1lbXB0eSBmcmFnbWVudHMgb2YgaW5saW5lIGNvbnRlbnQsXG4vLyBkZXRlcm1pbmUgd2hldGhlciB0aGUgZmlyc3QgY291bGQgYmUgY3JlYXRlZCBmcm9tIHRoZSBzZWNvbmQgYnlcbi8vIHJlbW92aW5nIG9yIGFkZGluZyBhIHNpbmdsZSBtYXJrIHR5cGUuXG5mdW5jdGlvbiBpc01hcmtDaGFuZ2UoY3VyLCBwcmV2KSB7XG4gICAgbGV0IGN1ck1hcmtzID0gY3VyLmZpcnN0Q2hpbGQubWFya3MsIHByZXZNYXJrcyA9IHByZXYuZmlyc3RDaGlsZC5tYXJrcztcbiAgICBsZXQgYWRkZWQgPSBjdXJNYXJrcywgcmVtb3ZlZCA9IHByZXZNYXJrcywgdHlwZSwgbWFyaywgdXBkYXRlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJldk1hcmtzLmxlbmd0aDsgaSsrKVxuICAgICAgICBhZGRlZCA9IHByZXZNYXJrc1tpXS5yZW1vdmVGcm9tU2V0KGFkZGVkKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1ck1hcmtzLmxlbmd0aDsgaSsrKVxuICAgICAgICByZW1vdmVkID0gY3VyTWFya3NbaV0ucmVtb3ZlRnJvbVNldChyZW1vdmVkKTtcbiAgICBpZiAoYWRkZWQubGVuZ3RoID09IDEgJiYgcmVtb3ZlZC5sZW5ndGggPT0gMCkge1xuICAgICAgICBtYXJrID0gYWRkZWRbMF07XG4gICAgICAgIHR5cGUgPSBcImFkZFwiO1xuICAgICAgICB1cGRhdGUgPSAobm9kZSkgPT4gbm9kZS5tYXJrKG1hcmsuYWRkVG9TZXQobm9kZS5tYXJrcykpO1xuICAgIH1cbiAgICBlbHNlIGlmIChhZGRlZC5sZW5ndGggPT0gMCAmJiByZW1vdmVkLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIG1hcmsgPSByZW1vdmVkWzBdO1xuICAgICAgICB0eXBlID0gXCJyZW1vdmVcIjtcbiAgICAgICAgdXBkYXRlID0gKG5vZGUpID0+IG5vZGUubWFyayhtYXJrLnJlbW92ZUZyb21TZXQobm9kZS5tYXJrcykpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGxldCB1cGRhdGVkID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmV2LmNoaWxkQ291bnQ7IGkrKylcbiAgICAgICAgdXBkYXRlZC5wdXNoKHVwZGF0ZShwcmV2LmNoaWxkKGkpKSk7XG4gICAgaWYgKEZyYWdtZW50LmZyb20odXBkYXRlZCkuZXEoY3VyKSlcbiAgICAgICAgcmV0dXJuIHsgbWFyaywgdHlwZSB9O1xufVxuZnVuY3Rpb24gbG9va3NMaWtlQmFja3NwYWNlKG9sZCwgc3RhcnQsIGVuZCwgJG5ld1N0YXJ0LCAkbmV3RW5kKSB7XG4gICAgaWYgKCAvLyBUaGUgY29udGVudCBtdXN0IGhhdmUgc2hydW5rXG4gICAgZW5kIC0gc3RhcnQgPD0gJG5ld0VuZC5wb3MgLSAkbmV3U3RhcnQucG9zIHx8XG4gICAgICAgIC8vIG5ld0VuZCBtdXN0IHBvaW50IGRpcmVjdGx5IGF0IG9yIGFmdGVyIHRoZSBlbmQgb2YgdGhlIGJsb2NrIHRoYXQgbmV3U3RhcnQgcG9pbnRzIGludG9cbiAgICAgICAgc2tpcENsb3NpbmdBbmRPcGVuaW5nKCRuZXdTdGFydCwgdHJ1ZSwgZmFsc2UpIDwgJG5ld0VuZC5wb3MpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgJHN0YXJ0ID0gb2xkLnJlc29sdmUoc3RhcnQpO1xuICAgIC8vIEhhbmRsZSB0aGUgY2FzZSB3aGVyZSwgcmF0aGVyIHRoYW4gam9pbmluZyBibG9ja3MsIHRoZSBjaGFuZ2UganVzdCByZW1vdmVkIGFuIGVudGlyZSBibG9ja1xuICAgIGlmICghJG5ld1N0YXJ0LnBhcmVudC5pc1RleHRibG9jaykge1xuICAgICAgICBsZXQgYWZ0ZXIgPSAkc3RhcnQubm9kZUFmdGVyO1xuICAgICAgICByZXR1cm4gYWZ0ZXIgIT0gbnVsbCAmJiBlbmQgPT0gc3RhcnQgKyBhZnRlci5ub2RlU2l6ZTtcbiAgICB9XG4gICAgLy8gU3RhcnQgbXVzdCBiZSBhdCB0aGUgZW5kIG9mIGEgYmxvY2tcbiAgICBpZiAoJHN0YXJ0LnBhcmVudE9mZnNldCA8ICRzdGFydC5wYXJlbnQuY29udGVudC5zaXplIHx8ICEkc3RhcnQucGFyZW50LmlzVGV4dGJsb2NrKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0ICRuZXh0ID0gb2xkLnJlc29sdmUoc2tpcENsb3NpbmdBbmRPcGVuaW5nKCRzdGFydCwgdHJ1ZSwgdHJ1ZSkpO1xuICAgIC8vIFRoZSBuZXh0IHRleHRibG9jayBtdXN0IHN0YXJ0IGJlZm9yZSBlbmQgYW5kIGVuZCBuZWFyIGl0XG4gICAgaWYgKCEkbmV4dC5wYXJlbnQuaXNUZXh0YmxvY2sgfHwgJG5leHQucG9zID4gZW5kIHx8XG4gICAgICAgIHNraXBDbG9zaW5nQW5kT3BlbmluZygkbmV4dCwgdHJ1ZSwgZmFsc2UpIDwgZW5kKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgLy8gVGhlIGZyYWdtZW50cyBhZnRlciB0aGUgam9pbiBwb2ludCBtdXN0IG1hdGNoXG4gICAgcmV0dXJuICRuZXdTdGFydC5wYXJlbnQuY29udGVudC5jdXQoJG5ld1N0YXJ0LnBhcmVudE9mZnNldCkuZXEoJG5leHQucGFyZW50LmNvbnRlbnQpO1xufVxuZnVuY3Rpb24gc2tpcENsb3NpbmdBbmRPcGVuaW5nKCRwb3MsIGZyb21FbmQsIG1heU9wZW4pIHtcbiAgICBsZXQgZGVwdGggPSAkcG9zLmRlcHRoLCBlbmQgPSBmcm9tRW5kID8gJHBvcy5lbmQoKSA6ICRwb3MucG9zO1xuICAgIHdoaWxlIChkZXB0aCA+IDAgJiYgKGZyb21FbmQgfHwgJHBvcy5pbmRleEFmdGVyKGRlcHRoKSA9PSAkcG9zLm5vZGUoZGVwdGgpLmNoaWxkQ291bnQpKSB7XG4gICAgICAgIGRlcHRoLS07XG4gICAgICAgIGVuZCsrO1xuICAgICAgICBmcm9tRW5kID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChtYXlPcGVuKSB7XG4gICAgICAgIGxldCBuZXh0ID0gJHBvcy5ub2RlKGRlcHRoKS5tYXliZUNoaWxkKCRwb3MuaW5kZXhBZnRlcihkZXB0aCkpO1xuICAgICAgICB3aGlsZSAobmV4dCAmJiAhbmV4dC5pc0xlYWYpIHtcbiAgICAgICAgICAgIG5leHQgPSBuZXh0LmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICBlbmQrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZW5kO1xufVxuZnVuY3Rpb24gZmluZERpZmYoYSwgYiwgcG9zLCBwcmVmZXJyZWRQb3MsIHByZWZlcnJlZFNpZGUpIHtcbiAgICBsZXQgc3RhcnQgPSBhLmZpbmREaWZmU3RhcnQoYiwgcG9zKTtcbiAgICBpZiAoc3RhcnQgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IHsgYTogZW5kQSwgYjogZW5kQiB9ID0gYS5maW5kRGlmZkVuZChiLCBwb3MgKyBhLnNpemUsIHBvcyArIGIuc2l6ZSk7XG4gICAgaWYgKHByZWZlcnJlZFNpZGUgPT0gXCJlbmRcIikge1xuICAgICAgICBsZXQgYWRqdXN0ID0gTWF0aC5tYXgoMCwgc3RhcnQgLSBNYXRoLm1pbihlbmRBLCBlbmRCKSk7XG4gICAgICAgIHByZWZlcnJlZFBvcyAtPSBlbmRBICsgYWRqdXN0IC0gc3RhcnQ7XG4gICAgfVxuICAgIGlmIChlbmRBIDwgc3RhcnQgJiYgYS5zaXplIDwgYi5zaXplKSB7XG4gICAgICAgIGxldCBtb3ZlID0gcHJlZmVycmVkUG9zIDw9IHN0YXJ0ICYmIHByZWZlcnJlZFBvcyA+PSBlbmRBID8gc3RhcnQgLSBwcmVmZXJyZWRQb3MgOiAwO1xuICAgICAgICBzdGFydCAtPSBtb3ZlO1xuICAgICAgICBpZiAoc3RhcnQgJiYgc3RhcnQgPCBiLnNpemUgJiYgaXNTdXJyb2dhdGVQYWlyKGIudGV4dEJldHdlZW4oc3RhcnQgLSAxLCBzdGFydCArIDEpKSlcbiAgICAgICAgICAgIHN0YXJ0ICs9IG1vdmUgPyAxIDogLTE7XG4gICAgICAgIGVuZEIgPSBzdGFydCArIChlbmRCIC0gZW5kQSk7XG4gICAgICAgIGVuZEEgPSBzdGFydDtcbiAgICB9XG4gICAgZWxzZSBpZiAoZW5kQiA8IHN0YXJ0KSB7XG4gICAgICAgIGxldCBtb3ZlID0gcHJlZmVycmVkUG9zIDw9IHN0YXJ0ICYmIHByZWZlcnJlZFBvcyA+PSBlbmRCID8gc3RhcnQgLSBwcmVmZXJyZWRQb3MgOiAwO1xuICAgICAgICBzdGFydCAtPSBtb3ZlO1xuICAgICAgICBpZiAoc3RhcnQgJiYgc3RhcnQgPCBhLnNpemUgJiYgaXNTdXJyb2dhdGVQYWlyKGEudGV4dEJldHdlZW4oc3RhcnQgLSAxLCBzdGFydCArIDEpKSlcbiAgICAgICAgICAgIHN0YXJ0ICs9IG1vdmUgPyAxIDogLTE7XG4gICAgICAgIGVuZEEgPSBzdGFydCArIChlbmRBIC0gZW5kQik7XG4gICAgICAgIGVuZEIgPSBzdGFydDtcbiAgICB9XG4gICAgcmV0dXJuIHsgc3RhcnQsIGVuZEEsIGVuZEIgfTtcbn1cbmZ1bmN0aW9uIGlzU3Vycm9nYXRlUGFpcihzdHIpIHtcbiAgICBpZiAoc3RyLmxlbmd0aCAhPSAyKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGEgPSBzdHIuY2hhckNvZGVBdCgwKSwgYiA9IHN0ci5jaGFyQ29kZUF0KDEpO1xuICAgIHJldHVybiBhID49IDB4REMwMCAmJiBhIDw9IDB4REZGRiAmJiBiID49IDB4RDgwMCAmJiBiIDw9IDB4REJGRjtcbn1cblxuLyoqXG5AaW50ZXJuYWxcbiovXG5jb25zdCBfX3BhcnNlRnJvbUNsaXBib2FyZCA9IHBhcnNlRnJvbUNsaXBib2FyZDtcbi8qKlxuQGludGVybmFsXG4qL1xuY29uc3QgX19lbmRDb21wb3NpdGlvbiA9IGVuZENvbXBvc2l0aW9uO1xuLyoqXG5BbiBlZGl0b3IgdmlldyBtYW5hZ2VzIHRoZSBET00gc3RydWN0dXJlIHRoYXQgcmVwcmVzZW50cyBhblxuZWRpdGFibGUgZG9jdW1lbnQuIEl0cyBzdGF0ZSBhbmQgYmVoYXZpb3IgYXJlIGRldGVybWluZWQgYnkgaXRzXG5bcHJvcHNdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN2aWV3LkRpcmVjdEVkaXRvclByb3BzKS5cbiovXG5jbGFzcyBFZGl0b3JWaWV3IHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSB2aWV3LiBgcGxhY2VgIG1heSBiZSBhIERPTSBub2RlIHRoYXQgdGhlIGVkaXRvciBzaG91bGRcbiAgICBiZSBhcHBlbmRlZCB0bywgYSBmdW5jdGlvbiB0aGF0IHdpbGwgcGxhY2UgaXQgaW50byB0aGUgZG9jdW1lbnQsXG4gICAgb3IgYW4gb2JqZWN0IHdob3NlIGBtb3VudGAgcHJvcGVydHkgaG9sZHMgdGhlIG5vZGUgdG8gdXNlIGFzIHRoZVxuICAgIGRvY3VtZW50IGNvbnRhaW5lci4gSWYgaXQgaXMgYG51bGxgLCB0aGUgZWRpdG9yIHdpbGwgbm90IGJlXG4gICAgYWRkZWQgdG8gdGhlIGRvY3VtZW50LlxuICAgICovXG4gICAgY29uc3RydWN0b3IocGxhY2UsIHByb3BzKSB7XG4gICAgICAgIHRoaXMuX3Jvb3QgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuZm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgS2x1ZGdlIHVzZWQgdG8gd29yayBhcm91bmQgYSBDaHJvbWUgYnVnIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnRyYWNrV3JpdGVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5tb3VudGVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYXJrQ3Vyc29yID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmN1cnNvcldyYXBwZXIgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMubGFzdFNlbGVjdGVkVmlld0Rlc2MgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbnB1dCA9IG5ldyBJbnB1dFN0YXRlO1xuICAgICAgICB0aGlzLnByZXZEaXJlY3RQbHVnaW5zID0gW107XG4gICAgICAgIHRoaXMucGx1Z2luVmlld3MgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgIEhvbGRzIGB0cnVlYCB3aGVuIGEgaGFjayBub2RlIGlzIG5lZWRlZCBpbiBGaXJlZm94IHRvIHByZXZlbnQgdGhlXG4gICAgICAgIFtzcGFjZSBpcyBlYXRlbiBpc3N1ZV0oaHR0cHM6Ly9naXRodWIuY29tL1Byb3NlTWlycm9yL3Byb3NlbWlycm9yL2lzc3Vlcy82NTEpXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlcXVpcmVzR2Vja29IYWNrTm9kZSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgV2hlbiBlZGl0b3IgY29udGVudCBpcyBiZWluZyBkcmFnZ2VkLCB0aGlzIG9iamVjdCBjb250YWluc1xuICAgICAgICBpbmZvcm1hdGlvbiBhYm91dCB0aGUgZHJhZ2dlZCBzbGljZSBhbmQgd2hldGhlciBpdCBpcyBiZWluZ1xuICAgICAgICBjb3BpZWQgb3IgbW92ZWQuIEF0IGFueSBvdGhlciB0aW1lLCBpdCBpcyBudWxsLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmRyYWdnaW5nID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJvcHMgPSBwcm9wcztcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHByb3BzLnN0YXRlO1xuICAgICAgICB0aGlzLmRpcmVjdFBsdWdpbnMgPSBwcm9wcy5wbHVnaW5zIHx8IFtdO1xuICAgICAgICB0aGlzLmRpcmVjdFBsdWdpbnMuZm9yRWFjaChjaGVja1N0YXRlQ29tcG9uZW50KTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCA9IHRoaXMuZGlzcGF0Y2guYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5kb20gPSAocGxhY2UgJiYgcGxhY2UubW91bnQpIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGlmIChwbGFjZSkge1xuICAgICAgICAgICAgaWYgKHBsYWNlLmFwcGVuZENoaWxkKVxuICAgICAgICAgICAgICAgIHBsYWNlLmFwcGVuZENoaWxkKHRoaXMuZG9tKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBwbGFjZSA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICAgICAgcGxhY2UodGhpcy5kb20pO1xuICAgICAgICAgICAgZWxzZSBpZiAocGxhY2UubW91bnQpXG4gICAgICAgICAgICAgICAgdGhpcy5tb3VudGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVkaXRhYmxlID0gZ2V0RWRpdGFibGUodGhpcyk7XG4gICAgICAgIHVwZGF0ZUN1cnNvcldyYXBwZXIodGhpcyk7XG4gICAgICAgIHRoaXMubm9kZVZpZXdzID0gYnVpbGROb2RlVmlld3ModGhpcyk7XG4gICAgICAgIHRoaXMuZG9jVmlldyA9IGRvY1ZpZXdEZXNjKHRoaXMuc3RhdGUuZG9jLCBjb21wdXRlRG9jRGVjbyh0aGlzKSwgdmlld0RlY29yYXRpb25zKHRoaXMpLCB0aGlzLmRvbSwgdGhpcyk7XG4gICAgICAgIHRoaXMuZG9tT2JzZXJ2ZXIgPSBuZXcgRE9NT2JzZXJ2ZXIodGhpcywgKGZyb20sIHRvLCB0eXBlT3ZlciwgYWRkZWQpID0+IHJlYWRET01DaGFuZ2UodGhpcywgZnJvbSwgdG8sIHR5cGVPdmVyLCBhZGRlZCkpO1xuICAgICAgICB0aGlzLmRvbU9ic2VydmVyLnN0YXJ0KCk7XG4gICAgICAgIGluaXRJbnB1dCh0aGlzKTtcbiAgICAgICAgdGhpcy51cGRhdGVQbHVnaW5WaWV3cygpO1xuICAgIH1cbiAgICAvKipcbiAgICBIb2xkcyBgdHJ1ZWAgd2hlbiBhXG4gICAgW2NvbXBvc2l0aW9uXShodHRwczovL3czYy5naXRodWIuaW8vdWlldmVudHMvI2V2ZW50cy1jb21wb3NpdGlvbmV2ZW50cylcbiAgICBpcyBhY3RpdmUuXG4gICAgKi9cbiAgICBnZXQgY29tcG9zaW5nKCkgeyByZXR1cm4gdGhpcy5pbnB1dC5jb21wb3Npbmc7IH1cbiAgICAvKipcbiAgICBUaGUgdmlldydzIGN1cnJlbnQgW3Byb3BzXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5FZGl0b3JQcm9wcykuXG4gICAgKi9cbiAgICBnZXQgcHJvcHMoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcm9wcy5zdGF0ZSAhPSB0aGlzLnN0YXRlKSB7XG4gICAgICAgICAgICBsZXQgcHJldiA9IHRoaXMuX3Byb3BzO1xuICAgICAgICAgICAgdGhpcy5fcHJvcHMgPSB7fTtcbiAgICAgICAgICAgIGZvciAobGV0IG5hbWUgaW4gcHJldilcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9wc1tuYW1lXSA9IHByZXZbbmFtZV07XG4gICAgICAgICAgICB0aGlzLl9wcm9wcy5zdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb3BzO1xuICAgIH1cbiAgICAvKipcbiAgICBVcGRhdGUgdGhlIHZpZXcncyBwcm9wcy4gV2lsbCBpbW1lZGlhdGVseSBjYXVzZSBhbiB1cGRhdGUgdG9cbiAgICB0aGUgRE9NLlxuICAgICovXG4gICAgdXBkYXRlKHByb3BzKSB7XG4gICAgICAgIGlmIChwcm9wcy5oYW5kbGVET01FdmVudHMgIT0gdGhpcy5fcHJvcHMuaGFuZGxlRE9NRXZlbnRzKVxuICAgICAgICAgICAgZW5zdXJlTGlzdGVuZXJzKHRoaXMpO1xuICAgICAgICBsZXQgcHJldlByb3BzID0gdGhpcy5fcHJvcHM7XG4gICAgICAgIHRoaXMuX3Byb3BzID0gcHJvcHM7XG4gICAgICAgIGlmIChwcm9wcy5wbHVnaW5zKSB7XG4gICAgICAgICAgICBwcm9wcy5wbHVnaW5zLmZvckVhY2goY2hlY2tTdGF0ZUNvbXBvbmVudCk7XG4gICAgICAgICAgICB0aGlzLmRpcmVjdFBsdWdpbnMgPSBwcm9wcy5wbHVnaW5zO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlU3RhdGVJbm5lcihwcm9wcy5zdGF0ZSwgcHJldlByb3BzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVXBkYXRlIHRoZSB2aWV3IGJ5IHVwZGF0aW5nIGV4aXN0aW5nIHByb3BzIG9iamVjdCB3aXRoIHRoZSBvYmplY3RcbiAgICBnaXZlbiBhcyBhcmd1bWVudC4gRXF1aXZhbGVudCB0byBgdmlldy51cGRhdGUoT2JqZWN0LmFzc2lnbih7fSxcbiAgICB2aWV3LnByb3BzLCBwcm9wcykpYC5cbiAgICAqL1xuICAgIHNldFByb3BzKHByb3BzKSB7XG4gICAgICAgIGxldCB1cGRhdGVkID0ge307XG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gdGhpcy5fcHJvcHMpXG4gICAgICAgICAgICB1cGRhdGVkW25hbWVdID0gdGhpcy5fcHJvcHNbbmFtZV07XG4gICAgICAgIHVwZGF0ZWQuc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgICBmb3IgKGxldCBuYW1lIGluIHByb3BzKVxuICAgICAgICAgICAgdXBkYXRlZFtuYW1lXSA9IHByb3BzW25hbWVdO1xuICAgICAgICB0aGlzLnVwZGF0ZSh1cGRhdGVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVXBkYXRlIHRoZSBlZGl0b3IncyBgc3RhdGVgIHByb3AsIHdpdGhvdXQgdG91Y2hpbmcgYW55IG9mIHRoZVxuICAgIG90aGVyIHByb3BzLlxuICAgICovXG4gICAgdXBkYXRlU3RhdGUoc3RhdGUpIHtcbiAgICAgICAgdGhpcy51cGRhdGVTdGF0ZUlubmVyKHN0YXRlLCB0aGlzLl9wcm9wcyk7XG4gICAgfVxuICAgIHVwZGF0ZVN0YXRlSW5uZXIoc3RhdGUsIHByZXZQcm9wcykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCBwcmV2ID0gdGhpcy5zdGF0ZSwgcmVkcmF3ID0gZmFsc2UsIHVwZGF0ZVNlbCA9IGZhbHNlO1xuICAgICAgICAvLyBXaGVuIHN0b3JlZCBtYXJrcyBhcmUgYWRkZWQsIHN0b3AgY29tcG9zaXRpb24sIHNvIHRoYXQgdGhleSBjYW5cbiAgICAgICAgLy8gYmUgZGlzcGxheWVkLlxuICAgICAgICBpZiAoc3RhdGUuc3RvcmVkTWFya3MgJiYgdGhpcy5jb21wb3NpbmcpIHtcbiAgICAgICAgICAgIGNsZWFyQ29tcG9zaXRpb24odGhpcyk7XG4gICAgICAgICAgICB1cGRhdGVTZWwgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgbGV0IHBsdWdpbnNDaGFuZ2VkID0gcHJldi5wbHVnaW5zICE9IHN0YXRlLnBsdWdpbnMgfHwgdGhpcy5fcHJvcHMucGx1Z2lucyAhPSBwcmV2UHJvcHMucGx1Z2lucztcbiAgICAgICAgaWYgKHBsdWdpbnNDaGFuZ2VkIHx8IHRoaXMuX3Byb3BzLnBsdWdpbnMgIT0gcHJldlByb3BzLnBsdWdpbnMgfHwgdGhpcy5fcHJvcHMubm9kZVZpZXdzICE9IHByZXZQcm9wcy5ub2RlVmlld3MpIHtcbiAgICAgICAgICAgIGxldCBub2RlVmlld3MgPSBidWlsZE5vZGVWaWV3cyh0aGlzKTtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VkTm9kZVZpZXdzKG5vZGVWaWV3cywgdGhpcy5ub2RlVmlld3MpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlVmlld3MgPSBub2RlVmlld3M7XG4gICAgICAgICAgICAgICAgcmVkcmF3ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocGx1Z2luc0NoYW5nZWQgfHwgcHJldlByb3BzLmhhbmRsZURPTUV2ZW50cyAhPSB0aGlzLl9wcm9wcy5oYW5kbGVET01FdmVudHMpIHtcbiAgICAgICAgICAgIGVuc3VyZUxpc3RlbmVycyh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVkaXRhYmxlID0gZ2V0RWRpdGFibGUodGhpcyk7XG4gICAgICAgIHVwZGF0ZUN1cnNvcldyYXBwZXIodGhpcyk7XG4gICAgICAgIGxldCBpbm5lckRlY28gPSB2aWV3RGVjb3JhdGlvbnModGhpcyksIG91dGVyRGVjbyA9IGNvbXB1dGVEb2NEZWNvKHRoaXMpO1xuICAgICAgICBsZXQgc2Nyb2xsID0gcHJldi5wbHVnaW5zICE9IHN0YXRlLnBsdWdpbnMgJiYgIXByZXYuZG9jLmVxKHN0YXRlLmRvYykgPyBcInJlc2V0XCJcbiAgICAgICAgICAgIDogc3RhdGUuc2Nyb2xsVG9TZWxlY3Rpb24gPiBwcmV2LnNjcm9sbFRvU2VsZWN0aW9uID8gXCJ0byBzZWxlY3Rpb25cIiA6IFwicHJlc2VydmVcIjtcbiAgICAgICAgbGV0IHVwZGF0ZURvYyA9IHJlZHJhdyB8fCAhdGhpcy5kb2NWaWV3Lm1hdGNoZXNOb2RlKHN0YXRlLmRvYywgb3V0ZXJEZWNvLCBpbm5lckRlY28pO1xuICAgICAgICBpZiAodXBkYXRlRG9jIHx8ICFzdGF0ZS5zZWxlY3Rpb24uZXEocHJldi5zZWxlY3Rpb24pKVxuICAgICAgICAgICAgdXBkYXRlU2VsID0gdHJ1ZTtcbiAgICAgICAgbGV0IG9sZFNjcm9sbFBvcyA9IHNjcm9sbCA9PSBcInByZXNlcnZlXCIgJiYgdXBkYXRlU2VsICYmIHRoaXMuZG9tLnN0eWxlLm92ZXJmbG93QW5jaG9yID09IG51bGwgJiYgc3RvcmVTY3JvbGxQb3ModGhpcyk7XG4gICAgICAgIGlmICh1cGRhdGVTZWwpIHtcbiAgICAgICAgICAgIHRoaXMuZG9tT2JzZXJ2ZXIuc3RvcCgpO1xuICAgICAgICAgICAgLy8gV29yayBhcm91bmQgYW4gaXNzdWUgaW4gQ2hyb21lLCBJRSwgYW5kIEVkZ2Ugd2hlcmUgY2hhbmdpbmdcbiAgICAgICAgICAgIC8vIHRoZSBET00gYXJvdW5kIGFuIGFjdGl2ZSBzZWxlY3Rpb24gcHV0cyBpdCBpbnRvIGEgYnJva2VuXG4gICAgICAgICAgICAvLyBzdGF0ZSB3aGVyZSB0aGUgdGhpbmcgdGhlIHVzZXIgc2VlcyBkaWZmZXJzIGZyb20gdGhlXG4gICAgICAgICAgICAvLyBzZWxlY3Rpb24gcmVwb3J0ZWQgYnkgdGhlIFNlbGVjdGlvbiBvYmplY3QgKCM3MTAsICM5NzMsXG4gICAgICAgICAgICAvLyAjMTAxMSwgIzEwMTMsICMxMDM1KS5cbiAgICAgICAgICAgIGxldCBmb3JjZVNlbFVwZGF0ZSA9IHVwZGF0ZURvYyAmJiAoaWUgfHwgY2hyb21lKSAmJiAhdGhpcy5jb21wb3NpbmcgJiZcbiAgICAgICAgICAgICAgICAhcHJldi5zZWxlY3Rpb24uZW1wdHkgJiYgIXN0YXRlLnNlbGVjdGlvbi5lbXB0eSAmJiBzZWxlY3Rpb25Db250ZXh0Q2hhbmdlZChwcmV2LnNlbGVjdGlvbiwgc3RhdGUuc2VsZWN0aW9uKTtcbiAgICAgICAgICAgIGlmICh1cGRhdGVEb2MpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgbm9kZSB0aGF0IHRoZSBzZWxlY3Rpb24gcG9pbnRzIGludG8gaXMgd3JpdHRlbiB0byxcbiAgICAgICAgICAgICAgICAvLyBDaHJvbWUgc29tZXRpbWVzIHN0YXJ0cyBtaXNyZXBvcnRpbmcgdGhlIHNlbGVjdGlvbiwgc28gdGhpc1xuICAgICAgICAgICAgICAgIC8vIHRyYWNrcyB0aGF0IGFuZCBmb3JjZXMgYSBzZWxlY3Rpb24gcmVzZXQgd2hlbiBvdXIgdXBkYXRlXG4gICAgICAgICAgICAgICAgLy8gZGlkIHdyaXRlIHRvIHRoZSBub2RlLlxuICAgICAgICAgICAgICAgIGxldCBjaHJvbWVLbHVkZ2UgPSBjaHJvbWUgPyAodGhpcy50cmFja1dyaXRlcyA9IHRoaXMuZG9tU2VsZWN0aW9uUmFuZ2UoKS5mb2N1c05vZGUpIDogbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb21wb3NpbmcpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5wdXQuY29tcG9zaXRpb25Ob2RlID0gZmluZENvbXBvc2l0aW9uTm9kZSh0aGlzKTtcbiAgICAgICAgICAgICAgICBpZiAocmVkcmF3IHx8ICF0aGlzLmRvY1ZpZXcudXBkYXRlKHN0YXRlLmRvYywgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9jVmlldy51cGRhdGVPdXRlckRlY28ob3V0ZXJEZWNvKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb2NWaWV3LmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb2NWaWV3ID0gZG9jVmlld0Rlc2Moc3RhdGUuZG9jLCBvdXRlckRlY28sIGlubmVyRGVjbywgdGhpcy5kb20sIHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2hyb21lS2x1ZGdlICYmICF0aGlzLnRyYWNrV3JpdGVzKVxuICAgICAgICAgICAgICAgICAgICBmb3JjZVNlbFVwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXb3JrIGFyb3VuZCBmb3IgYW4gaXNzdWUgd2hlcmUgYW4gdXBkYXRlIGFycml2aW5nIHJpZ2h0IGJldHdlZW5cbiAgICAgICAgICAgIC8vIGEgRE9NIHNlbGVjdGlvbiBjaGFuZ2UgYW5kIHRoZSBcInNlbGVjdGlvbmNoYW5nZVwiIGV2ZW50IGZvciBpdFxuICAgICAgICAgICAgLy8gY2FuIGNhdXNlIGEgc3B1cmlvdXMgRE9NIHNlbGVjdGlvbiB1cGRhdGUsIGRpc3J1cHRpbmcgbW91c2VcbiAgICAgICAgICAgIC8vIGRyYWcgc2VsZWN0aW9uLlxuICAgICAgICAgICAgaWYgKGZvcmNlU2VsVXBkYXRlIHx8XG4gICAgICAgICAgICAgICAgISh0aGlzLmlucHV0Lm1vdXNlRG93biAmJiB0aGlzLmRvbU9ic2VydmVyLmN1cnJlbnRTZWxlY3Rpb24uZXEodGhpcy5kb21TZWxlY3Rpb25SYW5nZSgpKSAmJlxuICAgICAgICAgICAgICAgICAgICBhbmNob3JJblJpZ2h0UGxhY2UodGhpcykpKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uVG9ET00odGhpcywgZm9yY2VTZWxVcGRhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3luY05vZGVTZWxlY3Rpb24odGhpcywgc3RhdGUuc2VsZWN0aW9uKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRvbU9ic2VydmVyLnNldEN1clNlbGVjdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kb21PYnNlcnZlci5zdGFydCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlUGx1Z2luVmlld3MocHJldik7XG4gICAgICAgIGlmICgoKF9hID0gdGhpcy5kcmFnZ2luZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5vZGUpICYmICFwcmV2LmRvYy5lcShzdGF0ZS5kb2MpKVxuICAgICAgICAgICAgdGhpcy51cGRhdGVEcmFnZ2VkTm9kZSh0aGlzLmRyYWdnaW5nLCBwcmV2KTtcbiAgICAgICAgaWYgKHNjcm9sbCA9PSBcInJlc2V0XCIpIHtcbiAgICAgICAgICAgIHRoaXMuZG9tLnNjcm9sbFRvcCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2Nyb2xsID09IFwidG8gc2VsZWN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9TZWxlY3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvbGRTY3JvbGxQb3MpIHtcbiAgICAgICAgICAgIHJlc2V0U2Nyb2xsUG9zKG9sZFNjcm9sbFBvcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzY3JvbGxUb1NlbGVjdGlvbigpIHtcbiAgICAgICAgbGV0IHN0YXJ0RE9NID0gdGhpcy5kb21TZWxlY3Rpb25SYW5nZSgpLmZvY3VzTm9kZTtcbiAgICAgICAgaWYgKCFzdGFydERPTSB8fCAhdGhpcy5kb20uY29udGFpbnMoc3RhcnRET00ubm9kZVR5cGUgPT0gMSA/IHN0YXJ0RE9NIDogc3RhcnRET00ucGFyZW50Tm9kZSkpIDtcbiAgICAgICAgZWxzZSBpZiAodGhpcy5zb21lUHJvcChcImhhbmRsZVNjcm9sbFRvU2VsZWN0aW9uXCIsIGYgPT4gZih0aGlzKSkpIDtcbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gdGhpcy5kb2NWaWV3LmRvbUFmdGVyUG9zKHRoaXMuc3RhdGUuc2VsZWN0aW9uLmZyb20pO1xuICAgICAgICAgICAgaWYgKHRhcmdldC5ub2RlVHlwZSA9PSAxKVxuICAgICAgICAgICAgICAgIHNjcm9sbFJlY3RJbnRvVmlldyh0aGlzLCB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHN0YXJ0RE9NKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNjcm9sbFJlY3RJbnRvVmlldyh0aGlzLCB0aGlzLmNvb3Jkc0F0UG9zKHRoaXMuc3RhdGUuc2VsZWN0aW9uLmhlYWQsIDEpLCBzdGFydERPTSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveVBsdWdpblZpZXdzKCkge1xuICAgICAgICBsZXQgdmlldztcbiAgICAgICAgd2hpbGUgKHZpZXcgPSB0aGlzLnBsdWdpblZpZXdzLnBvcCgpKVxuICAgICAgICAgICAgaWYgKHZpZXcuZGVzdHJveSlcbiAgICAgICAgICAgICAgICB2aWV3LmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdXBkYXRlUGx1Z2luVmlld3MocHJldlN0YXRlKSB7XG4gICAgICAgIGlmICghcHJldlN0YXRlIHx8IHByZXZTdGF0ZS5wbHVnaW5zICE9IHRoaXMuc3RhdGUucGx1Z2lucyB8fCB0aGlzLmRpcmVjdFBsdWdpbnMgIT0gdGhpcy5wcmV2RGlyZWN0UGx1Z2lucykge1xuICAgICAgICAgICAgdGhpcy5wcmV2RGlyZWN0UGx1Z2lucyA9IHRoaXMuZGlyZWN0UGx1Z2lucztcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveVBsdWdpblZpZXdzKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZGlyZWN0UGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBwbHVnaW4gPSB0aGlzLmRpcmVjdFBsdWdpbnNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHBsdWdpbi5zcGVjLnZpZXcpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luVmlld3MucHVzaChwbHVnaW4uc3BlYy52aWV3KHRoaXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdGF0ZS5wbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBsdWdpbiA9IHRoaXMuc3RhdGUucGx1Z2luc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAocGx1Z2luLnNwZWMudmlldylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW5WaWV3cy5wdXNoKHBsdWdpbi5zcGVjLnZpZXcodGhpcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnBsdWdpblZpZXdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBsdWdpblZpZXcgPSB0aGlzLnBsdWdpblZpZXdzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChwbHVnaW5WaWV3LnVwZGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgcGx1Z2luVmlldy51cGRhdGUodGhpcywgcHJldlN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVEcmFnZ2VkTm9kZShkcmFnZ2luZywgcHJldikge1xuICAgICAgICBsZXQgc2VsID0gZHJhZ2dpbmcubm9kZSwgZm91bmQgPSAtMTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuZG9jLm5vZGVBdChzZWwuZnJvbSkgPT0gc2VsLm5vZGUpIHtcbiAgICAgICAgICAgIGZvdW5kID0gc2VsLmZyb207XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbW92ZWRQb3MgPSBzZWwuZnJvbSArICh0aGlzLnN0YXRlLmRvYy5jb250ZW50LnNpemUgLSBwcmV2LmRvYy5jb250ZW50LnNpemUpO1xuICAgICAgICAgICAgbGV0IG1vdmVkID0gbW92ZWRQb3MgPiAwICYmIHRoaXMuc3RhdGUuZG9jLm5vZGVBdChtb3ZlZFBvcyk7XG4gICAgICAgICAgICBpZiAobW92ZWQgPT0gc2VsLm5vZGUpXG4gICAgICAgICAgICAgICAgZm91bmQgPSBtb3ZlZFBvcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRyYWdnaW5nID0gbmV3IERyYWdnaW5nKGRyYWdnaW5nLnNsaWNlLCBkcmFnZ2luZy5tb3ZlLCBmb3VuZCA8IDAgPyB1bmRlZmluZWQgOiBOb2RlU2VsZWN0aW9uLmNyZWF0ZSh0aGlzLnN0YXRlLmRvYywgZm91bmQpKTtcbiAgICB9XG4gICAgc29tZVByb3AocHJvcE5hbWUsIGYpIHtcbiAgICAgICAgbGV0IHByb3AgPSB0aGlzLl9wcm9wcyAmJiB0aGlzLl9wcm9wc1twcm9wTmFtZV0sIHZhbHVlO1xuICAgICAgICBpZiAocHJvcCAhPSBudWxsICYmICh2YWx1ZSA9IGYgPyBmKHByb3ApIDogcHJvcCkpXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5kaXJlY3RQbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcHJvcCA9IHRoaXMuZGlyZWN0UGx1Z2luc1tpXS5wcm9wc1twcm9wTmFtZV07XG4gICAgICAgICAgICBpZiAocHJvcCAhPSBudWxsICYmICh2YWx1ZSA9IGYgPyBmKHByb3ApIDogcHJvcCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwbHVnaW5zID0gdGhpcy5zdGF0ZS5wbHVnaW5zO1xuICAgICAgICBpZiAocGx1Z2lucylcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBwcm9wID0gcGx1Z2luc1tpXS5wcm9wc1twcm9wTmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKHByb3AgIT0gbnVsbCAmJiAodmFsdWUgPSBmID8gZihwcm9wKSA6IHByb3ApKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIFF1ZXJ5IHdoZXRoZXIgdGhlIHZpZXcgaGFzIGZvY3VzLlxuICAgICovXG4gICAgaGFzRm9jdXMoKSB7XG4gICAgICAgIC8vIFdvcmsgYXJvdW5kIElFIG5vdCBoYW5kbGluZyBmb2N1cyBjb3JyZWN0bHkgaWYgcmVzaXplIGhhbmRsZXMgYXJlIHNob3duLlxuICAgICAgICAvLyBJZiB0aGUgY3Vyc29yIGlzIGluc2lkZSBhbiBlbGVtZW50IHdpdGggcmVzaXplIGhhbmRsZXMsIGFjdGl2ZUVsZW1lbnRcbiAgICAgICAgLy8gd2lsbCBiZSB0aGF0IGVsZW1lbnQgaW5zdGVhZCBvZiB0aGlzLmRvbS5cbiAgICAgICAgaWYgKGllKSB7XG4gICAgICAgICAgICAvLyBJZiBhY3RpdmVFbGVtZW50IGlzIHdpdGhpbiB0aGlzLmRvbSwgYW5kIHRoZXJlIGFyZSBubyBvdGhlciBlbGVtZW50c1xuICAgICAgICAgICAgLy8gc2V0dGluZyBgY29udGVudGVkaXRhYmxlYCB0byBmYWxzZSBpbiBiZXR3ZWVuLCB0cmVhdCBpdCBhcyBmb2N1c2VkLlxuICAgICAgICAgICAgbGV0IG5vZGUgPSB0aGlzLnJvb3QuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgICAgIGlmIChub2RlID09IHRoaXMuZG9tKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgaWYgKCFub2RlIHx8ICF0aGlzLmRvbS5jb250YWlucyhub2RlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB3aGlsZSAobm9kZSAmJiB0aGlzLmRvbSAhPSBub2RlICYmIHRoaXMuZG9tLmNvbnRhaW5zKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuY29udGVudEVkaXRhYmxlID09ICdmYWxzZScpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5hY3RpdmVFbGVtZW50ID09IHRoaXMuZG9tO1xuICAgIH1cbiAgICAvKipcbiAgICBGb2N1cyB0aGUgZWRpdG9yLlxuICAgICovXG4gICAgZm9jdXMoKSB7XG4gICAgICAgIHRoaXMuZG9tT2JzZXJ2ZXIuc3RvcCgpO1xuICAgICAgICBpZiAodGhpcy5lZGl0YWJsZSlcbiAgICAgICAgICAgIGZvY3VzUHJldmVudFNjcm9sbCh0aGlzLmRvbSk7XG4gICAgICAgIHNlbGVjdGlvblRvRE9NKHRoaXMpO1xuICAgICAgICB0aGlzLmRvbU9ic2VydmVyLnN0YXJ0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgZG9jdW1lbnQgcm9vdCBpbiB3aGljaCB0aGUgZWRpdG9yIGV4aXN0cy4gVGhpcyB3aWxsXG4gICAgdXN1YWxseSBiZSB0aGUgdG9wLWxldmVsIGBkb2N1bWVudGAsIGJ1dCBtaWdodCBiZSBhIFtzaGFkb3dcbiAgICBET01dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL1dlYl9Db21wb25lbnRzL1NoYWRvd19ET00pXG4gICAgcm9vdCBpZiB0aGUgZWRpdG9yIGlzIGluc2lkZSBvbmUuXG4gICAgKi9cbiAgICBnZXQgcm9vdCgpIHtcbiAgICAgICAgbGV0IGNhY2hlZCA9IHRoaXMuX3Jvb3Q7XG4gICAgICAgIGlmIChjYWNoZWQgPT0gbnVsbClcbiAgICAgICAgICAgIGZvciAobGV0IHNlYXJjaCA9IHRoaXMuZG9tLnBhcmVudE5vZGU7IHNlYXJjaDsgc2VhcmNoID0gc2VhcmNoLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VhcmNoLm5vZGVUeXBlID09IDkgfHwgKHNlYXJjaC5ub2RlVHlwZSA9PSAxMSAmJiBzZWFyY2guaG9zdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWFyY2guZ2V0U2VsZWN0aW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmdldFByb3RvdHlwZU9mKHNlYXJjaCkuZ2V0U2VsZWN0aW9uID0gKCkgPT4gc2VhcmNoLm93bmVyRG9jdW1lbnQuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yb290ID0gc2VhcmNoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhY2hlZCB8fCBkb2N1bWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgV2hlbiBhbiBleGlzdGluZyBlZGl0b3IgdmlldyBpcyBtb3ZlZCB0byBhIG5ldyBkb2N1bWVudCBvclxuICAgIHNoYWRvdyB0cmVlLCBjYWxsIHRoaXMgdG8gbWFrZSBpdCByZWNvbXB1dGUgaXRzIHJvb3QuXG4gICAgKi9cbiAgICB1cGRhdGVSb290KCkge1xuICAgICAgICB0aGlzLl9yb290ID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgR2l2ZW4gYSBwYWlyIG9mIHZpZXdwb3J0IGNvb3JkaW5hdGVzLCByZXR1cm4gdGhlIGRvY3VtZW50XG4gICAgcG9zaXRpb24gdGhhdCBjb3JyZXNwb25kcyB0byB0aGVtLiBNYXkgcmV0dXJuIG51bGwgaWYgdGhlIGdpdmVuXG4gICAgY29vcmRpbmF0ZXMgYXJlbid0IGluc2lkZSBvZiB0aGUgZWRpdG9yLiBXaGVuIGFuIG9iamVjdCBpc1xuICAgIHJldHVybmVkLCBpdHMgYHBvc2AgcHJvcGVydHkgaXMgdGhlIHBvc2l0aW9uIG5lYXJlc3QgdG8gdGhlXG4gICAgY29vcmRpbmF0ZXMsIGFuZCBpdHMgYGluc2lkZWAgcHJvcGVydHkgaG9sZHMgdGhlIHBvc2l0aW9uIG9mIHRoZVxuICAgIGlubmVyIG5vZGUgdGhhdCB0aGUgcG9zaXRpb24gZmFsbHMgaW5zaWRlIG9mLCBvciAtMSBpZiBpdCBpcyBhdFxuICAgIHRoZSB0b3AgbGV2ZWwsIG5vdCBpbiBhbnkgbm9kZS5cbiAgICAqL1xuICAgIHBvc0F0Q29vcmRzKGNvb3Jkcykge1xuICAgICAgICByZXR1cm4gcG9zQXRDb29yZHModGhpcywgY29vcmRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0aGUgdmlld3BvcnQgcmVjdGFuZ2xlIGF0IGEgZ2l2ZW4gZG9jdW1lbnQgcG9zaXRpb24uXG4gICAgYGxlZnRgIGFuZCBgcmlnaHRgIHdpbGwgYmUgdGhlIHNhbWUgbnVtYmVyLCBhcyB0aGlzIHJldHVybnMgYVxuICAgIGZsYXQgY3Vyc29yLWlzaCByZWN0YW5nbGUuIElmIHRoZSBwb3NpdGlvbiBpcyBiZXR3ZWVuIHR3byB0aGluZ3NcbiAgICB0aGF0IGFyZW4ndCBkaXJlY3RseSBhZGphY2VudCwgYHNpZGVgIGRldGVybWluZXMgd2hpY2ggZWxlbWVudFxuICAgIGlzIHVzZWQuIFdoZW4gPCAwLCB0aGUgZWxlbWVudCBiZWZvcmUgdGhlIHBvc2l0aW9uIGlzIHVzZWQsXG4gICAgb3RoZXJ3aXNlIHRoZSBlbGVtZW50IGFmdGVyLlxuICAgICovXG4gICAgY29vcmRzQXRQb3MocG9zLCBzaWRlID0gMSkge1xuICAgICAgICByZXR1cm4gY29vcmRzQXRQb3ModGhpcywgcG9zLCBzaWRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgRE9NIHBvc2l0aW9uIHRoYXQgY29ycmVzcG9uZHMgdG8gdGhlIGdpdmVuIGRvY3VtZW50XG4gICAgcG9zaXRpb24uIFdoZW4gYHNpZGVgIGlzIG5lZ2F0aXZlLCBmaW5kIHRoZSBwb3NpdGlvbiBhcyBjbG9zZSBhc1xuICAgIHBvc3NpYmxlIHRvIHRoZSBjb250ZW50IGJlZm9yZSB0aGUgcG9zaXRpb24uIFdoZW4gcG9zaXRpdmUsXG4gICAgcHJlZmVyIHBvc2l0aW9ucyBjbG9zZSB0byB0aGUgY29udGVudCBhZnRlciB0aGUgcG9zaXRpb24uIFdoZW5cbiAgICB6ZXJvLCBwcmVmZXIgYXMgc2hhbGxvdyBhIHBvc2l0aW9uIGFzIHBvc3NpYmxlLlxuICAgIFxuICAgIE5vdGUgdGhhdCB5b3Ugc2hvdWxkICoqbm90KiogbXV0YXRlIHRoZSBlZGl0b3IncyBpbnRlcm5hbCBET00sXG4gICAgb25seSBpbnNwZWN0IGl0IChhbmQgZXZlbiB0aGF0IGlzIHVzdWFsbHkgbm90IG5lY2Vzc2FyeSkuXG4gICAgKi9cbiAgICBkb21BdFBvcyhwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY1ZpZXcuZG9tRnJvbVBvcyhwb3MsIHNpZGUpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBET00gbm9kZSB0aGF0IHJlcHJlc2VudHMgdGhlIGRvY3VtZW50IG5vZGUgYWZ0ZXIgdGhlXG4gICAgZ2l2ZW4gcG9zaXRpb24uIE1heSByZXR1cm4gYG51bGxgIHdoZW4gdGhlIHBvc2l0aW9uIGRvZXNuJ3QgcG9pbnRcbiAgICBpbiBmcm9udCBvZiBhIG5vZGUgb3IgaWYgdGhlIG5vZGUgaXMgaW5zaWRlIGFuIG9wYXF1ZSBub2RlIHZpZXcuXG4gICAgXG4gICAgVGhpcyBpcyBpbnRlbmRlZCB0byBiZSBhYmxlIHRvIGNhbGwgdGhpbmdzIGxpa2VcbiAgICBgZ2V0Qm91bmRpbmdDbGllbnRSZWN0YCBvbiB0aGF0IERPTSBub2RlLiBEbyAqKm5vdCoqIG11dGF0ZSB0aGVcbiAgICBlZGl0b3IgRE9NIGRpcmVjdGx5LCBvciBhZGQgc3R5bGluZyB0aGlzIHdheSwgc2luY2UgdGhhdCB3aWxsIGJlXG4gICAgaW1tZWRpYXRlbHkgb3ZlcnJpZGVuIGJ5IHRoZSBlZGl0b3IgYXMgaXQgcmVkcmF3cyB0aGUgbm9kZS5cbiAgICAqL1xuICAgIG5vZGVET00ocG9zKSB7XG4gICAgICAgIGxldCBkZXNjID0gdGhpcy5kb2NWaWV3LmRlc2NBdChwb3MpO1xuICAgICAgICByZXR1cm4gZGVzYyA/IGRlc2Mubm9kZURPTSA6IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGRvY3VtZW50IHBvc2l0aW9uIHRoYXQgY29ycmVzcG9uZHMgdG8gYSBnaXZlbiBET01cbiAgICBwb3NpdGlvbi4gKFdoZW5ldmVyIHBvc3NpYmxlLCBpdCBpcyBwcmVmZXJhYmxlIHRvIGluc3BlY3QgdGhlXG4gICAgZG9jdW1lbnQgc3RydWN0dXJlIGRpcmVjdGx5LCByYXRoZXIgdGhhbiBwb2tpbmcgYXJvdW5kIGluIHRoZVxuICAgIERPTSwgYnV0IHNvbWV0aW1lc+KAlGZvciBleGFtcGxlIHdoZW4gaW50ZXJwcmV0aW5nIGFuIGV2ZW50XG4gICAgdGFyZ2V04oCUeW91IGRvbid0IGhhdmUgYSBjaG9pY2UuKVxuICAgIFxuICAgIFRoZSBgYmlhc2AgcGFyYW1ldGVyIGNhbiBiZSB1c2VkIHRvIGluZmx1ZW5jZSB3aGljaCBzaWRlIG9mIGEgRE9NXG4gICAgbm9kZSB0byB1c2Ugd2hlbiB0aGUgcG9zaXRpb24gaXMgaW5zaWRlIGEgbGVhZiBub2RlLlxuICAgICovXG4gICAgcG9zQXRET00obm9kZSwgb2Zmc2V0LCBiaWFzID0gLTEpIHtcbiAgICAgICAgbGV0IHBvcyA9IHRoaXMuZG9jVmlldy5wb3NGcm9tRE9NKG5vZGUsIG9mZnNldCwgYmlhcyk7XG4gICAgICAgIGlmIChwb3MgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiRE9NIHBvc2l0aW9uIG5vdCBpbnNpZGUgdGhlIGVkaXRvclwiKTtcbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCBvdXQgd2hldGhlciB0aGUgc2VsZWN0aW9uIGlzIGF0IHRoZSBlbmQgb2YgYSB0ZXh0YmxvY2sgd2hlblxuICAgIG1vdmluZyBpbiBhIGdpdmVuIGRpcmVjdGlvbi4gV2hlbiwgZm9yIGV4YW1wbGUsIGdpdmVuIGBcImxlZnRcImAsXG4gICAgaXQgd2lsbCByZXR1cm4gdHJ1ZSBpZiBtb3ZpbmcgbGVmdCBmcm9tIHRoZSBjdXJyZW50IGN1cnNvclxuICAgIHBvc2l0aW9uIHdvdWxkIGxlYXZlIHRoYXQgcG9zaXRpb24ncyBwYXJlbnQgdGV4dGJsb2NrLiBXaWxsIGFwcGx5XG4gICAgdG8gdGhlIHZpZXcncyBjdXJyZW50IHN0YXRlIGJ5IGRlZmF1bHQsIGJ1dCBpdCBpcyBwb3NzaWJsZSB0b1xuICAgIHBhc3MgYSBkaWZmZXJlbnQgc3RhdGUuXG4gICAgKi9cbiAgICBlbmRPZlRleHRibG9jayhkaXIsIHN0YXRlKSB7XG4gICAgICAgIHJldHVybiBlbmRPZlRleHRibG9jayh0aGlzLCBzdGF0ZSB8fCB0aGlzLnN0YXRlLCBkaXIpO1xuICAgIH1cbiAgICAvKipcbiAgICBSdW4gdGhlIGVkaXRvcidzIHBhc3RlIGxvZ2ljIHdpdGggdGhlIGdpdmVuIEhUTUwgc3RyaW5nLiBUaGVcbiAgICBgZXZlbnRgLCBpZiBnaXZlbiwgd2lsbCBiZSBwYXNzZWQgdG8gdGhlXG4gICAgW2BoYW5kbGVQYXN0ZWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN2aWV3LkVkaXRvclByb3BzLmhhbmRsZVBhc3RlKSBob29rLlxuICAgICovXG4gICAgcGFzdGVIVE1MKGh0bWwsIGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBkb1Bhc3RlKHRoaXMsIFwiXCIsIGh0bWwsIGZhbHNlLCBldmVudCB8fCBuZXcgQ2xpcGJvYXJkRXZlbnQoXCJwYXN0ZVwiKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJ1biB0aGUgZWRpdG9yJ3MgcGFzdGUgbG9naWMgd2l0aCB0aGUgZ2l2ZW4gcGxhaW4tdGV4dCBpbnB1dC5cbiAgICAqL1xuICAgIHBhc3RlVGV4dCh0ZXh0LCBldmVudCkge1xuICAgICAgICByZXR1cm4gZG9QYXN0ZSh0aGlzLCB0ZXh0LCBudWxsLCB0cnVlLCBldmVudCB8fCBuZXcgQ2xpcGJvYXJkRXZlbnQoXCJwYXN0ZVwiKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFNlcmlhbGl6ZSB0aGUgZ2l2ZW4gc2xpY2UgYXMgaXQgd291bGQgYmUgaWYgaXQgd2FzIGNvcGllZCBmcm9tXG4gICAgdGhpcyBlZGl0b3IuIFJldHVybnMgYSBET00gZWxlbWVudCB0aGF0IGNvbnRhaW5zIGFcbiAgICByZXByZXNlbnRhdGlvbiBvZiB0aGUgc2xpY2UgYXMgaXRzIGNoaWxkcmVuLCBhIHRleHR1YWxcbiAgICByZXByZXNlbnRhdGlvbiwgYW5kIHRoZSB0cmFuc2Zvcm1lZCBzbGljZSAod2hpY2ggY2FuIGJlXG4gICAgZGlmZmVyZW50IGZyb20gdGhlIGdpdmVuIGlucHV0IGR1ZSB0byBob29rcyBsaWtlXG4gICAgW2B0cmFuc2Zvcm1Db3BpZWRgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5FZGl0b3JQcm9wcy50cmFuc2Zvcm1Db3BpZWQpKS5cbiAgICAqL1xuICAgIHNlcmlhbGl6ZUZvckNsaXBib2FyZChzbGljZSkge1xuICAgICAgICByZXR1cm4gc2VyaWFsaXplRm9yQ2xpcGJvYXJkKHRoaXMsIHNsaWNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVtb3ZlcyB0aGUgZWRpdG9yIGZyb20gdGhlIERPTSBhbmQgZGVzdHJveXMgYWxsIFtub2RlXG4gICAgdmlld3NdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN2aWV3Lk5vZGVWaWV3KS5cbiAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICghdGhpcy5kb2NWaWV3KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBkZXN0cm95SW5wdXQodGhpcyk7XG4gICAgICAgIHRoaXMuZGVzdHJveVBsdWdpblZpZXdzKCk7XG4gICAgICAgIGlmICh0aGlzLm1vdW50ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZG9jVmlldy51cGRhdGUodGhpcy5zdGF0ZS5kb2MsIFtdLCB2aWV3RGVjb3JhdGlvbnModGhpcyksIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5kb20udGV4dENvbnRlbnQgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZG9tLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuZG9tLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5kb20pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZG9jVmlldy5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuZG9jVmlldyA9IG51bGw7XG4gICAgICAgIGNsZWFyUmV1c2VkUmFuZ2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhpcyBpcyB0cnVlIHdoZW4gdGhlIHZpZXcgaGFzIGJlZW5cbiAgICBbZGVzdHJveWVkXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmRlc3Ryb3kpIChhbmQgdGh1cyBzaG91bGQgbm90IGJlXG4gICAgdXNlZCBhbnltb3JlKS5cbiAgICAqL1xuICAgIGdldCBpc0Rlc3Ryb3llZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jVmlldyA9PSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBVc2VkIGZvciB0ZXN0aW5nLlxuICAgICovXG4gICAgZGlzcGF0Y2hFdmVudChldmVudCkge1xuICAgICAgICByZXR1cm4gZGlzcGF0Y2hFdmVudCh0aGlzLCBldmVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZG9tU2VsZWN0aW9uUmFuZ2UoKSB7XG4gICAgICAgIGxldCBzZWwgPSB0aGlzLmRvbVNlbGVjdGlvbigpO1xuICAgICAgICBpZiAoIXNlbClcbiAgICAgICAgICAgIHJldHVybiB7IGZvY3VzTm9kZTogbnVsbCwgZm9jdXNPZmZzZXQ6IDAsIGFuY2hvck5vZGU6IG51bGwsIGFuY2hvck9mZnNldDogMCB9O1xuICAgICAgICByZXR1cm4gc2FmYXJpICYmIHRoaXMucm9vdC5ub2RlVHlwZSA9PT0gMTEgJiZcbiAgICAgICAgICAgIGRlZXBBY3RpdmVFbGVtZW50KHRoaXMuZG9tLm93bmVyRG9jdW1lbnQpID09IHRoaXMuZG9tICYmIHNhZmFyaVNoYWRvd1NlbGVjdGlvblJhbmdlKHRoaXMsIHNlbCkgfHwgc2VsO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGRvbVNlbGVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5nZXRTZWxlY3Rpb24oKTtcbiAgICB9XG59XG5FZGl0b3JWaWV3LnByb3RvdHlwZS5kaXNwYXRjaCA9IGZ1bmN0aW9uICh0cikge1xuICAgIGxldCBkaXNwYXRjaFRyYW5zYWN0aW9uID0gdGhpcy5fcHJvcHMuZGlzcGF0Y2hUcmFuc2FjdGlvbjtcbiAgICBpZiAoZGlzcGF0Y2hUcmFuc2FjdGlvbilcbiAgICAgICAgZGlzcGF0Y2hUcmFuc2FjdGlvbi5jYWxsKHRoaXMsIHRyKTtcbiAgICBlbHNlXG4gICAgICAgIHRoaXMudXBkYXRlU3RhdGUodGhpcy5zdGF0ZS5hcHBseSh0cikpO1xufTtcbmZ1bmN0aW9uIGNvbXB1dGVEb2NEZWNvKHZpZXcpIHtcbiAgICBsZXQgYXR0cnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGF0dHJzLmNsYXNzID0gXCJQcm9zZU1pcnJvclwiO1xuICAgIGF0dHJzLmNvbnRlbnRlZGl0YWJsZSA9IFN0cmluZyh2aWV3LmVkaXRhYmxlKTtcbiAgICB2aWV3LnNvbWVQcm9wKFwiYXR0cmlidXRlc1wiLCB2YWx1ZSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSh2aWV3LnN0YXRlKTtcbiAgICAgICAgaWYgKHZhbHVlKVxuICAgICAgICAgICAgZm9yIChsZXQgYXR0ciBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChhdHRyID09IFwiY2xhc3NcIilcbiAgICAgICAgICAgICAgICAgICAgYXR0cnMuY2xhc3MgKz0gXCIgXCIgKyB2YWx1ZVthdHRyXTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhdHRyID09IFwic3R5bGVcIilcbiAgICAgICAgICAgICAgICAgICAgYXR0cnMuc3R5bGUgPSAoYXR0cnMuc3R5bGUgPyBhdHRycy5zdHlsZSArIFwiO1wiIDogXCJcIikgKyB2YWx1ZVthdHRyXTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghYXR0cnNbYXR0cl0gJiYgYXR0ciAhPSBcImNvbnRlbnRlZGl0YWJsZVwiICYmIGF0dHIgIT0gXCJub2RlTmFtZVwiKVxuICAgICAgICAgICAgICAgICAgICBhdHRyc1thdHRyXSA9IFN0cmluZyh2YWx1ZVthdHRyXSk7XG4gICAgICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCFhdHRycy50cmFuc2xhdGUpXG4gICAgICAgIGF0dHJzLnRyYW5zbGF0ZSA9IFwibm9cIjtcbiAgICByZXR1cm4gW0RlY29yYXRpb24ubm9kZSgwLCB2aWV3LnN0YXRlLmRvYy5jb250ZW50LnNpemUsIGF0dHJzKV07XG59XG5mdW5jdGlvbiB1cGRhdGVDdXJzb3JXcmFwcGVyKHZpZXcpIHtcbiAgICBpZiAodmlldy5tYXJrQ3Vyc29yKSB7XG4gICAgICAgIGxldCBkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuICAgICAgICBkb20uY2xhc3NOYW1lID0gXCJQcm9zZU1pcnJvci1zZXBhcmF0b3JcIjtcbiAgICAgICAgZG9tLnNldEF0dHJpYnV0ZShcIm1hcmstcGxhY2Vob2xkZXJcIiwgXCJ0cnVlXCIpO1xuICAgICAgICBkb20uc2V0QXR0cmlidXRlKFwiYWx0XCIsIFwiXCIpO1xuICAgICAgICB2aWV3LmN1cnNvcldyYXBwZXIgPSB7IGRvbSwgZGVjbzogRGVjb3JhdGlvbi53aWRnZXQodmlldy5zdGF0ZS5zZWxlY3Rpb24uZnJvbSwgZG9tLCB7IHJhdzogdHJ1ZSwgbWFya3M6IHZpZXcubWFya0N1cnNvciB9KSB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmlldy5jdXJzb3JXcmFwcGVyID0gbnVsbDtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRFZGl0YWJsZSh2aWV3KSB7XG4gICAgcmV0dXJuICF2aWV3LnNvbWVQcm9wKFwiZWRpdGFibGVcIiwgdmFsdWUgPT4gdmFsdWUodmlldy5zdGF0ZSkgPT09IGZhbHNlKTtcbn1cbmZ1bmN0aW9uIHNlbGVjdGlvbkNvbnRleHRDaGFuZ2VkKHNlbDEsIHNlbDIpIHtcbiAgICBsZXQgZGVwdGggPSBNYXRoLm1pbihzZWwxLiRhbmNob3Iuc2hhcmVkRGVwdGgoc2VsMS5oZWFkKSwgc2VsMi4kYW5jaG9yLnNoYXJlZERlcHRoKHNlbDIuaGVhZCkpO1xuICAgIHJldHVybiBzZWwxLiRhbmNob3Iuc3RhcnQoZGVwdGgpICE9IHNlbDIuJGFuY2hvci5zdGFydChkZXB0aCk7XG59XG5mdW5jdGlvbiBidWlsZE5vZGVWaWV3cyh2aWV3KSB7XG4gICAgbGV0IHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZnVuY3Rpb24gYWRkKG9iaikge1xuICAgICAgICBmb3IgKGxldCBwcm9wIGluIG9iailcbiAgICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwgcHJvcCkpXG4gICAgICAgICAgICAgICAgcmVzdWx0W3Byb3BdID0gb2JqW3Byb3BdO1xuICAgIH1cbiAgICB2aWV3LnNvbWVQcm9wKFwibm9kZVZpZXdzXCIsIGFkZCk7XG4gICAgdmlldy5zb21lUHJvcChcIm1hcmtWaWV3c1wiLCBhZGQpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBjaGFuZ2VkTm9kZVZpZXdzKGEsIGIpIHtcbiAgICBsZXQgbkEgPSAwLCBuQiA9IDA7XG4gICAgZm9yIChsZXQgcHJvcCBpbiBhKSB7XG4gICAgICAgIGlmIChhW3Byb3BdICE9IGJbcHJvcF0pXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgbkErKztcbiAgICB9XG4gICAgZm9yIChsZXQgXyBpbiBiKVxuICAgICAgICBuQisrO1xuICAgIHJldHVybiBuQSAhPSBuQjtcbn1cbmZ1bmN0aW9uIGNoZWNrU3RhdGVDb21wb25lbnQocGx1Z2luKSB7XG4gICAgaWYgKHBsdWdpbi5zcGVjLnN0YXRlIHx8IHBsdWdpbi5zcGVjLmZpbHRlclRyYW5zYWN0aW9uIHx8IHBsdWdpbi5zcGVjLmFwcGVuZFRyYW5zYWN0aW9uKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlBsdWdpbnMgcGFzc2VkIGRpcmVjdGx5IHRvIHRoZSB2aWV3IG11c3Qgbm90IGhhdmUgYSBzdGF0ZSBjb21wb25lbnRcIik7XG59XG5cbmV4cG9ydCB7IERlY29yYXRpb24sIERlY29yYXRpb25TZXQsIEVkaXRvclZpZXcsIF9fZW5kQ29tcG9zaXRpb24sIF9fcGFyc2VGcm9tQ2xpcGJvYXJkIH07XG4iXSwibmFtZXMiOlsiVGV4dFNlbGVjdGlvbiIsIk5vZGVTZWxlY3Rpb24iLCJBbGxTZWxlY3Rpb24iLCJTZWxlY3Rpb24iLCJET01TZXJpYWxpemVyIiwiRnJhZ21lbnQiLCJNYXJrIiwiU2xpY2UiLCJET01QYXJzZXIiLCJkcm9wUG9pbnQiLCJkb21JbmRleCIsIm5vZGUiLCJpbmRleCIsInByZXZpb3VzU2libGluZyIsInBhcmVudE5vZGUiLCJwYXJlbnQiLCJhc3NpZ25lZFNsb3QiLCJub2RlVHlwZSIsImhvc3QiLCJyZXVzZWRSYW5nZSIsInRleHRSYW5nZSIsImZyb20iLCJ0byIsInJhbmdlIiwiZG9jdW1lbnQiLCJjcmVhdGVSYW5nZSIsInNldEVuZCIsIm5vZGVWYWx1ZSIsImxlbmd0aCIsInNldFN0YXJ0IiwiY2xlYXJSZXVzZWRSYW5nZSIsImlzRXF1aXZhbGVudFBvc2l0aW9uIiwib2ZmIiwidGFyZ2V0Tm9kZSIsInRhcmdldE9mZiIsInNjYW5Gb3IiLCJhdG9tRWxlbWVudHMiLCJkaXIiLCJfYSIsIm5vZGVTaXplIiwiaGFzQmxvY2tEZXNjIiwidGVzdCIsIm5vZGVOYW1lIiwiY29udGVudEVkaXRhYmxlIiwiY2hpbGQiLCJjaGlsZE5vZGVzIiwicG1WaWV3RGVzYyIsImlnbm9yZUZvclNlbGVjdGlvbiIsInRleHROb2RlQmVmb3JlJDEiLCJvZmZzZXQiLCJ0ZXh0Tm9kZUFmdGVyJDEiLCJpc09uRWRnZSIsImF0U3RhcnQiLCJhdEVuZCIsImRvbSIsImRlc2MiLCJjdXIiLCJpc0Jsb2NrIiwiY29udGVudERPTSIsInNlbGVjdGlvbkNvbGxhcHNlZCIsImRvbVNlbCIsImZvY3VzTm9kZSIsImZvY3VzT2Zmc2V0IiwiYW5jaG9yTm9kZSIsImFuY2hvck9mZnNldCIsImtleUV2ZW50Iiwia2V5Q29kZSIsImtleSIsImV2ZW50IiwiY3JlYXRlRXZlbnQiLCJpbml0RXZlbnQiLCJjb2RlIiwiZGVlcEFjdGl2ZUVsZW1lbnQiLCJkb2MiLCJlbHQiLCJhY3RpdmVFbGVtZW50Iiwic2hhZG93Um9vdCIsImNhcmV0RnJvbVBvaW50IiwieCIsInkiLCJjYXJldFBvc2l0aW9uRnJvbVBvaW50IiwicG9zIiwib2Zmc2V0Tm9kZSIsIk1hdGgiLCJtaW4iLCJfIiwiY2FyZXRSYW5nZUZyb21Qb2ludCIsInN0YXJ0Q29udGFpbmVyIiwic3RhcnRPZmZzZXQiLCJuYXYiLCJuYXZpZ2F0b3IiLCJhZ2VudCIsInVzZXJBZ2VudCIsImllX2VkZ2UiLCJleGVjIiwiaWVfdXB0bzEwIiwiaWVfMTF1cCIsImllIiwiaWVfdmVyc2lvbiIsImRvY3VtZW50TW9kZSIsImdlY2tvIiwiX2Nocm9tZSIsImNocm9tZSIsImNocm9tZV92ZXJzaW9uIiwic2FmYXJpIiwidmVuZG9yIiwiaW9zIiwibWF4VG91Y2hQb2ludHMiLCJtYWMiLCJwbGF0Zm9ybSIsIndpbmRvd3MiLCJhbmRyb2lkIiwid2Via2l0IiwiZG9jdW1lbnRFbGVtZW50Iiwic3R5bGUiLCJ3ZWJraXRfdmVyc2lvbiIsIndpbmRvd1JlY3QiLCJ2cCIsImRlZmF1bHRWaWV3IiwidmlzdWFsVmlld3BvcnQiLCJsZWZ0IiwicmlnaHQiLCJ3aWR0aCIsInRvcCIsImJvdHRvbSIsImhlaWdodCIsImNsaWVudFdpZHRoIiwiY2xpZW50SGVpZ2h0IiwiZ2V0U2lkZSIsInZhbHVlIiwic2lkZSIsImNsaWVudFJlY3QiLCJyZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0Iiwic2NhbGVYIiwib2Zmc2V0V2lkdGgiLCJzY2FsZVkiLCJvZmZzZXRIZWlnaHQiLCJzY3JvbGxSZWN0SW50b1ZpZXciLCJ2aWV3Iiwic3RhcnRET00iLCJzY3JvbGxUaHJlc2hvbGQiLCJzb21lUHJvcCIsInNjcm9sbE1hcmdpbiIsIm93bmVyRG9jdW1lbnQiLCJhdFRvcCIsImJvZHkiLCJib3VuZGluZyIsIm1vdmVYIiwibW92ZVkiLCJzY3JvbGxCeSIsInN0YXJ0WCIsInNjcm9sbExlZnQiLCJzdGFydFkiLCJzY3JvbGxUb3AiLCJkWCIsImRZIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInBvc2l0aW9uIiwib2Zmc2V0UGFyZW50Iiwic3RvcmVTY3JvbGxQb3MiLCJtYXgiLCJyZWZET00iLCJyZWZUb3AiLCJpbm5lckhlaWdodCIsInJvb3QiLCJlbGVtZW50RnJvbVBvaW50IiwiY29udGFpbnMiLCJsb2NhbFJlY3QiLCJzdGFjayIsInNjcm9sbFN0YWNrIiwicHVzaCIsInJlc2V0U2Nyb2xsUG9zIiwibmV3UmVmVG9wIiwicmVzdG9yZVNjcm9sbFN0YWNrIiwiZFRvcCIsImkiLCJwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkIiwiZm9jdXNQcmV2ZW50U2Nyb2xsIiwic2V0QWN0aXZlIiwiZm9jdXMiLCJzdG9yZWQiLCJwcmV2ZW50U2Nyb2xsIiwidW5kZWZpbmVkIiwiZmluZE9mZnNldEluTm9kZSIsImNvb3JkcyIsImNsb3Nlc3QiLCJkeENsb3Nlc3QiLCJjb29yZHNDbG9zZXN0Iiwicm93Qm90Iiwicm93VG9wIiwiZmlyc3RCZWxvdyIsImNvb3Jkc0JlbG93IiwiZmlyc3RDaGlsZCIsImNoaWxkSW5kZXgiLCJuZXh0U2libGluZyIsInJlY3RzIiwiZ2V0Q2xpZW50UmVjdHMiLCJkeCIsImZpbmRPZmZzZXRJblRleHQiLCJsZW4iLCJyZXN1bHQiLCJzaW5nbGVSZWN0IiwiaW5SZWN0IiwiZGV0YWNoIiwidGFyZ2V0S2x1ZGdlIiwicG9zRnJvbUVsZW1lbnQiLCJiaWFzIiwiZG9jVmlldyIsInBvc0Zyb21ET00iLCJwb3NGcm9tQ2FyZXQiLCJvdXRzaWRlQmxvY2siLCJzYXdCbG9jayIsIm5lYXJlc3REZXNjIiwicG9zQmVmb3JlIiwicG9zQWZ0ZXIiLCJpc1RleHQiLCJiZWZvcmUiLCJlbGVtZW50IiwiYm94Iiwic3RhcnRJIiwiZmxvb3IiLCJqIiwicG9zQXRDb29yZHMiLCJjYXJldCIsInAiLCJkcmFnZ2FibGUiLCJuZXh0IiwicHJldiIsImxhc3RDaGlsZCIsInN0YXRlIiwiY29udGVudCIsInNpemUiLCJpbnNpZGUiLCJwb3NBdFN0YXJ0IiwiYm9yZGVyIiwibm9uWmVybyIsInRhcmdldCIsImZpcnN0IiwiQXJyYXkiLCJwcm90b3R5cGUiLCJmaW5kIiwiY2FsbCIsIkJJREkiLCJjb29yZHNBdFBvcyIsImF0b20iLCJkb21Gcm9tUG9zIiwic3VwcG9ydEVtcHR5UmFuZ2UiLCJyZWN0QmVmb3JlIiwicmVjdEFmdGVyIiwiZmxhdHRlblYiLCJ0YWtlU2lkZSIsIiRkb20iLCJyZXNvbHZlIiwiaW5saW5lQ29udGVudCIsImZsYXR0ZW5IIiwiYWZ0ZXIiLCJpZ25vcmVGb3JDb29yZHMiLCJ3aXRoRmx1c2hlZFN0YXRlIiwiZiIsInZpZXdTdGF0ZSIsImFjdGl2ZSIsInVwZGF0ZVN0YXRlIiwiZW5kT2ZUZXh0YmxvY2tWZXJ0aWNhbCIsInNlbCIsInNlbGVjdGlvbiIsIiRwb3MiLCIkZnJvbSIsIiR0byIsIm5lYXJlc3QiLCJib3hlcyIsIm1heWJlUlRMIiwiZW5kT2ZUZXh0YmxvY2tIb3Jpem9udGFsIiwiJGhlYWQiLCJpc1RleHRibG9jayIsInBhcmVudE9mZnNldCIsImRvbVNlbGVjdGlvbiIsInN0YXJ0IiwiZW5kIiwidGV4dENvbnRlbnQiLCJtb2RpZnkiLCJvbGROb2RlIiwib2xkT2ZmIiwiZG9tU2VsZWN0aW9uUmFuZ2UiLCJvbGRCaWRpTGV2ZWwiLCJjYXJldEJpZGlMZXZlbCIsInBhcmVudERPTSIsImRlcHRoIiwiZG9tQWZ0ZXJQb3MiLCJuZXdOb2RlIiwibmV3T2ZmIiwiY29sbGFwc2UiLCJleHRlbmQiLCJjYWNoZWRTdGF0ZSIsImNhY2hlZERpciIsImNhY2hlZFJlc3VsdCIsImVuZE9mVGV4dGJsb2NrIiwiTk9UX0RJUlRZIiwiQ0hJTERfRElSVFkiLCJDT05URU5UX0RJUlRZIiwiTk9ERV9ESVJUWSIsIlZpZXdEZXNjIiwiY29uc3RydWN0b3IiLCJjaGlsZHJlbiIsImRpcnR5IiwibWF0Y2hlc1dpZGdldCIsIndpZGdldCIsIm1hdGNoZXNNYXJrIiwibWFyayIsIm1hdGNoZXNOb2RlIiwib3V0ZXJEZWNvIiwiaW5uZXJEZWNvIiwibWF0Y2hlc0hhY2siLCJwYXJzZVJ1bGUiLCJzdG9wRXZlbnQiLCJkZXN0cm95IiwicG9zQmVmb3JlQ2hpbGQiLCJwb3NBdEVuZCIsImxvY2FsUG9zRnJvbURPTSIsImRvbUJlZm9yZSIsImRvbUFmdGVyIiwiY29tcGFyZURvY3VtZW50UG9zaXRpb24iLCJzZWFyY2giLCJvbmx5Tm9kZXMiLCJnZXREZXNjIiwibm9kZURPTSIsInNjYW4iLCJkZXNjQXQiLCJpbm5lciIsImN1clBvcyIsIlRyYWlsaW5nSGFja1ZpZXdEZXNjIiwiV2lkZ2V0Vmlld0Rlc2MiLCJlbnRlciIsImRvbUF0b20iLCJwYXJzZVJhbmdlIiwiYmFzZSIsImZyb21PZmZzZXQiLCJ0b09mZnNldCIsImNoaWxkQmFzZSIsImVtcHR5Q2hpbGRBdCIsIlJhbmdlRXJyb3IiLCJzZXRTZWxlY3Rpb24iLCJhbmNob3IiLCJoZWFkIiwiZm9yY2UiLCJhbmNob3JET00iLCJoZWFkRE9NIiwiZ2V0U2VsZWN0aW9uIiwic2VsUmFuZ2UiLCJicktsdWRnZSIsImRvbVNlbEV4dGVuZGVkIiwidG1wIiwicmVtb3ZlQWxsUmFuZ2VzIiwiYWRkUmFuZ2UiLCJpZ25vcmVNdXRhdGlvbiIsIm11dGF0aW9uIiwidHlwZSIsImNvbnRlbnRMb3N0IiwibWFya0RpcnR5Iiwic3RhcnRJbnNpZGUiLCJlbmRJbnNpZGUiLCJtYXJrUGFyZW50c0RpcnR5IiwibGV2ZWwiLCJ0ZXh0Iiwic2VsZiIsInRvRE9NIiwic3BlYyIsInJhdyIsIndyYXAiLCJjcmVhdGVFbGVtZW50IiwiYXBwZW5kQ2hpbGQiLCJjbGFzc0xpc3QiLCJhZGQiLCJlcSIsImlnbm9yZSIsInN0b3AiLCJpZ25vcmVTZWxlY3Rpb24iLCJyZWxheGVkU2lkZSIsIkNvbXBvc2l0aW9uVmlld0Rlc2MiLCJ0ZXh0RE9NIiwibXV0Iiwib2xkVmFsdWUiLCJNYXJrVmlld0Rlc2MiLCJjcmVhdGUiLCJpbmxpbmUiLCJjdXN0b20iLCJub2RlVmlld3MiLCJuYW1lIiwicmVuZGVyU3BlYyIsImF0dHJzIiwicmVwYXJzZUluVmlldyIsImNvbnRlbnRFbGVtZW50Iiwic2xpY2UiLCJjb3B5Iiwibm9kZXMiLCJyZXBsYWNlTm9kZXMiLCJOb2RlVmlld0Rlc2MiLCJkZXNjT2JqIiwiY3JlYXRlVGV4dE5vZGUiLCJoYXNBdHRyaWJ1dGUiLCJhcHBseU91dGVyRGVjbyIsIkN1c3RvbU5vZGVWaWV3RGVzYyIsIlRleHRWaWV3RGVzYyIsInJ1bGUiLCJ3aGl0ZXNwYWNlIiwicHJlc2VydmVXaGl0ZXNwYWNlIiwiZ2V0Q29udGVudCIsImVtcHR5Iiwic2FtZU91dGVyRGVjbyIsImlzTGVhZiIsInVwZGF0ZUNoaWxkcmVuIiwiY29tcG9zaXRpb24iLCJjb21wb3NpbmciLCJsb2NhbENvbXBvc2l0aW9uSW5mbyIsImxvY2FsQ29tcG9zaXRpb24iLCJjb21wb3NpdGlvbkluQ2hpbGQiLCJ1cGRhdGVyIiwiVmlld1RyZWVVcGRhdGVyIiwiaXRlckRlY28iLCJpbnNpZGVOb2RlIiwibWFya3MiLCJzeW5jVG9NYXJrcyIsImNoaWxkQ291bnQiLCJub25lIiwicGxhY2VXaWRnZXQiLCJjb21wSW5kZXgiLCJmaW5kTm9kZU1hdGNoIiwiZmluZEluZGV4V2l0aENoaWxkIiwidXBkYXRlTm9kZUF0IiwidXBkYXRlTmV4dE5vZGUiLCJhZGROb2RlIiwiYWRkVGV4dGJsb2NrSGFja3MiLCJkZXN0cm95UmVzdCIsImNoYW5nZWQiLCJwcm90ZWN0TG9jYWxDb21wb3NpdGlvbiIsInJlbmRlckRlc2NzIiwiaW9zSGFja3MiLCJ0ZXh0Tm9kZSIsImlucHV0IiwiY29tcG9zaXRpb25Ob2RlIiwidGV4dFBvcyIsImZpbmRUZXh0SW5GcmFnbWVudCIsInRvcE5vZGUiLCJyZW1vdmVDaGlsZCIsImNvbXBvc2l0aW9uTm9kZXMiLCJ1cGRhdGUiLCJzYW1lTWFya3VwIiwidXBkYXRlSW5uZXIiLCJ1cGRhdGVPdXRlckRlY28iLCJuZWVkc1dyYXAiLCJvbGRET00iLCJwYXRjaE91dGVyRGVjbyIsImNvbXB1dGVPdXRlckRlY28iLCJzZWxlY3ROb2RlIiwiZGVzZWxlY3ROb2RlIiwicmVtb3ZlIiwicmVtb3ZlQXR0cmlidXRlIiwiaXNBdG9tIiwiZG9jVmlld0Rlc2MiLCJza2lwIiwicG1Jc0RlY28iLCJpblBhcmVudCIsInRyYWNrV3JpdGVzIiwibiIsImN1dCIsIm11bHRpVHlwZSIsImRlc2NzIiwid3JpdHRlbiIsImNoaWxkRE9NIiwicm0iLCJpbnNlcnRCZWZvcmUiLCJPdXRlckRlY29MZXZlbCIsIk9iamVjdCIsIm5vRGVjbyIsInZhbCIsImlzSW5saW5lIiwiY2xhc3MiLCJvdXRlckRPTSIsInByZXZDb21wdXRlZCIsImN1ckNvbXB1dGVkIiwiY3VyRE9NIiwiZGVjbyIsInRvTG93ZXJDYXNlIiwicGF0Y2hBdHRyaWJ1dGVzIiwic2V0QXR0cmlidXRlIiwicHJldkxpc3QiLCJzcGxpdCIsImZpbHRlciIsIkJvb2xlYW4iLCJjdXJMaXN0IiwiaW5kZXhPZiIsInByb3AiLCJtIiwicmVtb3ZlUHJvcGVydHkiLCJjc3NUZXh0IiwiYSIsImIiLCJsb2NrIiwicHJlTWF0Y2giLCJkZXN0cm95QmV0d2VlbiIsInNwbGljZSIsImtlZXAiLCJtYXhLZWVwIiwic3Bhbm5pbmciLCJwb3AiLCJmb3VuZCIsImlzTG9ja2VkIiwibWFya0Rlc2MiLCJ0YXJnZXREZXNjIiwibWF0Y2hlcyIsImUiLCJtYXRjaGVkIiwiaGFzIiwiZG9tTm9kZSIsImdldCIsIm5leHRET00iLCJ1cGRhdGVkIiwibG9ja2VkIiwicmVjcmVhdGVXcmFwcGVyIiwid3JhcHBlciIsImNoIiwicmVxdWlyZXNHZWNrb0hhY2tOb2RlIiwiYWRkSGFja05vZGUiLCJjbGFzc05hbWUiLCJhbHQiLCJoYWNrIiwiZnJhZyIsInBhcmVudERlc2MiLCJjdXJEZXNjIiwiZGVzY0kiLCJmSSIsIk1hcCIsIm91dGVyIiwic2V0IiwicmV2ZXJzZSIsImNvbXBhcmVTaWRlIiwib25XaWRnZXQiLCJvbk5vZGUiLCJsb2NhbHMiLCJmb3JDaGlsZCIsImRlY29JbmRleCIsInJlc3ROb2RlIiwicGFyZW50SW5kZXgiLCJ3aWRnZXRzIiwic29ydCIsImN1dEF0IiwiZCIsIm9sZENTUyIsIndpbmRvdyIsImxpc3RTdHlsZSIsImNoaWxkU3RhcnQiLCJzdHIiLCJsYXN0SW5kZXhPZiIsInJlcGxhY2VtZW50Iiwic2VsZWN0aW9uRnJvbURPTSIsIm9yaWdpbiIsImluV2lkZ2V0IiwibmVhcmVzdERlc2NOb2RlIiwiaXNTZWxlY3RhYmxlIiwicmFuZ2VDb3VudCIsImdldFJhbmdlQXQiLCJlbmRDb250YWluZXIiLCJlbmRPZmZzZXQiLCIkYW5jaG9yIiwic2VsZWN0aW9uQmV0d2VlbiIsImVkaXRvck93bnNTZWxlY3Rpb24iLCJlZGl0YWJsZSIsImhhc0ZvY3VzIiwiaGFzU2VsZWN0aW9uIiwic2VsZWN0aW9uVG9ET00iLCJzeW5jTm9kZVNlbGVjdGlvbiIsIm1vdXNlRG93biIsImFsbG93RGVmYXVsdCIsImN1clNlbCIsImRvbU9ic2VydmVyIiwiY3VycmVudFNlbGVjdGlvbiIsImRlbGF5ZWRTZWxlY3Rpb25TeW5jIiwic2V0Q3VyU2VsZWN0aW9uIiwiZGlzY29ubmVjdFNlbGVjdGlvbiIsImN1cnNvcldyYXBwZXIiLCJzZWxlY3RDdXJzb3JXcmFwcGVyIiwicmVzZXRFZGl0YWJsZUZyb20iLCJyZXNldEVkaXRhYmxlVG8iLCJicm9rZW5TZWxlY3RCZXR3ZWVuVW5lZGl0YWJsZSIsInRlbXBvcmFyaWx5RWRpdGFibGVOZWFyIiwicmVzZXRFZGl0YWJsZSIsInZpc2libGUiLCJyZW1vdmVDbGFzc09uU2VsZWN0aW9uQ2hhbmdlIiwiY29ubmVjdFNlbGVjdGlvbiIsInNldEVkaXRhYmxlIiwid2FzRHJhZ2dhYmxlIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImhpZGVTZWxlY3Rpb25HdWFyZCIsImFkZEV2ZW50TGlzdGVuZXIiLCJzZXRUaW1lb3V0IiwiaW1nIiwiZGlzYWJsZWQiLCJsYXN0U2VsZWN0ZWRWaWV3RGVzYyIsImNsZWFyTm9kZVNlbGVjdGlvbiIsImJldHdlZW4iLCJoYXNGb2N1c0FuZFNlbGVjdGlvbiIsImFuY2hvckluUmlnaHRQbGFjZSIsIm1vdmVTZWxlY3Rpb25CbG9jayIsIiRzaWRlIiwiJHN0YXJ0IiwiZmluZEZyb20iLCJhcHBseSIsImRpc3BhdGNoIiwidHIiLCJzY3JvbGxJbnRvVmlldyIsInNlbGVjdEhvcml6b250YWxseSIsIm1vZHMiLCJ0ZXh0T2Zmc2V0Iiwibm9kZUJlZm9yZSIsIm5vZGVBZnRlciIsIiRuZXdIZWFkIiwibm9kZVBvcyIsIm5vZGVMZW4iLCJpc0lnbm9yYWJsZSIsInNraXBJZ25vcmVkTm9kZXMiLCJza2lwSWdub3JlZE5vZGVzQmVmb3JlIiwic2tpcElnbm9yZWROb2Rlc0FmdGVyIiwibW92ZU5vZGUiLCJtb3ZlT2Zmc2V0IiwiaXNCbG9ja05vZGUiLCJzZXRTZWxGb2N1cyIsInRleHROb2RlQWZ0ZXIiLCJ0ZXh0Tm9kZUJlZm9yZSIsImZpbmREaXJlY3Rpb24iLCJtaWQiLCJhYnMiLCJjb21wdXRlZCIsImRpcmVjdGlvbiIsInNlbGVjdFZlcnRpY2FsbHkiLCJiZXlvbmQiLCJuZWFyIiwic3RvcE5hdGl2ZUhvcml6b250YWxEZWxldGUiLCJzYW1lUGFyZW50IiwibmV4dE5vZGUiLCJkZWxldGUiLCJzd2l0Y2hFZGl0YWJsZSIsInNhZmFyaURvd25BcnJvd0J1ZyIsImdldE1vZHMiLCJjdHJsS2V5IiwibWV0YUtleSIsImFsdEtleSIsInNoaWZ0S2V5IiwiY2FwdHVyZUtleURvd24iLCJzZXJpYWxpemVGb3JDbGlwYm9hcmQiLCJjb250ZXh0Iiwib3BlblN0YXJ0Iiwib3BlbkVuZCIsImRlZmF1bHRBdHRycyIsInNlcmlhbGl6ZXIiLCJmcm9tU2NoZW1hIiwic2NoZW1hIiwiZGV0YWNoZWREb2MiLCJzZXJpYWxpemVGcmFnbWVudCIsIndyYXBwZXJzIiwid3JhcE1hcCIsIkpTT04iLCJzdHJpbmdpZnkiLCJ0ZXh0QmV0d2VlbiIsInBhcnNlRnJvbUNsaXBib2FyZCIsImh0bWwiLCJwbGFpblRleHQiLCIkY29udGV4dCIsImluQ29kZSIsImFzVGV4dCIsInJlcGxhY2UiLCJwYXJzZWQiLCJmb3JFYWNoIiwiYmxvY2siLCJzZXJpYWxpemVOb2RlIiwicmVhZEhUTUwiLCJyZXN0b3JlUmVwbGFjZWRTcGFjZXMiLCJjb250ZXh0Tm9kZSIsInF1ZXJ5U2VsZWN0b3IiLCJzbGljZURhdGEiLCJnZXRBdHRyaWJ1dGUiLCJwYXJzZXIiLCJwYXJzZVNsaWNlIiwicnVsZUZyb21Ob2RlIiwiaW5saW5lUGFyZW50cyIsImFkZENvbnRleHQiLCJjbG9zZVNsaWNlIiwibWF4T3BlbiIsIm5vcm1hbGl6ZVNpYmxpbmdzIiwiaXNvbGF0aW5nIiwiZnJhZ21lbnQiLCJtYXRjaCIsImNvbnRlbnRNYXRjaEF0IiwibGFzdFdyYXAiLCJmaW5kV3JhcHBpbmciLCJpbkxhc3QiLCJhZGRUb1NpYmxpbmciLCJjbG9zZVJpZ2h0Iiwid3JhcHBlZCIsIndpdGhXcmFwcGVycyIsIm1hdGNoVHlwZSIsInNpYmxpbmciLCJyZXBsYWNlQ2hpbGQiLCJhcHBlbmQiLCJmaWxsIiwiZmlsbEJlZm9yZSIsImNsb3NlUmFuZ2UiLCJ0aGVhZCIsInRib2R5IiwidGZvb3QiLCJjYXB0aW9uIiwiY29sZ3JvdXAiLCJjb2wiLCJ0ZCIsInRoIiwiX2RldGFjaGVkRG9jIiwiaW1wbGVtZW50YXRpb24iLCJjcmVhdGVIVE1MRG9jdW1lbnQiLCJfcG9saWN5IiwibWF5YmVXcmFwVHJ1c3RlZCIsInRydXN0ZWRUeXBlcyIsImRlZmF1bHRQb2xpY3kiLCJjcmVhdGVQb2xpY3kiLCJjcmVhdGVIVE1MIiwicyIsIm1ldGFzIiwiZmlyc3RUYWciLCJtYXAiLCJqb2luIiwiaW5uZXJIVE1MIiwicXVlcnlTZWxlY3RvckFsbCIsImFycmF5IiwicGFyc2UiLCJoYXNSZXF1aXJlZEF0dHJzIiwiaGFuZGxlcnMiLCJlZGl0SGFuZGxlcnMiLCJwYXNzaXZlSGFuZGxlcnMiLCJ0b3VjaHN0YXJ0IiwidG91Y2htb3ZlIiwiSW5wdXRTdGF0ZSIsImxhc3RLZXlDb2RlIiwibGFzdEtleUNvZGVUaW1lIiwibGFzdENsaWNrIiwidGltZSIsImJ1dHRvbiIsImxhc3RTZWxlY3Rpb25PcmlnaW4iLCJsYXN0U2VsZWN0aW9uVGltZSIsImxhc3RJT1NFbnRlciIsImxhc3RJT1NFbnRlckZhbGxiYWNrVGltZW91dCIsImxhc3RGb2N1cyIsImxhc3RUb3VjaCIsImxhc3RDaHJvbWVEZWxldGUiLCJjb21wb3NpbmdUaW1lb3V0IiwiY29tcG9zaXRpb25FbmRlZEF0IiwiY29tcG9zaXRpb25JRCIsImNvbXBvc2l0aW9uUGVuZGluZ0NoYW5nZXMiLCJkb21DaGFuZ2VDb3VudCIsImV2ZW50SGFuZGxlcnMiLCJpbml0SW5wdXQiLCJoYW5kbGVyIiwiZXZlbnRCZWxvbmdzVG9WaWV3IiwicnVuQ3VzdG9tSGFuZGxlciIsInBhc3NpdmUiLCJlbnN1cmVMaXN0ZW5lcnMiLCJzZXRTZWxlY3Rpb25PcmlnaW4iLCJEYXRlIiwibm93IiwiZGVzdHJveUlucHV0IiwiY2xlYXJUaW1lb3V0IiwiY3VycmVudEhhbmRsZXJzIiwiZGVmYXVsdFByZXZlbnRlZCIsImJ1YmJsZXMiLCJkaXNwYXRjaEV2ZW50Iiwia2V5ZG93biIsIl9ldmVudCIsImluT3JOZWFyQ29tcG9zaXRpb24iLCJmb3JjZUZsdXNoIiwicHJldmVudERlZmF1bHQiLCJrZXl1cCIsImtleXByZXNzIiwiY2hhckNvZGUiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJkZWZsdCIsImluc2VydFRleHQiLCJldmVudENvb3JkcyIsImNsaWVudFgiLCJjbGllbnRZIiwiaXNOZWFyIiwiY2xpY2siLCJkeSIsInJ1bkhhbmRsZXJPbkNvbnRleHQiLCJwcm9wTmFtZSIsInVwZGF0ZVNlbGVjdGlvbiIsImZvY3VzZWQiLCJzZXRNZXRhIiwic2VsZWN0Q2xpY2tlZExlYWYiLCJzZWxlY3RDbGlja2VkTm9kZSIsInNlbGVjdGVkTm9kZSIsInNlbGVjdEF0IiwiaGFuZGxlU2luZ2xlQ2xpY2siLCJoYW5kbGVEb3VibGVDbGljayIsImhhbmRsZVRyaXBsZUNsaWNrIiwiZGVmYXVsdFRyaXBsZUNsaWNrIiwiZm9yY2VET01GbHVzaCIsImVuZENvbXBvc2l0aW9uIiwic2VsZWN0Tm9kZU1vZGlmaWVyIiwibW91c2Vkb3duIiwiZmx1c2hlZCIsImRvbmUiLCJNb3VzZURvd24iLCJtaWdodERyYWciLCJzdGFydERvYyIsInRhcmdldFBvcyIsIm5vZGVBdCIsInNlbGVjdGFibGUiLCJhZGRBdHRyIiwic2V0VW5lZGl0YWJsZSIsInVwIiwiYmluZCIsIm1vdmUiLCJ1cGRhdGVBbGxvd0RlZmF1bHQiLCJidXR0b25zIiwiY29udGV4dG1lbnUiLCJ0aW1lU3RhbXAiLCJ0aW1lb3V0Q29tcG9zaXRpb24iLCJjb21wb3NpdGlvbnN0YXJ0IiwiY29tcG9zaXRpb251cGRhdGUiLCJmbHVzaCIsInN0b3JlZE1hcmtzIiwic29tZSIsImluY2x1c2l2ZSIsInNlbGVjdGlvbkJlZm9yZVVuZWRpdGFibGUiLCJtYXJrQ3Vyc29yIiwic2NoZWR1bGVDb21wb3NlRW5kIiwiY29tcG9zaXRpb25lbmQiLCJwZW5kaW5nUmVjb3JkcyIsIlByb21pc2UiLCJ0aGVuIiwiZGVsYXkiLCJjbGVhckNvbXBvc2l0aW9uIiwidGltZXN0YW1wRnJvbUN1c3RvbUV2ZW50IiwiZmluZENvbXBvc2l0aW9uTm9kZSIsInRleHRCZWZvcmUiLCJ0ZXh0QWZ0ZXIiLCJkZXNjQWZ0ZXIiLCJsYXN0Q2hhbmdlZCIsImxhc3RDaGFuZ2VkVGV4dE5vZGUiLCJkZXNjQmVmb3JlIiwicmVzdGFydGluZyIsImZsdXNoaW5nU29vbiIsInNoYXJlZERlcHRoIiwiZGVsZXRlU2VsZWN0aW9uIiwiY2FwdHVyZUNvcHkiLCJzZWxlY3ROb2RlQ29udGVudHMiLCJibHVyIiwiYnJva2VuQ2xpcGJvYXJkQVBJIiwiZGF0YSIsImNsaXBib2FyZERhdGEiLCJjbGVhckRhdGEiLCJzZXREYXRhIiwic2xpY2VTaW5nbGVOb2RlIiwiY2FwdHVyZVBhc3RlIiwicGxhaW4iLCJkb1Bhc3RlIiwicHJlZmVyUGxhaW4iLCJzaW5nbGVOb2RlIiwicmVwbGFjZVNlbGVjdGlvbldpdGgiLCJyZXBsYWNlU2VsZWN0aW9uIiwiZ2V0VGV4dCIsImdldERhdGEiLCJ1cmlzIiwicGFzdGUiLCJEcmFnZ2luZyIsImRyYWdDb3B5TW9kaWZpZXIiLCJkcmFnTW92ZXMiLCJtb3ZlcyIsImRyYWdzdGFydCIsImRhdGFUcmFuc2ZlciIsImRyYWdnZWRTbGljZSIsImZpbGVzIiwiZWZmZWN0QWxsb3dlZCIsImRyYWdnaW5nIiwiZHJhZ2VuZCIsImRyYWdvdmVyIiwiZHJhZ2VudGVyIiwiZHJvcCIsImhhbmRsZURyb3AiLCJldmVudFBvcyIsIiRtb3VzZSIsImluc2VydFBvcyIsIm1hcHBpbmciLCJpc05vZGUiLCJiZWZvcmVJbnNlcnQiLCJyZXBsYWNlUmFuZ2VXaXRoIiwicmVwbGFjZVJhbmdlIiwibWFwcyIsIl9mcm9tIiwiX3RvIiwiX25ld0Zyb20iLCJuZXdUbyIsInJlbGF0ZWRUYXJnZXQiLCJjbGVhciIsImJlZm9yZWlucHV0IiwiaW5wdXRUeXBlIiwiZmx1c2hTb29uIiwiJGN1cnNvciIsImNvbXBhcmVPYmpzIiwiV2lkZ2V0VHlwZSIsIm5vU3BlYyIsInNwYW4iLCJvbGRPZmZzZXQiLCJkZWxldGVkIiwibWFwUmVzdWx0IiwiRGVjb3JhdGlvbiIsInZhbGlkIiwib3RoZXIiLCJJbmxpbmVUeXBlIiwiaW5jbHVzaXZlU3RhcnQiLCJpbmNsdXNpdmVFbmQiLCJpcyIsIk5vZGVUeXBlIiwiZmluZEluZGV4IiwiRGVjb3JhdGlvblNldCIsImxvY2FsIiwiZGVjb3JhdGlvbnMiLCJidWlsZFRyZWUiLCJwcmVkaWNhdGUiLCJmaW5kSW5uZXIiLCJjaGlsZE9mZiIsIm9wdGlvbnMiLCJtYXBJbm5lciIsIm5ld0xvY2FsIiwibWFwcGVkIiwib25SZW1vdmUiLCJtYXBDaGlsZHJlbiIsImJ5UG9zIiwiYWRkSW5uZXIiLCJjaGlsZE5vZGUiLCJjaGlsZE9mZnNldCIsImJhc2VPZmZzZXQiLCJ0YWtlU3BhbnNGb3JOb2RlIiwibW92ZVNwYW5zIiwid2l0aG91dE51bGxzIiwiY29uY2F0IiwicmVtb3ZlSW5uZXIiLCJyZW1vdmVkIiwiZGVjIiwibG9jYWxTZXQiLCJEZWNvcmF0aW9uR3JvdXAiLCJyZW1vdmVPdmVybGFwIiwibG9jYWxzSW5uZXIiLCJmb3JFYWNoU2V0IiwibWVtYmVycyIsIm1hcHBlZERlY29zIiwibWVtYmVyIiwic29ydGVkIiwiZXZlcnkiLCJyZWR1Y2UiLCJyIiwib2xkQ2hpbGRyZW4iLCJtb3ZlZCIsIm9sZFN0YXJ0Iiwib2xkRW5kIiwibmV3U3RhcnQiLCJuZXdFbmQiLCJkU2l6ZSIsIm11c3RSZWJ1aWxkIiwiZnJvbUxvY2FsIiwidG9Mb2NhbCIsIm1heWJlQ2hpbGQiLCJtYXBBbmRHYXRoZXJSZW1haW5pbmdEZWNvcmF0aW9ucyIsImJ1aWx0Iiwic3BhbnMiLCJnYXRoZXIiLCJoYXNOdWxscyIsImxvY2FsU3RhcnQiLCJzdWJ0cmVlIiwid29ya2luZyIsImluc2VydEFoZWFkIiwidmlld0RlY29yYXRpb25zIiwib2JzZXJ2ZU9wdGlvbnMiLCJjaGlsZExpc3QiLCJjaGFyYWN0ZXJEYXRhIiwiY2hhcmFjdGVyRGF0YU9sZFZhbHVlIiwiYXR0cmlidXRlcyIsImF0dHJpYnV0ZU9sZFZhbHVlIiwidXNlQ2hhckRhdGEiLCJTZWxlY3Rpb25TdGF0ZSIsIkRPTU9ic2VydmVyIiwiaGFuZGxlRE9NQ2hhbmdlIiwicXVldWUiLCJvYnNlcnZlciIsIm9uQ2hhckRhdGEiLCJzdXBwcmVzc2luZ1NlbGVjdGlvblVwZGF0ZXMiLCJNdXRhdGlvbk9ic2VydmVyIiwibXV0YXRpb25zIiwicmVtb3ZlZE5vZGVzIiwicHJldlZhbHVlIiwib25TZWxlY3Rpb25DaGFuZ2UiLCJ0YWtlUmVjb3JkcyIsIm9ic2VydmUiLCJ0YWtlIiwiZGlzY29ubmVjdCIsInN1cHByZXNzU2VsZWN0aW9uVXBkYXRlcyIsImlnbm9yZVNlbGVjdGlvbkNoYW5nZSIsImFuY2VzdG9ycyIsIlNldCIsImNvbnRhaW5lciIsIm5ld1NlbCIsInR5cGVPdmVyIiwiYWRkZWQiLCJyZWdpc3Rlck11dGF0aW9uIiwiYnJzIiwiYnIiLCJibG9ja1BhcmVudCIsInJlYWRTZWwiLCJzY3JvbGxUb1NlbGVjdGlvbiIsImNoZWNrQ1NTIiwiYXR0cmlidXRlTmFtZSIsImFkZGVkTm9kZXMiLCJjc3NDaGVja2VkIiwiV2Vha01hcCIsImNzc0NoZWNrV2FybmVkIiwid2hpdGVTcGFjZSIsImNvbnNvbGUiLCJyYW5nZVRvU2VsZWN0aW9uUmFuZ2UiLCJjdXJyZW50QW5jaG9yIiwiZG9tQXRQb3MiLCJzYWZhcmlTaGFkb3dTZWxlY3Rpb25SYW5nZSIsImdldENvbXBvc2VkUmFuZ2VzIiwicmVhZCIsInN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiIsImdldFRhcmdldFJhbmdlcyIsImV4ZWNDb21tYW5kIiwicGFyc2VCZXR3ZWVuIiwiZnJvbV8iLCJ0b18iLCJ0b3BNYXRjaCIsInRvcE9wZW4iLCJmaW5kUG9zaXRpb25zIiwicmVhZERPTUNoYW5nZSIsIiRiZWZvcmUiLCJzaGFyZWQiLCJjb21wYXJlIiwicHJlZmVycmVkUG9zIiwicHJlZmVycmVkU2lkZSIsImNoYW5nZSIsImZpbmREaWZmIiwiZW5kQSIsImVuZEIiLCJyZXNvbHZlU2VsZWN0aW9uIiwicmVzb2x2ZU5vQ2FjaGUiLCIkZnJvbUEiLCJpbmxpbmVDaGFuZ2UiLCJsb29rc0xpa2VCYWNrc3BhY2UiLCJjaEZyb20iLCJjaFRvIiwibWtUciIsIm1hcmtDaGFuZ2UiLCJtYXJrc0Fjcm9zcyIsImVuc3VyZU1hcmtzIiwiaXNNYXJrQ2hhbmdlIiwiYWRkTWFyayIsInJlbW92ZU1hcmsiLCJwYXJzZWRTZWwiLCJjdXJNYXJrcyIsInByZXZNYXJrcyIsInJlbW92ZUZyb21TZXQiLCJhZGRUb1NldCIsIm9sZCIsIiRuZXdTdGFydCIsIiRuZXdFbmQiLCJza2lwQ2xvc2luZ0FuZE9wZW5pbmciLCIkbmV4dCIsImZyb21FbmQiLCJtYXlPcGVuIiwiaW5kZXhBZnRlciIsImZpbmREaWZmU3RhcnQiLCJmaW5kRGlmZkVuZCIsImFkanVzdCIsImlzU3Vycm9nYXRlUGFpciIsImNoYXJDb2RlQXQiLCJfX3BhcnNlRnJvbUNsaXBib2FyZCIsIl9fZW5kQ29tcG9zaXRpb24iLCJFZGl0b3JWaWV3IiwicGxhY2UiLCJwcm9wcyIsIl9yb290IiwibW91bnRlZCIsInByZXZEaXJlY3RQbHVnaW5zIiwicGx1Z2luVmlld3MiLCJfcHJvcHMiLCJkaXJlY3RQbHVnaW5zIiwicGx1Z2lucyIsImNoZWNrU3RhdGVDb21wb25lbnQiLCJtb3VudCIsImdldEVkaXRhYmxlIiwidXBkYXRlQ3Vyc29yV3JhcHBlciIsImJ1aWxkTm9kZVZpZXdzIiwiY29tcHV0ZURvY0RlY28iLCJ1cGRhdGVQbHVnaW5WaWV3cyIsImhhbmRsZURPTUV2ZW50cyIsInByZXZQcm9wcyIsInVwZGF0ZVN0YXRlSW5uZXIiLCJzZXRQcm9wcyIsInJlZHJhdyIsInVwZGF0ZVNlbCIsInBsdWdpbnNDaGFuZ2VkIiwiY2hhbmdlZE5vZGVWaWV3cyIsInNjcm9sbCIsInVwZGF0ZURvYyIsIm9sZFNjcm9sbFBvcyIsIm92ZXJmbG93QW5jaG9yIiwiZm9yY2VTZWxVcGRhdGUiLCJzZWxlY3Rpb25Db250ZXh0Q2hhbmdlZCIsImNocm9tZUtsdWRnZSIsInVwZGF0ZURyYWdnZWROb2RlIiwiZGVzdHJveVBsdWdpblZpZXdzIiwicHJldlN0YXRlIiwicGx1Z2luIiwicGx1Z2luVmlldyIsIm1vdmVkUG9zIiwicGFyZW50RWxlbWVudCIsImNhY2hlZCIsImdldFByb3RvdHlwZU9mIiwidXBkYXRlUm9vdCIsInBvc0F0RE9NIiwicGFzdGVIVE1MIiwiQ2xpcGJvYXJkRXZlbnQiLCJwYXN0ZVRleHQiLCJpc0Rlc3Ryb3llZCIsImRpc3BhdGNoVHJhbnNhY3Rpb24iLCJjb250ZW50ZWRpdGFibGUiLCJhdHRyIiwidHJhbnNsYXRlIiwic2VsMSIsInNlbDIiLCJvYmoiLCJoYXNPd25Qcm9wZXJ0eSIsIm5BIiwibkIiLCJmaWx0ZXJUcmFuc2FjdGlvbiIsImFwcGVuZFRyYW5zYWN0aW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/prosemirror-view/dist/index.js\n");

/***/ })

};
;