"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/prosemirror-gapcursor";
exports.ids = ["vendor-chunks/prosemirror-gapcursor"];
exports.modules = {

/***/ "(ssr)/./node_modules/prosemirror-gapcursor/dist/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/prosemirror-gapcursor/dist/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GapCursor: () => (/* binding */ GapCursor),\n/* harmony export */   gapCursor: () => (/* binding */ gapCursor)\n/* harmony export */ });\n/* harmony import */ var prosemirror_keymap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-keymap */ \"(ssr)/./node_modules/prosemirror-keymap/dist/index.js\");\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-state */ \"(ssr)/./node_modules/prosemirror-state/dist/index.js\");\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-model */ \"(ssr)/./node_modules/prosemirror-model/dist/index.js\");\n/* harmony import */ var prosemirror_view__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! prosemirror-view */ \"(ssr)/./node_modules/prosemirror-view/dist/index.js\");\n\n\n\n\n/**\nGap cursor selections are represented using this class. Its\n`$anchor` and `$head` properties both point at the cursor position.\n*/ class GapCursor extends prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection {\n    /**\n    Create a gap cursor.\n    */ constructor($pos){\n        super($pos, $pos);\n    }\n    map(doc, mapping) {\n        let $pos = doc.resolve(mapping.map(this.head));\n        return GapCursor.valid($pos) ? new GapCursor($pos) : prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near($pos);\n    }\n    content() {\n        return prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice.empty;\n    }\n    eq(other) {\n        return other instanceof GapCursor && other.head == this.head;\n    }\n    toJSON() {\n        return {\n            type: \"gapcursor\",\n            pos: this.head\n        };\n    }\n    /**\n    @internal\n    */ static fromJSON(doc, json) {\n        if (typeof json.pos != \"number\") throw new RangeError(\"Invalid input for GapCursor.fromJSON\");\n        return new GapCursor(doc.resolve(json.pos));\n    }\n    /**\n    @internal\n    */ getBookmark() {\n        return new GapBookmark(this.anchor);\n    }\n    /**\n    @internal\n    */ static valid($pos) {\n        let parent = $pos.parent;\n        if (parent.isTextblock || !closedBefore($pos) || !closedAfter($pos)) return false;\n        let override = parent.type.spec.allowGapCursor;\n        if (override != null) return override;\n        let deflt = parent.contentMatchAt($pos.index()).defaultType;\n        return deflt && deflt.isTextblock;\n    }\n    /**\n    @internal\n    */ static findGapCursorFrom($pos, dir, mustMove = false) {\n        search: for(;;){\n            if (!mustMove && GapCursor.valid($pos)) return $pos;\n            let pos = $pos.pos, next = null;\n            // Scan up from this position\n            for(let d = $pos.depth;; d--){\n                let parent = $pos.node(d);\n                if (dir > 0 ? $pos.indexAfter(d) < parent.childCount : $pos.index(d) > 0) {\n                    next = parent.child(dir > 0 ? $pos.indexAfter(d) : $pos.index(d) - 1);\n                    break;\n                } else if (d == 0) {\n                    return null;\n                }\n                pos += dir;\n                let $cur = $pos.doc.resolve(pos);\n                if (GapCursor.valid($cur)) return $cur;\n            }\n            // And then down into the next node\n            for(;;){\n                let inside = dir > 0 ? next.firstChild : next.lastChild;\n                if (!inside) {\n                    if (next.isAtom && !next.isText && !prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.isSelectable(next)) {\n                        $pos = $pos.doc.resolve(pos + next.nodeSize * dir);\n                        mustMove = false;\n                        continue search;\n                    }\n                    break;\n                }\n                next = inside;\n                pos += dir;\n                let $cur = $pos.doc.resolve(pos);\n                if (GapCursor.valid($cur)) return $cur;\n            }\n            return null;\n        }\n    }\n}\nGapCursor.prototype.visible = false;\nGapCursor.findFrom = GapCursor.findGapCursorFrom;\nprosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.jsonID(\"gapcursor\", GapCursor);\nclass GapBookmark {\n    constructor(pos){\n        this.pos = pos;\n    }\n    map(mapping) {\n        return new GapBookmark(mapping.map(this.pos));\n    }\n    resolve(doc) {\n        let $pos = doc.resolve(this.pos);\n        return GapCursor.valid($pos) ? new GapCursor($pos) : prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near($pos);\n    }\n}\nfunction needsGap(type) {\n    return type.isAtom || type.spec.isolating || type.spec.createGapCursor;\n}\nfunction closedBefore($pos) {\n    for(let d = $pos.depth; d >= 0; d--){\n        let index = $pos.index(d), parent = $pos.node(d);\n        // At the start of this parent, look at next one\n        if (index == 0) {\n            if (parent.type.spec.isolating) return true;\n            continue;\n        }\n        // See if the node before (or its first ancestor) is closed\n        for(let before = parent.child(index - 1);; before = before.lastChild){\n            if (before.childCount == 0 && !before.inlineContent || needsGap(before.type)) return true;\n            if (before.inlineContent) return false;\n        }\n    }\n    // Hit start of document\n    return true;\n}\nfunction closedAfter($pos) {\n    for(let d = $pos.depth; d >= 0; d--){\n        let index = $pos.indexAfter(d), parent = $pos.node(d);\n        if (index == parent.childCount) {\n            if (parent.type.spec.isolating) return true;\n            continue;\n        }\n        for(let after = parent.child(index);; after = after.firstChild){\n            if (after.childCount == 0 && !after.inlineContent || needsGap(after.type)) return true;\n            if (after.inlineContent) return false;\n        }\n    }\n    return true;\n}\n/**\nCreate a gap cursor plugin. When enabled, this will capture clicks\nnear and arrow-key-motion past places that don't have a normally\nselectable position nearby, and create a gap cursor selection for\nthem. The cursor is drawn as an element with class\n`ProseMirror-gapcursor`. You can either include\n`style/gapcursor.css` from the package's directory or add your own\nstyles to make it visible.\n*/ function gapCursor() {\n    return new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        props: {\n            decorations: drawGapCursor,\n            createSelectionBetween (_view, $anchor, $head) {\n                return $anchor.pos == $head.pos && GapCursor.valid($head) ? new GapCursor($head) : null;\n            },\n            handleClick,\n            handleKeyDown,\n            handleDOMEvents: {\n                beforeinput: beforeinput\n            }\n        }\n    });\n}\nconst handleKeyDown = (0,prosemirror_keymap__WEBPACK_IMPORTED_MODULE_2__.keydownHandler)({\n    \"ArrowLeft\": arrow(\"horiz\", -1),\n    \"ArrowRight\": arrow(\"horiz\", 1),\n    \"ArrowUp\": arrow(\"vert\", -1),\n    \"ArrowDown\": arrow(\"vert\", 1)\n});\nfunction arrow(axis, dir) {\n    const dirStr = axis == \"vert\" ? dir > 0 ? \"down\" : \"up\" : dir > 0 ? \"right\" : \"left\";\n    return function(state, dispatch, view) {\n        let sel = state.selection;\n        let $start = dir > 0 ? sel.$to : sel.$from, mustMove = sel.empty;\n        if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection) {\n            if (!view.endOfTextblock(dirStr) || $start.depth == 0) return false;\n            mustMove = false;\n            $start = state.doc.resolve(dir > 0 ? $start.after() : $start.before());\n        }\n        let $found = GapCursor.findGapCursorFrom($start, dir, mustMove);\n        if (!$found) return false;\n        if (dispatch) dispatch(state.tr.setSelection(new GapCursor($found)));\n        return true;\n    };\n}\nfunction handleClick(view, pos, event) {\n    if (!view || !view.editable) return false;\n    let $pos = view.state.doc.resolve(pos);\n    if (!GapCursor.valid($pos)) return false;\n    let clickPos = view.posAtCoords({\n        left: event.clientX,\n        top: event.clientY\n    });\n    if (clickPos && clickPos.inside > -1 && prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.isSelectable(view.state.doc.nodeAt(clickPos.inside))) return false;\n    view.dispatch(view.state.tr.setSelection(new GapCursor($pos)));\n    return true;\n}\n// This is a hack that, when a composition starts while a gap cursor\n// is active, quickly creates an inline context for the composition to\n// happen in, to avoid it being aborted by the DOM selection being\n// moved into a valid position.\nfunction beforeinput(view, event) {\n    if (event.inputType != \"insertCompositionText\" || !(view.state.selection instanceof GapCursor)) return false;\n    let { $from } = view.state.selection;\n    let insert = $from.parent.contentMatchAt($from.index()).findWrapping(view.state.schema.nodes.text);\n    if (!insert) return false;\n    let frag = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty;\n    for(let i = insert.length - 1; i >= 0; i--)frag = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(insert[i].createAndFill(null, frag));\n    let tr = view.state.tr.replace($from.pos, $from.pos, new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(frag, 0, 0));\n    tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.near(tr.doc.resolve($from.pos + 1)));\n    view.dispatch(tr);\n    return false;\n}\nfunction drawGapCursor(state) {\n    if (!(state.selection instanceof GapCursor)) return null;\n    let node = document.createElement(\"div\");\n    node.className = \"ProseMirror-gapcursor\";\n    return prosemirror_view__WEBPACK_IMPORTED_MODULE_3__.DecorationSet.create(state.doc, [\n        prosemirror_view__WEBPACK_IMPORTED_MODULE_3__.Decoration.widget(state.selection.head, node, {\n            key: \"gapcursor\"\n        })\n    ]);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3ItZ2FwY3Vyc29yL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQW9EO0FBQ2dDO0FBQ2hDO0FBQ1M7QUFFN0Q7OztBQUdBLEdBQ0EsTUFBTVMsa0JBQWtCUix3REFBU0E7SUFDN0I7O0lBRUEsR0FDQVMsWUFBWUMsSUFBSSxDQUFFO1FBQ2QsS0FBSyxDQUFDQSxNQUFNQTtJQUNoQjtJQUNBQyxJQUFJQyxHQUFHLEVBQUVDLE9BQU8sRUFBRTtRQUNkLElBQUlILE9BQU9FLElBQUlFLE9BQU8sQ0FBQ0QsUUFBUUYsR0FBRyxDQUFDLElBQUksQ0FBQ0ksSUFBSTtRQUM1QyxPQUFPUCxVQUFVUSxLQUFLLENBQUNOLFFBQVEsSUFBSUYsVUFBVUUsUUFBUVYsd0RBQVNBLENBQUNpQixJQUFJLENBQUNQO0lBQ3hFO0lBQ0FRLFVBQVU7UUFBRSxPQUFPZCxvREFBS0EsQ0FBQ2UsS0FBSztJQUFFO0lBQ2hDQyxHQUFHQyxLQUFLLEVBQUU7UUFDTixPQUFPQSxpQkFBaUJiLGFBQWFhLE1BQU1OLElBQUksSUFBSSxJQUFJLENBQUNBLElBQUk7SUFDaEU7SUFDQU8sU0FBUztRQUNMLE9BQU87WUFBRUMsTUFBTTtZQUFhQyxLQUFLLElBQUksQ0FBQ1QsSUFBSTtRQUFDO0lBQy9DO0lBQ0E7O0lBRUEsR0FDQSxPQUFPVSxTQUFTYixHQUFHLEVBQUVjLElBQUksRUFBRTtRQUN2QixJQUFJLE9BQU9BLEtBQUtGLEdBQUcsSUFBSSxVQUNuQixNQUFNLElBQUlHLFdBQVc7UUFDekIsT0FBTyxJQUFJbkIsVUFBVUksSUFBSUUsT0FBTyxDQUFDWSxLQUFLRixHQUFHO0lBQzdDO0lBQ0E7O0lBRUEsR0FDQUksY0FBYztRQUFFLE9BQU8sSUFBSUMsWUFBWSxJQUFJLENBQUNDLE1BQU07SUFBRztJQUNyRDs7SUFFQSxHQUNBLE9BQU9kLE1BQU1OLElBQUksRUFBRTtRQUNmLElBQUlxQixTQUFTckIsS0FBS3FCLE1B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LEdBQUcsRUFBRTtRQUFDTCx3REFBVUEsQ0FBQ29ILE1BQU0sQ0FBQ3JDLE1BQU1JLFNBQVMsQ0FBQzNFLElBQUksRUFBRWtDLE1BQU07WUFBRTJFLEtBQUs7UUFBWTtLQUFHO0FBQ2hIO0FBRWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJhc29icGFpLXdlYi8uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci1nYXBjdXJzb3IvZGlzdC9pbmRleC5qcz81ZDIxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGtleWRvd25IYW5kbGVyIH0gZnJvbSAncHJvc2VtaXJyb3Ita2V5bWFwJztcbmltcG9ydCB7IFNlbGVjdGlvbiwgTm9kZVNlbGVjdGlvbiwgVGV4dFNlbGVjdGlvbiwgUGx1Z2luIH0gZnJvbSAncHJvc2VtaXJyb3Itc3RhdGUnO1xuaW1wb3J0IHsgU2xpY2UsIEZyYWdtZW50IH0gZnJvbSAncHJvc2VtaXJyb3ItbW9kZWwnO1xuaW1wb3J0IHsgRGVjb3JhdGlvblNldCwgRGVjb3JhdGlvbiB9IGZyb20gJ3Byb3NlbWlycm9yLXZpZXcnO1xuXG4vKipcbkdhcCBjdXJzb3Igc2VsZWN0aW9ucyBhcmUgcmVwcmVzZW50ZWQgdXNpbmcgdGhpcyBjbGFzcy4gSXRzXG5gJGFuY2hvcmAgYW5kIGAkaGVhZGAgcHJvcGVydGllcyBib3RoIHBvaW50IGF0IHRoZSBjdXJzb3IgcG9zaXRpb24uXG4qL1xuY2xhc3MgR2FwQ3Vyc29yIGV4dGVuZHMgU2VsZWN0aW9uIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBnYXAgY3Vyc29yLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoJHBvcykge1xuICAgICAgICBzdXBlcigkcG9zLCAkcG9zKTtcbiAgICB9XG4gICAgbWFwKGRvYywgbWFwcGluZykge1xuICAgICAgICBsZXQgJHBvcyA9IGRvYy5yZXNvbHZlKG1hcHBpbmcubWFwKHRoaXMuaGVhZCkpO1xuICAgICAgICByZXR1cm4gR2FwQ3Vyc29yLnZhbGlkKCRwb3MpID8gbmV3IEdhcEN1cnNvcigkcG9zKSA6IFNlbGVjdGlvbi5uZWFyKCRwb3MpO1xuICAgIH1cbiAgICBjb250ZW50KCkgeyByZXR1cm4gU2xpY2UuZW1wdHk7IH1cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBHYXBDdXJzb3IgJiYgb3RoZXIuaGVhZCA9PSB0aGlzLmhlYWQ7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJnYXBjdXJzb3JcIiwgcG9zOiB0aGlzLmhlYWQgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oZG9jLCBqc29uKSB7XG4gICAgICAgIGlmICh0eXBlb2YganNvbi5wb3MgIT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgR2FwQ3Vyc29yLmZyb21KU09OXCIpO1xuICAgICAgICByZXR1cm4gbmV3IEdhcEN1cnNvcihkb2MucmVzb2x2ZShqc29uLnBvcykpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldEJvb2ttYXJrKCkgeyByZXR1cm4gbmV3IEdhcEJvb2ttYXJrKHRoaXMuYW5jaG9yKTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIHZhbGlkKCRwb3MpIHtcbiAgICAgICAgbGV0IHBhcmVudCA9ICRwb3MucGFyZW50O1xuICAgICAgICBpZiAocGFyZW50LmlzVGV4dGJsb2NrIHx8ICFjbG9zZWRCZWZvcmUoJHBvcykgfHwgIWNsb3NlZEFmdGVyKCRwb3MpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgb3ZlcnJpZGUgPSBwYXJlbnQudHlwZS5zcGVjLmFsbG93R2FwQ3Vyc29yO1xuICAgICAgICBpZiAob3ZlcnJpZGUgIT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBvdmVycmlkZTtcbiAgICAgICAgbGV0IGRlZmx0ID0gcGFyZW50LmNvbnRlbnRNYXRjaEF0KCRwb3MuaW5kZXgoKSkuZGVmYXVsdFR5cGU7XG4gICAgICAgIHJldHVybiBkZWZsdCAmJiBkZWZsdC5pc1RleHRibG9jaztcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgZmluZEdhcEN1cnNvckZyb20oJHBvcywgZGlyLCBtdXN0TW92ZSA9IGZhbHNlKSB7XG4gICAgICAgIHNlYXJjaDogZm9yICg7Oykge1xuICAgICAgICAgICAgaWYgKCFtdXN0TW92ZSAmJiBHYXBDdXJzb3IudmFsaWQoJHBvcykpXG4gICAgICAgICAgICAgICAgcmV0dXJuICRwb3M7XG4gICAgICAgICAgICBsZXQgcG9zID0gJHBvcy5wb3MsIG5leHQgPSBudWxsO1xuICAgICAgICAgICAgLy8gU2NhbiB1cCBmcm9tIHRoaXMgcG9zaXRpb25cbiAgICAgICAgICAgIGZvciAobGV0IGQgPSAkcG9zLmRlcHRoOzsgZC0tKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhcmVudCA9ICRwb3Mubm9kZShkKTtcbiAgICAgICAgICAgICAgICBpZiAoZGlyID4gMCA/ICRwb3MuaW5kZXhBZnRlcihkKSA8IHBhcmVudC5jaGlsZENvdW50IDogJHBvcy5pbmRleChkKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHBhcmVudC5jaGlsZChkaXIgPiAwID8gJHBvcy5pbmRleEFmdGVyKGQpIDogJHBvcy5pbmRleChkKSAtIDEpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwb3MgKz0gZGlyO1xuICAgICAgICAgICAgICAgIGxldCAkY3VyID0gJHBvcy5kb2MucmVzb2x2ZShwb3MpO1xuICAgICAgICAgICAgICAgIGlmIChHYXBDdXJzb3IudmFsaWQoJGN1cikpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkY3VyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQW5kIHRoZW4gZG93biBpbnRvIHRoZSBuZXh0IG5vZGVcbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5zaWRlID0gZGlyID4gMCA/IG5leHQuZmlyc3RDaGlsZCA6IG5leHQubGFzdENoaWxkO1xuICAgICAgICAgICAgICAgIGlmICghaW5zaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0LmlzQXRvbSAmJiAhbmV4dC5pc1RleHQgJiYgIU5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKG5leHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkcG9zID0gJHBvcy5kb2MucmVzb2x2ZShwb3MgKyBuZXh0Lm5vZGVTaXplICogZGlyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG11c3RNb3ZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBzZWFyY2g7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5leHQgPSBpbnNpZGU7XG4gICAgICAgICAgICAgICAgcG9zICs9IGRpcjtcbiAgICAgICAgICAgICAgICBsZXQgJGN1ciA9ICRwb3MuZG9jLnJlc29sdmUocG9zKTtcbiAgICAgICAgICAgICAgICBpZiAoR2FwQ3Vyc29yLnZhbGlkKCRjdXIpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJGN1cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuR2FwQ3Vyc29yLnByb3RvdHlwZS52aXNpYmxlID0gZmFsc2U7XG5HYXBDdXJzb3IuZmluZEZyb20gPSBHYXBDdXJzb3IuZmluZEdhcEN1cnNvckZyb207XG5TZWxlY3Rpb24uanNvbklEKFwiZ2FwY3Vyc29yXCIsIEdhcEN1cnNvcik7XG5jbGFzcyBHYXBCb29rbWFyayB7XG4gICAgY29uc3RydWN0b3IocG9zKSB7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgIH1cbiAgICBtYXAobWFwcGluZykge1xuICAgICAgICByZXR1cm4gbmV3IEdhcEJvb2ttYXJrKG1hcHBpbmcubWFwKHRoaXMucG9zKSk7XG4gICAgfVxuICAgIHJlc29sdmUoZG9jKSB7XG4gICAgICAgIGxldCAkcG9zID0gZG9jLnJlc29sdmUodGhpcy5wb3MpO1xuICAgICAgICByZXR1cm4gR2FwQ3Vyc29yLnZhbGlkKCRwb3MpID8gbmV3IEdhcEN1cnNvcigkcG9zKSA6IFNlbGVjdGlvbi5uZWFyKCRwb3MpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG5lZWRzR2FwKHR5cGUpIHtcbiAgICByZXR1cm4gdHlwZS5pc0F0b20gfHwgdHlwZS5zcGVjLmlzb2xhdGluZyB8fCB0eXBlLnNwZWMuY3JlYXRlR2FwQ3Vyc29yO1xufVxuZnVuY3Rpb24gY2xvc2VkQmVmb3JlKCRwb3MpIHtcbiAgICBmb3IgKGxldCBkID0gJHBvcy5kZXB0aDsgZCA+PSAwOyBkLS0pIHtcbiAgICAgICAgbGV0IGluZGV4ID0gJHBvcy5pbmRleChkKSwgcGFyZW50ID0gJHBvcy5ub2RlKGQpO1xuICAgICAgICAvLyBBdCB0aGUgc3RhcnQgb2YgdGhpcyBwYXJlbnQsIGxvb2sgYXQgbmV4dCBvbmVcbiAgICAgICAgaWYgKGluZGV4ID09IDApIHtcbiAgICAgICAgICAgIGlmIChwYXJlbnQudHlwZS5zcGVjLmlzb2xhdGluZylcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNlZSBpZiB0aGUgbm9kZSBiZWZvcmUgKG9yIGl0cyBmaXJzdCBhbmNlc3RvcikgaXMgY2xvc2VkXG4gICAgICAgIGZvciAobGV0IGJlZm9yZSA9IHBhcmVudC5jaGlsZChpbmRleCAtIDEpOzsgYmVmb3JlID0gYmVmb3JlLmxhc3RDaGlsZCkge1xuICAgICAgICAgICAgaWYgKChiZWZvcmUuY2hpbGRDb3VudCA9PSAwICYmICFiZWZvcmUuaW5saW5lQ29udGVudCkgfHwgbmVlZHNHYXAoYmVmb3JlLnR5cGUpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgaWYgKGJlZm9yZS5pbmxpbmVDb250ZW50KVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBIaXQgc3RhcnQgb2YgZG9jdW1lbnRcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGNsb3NlZEFmdGVyKCRwb3MpIHtcbiAgICBmb3IgKGxldCBkID0gJHBvcy5kZXB0aDsgZCA+PSAwOyBkLS0pIHtcbiAgICAgICAgbGV0IGluZGV4ID0gJHBvcy5pbmRleEFmdGVyKGQpLCBwYXJlbnQgPSAkcG9zLm5vZGUoZCk7XG4gICAgICAgIGlmIChpbmRleCA9PSBwYXJlbnQuY2hpbGRDb3VudCkge1xuICAgICAgICAgICAgaWYgKHBhcmVudC50eXBlLnNwZWMuaXNvbGF0aW5nKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgYWZ0ZXIgPSBwYXJlbnQuY2hpbGQoaW5kZXgpOzsgYWZ0ZXIgPSBhZnRlci5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICBpZiAoKGFmdGVyLmNoaWxkQ291bnQgPT0gMCAmJiAhYWZ0ZXIuaW5saW5lQ29udGVudCkgfHwgbmVlZHNHYXAoYWZ0ZXIudHlwZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBpZiAoYWZ0ZXIuaW5saW5lQ29udGVudClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuQ3JlYXRlIGEgZ2FwIGN1cnNvciBwbHVnaW4uIFdoZW4gZW5hYmxlZCwgdGhpcyB3aWxsIGNhcHR1cmUgY2xpY2tzXG5uZWFyIGFuZCBhcnJvdy1rZXktbW90aW9uIHBhc3QgcGxhY2VzIHRoYXQgZG9uJ3QgaGF2ZSBhIG5vcm1hbGx5XG5zZWxlY3RhYmxlIHBvc2l0aW9uIG5lYXJieSwgYW5kIGNyZWF0ZSBhIGdhcCBjdXJzb3Igc2VsZWN0aW9uIGZvclxudGhlbS4gVGhlIGN1cnNvciBpcyBkcmF3biBhcyBhbiBlbGVtZW50IHdpdGggY2xhc3NcbmBQcm9zZU1pcnJvci1nYXBjdXJzb3JgLiBZb3UgY2FuIGVpdGhlciBpbmNsdWRlXG5gc3R5bGUvZ2FwY3Vyc29yLmNzc2AgZnJvbSB0aGUgcGFja2FnZSdzIGRpcmVjdG9yeSBvciBhZGQgeW91ciBvd25cbnN0eWxlcyB0byBtYWtlIGl0IHZpc2libGUuXG4qL1xuZnVuY3Rpb24gZ2FwQ3Vyc29yKCkge1xuICAgIHJldHVybiBuZXcgUGx1Z2luKHtcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIGRlY29yYXRpb25zOiBkcmF3R2FwQ3Vyc29yLFxuICAgICAgICAgICAgY3JlYXRlU2VsZWN0aW9uQmV0d2VlbihfdmlldywgJGFuY2hvciwgJGhlYWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJGFuY2hvci5wb3MgPT0gJGhlYWQucG9zICYmIEdhcEN1cnNvci52YWxpZCgkaGVhZCkgPyBuZXcgR2FwQ3Vyc29yKCRoZWFkKSA6IG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGFuZGxlQ2xpY2ssXG4gICAgICAgICAgICBoYW5kbGVLZXlEb3duLFxuICAgICAgICAgICAgaGFuZGxlRE9NRXZlbnRzOiB7IGJlZm9yZWlucHV0OiBiZWZvcmVpbnB1dCB9XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmNvbnN0IGhhbmRsZUtleURvd24gPSBrZXlkb3duSGFuZGxlcih7XG4gICAgXCJBcnJvd0xlZnRcIjogYXJyb3coXCJob3JpelwiLCAtMSksXG4gICAgXCJBcnJvd1JpZ2h0XCI6IGFycm93KFwiaG9yaXpcIiwgMSksXG4gICAgXCJBcnJvd1VwXCI6IGFycm93KFwidmVydFwiLCAtMSksXG4gICAgXCJBcnJvd0Rvd25cIjogYXJyb3coXCJ2ZXJ0XCIsIDEpXG59KTtcbmZ1bmN0aW9uIGFycm93KGF4aXMsIGRpcikge1xuICAgIGNvbnN0IGRpclN0ciA9IGF4aXMgPT0gXCJ2ZXJ0XCIgPyAoZGlyID4gMCA/IFwiZG93blwiIDogXCJ1cFwiKSA6IChkaXIgPiAwID8gXCJyaWdodFwiIDogXCJsZWZ0XCIpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSB7XG4gICAgICAgIGxldCBzZWwgPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIGxldCAkc3RhcnQgPSBkaXIgPiAwID8gc2VsLiR0byA6IHNlbC4kZnJvbSwgbXVzdE1vdmUgPSBzZWwuZW1wdHk7XG4gICAgICAgIGlmIChzZWwgaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uKSB7XG4gICAgICAgICAgICBpZiAoIXZpZXcuZW5kT2ZUZXh0YmxvY2soZGlyU3RyKSB8fCAkc3RhcnQuZGVwdGggPT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBtdXN0TW92ZSA9IGZhbHNlO1xuICAgICAgICAgICAgJHN0YXJ0ID0gc3RhdGUuZG9jLnJlc29sdmUoZGlyID4gMCA/ICRzdGFydC5hZnRlcigpIDogJHN0YXJ0LmJlZm9yZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgJGZvdW5kID0gR2FwQ3Vyc29yLmZpbmRHYXBDdXJzb3JGcm9tKCRzdGFydCwgZGlyLCBtdXN0TW92ZSk7XG4gICAgICAgIGlmICghJGZvdW5kKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5zZXRTZWxlY3Rpb24obmV3IEdhcEN1cnNvcigkZm91bmQpKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG5mdW5jdGlvbiBoYW5kbGVDbGljayh2aWV3LCBwb3MsIGV2ZW50KSB7XG4gICAgaWYgKCF2aWV3IHx8ICF2aWV3LmVkaXRhYmxlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0ICRwb3MgPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKHBvcyk7XG4gICAgaWYgKCFHYXBDdXJzb3IudmFsaWQoJHBvcykpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgY2xpY2tQb3MgPSB2aWV3LnBvc0F0Q29vcmRzKHsgbGVmdDogZXZlbnQuY2xpZW50WCwgdG9wOiBldmVudC5jbGllbnRZIH0pO1xuICAgIGlmIChjbGlja1BvcyAmJiBjbGlja1Bvcy5pbnNpZGUgPiAtMSAmJiBOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZSh2aWV3LnN0YXRlLmRvYy5ub2RlQXQoY2xpY2tQb3MuaW5zaWRlKSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB2aWV3LmRpc3BhdGNoKHZpZXcuc3RhdGUudHIuc2V0U2VsZWN0aW9uKG5ldyBHYXBDdXJzb3IoJHBvcykpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8vIFRoaXMgaXMgYSBoYWNrIHRoYXQsIHdoZW4gYSBjb21wb3NpdGlvbiBzdGFydHMgd2hpbGUgYSBnYXAgY3Vyc29yXG4vLyBpcyBhY3RpdmUsIHF1aWNrbHkgY3JlYXRlcyBhbiBpbmxpbmUgY29udGV4dCBmb3IgdGhlIGNvbXBvc2l0aW9uIHRvXG4vLyBoYXBwZW4gaW4sIHRvIGF2b2lkIGl0IGJlaW5nIGFib3J0ZWQgYnkgdGhlIERPTSBzZWxlY3Rpb24gYmVpbmdcbi8vIG1vdmVkIGludG8gYSB2YWxpZCBwb3NpdGlvbi5cbmZ1bmN0aW9uIGJlZm9yZWlucHV0KHZpZXcsIGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmlucHV0VHlwZSAhPSBcImluc2VydENvbXBvc2l0aW9uVGV4dFwiIHx8ICEodmlldy5zdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiBHYXBDdXJzb3IpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHsgJGZyb20gfSA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgIGxldCBpbnNlcnQgPSAkZnJvbS5wYXJlbnQuY29udGVudE1hdGNoQXQoJGZyb20uaW5kZXgoKSkuZmluZFdyYXBwaW5nKHZpZXcuc3RhdGUuc2NoZW1hLm5vZGVzLnRleHQpO1xuICAgIGlmICghaW5zZXJ0KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGZyYWcgPSBGcmFnbWVudC5lbXB0eTtcbiAgICBmb3IgKGxldCBpID0gaW5zZXJ0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBmcmFnID0gRnJhZ21lbnQuZnJvbShpbnNlcnRbaV0uY3JlYXRlQW5kRmlsbChudWxsLCBmcmFnKSk7XG4gICAgbGV0IHRyID0gdmlldy5zdGF0ZS50ci5yZXBsYWNlKCRmcm9tLnBvcywgJGZyb20ucG9zLCBuZXcgU2xpY2UoZnJhZywgMCwgMCkpO1xuICAgIHRyLnNldFNlbGVjdGlvbihUZXh0U2VsZWN0aW9uLm5lYXIodHIuZG9jLnJlc29sdmUoJGZyb20ucG9zICsgMSkpKTtcbiAgICB2aWV3LmRpc3BhdGNoKHRyKTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBkcmF3R2FwQ3Vyc29yKHN0YXRlKSB7XG4gICAgaWYgKCEoc3RhdGUuc2VsZWN0aW9uIGluc3RhbmNlb2YgR2FwQ3Vyc29yKSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIG5vZGUuY2xhc3NOYW1lID0gXCJQcm9zZU1pcnJvci1nYXBjdXJzb3JcIjtcbiAgICByZXR1cm4gRGVjb3JhdGlvblNldC5jcmVhdGUoc3RhdGUuZG9jLCBbRGVjb3JhdGlvbi53aWRnZXQoc3RhdGUuc2VsZWN0aW9uLmhlYWQsIG5vZGUsIHsga2V5OiBcImdhcGN1cnNvclwiIH0pXSk7XG59XG5cbmV4cG9ydCB7IEdhcEN1cnNvciwgZ2FwQ3Vyc29yIH07XG4iXSwibmFtZXMiOlsia2V5ZG93bkhhbmRsZXIiLCJTZWxlY3Rpb24iLCJOb2RlU2VsZWN0aW9uIiwiVGV4dFNlbGVjdGlvbiIsIlBsdWdpbiIsIlNsaWNlIiwiRnJhZ21lbnQiLCJEZWNvcmF0aW9uU2V0IiwiRGVjb3JhdGlvbiIsIkdhcEN1cnNvciIsImNvbnN0cnVjdG9yIiwiJHBvcyIsIm1hcCIsImRvYyIsIm1hcHBpbmciLCJyZXNvbHZlIiwiaGVhZCIsInZhbGlkIiwibmVhciIsImNvbnRlbnQiLCJlbXB0eSIsImVxIiwib3RoZXIiLCJ0b0pTT04iLCJ0eXBlIiwicG9zIiwiZnJvbUpTT04iLCJqc29uIiwiUmFuZ2VFcnJvciIsImdldEJvb2ttYXJrIiwiR2FwQm9va21hcmsiLCJhbmNob3IiLCJwYXJlbnQiLCJpc1RleHRibG9jayIsImNsb3NlZEJlZm9yZSIsImNsb3NlZEFmdGVyIiwib3ZlcnJpZGUiLCJzcGVjIiwiYWxsb3dHYXBDdXJzb3IiLCJkZWZsdCIsImNvbnRlbnRNYXRjaEF0IiwiaW5kZXgiLCJkZWZhdWx0VHlwZSIsImZpbmRHYXBDdXJzb3JGcm9tIiwiZGlyIiwibXVzdE1vdmUiLCJzZWFyY2giLCJuZXh0IiwiZCIsImRlcHRoIiwibm9kZSIsImluZGV4QWZ0ZXIiLCJjaGlsZENvdW50IiwiY2hpbGQiLCIkY3VyIiwiaW5zaWRlIiwiZmlyc3RDaGlsZCIsImxhc3RDaGlsZCIsImlzQXRvbSIsImlzVGV4dCIsImlzU2VsZWN0YWJsZSIsIm5vZGVTaXplIiwicHJvdG90eXBlIiwidmlzaWJsZSIsImZpbmRGcm9tIiwianNvbklEIiwibmVlZHNHYXAiLCJpc29sYXRpbmciLCJjcmVhdGVHYXBDdXJzb3IiLCJiZWZvcmUiLCJpbmxpbmVDb250ZW50IiwiYWZ0ZXIiLCJnYXBDdXJzb3IiLCJwcm9wcyIsImRlY29yYXRpb25zIiwiZHJhd0dhcEN1cnNvciIsImNyZWF0ZVNlbGVjdGlvbkJldHdlZW4iLCJfdmlldyIsIiRhbmNob3IiLCIkaGVhZCIsImhhbmRsZUNsaWNrIiwiaGFuZGxlS2V5RG93biIsImhhbmRsZURPTUV2ZW50cyIsImJlZm9yZWlucHV0IiwiYXJyb3ciLCJheGlzIiwiZGlyU3RyIiwic3RhdGUiLCJkaXNwYXRjaCIsInZpZXciLCJzZWwiLCJzZWxlY3Rpb24iLCIkc3RhcnQiLCIkdG8iLCIkZnJvbSIsImVuZE9mVGV4dGJsb2NrIiwiJGZvdW5kIiwidHIiLCJzZXRTZWxlY3Rpb24iLCJldmVudCIsImVkaXRhYmxlIiwiY2xpY2tQb3MiLCJwb3NBdENvb3JkcyIsImxlZnQiLCJjbGllbnRYIiwidG9wIiwiY2xpZW50WSIsIm5vZGVBdCIsImlucHV0VHlwZSIsImluc2VydCIsImZpbmRXcmFwcGluZyIsInNjaGVtYSIsIm5vZGVzIiwidGV4dCIsImZyYWciLCJpIiwibGVuZ3RoIiwiZnJvbSIsImNyZWF0ZUFuZEZpbGwiLCJyZXBsYWNlIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiY2xhc3NOYW1lIiwiY3JlYXRlIiwid2lkZ2V0Iiwia2V5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/prosemirror-gapcursor/dist/index.js\n");

/***/ })

};
;