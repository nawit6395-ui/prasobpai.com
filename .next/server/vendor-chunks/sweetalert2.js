"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/sweetalert2";
exports.ids = ["vendor-chunks/sweetalert2"];
exports.modules = {

/***/ "(ssr)/./node_modules/sweetalert2/dist/sweetalert2.esm.all.js":
/*!**************************************************************!*\
  !*** ./node_modules/sweetalert2/dist/sweetalert2.esm.all.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Swal)\n/* harmony export */ });\n/*!\n* sweetalert2 v11.26.10\n* Released under the MIT License.\n*/ function _assertClassBrand(e, t, n) {\n    if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;\n    throw new TypeError(\"Private element is not present on this object\");\n}\nfunction _checkPrivateRedeclaration(e, t) {\n    if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n}\nfunction _classPrivateFieldGet2(s, a) {\n    return s.get(_assertClassBrand(s, a));\n}\nfunction _classPrivateFieldInitSpec(e, t, a) {\n    _checkPrivateRedeclaration(e, t), t.set(e, a);\n}\nfunction _classPrivateFieldSet2(s, a, r) {\n    return s.set(_assertClassBrand(s, a), r), r;\n}\nconst RESTORE_FOCUS_TIMEOUT = 100;\n/** @type {GlobalState} */ const globalState = {};\nconst focusPreviousActiveElement = ()=>{\n    if (globalState.previousActiveElement instanceof HTMLElement) {\n        globalState.previousActiveElement.focus();\n        globalState.previousActiveElement = null;\n    } else if (document.body) {\n        document.body.focus();\n    }\n};\n/**\n * Restore previous active (focused) element\n *\n * @param {boolean} returnFocus\n * @returns {Promise<void>}\n */ const restoreActiveElement = (returnFocus)=>{\n    return new Promise((resolve)=>{\n        if (!returnFocus) {\n            return resolve();\n        }\n        const x = window.scrollX;\n        const y = window.scrollY;\n        globalState.restoreFocusTimeout = setTimeout(()=>{\n            focusPreviousActiveElement();\n            resolve();\n        }, RESTORE_FOCUS_TIMEOUT); // issues/900\n        window.scrollTo(x, y);\n    });\n};\nconst swalPrefix = \"swal2-\";\n/**\n * @typedef {Record<SwalClass, string>} SwalClasses\n */ /**\n * @typedef {'success' | 'warning' | 'info' | 'question' | 'error'} SwalIcon\n * @typedef {Record<SwalIcon, string>} SwalIcons\n */ /** @type {SwalClass[]} */ const classNames = [\n    \"container\",\n    \"shown\",\n    \"height-auto\",\n    \"iosfix\",\n    \"popup\",\n    \"modal\",\n    \"no-backdrop\",\n    \"no-transition\",\n    \"toast\",\n    \"toast-shown\",\n    \"show\",\n    \"hide\",\n    \"close\",\n    \"title\",\n    \"html-container\",\n    \"actions\",\n    \"confirm\",\n    \"deny\",\n    \"cancel\",\n    \"footer\",\n    \"icon\",\n    \"icon-content\",\n    \"image\",\n    \"input\",\n    \"file\",\n    \"range\",\n    \"select\",\n    \"radio\",\n    \"checkbox\",\n    \"label\",\n    \"textarea\",\n    \"inputerror\",\n    \"input-label\",\n    \"validation-message\",\n    \"progress-steps\",\n    \"active-progress-step\",\n    \"progress-step\",\n    \"progress-step-line\",\n    \"loader\",\n    \"loading\",\n    \"styled\",\n    \"top\",\n    \"top-start\",\n    \"top-end\",\n    \"top-left\",\n    \"top-right\",\n    \"center\",\n    \"center-start\",\n    \"center-end\",\n    \"center-left\",\n    \"center-right\",\n    \"bottom\",\n    \"bottom-start\",\n    \"bottom-end\",\n    \"bottom-left\",\n    \"bottom-right\",\n    \"grow-row\",\n    \"grow-column\",\n    \"grow-fullscreen\",\n    \"rtl\",\n    \"timer-progress-bar\",\n    \"timer-progress-bar-container\",\n    \"scrollbar-measure\",\n    \"icon-success\",\n    \"icon-warning\",\n    \"icon-info\",\n    \"icon-question\",\n    \"icon-error\",\n    \"draggable\",\n    \"dragging\"\n];\nconst swalClasses = classNames.reduce((acc, className)=>{\n    acc[className] = swalPrefix + className;\n    return acc;\n}, /** @type {SwalClasses} */ {});\n/** @type {SwalIcon[]} */ const icons = [\n    \"success\",\n    \"warning\",\n    \"info\",\n    \"question\",\n    \"error\"\n];\nconst iconTypes = icons.reduce((acc, icon)=>{\n    acc[icon] = swalPrefix + icon;\n    return acc;\n}, /** @type {SwalIcons} */ {});\nconst consolePrefix = \"SweetAlert2:\";\n/**\n * Capitalize the first letter of a string\n *\n * @param {string} str\n * @returns {string}\n */ const capitalizeFirstLetter = (str)=>str.charAt(0).toUpperCase() + str.slice(1);\n/**\n * Standardize console warnings\n *\n * @param {string | string[]} message\n */ const warn = (message)=>{\n    console.warn(`${consolePrefix} ${typeof message === \"object\" ? message.join(\" \") : message}`);\n};\n/**\n * Standardize console errors\n *\n * @param {string} message\n */ const error = (message)=>{\n    console.error(`${consolePrefix} ${message}`);\n};\n/**\n * Private global state for `warnOnce`\n *\n * @type {string[]}\n * @private\n */ const previousWarnOnceMessages = [];\n/**\n * Show a console warning, but only if it hasn't already been shown\n *\n * @param {string} message\n */ const warnOnce = (message)=>{\n    if (!previousWarnOnceMessages.includes(message)) {\n        previousWarnOnceMessages.push(message);\n        warn(message);\n    }\n};\n/**\n * Show a one-time console warning about deprecated params/methods\n *\n * @param {string} deprecatedParam\n * @param {string?} useInstead\n */ const warnAboutDeprecation = (deprecatedParam, useInstead = null)=>{\n    warnOnce(`\"${deprecatedParam}\" is deprecated and will be removed in the next major release.${useInstead ? ` Use \"${useInstead}\" instead.` : \"\"}`);\n};\n/**\n * If `arg` is a function, call it (with no arguments or context) and return the result.\n * Otherwise, just pass the value through\n *\n * @param {(() => *) | *} arg\n * @returns {*}\n */ const callIfFunction = (arg)=>typeof arg === \"function\" ? arg() : arg;\n/**\n * @param {*} arg\n * @returns {boolean}\n */ const hasToPromiseFn = (arg)=>arg && typeof arg.toPromise === \"function\";\n/**\n * @param {*} arg\n * @returns {Promise<*>}\n */ const asPromise = (arg)=>hasToPromiseFn(arg) ? arg.toPromise() : Promise.resolve(arg);\n/**\n * @param {*} arg\n * @returns {boolean}\n */ const isPromise = (arg)=>arg && Promise.resolve(arg) === arg;\n/**\n * Gets the popup container which contains the backdrop and the popup itself.\n *\n * @returns {HTMLElement | null}\n */ const getContainer = ()=>document.body.querySelector(`.${swalClasses.container}`);\n/**\n * @param {string} selectorString\n * @returns {HTMLElement | null}\n */ const elementBySelector = (selectorString)=>{\n    const container = getContainer();\n    return container ? container.querySelector(selectorString) : null;\n};\n/**\n * @param {string} className\n * @returns {HTMLElement | null}\n */ const elementByClass = (className)=>{\n    return elementBySelector(`.${className}`);\n};\n/**\n * @returns {HTMLElement | null}\n */ const getPopup = ()=>elementByClass(swalClasses.popup);\n/**\n * @returns {HTMLElement | null}\n */ const getIcon = ()=>elementByClass(swalClasses.icon);\n/**\n * @returns {HTMLElement | null}\n */ const getIconContent = ()=>elementByClass(swalClasses[\"icon-content\"]);\n/**\n * @returns {HTMLElement | null}\n */ const getTitle = ()=>elementByClass(swalClasses.title);\n/**\n * @returns {HTMLElement | null}\n */ const getHtmlContainer = ()=>elementByClass(swalClasses[\"html-container\"]);\n/**\n * @returns {HTMLElement | null}\n */ const getImage = ()=>elementByClass(swalClasses.image);\n/**\n * @returns {HTMLElement | null}\n */ const getProgressSteps = ()=>elementByClass(swalClasses[\"progress-steps\"]);\n/**\n * @returns {HTMLElement | null}\n */ const getValidationMessage = ()=>elementByClass(swalClasses[\"validation-message\"]);\n/**\n * @returns {HTMLButtonElement | null}\n */ const getConfirmButton = ()=>/** @type {HTMLButtonElement} */ elementBySelector(`.${swalClasses.actions} .${swalClasses.confirm}`);\n/**\n * @returns {HTMLButtonElement | null}\n */ const getCancelButton = ()=>/** @type {HTMLButtonElement} */ elementBySelector(`.${swalClasses.actions} .${swalClasses.cancel}`);\n/**\n * @returns {HTMLButtonElement | null}\n */ const getDenyButton = ()=>/** @type {HTMLButtonElement} */ elementBySelector(`.${swalClasses.actions} .${swalClasses.deny}`);\n/**\n * @returns {HTMLElement | null}\n */ const getInputLabel = ()=>elementByClass(swalClasses[\"input-label\"]);\n/**\n * @returns {HTMLElement | null}\n */ const getLoader = ()=>elementBySelector(`.${swalClasses.loader}`);\n/**\n * @returns {HTMLElement | null}\n */ const getActions = ()=>elementByClass(swalClasses.actions);\n/**\n * @returns {HTMLElement | null}\n */ const getFooter = ()=>elementByClass(swalClasses.footer);\n/**\n * @returns {HTMLElement | null}\n */ const getTimerProgressBar = ()=>elementByClass(swalClasses[\"timer-progress-bar\"]);\n/**\n * @returns {HTMLElement | null}\n */ const getCloseButton = ()=>elementByClass(swalClasses.close);\n// https://github.com/jkup/focusable/blob/master/index.js\nconst focusable = `\n  a[href],\n  area[href],\n  input:not([disabled]),\n  select:not([disabled]),\n  textarea:not([disabled]),\n  button:not([disabled]),\n  iframe,\n  object,\n  embed,\n  [tabindex=\"0\"],\n  [contenteditable],\n  audio[controls],\n  video[controls],\n  summary\n`;\n/**\n * @returns {HTMLElement[]}\n */ const getFocusableElements = ()=>{\n    const popup = getPopup();\n    if (!popup) {\n        return [];\n    }\n    /** @type {NodeListOf<HTMLElement>} */ const focusableElementsWithTabindex = popup.querySelectorAll('[tabindex]:not([tabindex=\"-1\"]):not([tabindex=\"0\"])');\n    const focusableElementsWithTabindexSorted = Array.from(focusableElementsWithTabindex)// sort according to tabindex\n    .sort((a, b)=>{\n        const tabindexA = parseInt(a.getAttribute(\"tabindex\") || \"0\");\n        const tabindexB = parseInt(b.getAttribute(\"tabindex\") || \"0\");\n        if (tabindexA > tabindexB) {\n            return 1;\n        } else if (tabindexA < tabindexB) {\n            return -1;\n        }\n        return 0;\n    });\n    /** @type {NodeListOf<HTMLElement>} */ const otherFocusableElements = popup.querySelectorAll(focusable);\n    const otherFocusableElementsFiltered = Array.from(otherFocusableElements).filter((el)=>el.getAttribute(\"tabindex\") !== \"-1\");\n    return [\n        ...new Set(focusableElementsWithTabindexSorted.concat(otherFocusableElementsFiltered))\n    ].filter((el)=>isVisible$1(el));\n};\n/**\n * @returns {boolean}\n */ const isModal = ()=>{\n    return hasClass(document.body, swalClasses.shown) && !hasClass(document.body, swalClasses[\"toast-shown\"]) && !hasClass(document.body, swalClasses[\"no-backdrop\"]);\n};\n/**\n * @returns {boolean}\n */ const isToast = ()=>{\n    const popup = getPopup();\n    if (!popup) {\n        return false;\n    }\n    return hasClass(popup, swalClasses.toast);\n};\n/**\n * @returns {boolean}\n */ const isLoading = ()=>{\n    const popup = getPopup();\n    if (!popup) {\n        return false;\n    }\n    return popup.hasAttribute(\"data-loading\");\n};\n/**\n * Securely set innerHTML of an element\n * https://github.com/sweetalert2/sweetalert2/issues/1926\n *\n * @param {HTMLElement} elem\n * @param {string} html\n */ const setInnerHtml = (elem, html)=>{\n    elem.textContent = \"\";\n    if (html) {\n        const parser = new DOMParser();\n        const parsed = parser.parseFromString(html, `text/html`);\n        const head = parsed.querySelector(\"head\");\n        if (head) {\n            Array.from(head.childNodes).forEach((child)=>{\n                elem.appendChild(child);\n            });\n        }\n        const body = parsed.querySelector(\"body\");\n        if (body) {\n            Array.from(body.childNodes).forEach((child)=>{\n                if (child instanceof HTMLVideoElement || child instanceof HTMLAudioElement) {\n                    elem.appendChild(child.cloneNode(true)); // https://github.com/sweetalert2/sweetalert2/issues/2507\n                } else {\n                    elem.appendChild(child);\n                }\n            });\n        }\n    }\n};\n/**\n * @param {HTMLElement} elem\n * @param {string} className\n * @returns {boolean}\n */ const hasClass = (elem, className)=>{\n    if (!className) {\n        return false;\n    }\n    const classList = className.split(/\\s+/);\n    for(let i = 0; i < classList.length; i++){\n        if (!elem.classList.contains(classList[i])) {\n            return false;\n        }\n    }\n    return true;\n};\n/**\n * @param {HTMLElement} elem\n * @param {SweetAlertOptions} params\n */ const removeCustomClasses = (elem, params)=>{\n    Array.from(elem.classList).forEach((className)=>{\n        if (!Object.values(swalClasses).includes(className) && !Object.values(iconTypes).includes(className) && !Object.values(params.showClass || {}).includes(className)) {\n            elem.classList.remove(className);\n        }\n    });\n};\n/**\n * @param {HTMLElement} elem\n * @param {SweetAlertOptions} params\n * @param {string} className\n */ const applyCustomClass = (elem, params, className)=>{\n    removeCustomClasses(elem, params);\n    if (!params.customClass) {\n        return;\n    }\n    const customClass = params.customClass[/** @type {keyof SweetAlertCustomClass} */ className];\n    if (!customClass) {\n        return;\n    }\n    if (typeof customClass !== \"string\" && !customClass.forEach) {\n        warn(`Invalid type of customClass.${className}! Expected string or iterable object, got \"${typeof customClass}\"`);\n        return;\n    }\n    addClass(elem, customClass);\n};\n/**\n * @param {HTMLElement} popup\n * @param {import('./renderers/renderInput').InputClass | SweetAlertInput} inputClass\n * @returns {HTMLInputElement | null}\n */ const getInput$1 = (popup, inputClass)=>{\n    if (!inputClass) {\n        return null;\n    }\n    switch(inputClass){\n        case \"select\":\n        case \"textarea\":\n        case \"file\":\n            return popup.querySelector(`.${swalClasses.popup} > .${swalClasses[inputClass]}`);\n        case \"checkbox\":\n            return popup.querySelector(`.${swalClasses.popup} > .${swalClasses.checkbox} input`);\n        case \"radio\":\n            return popup.querySelector(`.${swalClasses.popup} > .${swalClasses.radio} input:checked`) || popup.querySelector(`.${swalClasses.popup} > .${swalClasses.radio} input:first-child`);\n        case \"range\":\n            return popup.querySelector(`.${swalClasses.popup} > .${swalClasses.range} input`);\n        default:\n            return popup.querySelector(`.${swalClasses.popup} > .${swalClasses.input}`);\n    }\n};\n/**\n * @param {HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement} input\n */ const focusInput = (input)=>{\n    input.focus();\n    // place cursor at end of text in text input\n    if (input.type !== \"file\") {\n        // http://stackoverflow.com/a/2345915\n        const val = input.value;\n        input.value = \"\";\n        input.value = val;\n    }\n};\n/**\n * @param {HTMLElement | HTMLElement[] | null} target\n * @param {string | string[] | readonly string[] | undefined} classList\n * @param {boolean} condition\n */ const toggleClass = (target, classList, condition)=>{\n    if (!target || !classList) {\n        return;\n    }\n    if (typeof classList === \"string\") {\n        classList = classList.split(/\\s+/).filter(Boolean);\n    }\n    classList.forEach((className)=>{\n        if (Array.isArray(target)) {\n            target.forEach((elem)=>{\n                if (condition) {\n                    elem.classList.add(className);\n                } else {\n                    elem.classList.remove(className);\n                }\n            });\n        } else {\n            if (condition) {\n                target.classList.add(className);\n            } else {\n                target.classList.remove(className);\n            }\n        }\n    });\n};\n/**\n * @param {HTMLElement | HTMLElement[] | null} target\n * @param {string | string[] | readonly string[] | undefined} classList\n */ const addClass = (target, classList)=>{\n    toggleClass(target, classList, true);\n};\n/**\n * @param {HTMLElement | HTMLElement[] | null} target\n * @param {string | string[] | readonly string[] | undefined} classList\n */ const removeClass = (target, classList)=>{\n    toggleClass(target, classList, false);\n};\n/**\n * Get direct child of an element by class name\n *\n * @param {HTMLElement} elem\n * @param {string} className\n * @returns {HTMLElement | undefined}\n */ const getDirectChildByClass = (elem, className)=>{\n    const children = Array.from(elem.children);\n    for(let i = 0; i < children.length; i++){\n        const child = children[i];\n        if (child instanceof HTMLElement && hasClass(child, className)) {\n            return child;\n        }\n    }\n};\n/**\n * @param {HTMLElement} elem\n * @param {string} property\n * @param {string | number | null | undefined} value\n */ const applyNumericalStyle = (elem, property, value)=>{\n    if (value === `${parseInt(`${value}`)}`) {\n        value = parseInt(value);\n    }\n    if (value || parseInt(`${value}`) === 0) {\n        elem.style.setProperty(property, typeof value === \"number\" ? `${value}px` : value);\n    } else {\n        elem.style.removeProperty(property);\n    }\n};\n/**\n * @param {HTMLElement | null} elem\n * @param {string} display\n */ const show = (elem, display = \"flex\")=>{\n    if (!elem) {\n        return;\n    }\n    elem.style.display = display;\n};\n/**\n * @param {HTMLElement | null} elem\n */ const hide = (elem)=>{\n    if (!elem) {\n        return;\n    }\n    elem.style.display = \"none\";\n};\n/**\n * @param {HTMLElement | null} elem\n * @param {string} display\n */ const showWhenInnerHtmlPresent = (elem, display = \"block\")=>{\n    if (!elem) {\n        return;\n    }\n    new MutationObserver(()=>{\n        toggle(elem, elem.innerHTML, display);\n    }).observe(elem, {\n        childList: true,\n        subtree: true\n    });\n};\n/**\n * @param {HTMLElement} parent\n * @param {string} selector\n * @param {string} property\n * @param {string} value\n */ const setStyle = (parent, selector, property, value)=>{\n    /** @type {HTMLElement | null} */ const el = parent.querySelector(selector);\n    if (el) {\n        el.style.setProperty(property, value);\n    }\n};\n/**\n * @param {HTMLElement} elem\n * @param {boolean | string | null | undefined} condition\n * @param {string} display\n */ const toggle = (elem, condition, display = \"flex\")=>{\n    if (condition) {\n        show(elem, display);\n    } else {\n        hide(elem);\n    }\n};\n/**\n * borrowed from jquery $(elem).is(':visible') implementation\n *\n * @param {HTMLElement | null} elem\n * @returns {boolean}\n */ const isVisible$1 = (elem)=>!!(elem && (elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length));\n/**\n * @returns {boolean}\n */ const allButtonsAreHidden = ()=>!isVisible$1(getConfirmButton()) && !isVisible$1(getDenyButton()) && !isVisible$1(getCancelButton());\n/**\n * @param {HTMLElement} elem\n * @returns {boolean}\n */ const isScrollable = (elem)=>!!(elem.scrollHeight > elem.clientHeight);\n/**\n * @param {HTMLElement} element\n * @param {HTMLElement} stopElement\n * @returns {boolean}\n */ const selfOrParentIsScrollable = (element, stopElement)=>{\n    let parent = element;\n    while(parent && parent !== stopElement){\n        if (isScrollable(parent)) {\n            return true;\n        }\n        parent = parent.parentElement;\n    }\n    return false;\n};\n/**\n * borrowed from https://stackoverflow.com/a/46352119\n *\n * @param {HTMLElement} elem\n * @returns {boolean}\n */ const hasCssAnimation = (elem)=>{\n    const style = window.getComputedStyle(elem);\n    const animDuration = parseFloat(style.getPropertyValue(\"animation-duration\") || \"0\");\n    const transDuration = parseFloat(style.getPropertyValue(\"transition-duration\") || \"0\");\n    return animDuration > 0 || transDuration > 0;\n};\n/**\n * @param {number} timer\n * @param {boolean} reset\n */ const animateTimerProgressBar = (timer, reset = false)=>{\n    const timerProgressBar = getTimerProgressBar();\n    if (!timerProgressBar) {\n        return;\n    }\n    if (isVisible$1(timerProgressBar)) {\n        if (reset) {\n            timerProgressBar.style.transition = \"none\";\n            timerProgressBar.style.width = \"100%\";\n        }\n        setTimeout(()=>{\n            timerProgressBar.style.transition = `width ${timer / 1000}s linear`;\n            timerProgressBar.style.width = \"0%\";\n        }, 10);\n    }\n};\nconst stopTimerProgressBar = ()=>{\n    const timerProgressBar = getTimerProgressBar();\n    if (!timerProgressBar) {\n        return;\n    }\n    const timerProgressBarWidth = parseInt(window.getComputedStyle(timerProgressBar).width);\n    timerProgressBar.style.removeProperty(\"transition\");\n    timerProgressBar.style.width = \"100%\";\n    const timerProgressBarFullWidth = parseInt(window.getComputedStyle(timerProgressBar).width);\n    const timerProgressBarPercent = timerProgressBarWidth / timerProgressBarFullWidth * 100;\n    timerProgressBar.style.width = `${timerProgressBarPercent}%`;\n};\n/**\n * Detect Node env\n *\n * @returns {boolean}\n */ const isNodeEnv = ()=> true || 0;\nconst sweetHTML = `\n <div aria-labelledby=\"${swalClasses.title}\" aria-describedby=\"${swalClasses[\"html-container\"]}\" class=\"${swalClasses.popup}\" tabindex=\"-1\">\n   <button type=\"button\" class=\"${swalClasses.close}\"></button>\n   <ul class=\"${swalClasses[\"progress-steps\"]}\"></ul>\n   <div class=\"${swalClasses.icon}\"></div>\n   <img class=\"${swalClasses.image}\" />\n   <h2 class=\"${swalClasses.title}\" id=\"${swalClasses.title}\"></h2>\n   <div class=\"${swalClasses[\"html-container\"]}\" id=\"${swalClasses[\"html-container\"]}\"></div>\n   <input class=\"${swalClasses.input}\" id=\"${swalClasses.input}\" />\n   <input type=\"file\" class=\"${swalClasses.file}\" />\n   <div class=\"${swalClasses.range}\">\n     <input type=\"range\" />\n     <output></output>\n   </div>\n   <select class=\"${swalClasses.select}\" id=\"${swalClasses.select}\"></select>\n   <div class=\"${swalClasses.radio}\"></div>\n   <label class=\"${swalClasses.checkbox}\">\n     <input type=\"checkbox\" id=\"${swalClasses.checkbox}\" />\n     <span class=\"${swalClasses.label}\"></span>\n   </label>\n   <textarea class=\"${swalClasses.textarea}\" id=\"${swalClasses.textarea}\"></textarea>\n   <div class=\"${swalClasses[\"validation-message\"]}\" id=\"${swalClasses[\"validation-message\"]}\"></div>\n   <div class=\"${swalClasses.actions}\">\n     <div class=\"${swalClasses.loader}\"></div>\n     <button type=\"button\" class=\"${swalClasses.confirm}\"></button>\n     <button type=\"button\" class=\"${swalClasses.deny}\"></button>\n     <button type=\"button\" class=\"${swalClasses.cancel}\"></button>\n   </div>\n   <div class=\"${swalClasses.footer}\"></div>\n   <div class=\"${swalClasses[\"timer-progress-bar-container\"]}\">\n     <div class=\"${swalClasses[\"timer-progress-bar\"]}\"></div>\n   </div>\n </div>\n`.replace(/(^|\\n)\\s*/g, \"\");\n/**\n * @returns {boolean}\n */ const resetOldContainer = ()=>{\n    const oldContainer = getContainer();\n    if (!oldContainer) {\n        return false;\n    }\n    oldContainer.remove();\n    removeClass([\n        document.documentElement,\n        document.body\n    ], [\n        swalClasses[\"no-backdrop\"],\n        swalClasses[\"toast-shown\"],\n        swalClasses[\"has-column\"]\n    ]);\n    return true;\n};\nconst resetValidationMessage$1 = ()=>{\n    globalState.currentInstance.resetValidationMessage();\n};\nconst addInputChangeListeners = ()=>{\n    const popup = getPopup();\n    const input = getDirectChildByClass(popup, swalClasses.input);\n    const file = getDirectChildByClass(popup, swalClasses.file);\n    /** @type {HTMLInputElement} */ const range = popup.querySelector(`.${swalClasses.range} input`);\n    /** @type {HTMLOutputElement} */ const rangeOutput = popup.querySelector(`.${swalClasses.range} output`);\n    const select = getDirectChildByClass(popup, swalClasses.select);\n    /** @type {HTMLInputElement} */ const checkbox = popup.querySelector(`.${swalClasses.checkbox} input`);\n    const textarea = getDirectChildByClass(popup, swalClasses.textarea);\n    input.oninput = resetValidationMessage$1;\n    file.onchange = resetValidationMessage$1;\n    select.onchange = resetValidationMessage$1;\n    checkbox.onchange = resetValidationMessage$1;\n    textarea.oninput = resetValidationMessage$1;\n    range.oninput = ()=>{\n        resetValidationMessage$1();\n        rangeOutput.value = range.value;\n    };\n    range.onchange = ()=>{\n        resetValidationMessage$1();\n        rangeOutput.value = range.value;\n    };\n};\n/**\n * @param {string | HTMLElement} target\n * @returns {HTMLElement}\n */ const getTarget = (target)=>typeof target === \"string\" ? document.querySelector(target) : target;\n/**\n * @param {SweetAlertOptions} params\n */ const setupAccessibility = (params)=>{\n    const popup = getPopup();\n    popup.setAttribute(\"role\", params.toast ? \"alert\" : \"dialog\");\n    popup.setAttribute(\"aria-live\", params.toast ? \"polite\" : \"assertive\");\n    if (!params.toast) {\n        popup.setAttribute(\"aria-modal\", \"true\");\n    }\n};\n/**\n * @param {HTMLElement} targetElement\n */ const setupRTL = (targetElement)=>{\n    if (window.getComputedStyle(targetElement).direction === \"rtl\") {\n        addClass(getContainer(), swalClasses.rtl);\n        globalState.isRTL = true;\n    }\n};\n/**\n * Add modal + backdrop to DOM\n *\n * @param {SweetAlertOptions} params\n */ const init = (params)=>{\n    // Clean up the old popup container if it exists\n    const oldContainerExisted = resetOldContainer();\n    if (isNodeEnv()) {\n        error(\"SweetAlert2 requires document to initialize\");\n        return;\n    }\n    const container = document.createElement(\"div\");\n    container.className = swalClasses.container;\n    if (oldContainerExisted) {\n        addClass(container, swalClasses[\"no-transition\"]);\n    }\n    setInnerHtml(container, sweetHTML);\n    container.dataset[\"swal2Theme\"] = params.theme;\n    const targetElement = getTarget(params.target);\n    targetElement.appendChild(container);\n    if (params.topLayer) {\n        container.setAttribute(\"popover\", \"\");\n        container.showPopover();\n    }\n    setupAccessibility(params);\n    setupRTL(targetElement);\n    addInputChangeListeners();\n};\n/**\n * @param {HTMLElement | object | string} param\n * @param {HTMLElement} target\n */ const parseHtmlToContainer = (param, target)=>{\n    // DOM element\n    if (param instanceof HTMLElement) {\n        target.appendChild(param);\n    } else if (typeof param === \"object\") {\n        handleObject(param, target);\n    } else if (param) {\n        setInnerHtml(target, param);\n    }\n};\n/**\n * @param {object} param\n * @param {HTMLElement} target\n */ const handleObject = (param, target)=>{\n    // JQuery element(s)\n    if (param.jquery) {\n        handleJqueryElem(target, param);\n    } else {\n        setInnerHtml(target, param.toString());\n    }\n};\n/**\n * @param {HTMLElement} target\n * @param {object} elem\n */ const handleJqueryElem = (target, elem)=>{\n    target.textContent = \"\";\n    if (0 in elem) {\n        for(let i = 0; (i in elem); i++){\n            target.appendChild(elem[i].cloneNode(true));\n        }\n    } else {\n        target.appendChild(elem.cloneNode(true));\n    }\n};\n/**\n * @param {SweetAlert} instance\n * @param {SweetAlertOptions} params\n */ const renderActions = (instance, params)=>{\n    const actions = getActions();\n    const loader = getLoader();\n    if (!actions || !loader) {\n        return;\n    }\n    // Actions (buttons) wrapper\n    if (!params.showConfirmButton && !params.showDenyButton && !params.showCancelButton) {\n        hide(actions);\n    } else {\n        show(actions);\n    }\n    // Custom class\n    applyCustomClass(actions, params, \"actions\");\n    // Render all the buttons\n    renderButtons(actions, loader, params);\n    // Loader\n    setInnerHtml(loader, params.loaderHtml || \"\");\n    applyCustomClass(loader, params, \"loader\");\n};\n/**\n * @param {HTMLElement} actions\n * @param {HTMLElement} loader\n * @param {SweetAlertOptions} params\n */ function renderButtons(actions, loader, params) {\n    const confirmButton = getConfirmButton();\n    const denyButton = getDenyButton();\n    const cancelButton = getCancelButton();\n    if (!confirmButton || !denyButton || !cancelButton) {\n        return;\n    }\n    // Render buttons\n    renderButton(confirmButton, \"confirm\", params);\n    renderButton(denyButton, \"deny\", params);\n    renderButton(cancelButton, \"cancel\", params);\n    handleButtonsStyling(confirmButton, denyButton, cancelButton, params);\n    if (params.reverseButtons) {\n        if (params.toast) {\n            actions.insertBefore(cancelButton, confirmButton);\n            actions.insertBefore(denyButton, confirmButton);\n        } else {\n            actions.insertBefore(cancelButton, loader);\n            actions.insertBefore(denyButton, loader);\n            actions.insertBefore(confirmButton, loader);\n        }\n    }\n}\n/**\n * @param {HTMLElement} confirmButton\n * @param {HTMLElement} denyButton\n * @param {HTMLElement} cancelButton\n * @param {SweetAlertOptions} params\n */ function handleButtonsStyling(confirmButton, denyButton, cancelButton, params) {\n    if (!params.buttonsStyling) {\n        removeClass([\n            confirmButton,\n            denyButton,\n            cancelButton\n        ], swalClasses.styled);\n        return;\n    }\n    addClass([\n        confirmButton,\n        denyButton,\n        cancelButton\n    ], swalClasses.styled);\n    // Apply custom background colors to action buttons\n    if (params.confirmButtonColor) {\n        confirmButton.style.setProperty(\"--swal2-confirm-button-background-color\", params.confirmButtonColor);\n    }\n    if (params.denyButtonColor) {\n        denyButton.style.setProperty(\"--swal2-deny-button-background-color\", params.denyButtonColor);\n    }\n    if (params.cancelButtonColor) {\n        cancelButton.style.setProperty(\"--swal2-cancel-button-background-color\", params.cancelButtonColor);\n    }\n    // Apply the outline color to action buttons\n    applyOutlineColor(confirmButton);\n    applyOutlineColor(denyButton);\n    applyOutlineColor(cancelButton);\n}\n/**\n * @param {HTMLElement} button\n */ function applyOutlineColor(button) {\n    const buttonStyle = window.getComputedStyle(button);\n    if (buttonStyle.getPropertyValue(\"--swal2-action-button-focus-box-shadow\")) {\n        // If the button already has a custom outline color, no need to change it\n        return;\n    }\n    const outlineColor = buttonStyle.backgroundColor.replace(/rgba?\\((\\d+), (\\d+), (\\d+).*/, \"rgba($1, $2, $3, 0.5)\");\n    button.style.setProperty(\"--swal2-action-button-focus-box-shadow\", buttonStyle.getPropertyValue(\"--swal2-outline\").replace(/ rgba\\(.*/, ` ${outlineColor}`));\n}\n/**\n * @param {HTMLElement} button\n * @param {'confirm' | 'deny' | 'cancel'} buttonType\n * @param {SweetAlertOptions} params\n */ function renderButton(button, buttonType, params) {\n    const buttonName = /** @type {'Confirm' | 'Deny' | 'Cancel'} */ capitalizeFirstLetter(buttonType);\n    toggle(button, params[`show${buttonName}Button`], \"inline-block\");\n    setInnerHtml(button, params[`${buttonType}ButtonText`] || \"\"); // Set caption text\n    button.setAttribute(\"aria-label\", params[`${buttonType}ButtonAriaLabel`] || \"\"); // ARIA label\n    // Add buttons custom classes\n    button.className = swalClasses[buttonType];\n    applyCustomClass(button, params, `${buttonType}Button`);\n}\n/**\n * @param {SweetAlert} instance\n * @param {SweetAlertOptions} params\n */ const renderCloseButton = (instance, params)=>{\n    const closeButton = getCloseButton();\n    if (!closeButton) {\n        return;\n    }\n    setInnerHtml(closeButton, params.closeButtonHtml || \"\");\n    // Custom class\n    applyCustomClass(closeButton, params, \"closeButton\");\n    toggle(closeButton, params.showCloseButton);\n    closeButton.setAttribute(\"aria-label\", params.closeButtonAriaLabel || \"\");\n};\n/**\n * @param {SweetAlert} instance\n * @param {SweetAlertOptions} params\n */ const renderContainer = (instance, params)=>{\n    const container = getContainer();\n    if (!container) {\n        return;\n    }\n    handleBackdropParam(container, params.backdrop);\n    handlePositionParam(container, params.position);\n    handleGrowParam(container, params.grow);\n    // Custom class\n    applyCustomClass(container, params, \"container\");\n};\n/**\n * @param {HTMLElement} container\n * @param {SweetAlertOptions['backdrop']} backdrop\n */ function handleBackdropParam(container, backdrop) {\n    if (typeof backdrop === \"string\") {\n        container.style.background = backdrop;\n    } else if (!backdrop) {\n        addClass([\n            document.documentElement,\n            document.body\n        ], swalClasses[\"no-backdrop\"]);\n    }\n}\n/**\n * @param {HTMLElement} container\n * @param {SweetAlertOptions['position']} position\n */ function handlePositionParam(container, position) {\n    if (!position) {\n        return;\n    }\n    if (position in swalClasses) {\n        addClass(container, swalClasses[position]);\n    } else {\n        warn('The \"position\" parameter is not valid, defaulting to \"center\"');\n        addClass(container, swalClasses.center);\n    }\n}\n/**\n * @param {HTMLElement} container\n * @param {SweetAlertOptions['grow']} grow\n */ function handleGrowParam(container, grow) {\n    if (!grow) {\n        return;\n    }\n    addClass(container, swalClasses[`grow-${grow}`]);\n}\n/**\n * This module contains `WeakMap`s for each effectively-\"private  property\" that a `Swal` has.\n * For example, to set the private property \"foo\" of `this` to \"bar\", you can `privateProps.foo.set(this, 'bar')`\n * This is the approach that Babel will probably take to implement private methods/fields\n *   https://github.com/tc39/proposal-private-methods\n *   https://github.com/babel/babel/pull/7555\n * Once we have the changes from that PR in Babel, and our core class fits reasonable in *one module*\n *   then we can use that language feature.\n */ var privateProps = {\n    innerParams: new WeakMap(),\n    domCache: new WeakMap()\n};\n/// <reference path=\"../../../../sweetalert2.d.ts\"/>\n/** @type {InputClass[]} */ const inputClasses = [\n    \"input\",\n    \"file\",\n    \"range\",\n    \"select\",\n    \"radio\",\n    \"checkbox\",\n    \"textarea\"\n];\n/**\n * @param {SweetAlert} instance\n * @param {SweetAlertOptions} params\n */ const renderInput = (instance, params)=>{\n    const popup = getPopup();\n    if (!popup) {\n        return;\n    }\n    const innerParams = privateProps.innerParams.get(instance);\n    const rerender = !innerParams || params.input !== innerParams.input;\n    inputClasses.forEach((inputClass)=>{\n        const inputContainer = getDirectChildByClass(popup, swalClasses[inputClass]);\n        if (!inputContainer) {\n            return;\n        }\n        // set attributes\n        setAttributes(inputClass, params.inputAttributes);\n        // set class\n        inputContainer.className = swalClasses[inputClass];\n        if (rerender) {\n            hide(inputContainer);\n        }\n    });\n    if (params.input) {\n        if (rerender) {\n            showInput(params);\n        }\n        // set custom class\n        setCustomClass(params);\n    }\n};\n/**\n * @param {SweetAlertOptions} params\n */ const showInput = (params)=>{\n    if (!params.input) {\n        return;\n    }\n    if (!renderInputType[params.input]) {\n        error(`Unexpected type of input! Expected ${Object.keys(renderInputType).join(\" | \")}, got \"${params.input}\"`);\n        return;\n    }\n    const inputContainer = getInputContainer(params.input);\n    if (!inputContainer) {\n        return;\n    }\n    const input = renderInputType[params.input](inputContainer, params);\n    show(inputContainer);\n    // input autofocus\n    if (params.inputAutoFocus) {\n        setTimeout(()=>{\n            focusInput(input);\n        });\n    }\n};\n/**\n * @param {HTMLInputElement} input\n */ const removeAttributes = (input)=>{\n    for(let i = 0; i < input.attributes.length; i++){\n        const attrName = input.attributes[i].name;\n        if (![\n            \"id\",\n            \"type\",\n            \"value\",\n            \"style\"\n        ].includes(attrName)) {\n            input.removeAttribute(attrName);\n        }\n    }\n};\n/**\n * @param {InputClass} inputClass\n * @param {SweetAlertOptions['inputAttributes']} inputAttributes\n */ const setAttributes = (inputClass, inputAttributes)=>{\n    const popup = getPopup();\n    if (!popup) {\n        return;\n    }\n    const input = getInput$1(popup, inputClass);\n    if (!input) {\n        return;\n    }\n    removeAttributes(input);\n    for(const attr in inputAttributes){\n        input.setAttribute(attr, inputAttributes[attr]);\n    }\n};\n/**\n * @param {SweetAlertOptions} params\n */ const setCustomClass = (params)=>{\n    if (!params.input) {\n        return;\n    }\n    const inputContainer = getInputContainer(params.input);\n    if (inputContainer) {\n        applyCustomClass(inputContainer, params, \"input\");\n    }\n};\n/**\n * @param {HTMLInputElement | HTMLTextAreaElement} input\n * @param {SweetAlertOptions} params\n */ const setInputPlaceholder = (input, params)=>{\n    if (!input.placeholder && params.inputPlaceholder) {\n        input.placeholder = params.inputPlaceholder;\n    }\n};\n/**\n * @param {Input} input\n * @param {Input} prependTo\n * @param {SweetAlertOptions} params\n */ const setInputLabel = (input, prependTo, params)=>{\n    if (params.inputLabel) {\n        const label = document.createElement(\"label\");\n        const labelClass = swalClasses[\"input-label\"];\n        label.setAttribute(\"for\", input.id);\n        label.className = labelClass;\n        if (typeof params.customClass === \"object\") {\n            addClass(label, params.customClass.inputLabel);\n        }\n        label.innerText = params.inputLabel;\n        prependTo.insertAdjacentElement(\"beforebegin\", label);\n    }\n};\n/**\n * @param {SweetAlertInput} inputType\n * @returns {HTMLElement | undefined}\n */ const getInputContainer = (inputType)=>{\n    const popup = getPopup();\n    if (!popup) {\n        return;\n    }\n    return getDirectChildByClass(popup, swalClasses[/** @type {SwalClass} */ inputType] || swalClasses.input);\n};\n/**\n * @param {HTMLInputElement | HTMLOutputElement | HTMLTextAreaElement} input\n * @param {SweetAlertOptions['inputValue']} inputValue\n */ const checkAndSetInputValue = (input, inputValue)=>{\n    if ([\n        \"string\",\n        \"number\"\n    ].includes(typeof inputValue)) {\n        input.value = `${inputValue}`;\n    } else if (!isPromise(inputValue)) {\n        warn(`Unexpected type of inputValue! Expected \"string\", \"number\" or \"Promise\", got \"${typeof inputValue}\"`);\n    }\n};\n/** @type {Record<SweetAlertInput, (input: Input | HTMLElement, params: SweetAlertOptions) => Input>} */ const renderInputType = {};\n/**\n * @param {HTMLInputElement} input\n * @param {SweetAlertOptions} params\n * @returns {HTMLInputElement}\n */ renderInputType.text = renderInputType.email = renderInputType.password = renderInputType.number = renderInputType.tel = renderInputType.url = renderInputType.search = renderInputType.date = renderInputType[\"datetime-local\"] = renderInputType.time = renderInputType.week = renderInputType.month = /** @type {(input: Input | HTMLElement, params: SweetAlertOptions) => Input} */ (input, params)=>{\n    checkAndSetInputValue(input, params.inputValue);\n    setInputLabel(input, input, params);\n    setInputPlaceholder(input, params);\n    input.type = params.input;\n    return input;\n};\n/**\n * @param {HTMLInputElement} input\n * @param {SweetAlertOptions} params\n * @returns {HTMLInputElement}\n */ renderInputType.file = (input, params)=>{\n    setInputLabel(input, input, params);\n    setInputPlaceholder(input, params);\n    return input;\n};\n/**\n * @param {HTMLInputElement} range\n * @param {SweetAlertOptions} params\n * @returns {HTMLInputElement}\n */ renderInputType.range = (range, params)=>{\n    const rangeInput = range.querySelector(\"input\");\n    const rangeOutput = range.querySelector(\"output\");\n    checkAndSetInputValue(rangeInput, params.inputValue);\n    rangeInput.type = params.input;\n    checkAndSetInputValue(rangeOutput, params.inputValue);\n    setInputLabel(rangeInput, range, params);\n    return range;\n};\n/**\n * @param {HTMLSelectElement} select\n * @param {SweetAlertOptions} params\n * @returns {HTMLSelectElement}\n */ renderInputType.select = (select, params)=>{\n    select.textContent = \"\";\n    if (params.inputPlaceholder) {\n        const placeholder = document.createElement(\"option\");\n        setInnerHtml(placeholder, params.inputPlaceholder);\n        placeholder.value = \"\";\n        placeholder.disabled = true;\n        placeholder.selected = true;\n        select.appendChild(placeholder);\n    }\n    setInputLabel(select, select, params);\n    return select;\n};\n/**\n * @param {HTMLInputElement} radio\n * @returns {HTMLInputElement}\n */ renderInputType.radio = (radio)=>{\n    radio.textContent = \"\";\n    return radio;\n};\n/**\n * @param {HTMLLabelElement} checkboxContainer\n * @param {SweetAlertOptions} params\n * @returns {HTMLInputElement}\n */ renderInputType.checkbox = (checkboxContainer, params)=>{\n    const checkbox = getInput$1(getPopup(), \"checkbox\");\n    checkbox.value = \"1\";\n    checkbox.checked = Boolean(params.inputValue);\n    const label = checkboxContainer.querySelector(\"span\");\n    setInnerHtml(label, params.inputPlaceholder || params.inputLabel);\n    return checkbox;\n};\n/**\n * @param {HTMLTextAreaElement} textarea\n * @param {SweetAlertOptions} params\n * @returns {HTMLTextAreaElement}\n */ renderInputType.textarea = (textarea, params)=>{\n    checkAndSetInputValue(textarea, params.inputValue);\n    setInputPlaceholder(textarea, params);\n    setInputLabel(textarea, textarea, params);\n    /**\n   * @param {HTMLElement} el\n   * @returns {number}\n   */ const getMargin = (el)=>parseInt(window.getComputedStyle(el).marginLeft) + parseInt(window.getComputedStyle(el).marginRight);\n    // https://github.com/sweetalert2/sweetalert2/issues/2291\n    setTimeout(()=>{\n        // https://github.com/sweetalert2/sweetalert2/issues/1699\n        if (\"MutationObserver\" in window) {\n            const initialPopupWidth = parseInt(window.getComputedStyle(getPopup()).width);\n            const textareaResizeHandler = ()=>{\n                // check if texarea is still in document (i.e. popup wasn't closed in the meantime)\n                if (!document.body.contains(textarea)) {\n                    return;\n                }\n                const textareaWidth = textarea.offsetWidth + getMargin(textarea);\n                if (textareaWidth > initialPopupWidth) {\n                    getPopup().style.width = `${textareaWidth}px`;\n                } else {\n                    applyNumericalStyle(getPopup(), \"width\", params.width);\n                }\n            };\n            new MutationObserver(textareaResizeHandler).observe(textarea, {\n                attributes: true,\n                attributeFilter: [\n                    \"style\"\n                ]\n            });\n        }\n    });\n    return textarea;\n};\n/**\n * @param {SweetAlert} instance\n * @param {SweetAlertOptions} params\n */ const renderContent = (instance, params)=>{\n    const htmlContainer = getHtmlContainer();\n    if (!htmlContainer) {\n        return;\n    }\n    showWhenInnerHtmlPresent(htmlContainer);\n    applyCustomClass(htmlContainer, params, \"htmlContainer\");\n    // Content as HTML\n    if (params.html) {\n        parseHtmlToContainer(params.html, htmlContainer);\n        show(htmlContainer, \"block\");\n    } else if (params.text) {\n        htmlContainer.textContent = params.text;\n        show(htmlContainer, \"block\");\n    } else {\n        hide(htmlContainer);\n    }\n    renderInput(instance, params);\n};\n/**\n * @param {SweetAlert} instance\n * @param {SweetAlertOptions} params\n */ const renderFooter = (instance, params)=>{\n    const footer = getFooter();\n    if (!footer) {\n        return;\n    }\n    showWhenInnerHtmlPresent(footer);\n    toggle(footer, Boolean(params.footer), \"block\");\n    if (params.footer) {\n        parseHtmlToContainer(params.footer, footer);\n    }\n    // Custom class\n    applyCustomClass(footer, params, \"footer\");\n};\n/**\n * @param {SweetAlert} instance\n * @param {SweetAlertOptions} params\n */ const renderIcon = (instance, params)=>{\n    const innerParams = privateProps.innerParams.get(instance);\n    const icon = getIcon();\n    if (!icon) {\n        return;\n    }\n    // if the given icon already rendered, apply the styling without re-rendering the icon\n    if (innerParams && params.icon === innerParams.icon) {\n        // Custom or default content\n        setContent(icon, params);\n        applyStyles(icon, params);\n        return;\n    }\n    if (!params.icon && !params.iconHtml) {\n        hide(icon);\n        return;\n    }\n    if (params.icon && Object.keys(iconTypes).indexOf(params.icon) === -1) {\n        error(`Unknown icon! Expected \"success\", \"error\", \"warning\", \"info\" or \"question\", got \"${params.icon}\"`);\n        hide(icon);\n        return;\n    }\n    show(icon);\n    // Custom or default content\n    setContent(icon, params);\n    applyStyles(icon, params);\n    // Animate icon\n    addClass(icon, params.showClass && params.showClass.icon);\n    // Re-adjust the success icon on system theme change\n    const colorSchemeQueryList = window.matchMedia(\"(prefers-color-scheme: dark)\");\n    colorSchemeQueryList.addEventListener(\"change\", adjustSuccessIconBackgroundColor);\n};\n/**\n * @param {HTMLElement} icon\n * @param {SweetAlertOptions} params\n */ const applyStyles = (icon, params)=>{\n    for (const [iconType, iconClassName] of Object.entries(iconTypes)){\n        if (params.icon !== iconType) {\n            removeClass(icon, iconClassName);\n        }\n    }\n    addClass(icon, params.icon && iconTypes[params.icon]);\n    // Icon color\n    setColor(icon, params);\n    // Success icon background color\n    adjustSuccessIconBackgroundColor();\n    // Custom class\n    applyCustomClass(icon, params, \"icon\");\n};\n// Adjust success icon background color to match the popup background color\nconst adjustSuccessIconBackgroundColor = ()=>{\n    const popup = getPopup();\n    if (!popup) {\n        return;\n    }\n    const popupBackgroundColor = window.getComputedStyle(popup).getPropertyValue(\"background-color\");\n    /** @type {NodeListOf<HTMLElement>} */ const successIconParts = popup.querySelectorAll(\"[class^=swal2-success-circular-line], .swal2-success-fix\");\n    for(let i = 0; i < successIconParts.length; i++){\n        successIconParts[i].style.backgroundColor = popupBackgroundColor;\n    }\n};\n/**\n *\n * @param {SweetAlertOptions} params\n * @returns {string}\n */ const successIconHtml = (params)=>`\n  ${params.animation ? '<div class=\"swal2-success-circular-line-left\"></div>' : \"\"}\n  <span class=\"swal2-success-line-tip\"></span> <span class=\"swal2-success-line-long\"></span>\n  <div class=\"swal2-success-ring\"></div>\n  ${params.animation ? '<div class=\"swal2-success-fix\"></div>' : \"\"}\n  ${params.animation ? '<div class=\"swal2-success-circular-line-right\"></div>' : \"\"}\n`;\nconst errorIconHtml = `\n  <span class=\"swal2-x-mark\">\n    <span class=\"swal2-x-mark-line-left\"></span>\n    <span class=\"swal2-x-mark-line-right\"></span>\n  </span>\n`;\n/**\n * @param {HTMLElement} icon\n * @param {SweetAlertOptions} params\n */ const setContent = (icon, params)=>{\n    if (!params.icon && !params.iconHtml) {\n        return;\n    }\n    let oldContent = icon.innerHTML;\n    let newContent = \"\";\n    if (params.iconHtml) {\n        newContent = iconContent(params.iconHtml);\n    } else if (params.icon === \"success\") {\n        newContent = successIconHtml(params);\n        oldContent = oldContent.replace(/ style=\".*?\"/g, \"\"); // undo adjustSuccessIconBackgroundColor()\n    } else if (params.icon === \"error\") {\n        newContent = errorIconHtml;\n    } else if (params.icon) {\n        const defaultIconHtml = {\n            question: \"?\",\n            warning: \"!\",\n            info: \"i\"\n        };\n        newContent = iconContent(defaultIconHtml[params.icon]);\n    }\n    if (oldContent.trim() !== newContent.trim()) {\n        setInnerHtml(icon, newContent);\n    }\n};\n/**\n * @param {HTMLElement} icon\n * @param {SweetAlertOptions} params\n */ const setColor = (icon, params)=>{\n    if (!params.iconColor) {\n        return;\n    }\n    icon.style.color = params.iconColor;\n    icon.style.borderColor = params.iconColor;\n    for (const sel of [\n        \".swal2-success-line-tip\",\n        \".swal2-success-line-long\",\n        \".swal2-x-mark-line-left\",\n        \".swal2-x-mark-line-right\"\n    ]){\n        setStyle(icon, sel, \"background-color\", params.iconColor);\n    }\n    setStyle(icon, \".swal2-success-ring\", \"border-color\", params.iconColor);\n};\n/**\n * @param {string} content\n * @returns {string}\n */ const iconContent = (content)=>`<div class=\"${swalClasses[\"icon-content\"]}\">${content}</div>`;\n/**\n * @param {SweetAlert} instance\n * @param {SweetAlertOptions} params\n */ const renderImage = (instance, params)=>{\n    const image = getImage();\n    if (!image) {\n        return;\n    }\n    if (!params.imageUrl) {\n        hide(image);\n        return;\n    }\n    show(image, \"\");\n    // Src, alt\n    image.setAttribute(\"src\", params.imageUrl);\n    image.setAttribute(\"alt\", params.imageAlt || \"\");\n    // Width, height\n    applyNumericalStyle(image, \"width\", params.imageWidth);\n    applyNumericalStyle(image, \"height\", params.imageHeight);\n    // Class\n    image.className = swalClasses.image;\n    applyCustomClass(image, params, \"image\");\n};\nlet dragging = false;\nlet mousedownX = 0;\nlet mousedownY = 0;\nlet initialX = 0;\nlet initialY = 0;\n/**\n * @param {HTMLElement} popup\n */ const addDraggableListeners = (popup)=>{\n    popup.addEventListener(\"mousedown\", down);\n    document.body.addEventListener(\"mousemove\", move);\n    popup.addEventListener(\"mouseup\", up);\n    popup.addEventListener(\"touchstart\", down);\n    document.body.addEventListener(\"touchmove\", move);\n    popup.addEventListener(\"touchend\", up);\n};\n/**\n * @param {HTMLElement} popup\n */ const removeDraggableListeners = (popup)=>{\n    popup.removeEventListener(\"mousedown\", down);\n    document.body.removeEventListener(\"mousemove\", move);\n    popup.removeEventListener(\"mouseup\", up);\n    popup.removeEventListener(\"touchstart\", down);\n    document.body.removeEventListener(\"touchmove\", move);\n    popup.removeEventListener(\"touchend\", up);\n};\n/**\n * @param {MouseEvent | TouchEvent} event\n */ const down = (event)=>{\n    const popup = getPopup();\n    if (event.target === popup || getIcon().contains(/** @type {HTMLElement} */ event.target)) {\n        dragging = true;\n        const clientXY = getClientXY(event);\n        mousedownX = clientXY.clientX;\n        mousedownY = clientXY.clientY;\n        initialX = parseInt(popup.style.insetInlineStart) || 0;\n        initialY = parseInt(popup.style.insetBlockStart) || 0;\n        addClass(popup, \"swal2-dragging\");\n    }\n};\n/**\n * @param {MouseEvent | TouchEvent} event\n */ const move = (event)=>{\n    const popup = getPopup();\n    if (dragging) {\n        let { clientX, clientY } = getClientXY(event);\n        const deltaX = clientX - mousedownX;\n        // In RTL mode, negate the horizontal delta since insetInlineStart refers to the right edge\n        popup.style.insetInlineStart = `${initialX + (globalState.isRTL ? -deltaX : deltaX)}px`;\n        popup.style.insetBlockStart = `${initialY + (clientY - mousedownY)}px`;\n    }\n};\nconst up = ()=>{\n    const popup = getPopup();\n    dragging = false;\n    removeClass(popup, \"swal2-dragging\");\n};\n/**\n * @param {MouseEvent | TouchEvent} event\n * @returns {{ clientX: number, clientY: number }}\n */ const getClientXY = (event)=>{\n    let clientX = 0, clientY = 0;\n    if (event.type.startsWith(\"mouse\")) {\n        clientX = /** @type {MouseEvent} */ event.clientX;\n        clientY = /** @type {MouseEvent} */ event.clientY;\n    } else if (event.type.startsWith(\"touch\")) {\n        clientX = /** @type {TouchEvent} */ event.touches[0].clientX;\n        clientY = /** @type {TouchEvent} */ event.touches[0].clientY;\n    }\n    return {\n        clientX,\n        clientY\n    };\n};\n/**\n * @param {SweetAlert} instance\n * @param {SweetAlertOptions} params\n */ const renderPopup = (instance, params)=>{\n    const container = getContainer();\n    const popup = getPopup();\n    if (!container || !popup) {\n        return;\n    }\n    // Width\n    // https://github.com/sweetalert2/sweetalert2/issues/2170\n    if (params.toast) {\n        applyNumericalStyle(container, \"width\", params.width);\n        popup.style.width = \"100%\";\n        const loader = getLoader();\n        if (loader) {\n            popup.insertBefore(loader, getIcon());\n        }\n    } else {\n        applyNumericalStyle(popup, \"width\", params.width);\n    }\n    // Padding\n    applyNumericalStyle(popup, \"padding\", params.padding);\n    // Color\n    if (params.color) {\n        popup.style.color = params.color;\n    }\n    // Background\n    if (params.background) {\n        popup.style.background = params.background;\n    }\n    hide(getValidationMessage());\n    // Classes\n    addClasses$1(popup, params);\n    if (params.draggable && !params.toast) {\n        addClass(popup, swalClasses.draggable);\n        addDraggableListeners(popup);\n    } else {\n        removeClass(popup, swalClasses.draggable);\n        removeDraggableListeners(popup);\n    }\n};\n/**\n * @param {HTMLElement} popup\n * @param {SweetAlertOptions} params\n */ const addClasses$1 = (popup, params)=>{\n    const showClass = params.showClass || {};\n    // Default Class + showClass when updating Swal.update({})\n    popup.className = `${swalClasses.popup} ${isVisible$1(popup) ? showClass.popup : \"\"}`;\n    if (params.toast) {\n        addClass([\n            document.documentElement,\n            document.body\n        ], swalClasses[\"toast-shown\"]);\n        addClass(popup, swalClasses.toast);\n    } else {\n        addClass(popup, swalClasses.modal);\n    }\n    // Custom class\n    applyCustomClass(popup, params, \"popup\");\n    // TODO: remove in the next major\n    if (typeof params.customClass === \"string\") {\n        addClass(popup, params.customClass);\n    }\n    // Icon class (#1842)\n    if (params.icon) {\n        addClass(popup, swalClasses[`icon-${params.icon}`]);\n    }\n};\n/**\n * @param {SweetAlert} instance\n * @param {SweetAlertOptions} params\n */ const renderProgressSteps = (instance, params)=>{\n    const progressStepsContainer = getProgressSteps();\n    if (!progressStepsContainer) {\n        return;\n    }\n    const { progressSteps, currentProgressStep } = params;\n    if (!progressSteps || progressSteps.length === 0 || currentProgressStep === undefined) {\n        hide(progressStepsContainer);\n        return;\n    }\n    show(progressStepsContainer);\n    progressStepsContainer.textContent = \"\";\n    if (currentProgressStep >= progressSteps.length) {\n        warn(\"Invalid currentProgressStep parameter, it should be less than progressSteps.length \" + \"(currentProgressStep like JS arrays starts from 0)\");\n    }\n    progressSteps.forEach((step, index)=>{\n        const stepEl = createStepElement(step);\n        progressStepsContainer.appendChild(stepEl);\n        if (index === currentProgressStep) {\n            addClass(stepEl, swalClasses[\"active-progress-step\"]);\n        }\n        if (index !== progressSteps.length - 1) {\n            const lineEl = createLineElement(params);\n            progressStepsContainer.appendChild(lineEl);\n        }\n    });\n};\n/**\n * @param {string} step\n * @returns {HTMLLIElement}\n */ const createStepElement = (step)=>{\n    const stepEl = document.createElement(\"li\");\n    addClass(stepEl, swalClasses[\"progress-step\"]);\n    setInnerHtml(stepEl, step);\n    return stepEl;\n};\n/**\n * @param {SweetAlertOptions} params\n * @returns {HTMLLIElement}\n */ const createLineElement = (params)=>{\n    const lineEl = document.createElement(\"li\");\n    addClass(lineEl, swalClasses[\"progress-step-line\"]);\n    if (params.progressStepsDistance) {\n        applyNumericalStyle(lineEl, \"width\", params.progressStepsDistance);\n    }\n    return lineEl;\n};\n/**\n * @param {SweetAlert} instance\n * @param {SweetAlertOptions} params\n */ const renderTitle = (instance, params)=>{\n    const title = getTitle();\n    if (!title) {\n        return;\n    }\n    showWhenInnerHtmlPresent(title);\n    toggle(title, Boolean(params.title || params.titleText), \"block\");\n    if (params.title) {\n        parseHtmlToContainer(params.title, title);\n    }\n    if (params.titleText) {\n        title.innerText = params.titleText;\n    }\n    // Custom class\n    applyCustomClass(title, params, \"title\");\n};\n/**\n * @param {SweetAlert} instance\n * @param {SweetAlertOptions} params\n */ const render = (instance, params)=>{\n    renderPopup(instance, params);\n    renderContainer(instance, params);\n    renderProgressSteps(instance, params);\n    renderIcon(instance, params);\n    renderImage(instance, params);\n    renderTitle(instance, params);\n    renderCloseButton(instance, params);\n    renderContent(instance, params);\n    renderActions(instance, params);\n    renderFooter(instance, params);\n    const popup = getPopup();\n    if (typeof params.didRender === \"function\" && popup) {\n        params.didRender(popup);\n    }\n    globalState.eventEmitter.emit(\"didRender\", popup);\n};\n/*\n * Global function to determine if SweetAlert2 popup is shown\n */ const isVisible = ()=>{\n    return isVisible$1(getPopup());\n};\n/*\n * Global function to click 'Confirm' button\n */ const clickConfirm = ()=>{\n    var _dom$getConfirmButton;\n    return (_dom$getConfirmButton = getConfirmButton()) === null || _dom$getConfirmButton === void 0 ? void 0 : _dom$getConfirmButton.click();\n};\n/*\n * Global function to click 'Deny' button\n */ const clickDeny = ()=>{\n    var _dom$getDenyButton;\n    return (_dom$getDenyButton = getDenyButton()) === null || _dom$getDenyButton === void 0 ? void 0 : _dom$getDenyButton.click();\n};\n/*\n * Global function to click 'Cancel' button\n */ const clickCancel = ()=>{\n    var _dom$getCancelButton;\n    return (_dom$getCancelButton = getCancelButton()) === null || _dom$getCancelButton === void 0 ? void 0 : _dom$getCancelButton.click();\n};\n/** @type {Record<DismissReason, DismissReason>} */ const DismissReason = Object.freeze({\n    cancel: \"cancel\",\n    backdrop: \"backdrop\",\n    close: \"close\",\n    esc: \"esc\",\n    timer: \"timer\"\n});\n/**\n * @param {GlobalState} globalState\n */ const removeKeydownHandler = (globalState)=>{\n    if (globalState.keydownTarget && globalState.keydownHandlerAdded) {\n        globalState.keydownTarget.removeEventListener(\"keydown\", globalState.keydownHandler, {\n            capture: globalState.keydownListenerCapture\n        });\n        globalState.keydownHandlerAdded = false;\n    }\n};\n/**\n * @param {GlobalState} globalState\n * @param {SweetAlertOptions} innerParams\n * @param {(dismiss: DismissReason) => void} dismissWith\n */ const addKeydownHandler = (globalState, innerParams, dismissWith)=>{\n    removeKeydownHandler(globalState);\n    if (!innerParams.toast) {\n        globalState.keydownHandler = (e)=>keydownHandler(innerParams, e, dismissWith);\n        globalState.keydownTarget = innerParams.keydownListenerCapture ? window : getPopup();\n        globalState.keydownListenerCapture = innerParams.keydownListenerCapture;\n        globalState.keydownTarget.addEventListener(\"keydown\", globalState.keydownHandler, {\n            capture: globalState.keydownListenerCapture\n        });\n        globalState.keydownHandlerAdded = true;\n    }\n};\n/**\n * @param {number} index\n * @param {number} increment\n */ const setFocus = (index, increment)=>{\n    var _dom$getPopup;\n    const focusableElements = getFocusableElements();\n    // search for visible elements and select the next possible match\n    if (focusableElements.length) {\n        index = index + increment;\n        // shift + tab when .swal2-popup is focused\n        if (index === -2) {\n            index = focusableElements.length - 1;\n        }\n        // rollover to first item\n        if (index === focusableElements.length) {\n            index = 0;\n        // go to last item\n        } else if (index === -1) {\n            index = focusableElements.length - 1;\n        }\n        focusableElements[index].focus();\n        return;\n    }\n    // no visible focusable elements, focus the popup\n    (_dom$getPopup = getPopup()) === null || _dom$getPopup === void 0 || _dom$getPopup.focus();\n};\nconst arrowKeysNextButton = [\n    \"ArrowRight\",\n    \"ArrowDown\"\n];\nconst arrowKeysPreviousButton = [\n    \"ArrowLeft\",\n    \"ArrowUp\"\n];\n/**\n * @param {SweetAlertOptions} innerParams\n * @param {KeyboardEvent} event\n * @param {(dismiss: DismissReason) => void} dismissWith\n */ const keydownHandler = (innerParams, event, dismissWith)=>{\n    if (!innerParams) {\n        return; // This instance has already been destroyed\n    }\n    // Ignore keydown during IME composition\n    // https://developer.mozilla.org/en-US/docs/Web/API/Document/keydown_event#ignoring_keydown_during_ime_composition\n    // https://github.com/sweetalert2/sweetalert2/issues/720\n    // https://github.com/sweetalert2/sweetalert2/issues/2406\n    if (event.isComposing || event.keyCode === 229) {\n        return;\n    }\n    if (innerParams.stopKeydownPropagation) {\n        event.stopPropagation();\n    }\n    // ENTER\n    if (event.key === \"Enter\") {\n        handleEnter(event, innerParams);\n    } else if (event.key === \"Tab\") {\n        handleTab(event);\n    } else if ([\n        ...arrowKeysNextButton,\n        ...arrowKeysPreviousButton\n    ].includes(event.key)) {\n        handleArrows(event.key);\n    } else if (event.key === \"Escape\") {\n        handleEsc(event, innerParams, dismissWith);\n    }\n};\n/**\n * @param {KeyboardEvent} event\n * @param {SweetAlertOptions} innerParams\n */ const handleEnter = (event, innerParams)=>{\n    // https://github.com/sweetalert2/sweetalert2/issues/2386\n    if (!callIfFunction(innerParams.allowEnterKey)) {\n        return;\n    }\n    const input = getInput$1(getPopup(), innerParams.input);\n    if (event.target && input && event.target instanceof HTMLElement && event.target.outerHTML === input.outerHTML) {\n        if ([\n            \"textarea\",\n            \"file\"\n        ].includes(innerParams.input)) {\n            return; // do not submit\n        }\n        clickConfirm();\n        event.preventDefault();\n    }\n};\n/**\n * @param {KeyboardEvent} event\n */ const handleTab = (event)=>{\n    const targetElement = event.target;\n    const focusableElements = getFocusableElements();\n    let btnIndex = -1;\n    for(let i = 0; i < focusableElements.length; i++){\n        if (targetElement === focusableElements[i]) {\n            btnIndex = i;\n            break;\n        }\n    }\n    // Cycle to the next button\n    if (!event.shiftKey) {\n        setFocus(btnIndex, 1);\n    } else {\n        setFocus(btnIndex, -1);\n    }\n    event.stopPropagation();\n    event.preventDefault();\n};\n/**\n * @param {string} key\n */ const handleArrows = (key)=>{\n    const actions = getActions();\n    const confirmButton = getConfirmButton();\n    const denyButton = getDenyButton();\n    const cancelButton = getCancelButton();\n    if (!actions || !confirmButton || !denyButton || !cancelButton) {\n        return;\n    }\n    /** @type HTMLElement[] */ const buttons = [\n        confirmButton,\n        denyButton,\n        cancelButton\n    ];\n    if (document.activeElement instanceof HTMLElement && !buttons.includes(document.activeElement)) {\n        return;\n    }\n    const sibling = arrowKeysNextButton.includes(key) ? \"nextElementSibling\" : \"previousElementSibling\";\n    let buttonToFocus = document.activeElement;\n    if (!buttonToFocus) {\n        return;\n    }\n    for(let i = 0; i < actions.children.length; i++){\n        buttonToFocus = buttonToFocus[sibling];\n        if (!buttonToFocus) {\n            return;\n        }\n        if (buttonToFocus instanceof HTMLButtonElement && isVisible$1(buttonToFocus)) {\n            break;\n        }\n    }\n    if (buttonToFocus instanceof HTMLButtonElement) {\n        buttonToFocus.focus();\n    }\n};\n/**\n * @param {KeyboardEvent} event\n * @param {SweetAlertOptions} innerParams\n * @param {(dismiss: DismissReason) => void} dismissWith\n */ const handleEsc = (event, innerParams, dismissWith)=>{\n    event.preventDefault();\n    if (callIfFunction(innerParams.allowEscapeKey)) {\n        dismissWith(DismissReason.esc);\n    }\n};\n/**\n * This module contains `WeakMap`s for each effectively-\"private  property\" that a `Swal` has.\n * For example, to set the private property \"foo\" of `this` to \"bar\", you can `privateProps.foo.set(this, 'bar')`\n * This is the approach that Babel will probably take to implement private methods/fields\n *   https://github.com/tc39/proposal-private-methods\n *   https://github.com/babel/babel/pull/7555\n * Once we have the changes from that PR in Babel, and our core class fits reasonable in *one module*\n *   then we can use that language feature.\n */ var privateMethods = {\n    swalPromiseResolve: new WeakMap(),\n    swalPromiseReject: new WeakMap()\n};\n// From https://developer.paciellogroup.com/blog/2018/06/the-current-state-of-modal-dialog-accessibility/\n// Adding aria-hidden=\"true\" to elements outside of the active modal dialog ensures that\n// elements not within the active modal dialog will not be surfaced if a user opens a screen\n// readers list of elements (headings, form controls, landmarks, etc.) in the document.\nconst setAriaHidden = ()=>{\n    const container = getContainer();\n    const bodyChildren = Array.from(document.body.children);\n    bodyChildren.forEach((el)=>{\n        if (el.contains(container)) {\n            return;\n        }\n        if (el.hasAttribute(\"aria-hidden\")) {\n            el.setAttribute(\"data-previous-aria-hidden\", el.getAttribute(\"aria-hidden\") || \"\");\n        }\n        el.setAttribute(\"aria-hidden\", \"true\");\n    });\n};\nconst unsetAriaHidden = ()=>{\n    const bodyChildren = Array.from(document.body.children);\n    bodyChildren.forEach((el)=>{\n        if (el.hasAttribute(\"data-previous-aria-hidden\")) {\n            el.setAttribute(\"aria-hidden\", el.getAttribute(\"data-previous-aria-hidden\") || \"\");\n            el.removeAttribute(\"data-previous-aria-hidden\");\n        } else {\n            el.removeAttribute(\"aria-hidden\");\n        }\n    });\n};\n// @ts-ignore\nconst isSafariOrIOS =  false && 0; // true for Safari desktop + all iOS browsers https://stackoverflow.com/a/70585394\n/**\n * Fix iOS scrolling\n * http://stackoverflow.com/q/39626302\n */ const iOSfix = ()=>{\n    if (isSafariOrIOS && !hasClass(document.body, swalClasses.iosfix)) {\n        const offset = document.body.scrollTop;\n        document.body.style.top = `${offset * -1}px`;\n        addClass(document.body, swalClasses.iosfix);\n        lockBodyScroll();\n    }\n};\n/**\n * https://github.com/sweetalert2/sweetalert2/issues/1246\n */ const lockBodyScroll = ()=>{\n    const container = getContainer();\n    if (!container) {\n        return;\n    }\n    /** @type {boolean} */ let preventTouchMove;\n    /**\n   * @param {TouchEvent} event\n   */ container.ontouchstart = (event)=>{\n        preventTouchMove = shouldPreventTouchMove(event);\n    };\n    /**\n   * @param {TouchEvent} event\n   */ container.ontouchmove = (event)=>{\n        if (preventTouchMove) {\n            event.preventDefault();\n            event.stopPropagation();\n        }\n    };\n};\n/**\n * @param {TouchEvent} event\n * @returns {boolean}\n */ const shouldPreventTouchMove = (event)=>{\n    const target = event.target;\n    const container = getContainer();\n    const htmlContainer = getHtmlContainer();\n    if (!container || !htmlContainer) {\n        return false;\n    }\n    if (isStylus(event) || isZoom(event)) {\n        return false;\n    }\n    if (target === container) {\n        return true;\n    }\n    if (!isScrollable(container) && target instanceof HTMLElement && !selfOrParentIsScrollable(target, htmlContainer) && // #2823\n    target.tagName !== \"INPUT\" && // #1603\n    target.tagName !== \"TEXTAREA\" && // #2266\n    !(isScrollable(htmlContainer) && // #1944\n    htmlContainer.contains(target))) {\n        return true;\n    }\n    return false;\n};\n/**\n * https://github.com/sweetalert2/sweetalert2/issues/1786\n *\n * @param {object} event\n * @returns {boolean}\n */ const isStylus = (event)=>{\n    return event.touches && event.touches.length && event.touches[0].touchType === \"stylus\";\n};\n/**\n * https://github.com/sweetalert2/sweetalert2/issues/1891\n *\n * @param {TouchEvent} event\n * @returns {boolean}\n */ const isZoom = (event)=>{\n    return event.touches && event.touches.length > 1;\n};\nconst undoIOSfix = ()=>{\n    if (hasClass(document.body, swalClasses.iosfix)) {\n        const offset = parseInt(document.body.style.top, 10);\n        removeClass(document.body, swalClasses.iosfix);\n        document.body.style.top = \"\";\n        document.body.scrollTop = offset * -1;\n    }\n};\n/**\n * Measure scrollbar width for padding body during modal show/hide\n * https://github.com/twbs/bootstrap/blob/master/js/src/modal.js\n *\n * @returns {number}\n */ const measureScrollbar = ()=>{\n    const scrollDiv = document.createElement(\"div\");\n    scrollDiv.className = swalClasses[\"scrollbar-measure\"];\n    document.body.appendChild(scrollDiv);\n    const scrollbarWidth = scrollDiv.getBoundingClientRect().width - scrollDiv.clientWidth;\n    document.body.removeChild(scrollDiv);\n    return scrollbarWidth;\n};\n/**\n * Remember state in cases where opening and handling a modal will fiddle with it.\n * @type {number | null}\n */ let previousBodyPadding = null;\n/**\n * @param {string} initialBodyOverflow\n */ const replaceScrollbarWithPadding = (initialBodyOverflow)=>{\n    // for queues, do not do this more than once\n    if (previousBodyPadding !== null) {\n        return;\n    }\n    // if the body has overflow\n    if (document.body.scrollHeight > window.innerHeight || initialBodyOverflow === \"scroll\" // https://github.com/sweetalert2/sweetalert2/issues/2663\n    ) {\n        // add padding so the content doesn't shift after removal of scrollbar\n        previousBodyPadding = parseInt(window.getComputedStyle(document.body).getPropertyValue(\"padding-right\"));\n        document.body.style.paddingRight = `${previousBodyPadding + measureScrollbar()}px`;\n    }\n};\nconst undoReplaceScrollbarWithPadding = ()=>{\n    if (previousBodyPadding !== null) {\n        document.body.style.paddingRight = `${previousBodyPadding}px`;\n        previousBodyPadding = null;\n    }\n};\n/**\n * @param {SweetAlert} instance\n * @param {HTMLElement} container\n * @param {boolean} returnFocus\n * @param {() => void} didClose\n */ function removePopupAndResetState(instance, container, returnFocus, didClose) {\n    if (isToast()) {\n        triggerDidCloseAndDispose(instance, didClose);\n    } else {\n        restoreActiveElement(returnFocus).then(()=>triggerDidCloseAndDispose(instance, didClose));\n        removeKeydownHandler(globalState);\n    }\n    // workaround for https://github.com/sweetalert2/sweetalert2/issues/2088\n    // for some reason removing the container in Safari will scroll the document to bottom\n    if (isSafariOrIOS) {\n        container.setAttribute(\"style\", \"display:none !important\");\n        container.removeAttribute(\"class\");\n        container.innerHTML = \"\";\n    } else {\n        container.remove();\n    }\n    if (isModal()) {\n        undoReplaceScrollbarWithPadding();\n        undoIOSfix();\n        unsetAriaHidden();\n    }\n    removeBodyClasses();\n}\n/**\n * Remove SweetAlert2 classes from body\n */ function removeBodyClasses() {\n    removeClass([\n        document.documentElement,\n        document.body\n    ], [\n        swalClasses.shown,\n        swalClasses[\"height-auto\"],\n        swalClasses[\"no-backdrop\"],\n        swalClasses[\"toast-shown\"]\n    ]);\n}\n/**\n * Instance method to close sweetAlert\n *\n * @param {SweetAlertResult | undefined} resolveValue\n */ function close(resolveValue) {\n    resolveValue = prepareResolveValue(resolveValue);\n    const swalPromiseResolve = privateMethods.swalPromiseResolve.get(this);\n    const didClose = triggerClosePopup(this);\n    if (this.isAwaitingPromise) {\n        // A swal awaiting for a promise (after a click on Confirm or Deny) cannot be dismissed anymore #2335\n        if (!resolveValue.isDismissed) {\n            handleAwaitingPromise(this);\n            swalPromiseResolve(resolveValue);\n        }\n    } else if (didClose) {\n        // Resolve Swal promise\n        swalPromiseResolve(resolveValue);\n    }\n}\nconst triggerClosePopup = (instance)=>{\n    const popup = getPopup();\n    if (!popup) {\n        return false;\n    }\n    const innerParams = privateProps.innerParams.get(instance);\n    if (!innerParams || hasClass(popup, innerParams.hideClass.popup)) {\n        return false;\n    }\n    removeClass(popup, innerParams.showClass.popup);\n    addClass(popup, innerParams.hideClass.popup);\n    const backdrop = getContainer();\n    removeClass(backdrop, innerParams.showClass.backdrop);\n    addClass(backdrop, innerParams.hideClass.backdrop);\n    handlePopupAnimation(instance, popup, innerParams);\n    return true;\n};\n/**\n * @param {Error | string} error\n */ function rejectPromise(error) {\n    const rejectPromise = privateMethods.swalPromiseReject.get(this);\n    handleAwaitingPromise(this);\n    if (rejectPromise) {\n        // Reject Swal promise\n        rejectPromise(error);\n    }\n}\n/**\n * @param {SweetAlert} instance\n */ const handleAwaitingPromise = (instance)=>{\n    if (instance.isAwaitingPromise) {\n        delete instance.isAwaitingPromise;\n        // The instance might have been previously partly destroyed, we must resume the destroy process in this case #2335\n        if (!privateProps.innerParams.get(instance)) {\n            instance._destroy();\n        }\n    }\n};\n/**\n * @param {SweetAlertResult | undefined} resolveValue\n * @returns {SweetAlertResult}\n */ const prepareResolveValue = (resolveValue)=>{\n    // When user calls Swal.close()\n    if (typeof resolveValue === \"undefined\") {\n        return {\n            isConfirmed: false,\n            isDenied: false,\n            isDismissed: true\n        };\n    }\n    return Object.assign({\n        isConfirmed: false,\n        isDenied: false,\n        isDismissed: false\n    }, resolveValue);\n};\n/**\n * @param {SweetAlert} instance\n * @param {HTMLElement} popup\n * @param {SweetAlertOptions} innerParams\n */ const handlePopupAnimation = (instance, popup, innerParams)=>{\n    var _globalState$eventEmi;\n    const container = getContainer();\n    // If animation is supported, animate\n    const animationIsSupported = hasCssAnimation(popup);\n    if (typeof innerParams.willClose === \"function\") {\n        innerParams.willClose(popup);\n    }\n    (_globalState$eventEmi = globalState.eventEmitter) === null || _globalState$eventEmi === void 0 || _globalState$eventEmi.emit(\"willClose\", popup);\n    if (animationIsSupported) {\n        animatePopup(instance, popup, container, innerParams.returnFocus, innerParams.didClose);\n    } else {\n        // Otherwise, remove immediately\n        removePopupAndResetState(instance, container, innerParams.returnFocus, innerParams.didClose);\n    }\n};\n/**\n * @param {SweetAlert} instance\n * @param {HTMLElement} popup\n * @param {HTMLElement} container\n * @param {boolean} returnFocus\n * @param {() => void} didClose\n */ const animatePopup = (instance, popup, container, returnFocus, didClose)=>{\n    globalState.swalCloseEventFinishedCallback = removePopupAndResetState.bind(null, instance, container, returnFocus, didClose);\n    /**\n   * @param {AnimationEvent | TransitionEvent} e\n   */ const swalCloseAnimationFinished = function(e) {\n        if (e.target === popup) {\n            var _globalState$swalClos;\n            (_globalState$swalClos = globalState.swalCloseEventFinishedCallback) === null || _globalState$swalClos === void 0 || _globalState$swalClos.call(globalState);\n            delete globalState.swalCloseEventFinishedCallback;\n            popup.removeEventListener(\"animationend\", swalCloseAnimationFinished);\n            popup.removeEventListener(\"transitionend\", swalCloseAnimationFinished);\n        }\n    };\n    popup.addEventListener(\"animationend\", swalCloseAnimationFinished);\n    popup.addEventListener(\"transitionend\", swalCloseAnimationFinished);\n};\n/**\n * @param {SweetAlert} instance\n * @param {() => void} didClose\n */ const triggerDidCloseAndDispose = (instance, didClose)=>{\n    setTimeout(()=>{\n        var _globalState$eventEmi2;\n        if (typeof didClose === \"function\") {\n            didClose.bind(instance.params)();\n        }\n        (_globalState$eventEmi2 = globalState.eventEmitter) === null || _globalState$eventEmi2 === void 0 || _globalState$eventEmi2.emit(\"didClose\");\n        // instance might have been destroyed already\n        if (instance._destroy) {\n            instance._destroy();\n        }\n    });\n};\n/**\n * Shows loader (spinner), this is useful with AJAX requests.\n * By default the loader be shown instead of the \"Confirm\" button.\n *\n * @param {HTMLButtonElement | null} [buttonToReplace]\n */ const showLoading = (buttonToReplace)=>{\n    let popup = getPopup();\n    if (!popup) {\n        new Swal();\n    }\n    popup = getPopup();\n    if (!popup) {\n        return;\n    }\n    const loader = getLoader();\n    if (isToast()) {\n        hide(getIcon());\n    } else {\n        replaceButton(popup, buttonToReplace);\n    }\n    show(loader);\n    popup.setAttribute(\"data-loading\", \"true\");\n    popup.setAttribute(\"aria-busy\", \"true\");\n    popup.focus();\n};\n/**\n * @param {HTMLElement} popup\n * @param {HTMLButtonElement | null} [buttonToReplace]\n */ const replaceButton = (popup, buttonToReplace)=>{\n    const actions = getActions();\n    const loader = getLoader();\n    if (!actions || !loader) {\n        return;\n    }\n    if (!buttonToReplace && isVisible$1(getConfirmButton())) {\n        buttonToReplace = getConfirmButton();\n    }\n    show(actions);\n    if (buttonToReplace) {\n        hide(buttonToReplace);\n        loader.setAttribute(\"data-button-to-replace\", buttonToReplace.className);\n        actions.insertBefore(loader, buttonToReplace);\n    }\n    addClass([\n        popup,\n        actions\n    ], swalClasses.loading);\n};\n/**\n * @param {SweetAlert} instance\n * @param {SweetAlertOptions} params\n */ const handleInputOptionsAndValue = (instance, params)=>{\n    if (params.input === \"select\" || params.input === \"radio\") {\n        handleInputOptions(instance, params);\n    } else if ([\n        \"text\",\n        \"email\",\n        \"number\",\n        \"tel\",\n        \"textarea\"\n    ].some((i)=>i === params.input) && (hasToPromiseFn(params.inputValue) || isPromise(params.inputValue))) {\n        showLoading(getConfirmButton());\n        handleInputValue(instance, params);\n    }\n};\n/**\n * @param {SweetAlert} instance\n * @param {SweetAlertOptions} innerParams\n * @returns {SweetAlertInputValue}\n */ const getInputValue = (instance, innerParams)=>{\n    const input = instance.getInput();\n    if (!input) {\n        return null;\n    }\n    switch(innerParams.input){\n        case \"checkbox\":\n            return getCheckboxValue(input);\n        case \"radio\":\n            return getRadioValue(input);\n        case \"file\":\n            return getFileValue(input);\n        default:\n            return innerParams.inputAutoTrim ? input.value.trim() : input.value;\n    }\n};\n/**\n * @param {HTMLInputElement} input\n * @returns {number}\n */ const getCheckboxValue = (input)=>input.checked ? 1 : 0;\n/**\n * @param {HTMLInputElement} input\n * @returns {string | null}\n */ const getRadioValue = (input)=>input.checked ? input.value : null;\n/**\n * @param {HTMLInputElement} input\n * @returns {FileList | File | null}\n */ const getFileValue = (input)=>input.files && input.files.length ? input.getAttribute(\"multiple\") !== null ? input.files : input.files[0] : null;\n/**\n * @param {SweetAlert} instance\n * @param {SweetAlertOptions} params\n */ const handleInputOptions = (instance, params)=>{\n    const popup = getPopup();\n    if (!popup) {\n        return;\n    }\n    /**\n   * @param {*} inputOptions\n   */ const processInputOptions = (inputOptions)=>{\n        if (params.input === \"select\") {\n            populateSelectOptions(popup, formatInputOptions(inputOptions), params);\n        } else if (params.input === \"radio\") {\n            populateRadioOptions(popup, formatInputOptions(inputOptions), params);\n        }\n    };\n    if (hasToPromiseFn(params.inputOptions) || isPromise(params.inputOptions)) {\n        showLoading(getConfirmButton());\n        asPromise(params.inputOptions).then((inputOptions)=>{\n            instance.hideLoading();\n            processInputOptions(inputOptions);\n        });\n    } else if (typeof params.inputOptions === \"object\") {\n        processInputOptions(params.inputOptions);\n    } else {\n        error(`Unexpected type of inputOptions! Expected object, Map or Promise, got ${typeof params.inputOptions}`);\n    }\n};\n/**\n * @param {SweetAlert} instance\n * @param {SweetAlertOptions} params\n */ const handleInputValue = (instance, params)=>{\n    const input = instance.getInput();\n    if (!input) {\n        return;\n    }\n    hide(input);\n    asPromise(params.inputValue).then((inputValue)=>{\n        input.value = params.input === \"number\" ? `${parseFloat(inputValue) || 0}` : `${inputValue}`;\n        show(input);\n        input.focus();\n        instance.hideLoading();\n    }).catch((err)=>{\n        error(`Error in inputValue promise: ${err}`);\n        input.value = \"\";\n        show(input);\n        input.focus();\n        instance.hideLoading();\n    });\n};\n/**\n * @param {HTMLElement} popup\n * @param {InputOptionFlattened[]} inputOptions\n * @param {SweetAlertOptions} params\n */ function populateSelectOptions(popup, inputOptions, params) {\n    const select = getDirectChildByClass(popup, swalClasses.select);\n    if (!select) {\n        return;\n    }\n    /**\n   * @param {HTMLElement} parent\n   * @param {string} optionLabel\n   * @param {string} optionValue\n   */ const renderOption = (parent, optionLabel, optionValue)=>{\n        const option = document.createElement(\"option\");\n        option.value = optionValue;\n        setInnerHtml(option, optionLabel);\n        option.selected = isSelected(optionValue, params.inputValue);\n        parent.appendChild(option);\n    };\n    inputOptions.forEach((inputOption)=>{\n        const optionValue = inputOption[0];\n        const optionLabel = inputOption[1];\n        // <optgroup> spec:\n        // https://www.w3.org/TR/html401/interact/forms.html#h-17.6\n        // \"...all OPTGROUP elements must be specified directly within a SELECT element (i.e., groups may not be nested)...\"\n        // check whether this is a <optgroup>\n        if (Array.isArray(optionLabel)) {\n            // if it is an array, then it is an <optgroup>\n            const optgroup = document.createElement(\"optgroup\");\n            optgroup.label = optionValue;\n            optgroup.disabled = false; // not configurable for now\n            select.appendChild(optgroup);\n            optionLabel.forEach((o)=>renderOption(optgroup, o[1], o[0]));\n        } else {\n            // case of <option>\n            renderOption(select, optionLabel, optionValue);\n        }\n    });\n    select.focus();\n}\n/**\n * @param {HTMLElement} popup\n * @param {InputOptionFlattened[]} inputOptions\n * @param {SweetAlertOptions} params\n */ function populateRadioOptions(popup, inputOptions, params) {\n    const radio = getDirectChildByClass(popup, swalClasses.radio);\n    if (!radio) {\n        return;\n    }\n    inputOptions.forEach((inputOption)=>{\n        const radioValue = inputOption[0];\n        const radioLabel = inputOption[1];\n        const radioInput = document.createElement(\"input\");\n        const radioLabelElement = document.createElement(\"label\");\n        radioInput.type = \"radio\";\n        radioInput.name = swalClasses.radio;\n        radioInput.value = radioValue;\n        if (isSelected(radioValue, params.inputValue)) {\n            radioInput.checked = true;\n        }\n        const label = document.createElement(\"span\");\n        setInnerHtml(label, radioLabel);\n        label.className = swalClasses.label;\n        radioLabelElement.appendChild(radioInput);\n        radioLabelElement.appendChild(label);\n        radio.appendChild(radioLabelElement);\n    });\n    const radios = radio.querySelectorAll(\"input\");\n    if (radios.length) {\n        radios[0].focus();\n    }\n}\n/**\n * Converts `inputOptions` into an array of `[value, label]`s\n *\n * @param {*} inputOptions\n * @typedef {string[]} InputOptionFlattened\n * @returns {InputOptionFlattened[]}\n */ const formatInputOptions = (inputOptions)=>{\n    /** @type {InputOptionFlattened[]} */ const result = [];\n    if (inputOptions instanceof Map) {\n        inputOptions.forEach((value, key)=>{\n            let valueFormatted = value;\n            if (typeof valueFormatted === \"object\") {\n                // case of <optgroup>\n                valueFormatted = formatInputOptions(valueFormatted);\n            }\n            result.push([\n                key,\n                valueFormatted\n            ]);\n        });\n    } else {\n        Object.keys(inputOptions).forEach((key)=>{\n            let valueFormatted = inputOptions[key];\n            if (typeof valueFormatted === \"object\") {\n                // case of <optgroup>\n                valueFormatted = formatInputOptions(valueFormatted);\n            }\n            result.push([\n                key,\n                valueFormatted\n            ]);\n        });\n    }\n    return result;\n};\n/**\n * @param {string} optionValue\n * @param {SweetAlertInputValue} inputValue\n * @returns {boolean}\n */ const isSelected = (optionValue, inputValue)=>{\n    return !!inputValue && inputValue.toString() === optionValue.toString();\n};\n/**\n * @param {SweetAlert} instance\n */ const handleConfirmButtonClick = (instance)=>{\n    const innerParams = privateProps.innerParams.get(instance);\n    instance.disableButtons();\n    if (innerParams.input) {\n        handleConfirmOrDenyWithInput(instance, \"confirm\");\n    } else {\n        confirm(instance, true);\n    }\n};\n/**\n * @param {SweetAlert} instance\n */ const handleDenyButtonClick = (instance)=>{\n    const innerParams = privateProps.innerParams.get(instance);\n    instance.disableButtons();\n    if (innerParams.returnInputValueOnDeny) {\n        handleConfirmOrDenyWithInput(instance, \"deny\");\n    } else {\n        deny(instance, false);\n    }\n};\n/**\n * @param {SweetAlert} instance\n * @param {(dismiss: DismissReason) => void} dismissWith\n */ const handleCancelButtonClick = (instance, dismissWith)=>{\n    instance.disableButtons();\n    dismissWith(DismissReason.cancel);\n};\n/**\n * @param {SweetAlert} instance\n * @param {'confirm' | 'deny'} type\n */ const handleConfirmOrDenyWithInput = (instance, type)=>{\n    const innerParams = privateProps.innerParams.get(instance);\n    if (!innerParams.input) {\n        error(`The \"input\" parameter is needed to be set when using returnInputValueOn${capitalizeFirstLetter(type)}`);\n        return;\n    }\n    const input = instance.getInput();\n    const inputValue = getInputValue(instance, innerParams);\n    if (innerParams.inputValidator) {\n        handleInputValidator(instance, inputValue, type);\n    } else if (input && !input.checkValidity()) {\n        instance.enableButtons();\n        instance.showValidationMessage(innerParams.validationMessage || input.validationMessage);\n    } else if (type === \"deny\") {\n        deny(instance, inputValue);\n    } else {\n        confirm(instance, inputValue);\n    }\n};\n/**\n * @param {SweetAlert} instance\n * @param {SweetAlertInputValue} inputValue\n * @param {'confirm' | 'deny'} type\n */ const handleInputValidator = (instance, inputValue, type)=>{\n    const innerParams = privateProps.innerParams.get(instance);\n    instance.disableInput();\n    const validationPromise = Promise.resolve().then(()=>asPromise(innerParams.inputValidator(inputValue, innerParams.validationMessage)));\n    validationPromise.then((validationMessage)=>{\n        instance.enableButtons();\n        instance.enableInput();\n        if (validationMessage) {\n            instance.showValidationMessage(validationMessage);\n        } else if (type === \"deny\") {\n            deny(instance, inputValue);\n        } else {\n            confirm(instance, inputValue);\n        }\n    });\n};\n/**\n * @param {SweetAlert} instance\n * @param {*} value\n */ const deny = (instance, value)=>{\n    const innerParams = privateProps.innerParams.get(instance || undefined);\n    if (innerParams.showLoaderOnDeny) {\n        showLoading(getDenyButton());\n    }\n    if (innerParams.preDeny) {\n        instance.isAwaitingPromise = true; // Flagging the instance as awaiting a promise so it's own promise's reject/resolve methods doesn't get destroyed until the result from this preDeny's promise is received\n        const preDenyPromise = Promise.resolve().then(()=>asPromise(innerParams.preDeny(value, innerParams.validationMessage)));\n        preDenyPromise.then((preDenyValue)=>{\n            if (preDenyValue === false) {\n                instance.hideLoading();\n                handleAwaitingPromise(instance);\n            } else {\n                instance.close(/** @type SweetAlertResult */ {\n                    isDenied: true,\n                    value: typeof preDenyValue === \"undefined\" ? value : preDenyValue\n                });\n            }\n        }).catch((error)=>rejectWith(instance || undefined, error));\n    } else {\n        instance.close(/** @type SweetAlertResult */ {\n            isDenied: true,\n            value\n        });\n    }\n};\n/**\n * @param {SweetAlert} instance\n * @param {*} value\n */ const succeedWith = (instance, value)=>{\n    instance.close(/** @type SweetAlertResult */ {\n        isConfirmed: true,\n        value\n    });\n};\n/**\n *\n * @param {SweetAlert} instance\n * @param {string} error\n */ const rejectWith = (instance, error)=>{\n    instance.rejectPromise(error);\n};\n/**\n *\n * @param {SweetAlert} instance\n * @param {*} value\n */ const confirm = (instance, value)=>{\n    const innerParams = privateProps.innerParams.get(instance || undefined);\n    if (innerParams.showLoaderOnConfirm) {\n        showLoading();\n    }\n    if (innerParams.preConfirm) {\n        instance.resetValidationMessage();\n        instance.isAwaitingPromise = true; // Flagging the instance as awaiting a promise so it's own promise's reject/resolve methods doesn't get destroyed until the result from this preConfirm's promise is received\n        const preConfirmPromise = Promise.resolve().then(()=>asPromise(innerParams.preConfirm(value, innerParams.validationMessage)));\n        preConfirmPromise.then((preConfirmValue)=>{\n            if (isVisible$1(getValidationMessage()) || preConfirmValue === false) {\n                instance.hideLoading();\n                handleAwaitingPromise(instance);\n            } else {\n                succeedWith(instance, typeof preConfirmValue === \"undefined\" ? value : preConfirmValue);\n            }\n        }).catch((error)=>rejectWith(instance || undefined, error));\n    } else {\n        succeedWith(instance, value);\n    }\n};\n/**\n * Hides loader and shows back the button which was hidden by .showLoading()\n */ function hideLoading() {\n    // do nothing if popup is closed\n    const innerParams = privateProps.innerParams.get(this);\n    if (!innerParams) {\n        return;\n    }\n    const domCache = privateProps.domCache.get(this);\n    hide(domCache.loader);\n    if (isToast()) {\n        if (innerParams.icon) {\n            show(getIcon());\n        }\n    } else {\n        showRelatedButton(domCache);\n    }\n    removeClass([\n        domCache.popup,\n        domCache.actions\n    ], swalClasses.loading);\n    domCache.popup.removeAttribute(\"aria-busy\");\n    domCache.popup.removeAttribute(\"data-loading\");\n    domCache.confirmButton.disabled = false;\n    domCache.denyButton.disabled = false;\n    domCache.cancelButton.disabled = false;\n}\nconst showRelatedButton = (domCache)=>{\n    const buttonToReplace = domCache.popup.getElementsByClassName(domCache.loader.getAttribute(\"data-button-to-replace\"));\n    if (buttonToReplace.length) {\n        show(buttonToReplace[0], \"inline-block\");\n    } else if (allButtonsAreHidden()) {\n        hide(domCache.actions);\n    }\n};\n/**\n * Gets the input DOM node, this method works with input parameter.\n *\n * @returns {HTMLInputElement | null}\n */ function getInput() {\n    const innerParams = privateProps.innerParams.get(this);\n    const domCache = privateProps.domCache.get(this);\n    if (!domCache) {\n        return null;\n    }\n    return getInput$1(domCache.popup, innerParams.input);\n}\n/**\n * @param {SweetAlert} instance\n * @param {string[]} buttons\n * @param {boolean} disabled\n */ function setButtonsDisabled(instance, buttons, disabled) {\n    const domCache = privateProps.domCache.get(instance);\n    buttons.forEach((button)=>{\n        domCache[button].disabled = disabled;\n    });\n}\n/**\n * @param {HTMLInputElement | null} input\n * @param {boolean} disabled\n */ function setInputDisabled(input, disabled) {\n    const popup = getPopup();\n    if (!popup || !input) {\n        return;\n    }\n    if (input.type === \"radio\") {\n        /** @type {NodeListOf<HTMLInputElement>} */ const radios = popup.querySelectorAll(`[name=\"${swalClasses.radio}\"]`);\n        for(let i = 0; i < radios.length; i++){\n            radios[i].disabled = disabled;\n        }\n    } else {\n        input.disabled = disabled;\n    }\n}\n/**\n * Enable all the buttons\n * @this {SweetAlert}\n */ function enableButtons() {\n    setButtonsDisabled(this, [\n        \"confirmButton\",\n        \"denyButton\",\n        \"cancelButton\"\n    ], false);\n}\n/**\n * Disable all the buttons\n * @this {SweetAlert}\n */ function disableButtons() {\n    setButtonsDisabled(this, [\n        \"confirmButton\",\n        \"denyButton\",\n        \"cancelButton\"\n    ], true);\n}\n/**\n * Enable the input field\n * @this {SweetAlert}\n */ function enableInput() {\n    setInputDisabled(this.getInput(), false);\n}\n/**\n * Disable the input field\n * @this {SweetAlert}\n */ function disableInput() {\n    setInputDisabled(this.getInput(), true);\n}\n/**\n * Show block with validation message\n *\n * @param {string} error\n * @this {SweetAlert}\n */ function showValidationMessage(error) {\n    const domCache = privateProps.domCache.get(this);\n    const params = privateProps.innerParams.get(this);\n    setInnerHtml(domCache.validationMessage, error);\n    domCache.validationMessage.className = swalClasses[\"validation-message\"];\n    if (params.customClass && params.customClass.validationMessage) {\n        addClass(domCache.validationMessage, params.customClass.validationMessage);\n    }\n    show(domCache.validationMessage);\n    const input = this.getInput();\n    if (input) {\n        input.setAttribute(\"aria-invalid\", \"true\");\n        input.setAttribute(\"aria-describedby\", swalClasses[\"validation-message\"]);\n        focusInput(input);\n        addClass(input, swalClasses.inputerror);\n    }\n}\n/**\n * Hide block with validation message\n *\n * @this {SweetAlert}\n */ function resetValidationMessage() {\n    const domCache = privateProps.domCache.get(this);\n    if (domCache.validationMessage) {\n        hide(domCache.validationMessage);\n    }\n    const input = this.getInput();\n    if (input) {\n        input.removeAttribute(\"aria-invalid\");\n        input.removeAttribute(\"aria-describedby\");\n        removeClass(input, swalClasses.inputerror);\n    }\n}\nconst defaultParams = {\n    title: \"\",\n    titleText: \"\",\n    text: \"\",\n    html: \"\",\n    footer: \"\",\n    icon: undefined,\n    iconColor: undefined,\n    iconHtml: undefined,\n    template: undefined,\n    toast: false,\n    draggable: false,\n    animation: true,\n    theme: \"light\",\n    showClass: {\n        popup: \"swal2-show\",\n        backdrop: \"swal2-backdrop-show\",\n        icon: \"swal2-icon-show\"\n    },\n    hideClass: {\n        popup: \"swal2-hide\",\n        backdrop: \"swal2-backdrop-hide\",\n        icon: \"swal2-icon-hide\"\n    },\n    customClass: {},\n    target: \"body\",\n    color: undefined,\n    backdrop: true,\n    heightAuto: true,\n    allowOutsideClick: true,\n    allowEscapeKey: true,\n    allowEnterKey: true,\n    stopKeydownPropagation: true,\n    keydownListenerCapture: false,\n    showConfirmButton: true,\n    showDenyButton: false,\n    showCancelButton: false,\n    preConfirm: undefined,\n    preDeny: undefined,\n    confirmButtonText: \"OK\",\n    confirmButtonAriaLabel: \"\",\n    confirmButtonColor: undefined,\n    denyButtonText: \"No\",\n    denyButtonAriaLabel: \"\",\n    denyButtonColor: undefined,\n    cancelButtonText: \"Cancel\",\n    cancelButtonAriaLabel: \"\",\n    cancelButtonColor: undefined,\n    buttonsStyling: true,\n    reverseButtons: false,\n    focusConfirm: true,\n    focusDeny: false,\n    focusCancel: false,\n    returnFocus: true,\n    showCloseButton: false,\n    closeButtonHtml: \"&times;\",\n    closeButtonAriaLabel: \"Close this dialog\",\n    loaderHtml: \"\",\n    showLoaderOnConfirm: false,\n    showLoaderOnDeny: false,\n    imageUrl: undefined,\n    imageWidth: undefined,\n    imageHeight: undefined,\n    imageAlt: \"\",\n    timer: undefined,\n    timerProgressBar: false,\n    width: undefined,\n    padding: undefined,\n    background: undefined,\n    input: undefined,\n    inputPlaceholder: \"\",\n    inputLabel: \"\",\n    inputValue: \"\",\n    inputOptions: {},\n    inputAutoFocus: true,\n    inputAutoTrim: true,\n    inputAttributes: {},\n    inputValidator: undefined,\n    returnInputValueOnDeny: false,\n    validationMessage: undefined,\n    grow: false,\n    position: \"center\",\n    progressSteps: [],\n    currentProgressStep: undefined,\n    progressStepsDistance: undefined,\n    willOpen: undefined,\n    didOpen: undefined,\n    didRender: undefined,\n    willClose: undefined,\n    didClose: undefined,\n    didDestroy: undefined,\n    scrollbarPadding: true,\n    topLayer: false\n};\nconst updatableParams = [\n    \"allowEscapeKey\",\n    \"allowOutsideClick\",\n    \"background\",\n    \"buttonsStyling\",\n    \"cancelButtonAriaLabel\",\n    \"cancelButtonColor\",\n    \"cancelButtonText\",\n    \"closeButtonAriaLabel\",\n    \"closeButtonHtml\",\n    \"color\",\n    \"confirmButtonAriaLabel\",\n    \"confirmButtonColor\",\n    \"confirmButtonText\",\n    \"currentProgressStep\",\n    \"customClass\",\n    \"denyButtonAriaLabel\",\n    \"denyButtonColor\",\n    \"denyButtonText\",\n    \"didClose\",\n    \"didDestroy\",\n    \"draggable\",\n    \"footer\",\n    \"hideClass\",\n    \"html\",\n    \"icon\",\n    \"iconColor\",\n    \"iconHtml\",\n    \"imageAlt\",\n    \"imageHeight\",\n    \"imageUrl\",\n    \"imageWidth\",\n    \"preConfirm\",\n    \"preDeny\",\n    \"progressSteps\",\n    \"returnFocus\",\n    \"reverseButtons\",\n    \"showCancelButton\",\n    \"showCloseButton\",\n    \"showConfirmButton\",\n    \"showDenyButton\",\n    \"text\",\n    \"title\",\n    \"titleText\",\n    \"theme\",\n    \"willClose\"\n];\n/** @type {Record<string, string | undefined>} */ const deprecatedParams = {\n    allowEnterKey: undefined\n};\nconst toastIncompatibleParams = [\n    \"allowOutsideClick\",\n    \"allowEnterKey\",\n    \"backdrop\",\n    \"draggable\",\n    \"focusConfirm\",\n    \"focusDeny\",\n    \"focusCancel\",\n    \"returnFocus\",\n    \"heightAuto\",\n    \"keydownListenerCapture\"\n];\n/**\n * Is valid parameter\n *\n * @param {string} paramName\n * @returns {boolean}\n */ const isValidParameter = (paramName)=>{\n    return Object.prototype.hasOwnProperty.call(defaultParams, paramName);\n};\n/**\n * Is valid parameter for Swal.update() method\n *\n * @param {string} paramName\n * @returns {boolean}\n */ const isUpdatableParameter = (paramName)=>{\n    return updatableParams.indexOf(paramName) !== -1;\n};\n/**\n * Is deprecated parameter\n *\n * @param {string} paramName\n * @returns {string | undefined}\n */ const isDeprecatedParameter = (paramName)=>{\n    return deprecatedParams[paramName];\n};\n/**\n * @param {string} param\n */ const checkIfParamIsValid = (param)=>{\n    if (!isValidParameter(param)) {\n        warn(`Unknown parameter \"${param}\"`);\n    }\n};\n/**\n * @param {string} param\n */ const checkIfToastParamIsValid = (param)=>{\n    if (toastIncompatibleParams.includes(param)) {\n        warn(`The parameter \"${param}\" is incompatible with toasts`);\n    }\n};\n/**\n * @param {string} param\n */ const checkIfParamIsDeprecated = (param)=>{\n    const isDeprecated = isDeprecatedParameter(param);\n    if (isDeprecated) {\n        warnAboutDeprecation(param, isDeprecated);\n    }\n};\n/**\n * Show relevant warnings for given params\n *\n * @param {SweetAlertOptions} params\n */ const showWarningsForParams = (params)=>{\n    if (params.backdrop === false && params.allowOutsideClick) {\n        warn('\"allowOutsideClick\" parameter requires `backdrop` parameter to be set to `true`');\n    }\n    if (params.theme && ![\n        \"light\",\n        \"dark\",\n        \"auto\",\n        \"minimal\",\n        \"borderless\",\n        \"bootstrap-4\",\n        \"bootstrap-4-light\",\n        \"bootstrap-4-dark\",\n        \"bootstrap-5\",\n        \"bootstrap-5-light\",\n        \"bootstrap-5-dark\",\n        \"material-ui\",\n        \"material-ui-light\",\n        \"material-ui-dark\",\n        \"embed-iframe\",\n        \"bulma\",\n        \"bulma-light\",\n        \"bulma-dark\"\n    ].includes(params.theme)) {\n        warn(`Invalid theme \"${params.theme}\"`);\n    }\n    for(const param in params){\n        checkIfParamIsValid(param);\n        if (params.toast) {\n            checkIfToastParamIsValid(param);\n        }\n        checkIfParamIsDeprecated(param);\n    }\n};\n/**\n * Updates popup parameters.\n *\n * @param {SweetAlertOptions} params\n */ function update(params) {\n    const container = getContainer();\n    const popup = getPopup();\n    const innerParams = privateProps.innerParams.get(this);\n    if (!popup || hasClass(popup, innerParams.hideClass.popup)) {\n        warn(`You're trying to update the closed or closing popup, that won't work. Use the update() method in preConfirm parameter or show a new popup.`);\n        return;\n    }\n    const validUpdatableParams = filterValidParams(params);\n    const updatedParams = Object.assign({}, innerParams, validUpdatableParams);\n    showWarningsForParams(updatedParams);\n    container.dataset[\"swal2Theme\"] = updatedParams.theme;\n    render(this, updatedParams);\n    privateProps.innerParams.set(this, updatedParams);\n    Object.defineProperties(this, {\n        params: {\n            value: Object.assign({}, this.params, params),\n            writable: false,\n            enumerable: true\n        }\n    });\n}\n/**\n * @param {SweetAlertOptions} params\n * @returns {SweetAlertOptions}\n */ const filterValidParams = (params)=>{\n    const validUpdatableParams = {};\n    Object.keys(params).forEach((param)=>{\n        if (isUpdatableParameter(param)) {\n            validUpdatableParams[param] = params[param];\n        } else {\n            warn(`Invalid parameter to update: ${param}`);\n        }\n    });\n    return validUpdatableParams;\n};\n/**\n * Dispose the current SweetAlert2 instance\n */ function _destroy() {\n    const domCache = privateProps.domCache.get(this);\n    const innerParams = privateProps.innerParams.get(this);\n    if (!innerParams) {\n        disposeWeakMaps(this); // The WeakMaps might have been partly destroyed, we must recall it to dispose any remaining WeakMaps #2335\n        return; // This instance has already been destroyed\n    }\n    // Check if there is another Swal closing\n    if (domCache.popup && globalState.swalCloseEventFinishedCallback) {\n        globalState.swalCloseEventFinishedCallback();\n        delete globalState.swalCloseEventFinishedCallback;\n    }\n    if (typeof innerParams.didDestroy === \"function\") {\n        innerParams.didDestroy();\n    }\n    globalState.eventEmitter.emit(\"didDestroy\");\n    disposeSwal(this);\n}\n/**\n * @param {SweetAlert} instance\n */ const disposeSwal = (instance)=>{\n    disposeWeakMaps(instance);\n    // Unset this.params so GC will dispose it (#1569)\n    delete instance.params;\n    // Unset globalState props so GC will dispose globalState (#1569)\n    delete globalState.keydownHandler;\n    delete globalState.keydownTarget;\n    // Unset currentInstance\n    delete globalState.currentInstance;\n};\n/**\n * @param {SweetAlert} instance\n */ const disposeWeakMaps = (instance)=>{\n    // If the current instance is awaiting a promise result, we keep the privateMethods to call them once the promise result is retrieved #2335\n    if (instance.isAwaitingPromise) {\n        unsetWeakMaps(privateProps, instance);\n        instance.isAwaitingPromise = true;\n    } else {\n        unsetWeakMaps(privateMethods, instance);\n        unsetWeakMaps(privateProps, instance);\n        delete instance.isAwaitingPromise;\n        // Unset instance methods\n        delete instance.disableButtons;\n        delete instance.enableButtons;\n        delete instance.getInput;\n        delete instance.disableInput;\n        delete instance.enableInput;\n        delete instance.hideLoading;\n        delete instance.disableLoading;\n        delete instance.showValidationMessage;\n        delete instance.resetValidationMessage;\n        delete instance.close;\n        delete instance.closePopup;\n        delete instance.closeModal;\n        delete instance.closeToast;\n        delete instance.rejectPromise;\n        delete instance.update;\n        delete instance._destroy;\n    }\n};\n/**\n * @param {object} obj\n * @param {SweetAlert} instance\n */ const unsetWeakMaps = (obj, instance)=>{\n    for(const i in obj){\n        obj[i].delete(instance);\n    }\n};\nvar instanceMethods = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    _destroy: _destroy,\n    close: close,\n    closeModal: close,\n    closePopup: close,\n    closeToast: close,\n    disableButtons: disableButtons,\n    disableInput: disableInput,\n    disableLoading: hideLoading,\n    enableButtons: enableButtons,\n    enableInput: enableInput,\n    getInput: getInput,\n    handleAwaitingPromise: handleAwaitingPromise,\n    hideLoading: hideLoading,\n    rejectPromise: rejectPromise,\n    resetValidationMessage: resetValidationMessage,\n    showValidationMessage: showValidationMessage,\n    update: update\n});\n/**\n * @param {SweetAlertOptions} innerParams\n * @param {DomCache} domCache\n * @param {(dismiss: DismissReason) => void} dismissWith\n */ const handlePopupClick = (innerParams, domCache, dismissWith)=>{\n    if (innerParams.toast) {\n        handleToastClick(innerParams, domCache, dismissWith);\n    } else {\n        // Ignore click events that had mousedown on the popup but mouseup on the container\n        // This can happen when the user drags a slider\n        handleModalMousedown(domCache);\n        // Ignore click events that had mousedown on the container but mouseup on the popup\n        handleContainerMousedown(domCache);\n        handleModalClick(innerParams, domCache, dismissWith);\n    }\n};\n/**\n * @param {SweetAlertOptions} innerParams\n * @param {DomCache} domCache\n * @param {(dismiss: DismissReason) => void} dismissWith\n */ const handleToastClick = (innerParams, domCache, dismissWith)=>{\n    // Closing toast by internal click\n    domCache.popup.onclick = ()=>{\n        if (innerParams && (isAnyButtonShown(innerParams) || innerParams.timer || innerParams.input)) {\n            return;\n        }\n        dismissWith(DismissReason.close);\n    };\n};\n/**\n * @param {SweetAlertOptions} innerParams\n * @returns {boolean}\n */ const isAnyButtonShown = (innerParams)=>{\n    return !!(innerParams.showConfirmButton || innerParams.showDenyButton || innerParams.showCancelButton || innerParams.showCloseButton);\n};\nlet ignoreOutsideClick = false;\n/**\n * @param {DomCache} domCache\n */ const handleModalMousedown = (domCache)=>{\n    domCache.popup.onmousedown = ()=>{\n        domCache.container.onmouseup = function(e) {\n            domCache.container.onmouseup = ()=>{};\n            // We only check if the mouseup target is the container because usually it doesn't\n            // have any other direct children aside of the popup\n            if (e.target === domCache.container) {\n                ignoreOutsideClick = true;\n            }\n        };\n    };\n};\n/**\n * @param {DomCache} domCache\n */ const handleContainerMousedown = (domCache)=>{\n    domCache.container.onmousedown = (e)=>{\n        // prevent the modal text from being selected on double click on the container (allowOutsideClick: false)\n        if (e.target === domCache.container) {\n            e.preventDefault();\n        }\n        domCache.popup.onmouseup = function(e) {\n            domCache.popup.onmouseup = ()=>{};\n            // We also need to check if the mouseup target is a child of the popup\n            if (e.target === domCache.popup || e.target instanceof HTMLElement && domCache.popup.contains(e.target)) {\n                ignoreOutsideClick = true;\n            }\n        };\n    };\n};\n/**\n * @param {SweetAlertOptions} innerParams\n * @param {DomCache} domCache\n * @param {(dismiss: DismissReason) => void} dismissWith\n */ const handleModalClick = (innerParams, domCache, dismissWith)=>{\n    domCache.container.onclick = (e)=>{\n        if (ignoreOutsideClick) {\n            ignoreOutsideClick = false;\n            return;\n        }\n        if (e.target === domCache.container && callIfFunction(innerParams.allowOutsideClick)) {\n            dismissWith(DismissReason.backdrop);\n        }\n    };\n};\nconst isJqueryElement = (elem)=>typeof elem === \"object\" && elem.jquery;\nconst isElement = (elem)=>elem instanceof Element || isJqueryElement(elem);\nconst argsToParams = (args)=>{\n    const params = {};\n    if (typeof args[0] === \"object\" && !isElement(args[0])) {\n        Object.assign(params, args[0]);\n    } else {\n        [\n            \"title\",\n            \"html\",\n            \"icon\"\n        ].forEach((name, index)=>{\n            const arg = args[index];\n            if (typeof arg === \"string\" || isElement(arg)) {\n                params[name] = arg;\n            } else if (arg !== undefined) {\n                error(`Unexpected type of ${name}! Expected \"string\" or \"Element\", got ${typeof arg}`);\n            }\n        });\n    }\n    return params;\n};\n/**\n * Main method to create a new SweetAlert2 popup\n *\n * @param  {...SweetAlertOptions} args\n * @returns {Promise<SweetAlertResult>}\n */ function fire(...args) {\n    return new this(...args);\n}\n/**\n * Returns an extended version of `Swal` containing `params` as defaults.\n * Useful for reusing Swal configuration.\n *\n * For example:\n *\n * Before:\n * const textPromptOptions = { input: 'text', showCancelButton: true }\n * const {value: firstName} = await Swal.fire({ ...textPromptOptions, title: 'What is your first name?' })\n * const {value: lastName} = await Swal.fire({ ...textPromptOptions, title: 'What is your last name?' })\n *\n * After:\n * const TextPrompt = Swal.mixin({ input: 'text', showCancelButton: true })\n * const {value: firstName} = await TextPrompt('What is your first name?')\n * const {value: lastName} = await TextPrompt('What is your last name?')\n *\n * @param {SweetAlertOptions} mixinParams\n * @returns {SweetAlert}\n */ function mixin(mixinParams) {\n    class MixinSwal extends this {\n        _main(params, priorityMixinParams) {\n            return super._main(params, Object.assign({}, mixinParams, priorityMixinParams));\n        }\n    }\n    // @ts-ignore\n    return MixinSwal;\n}\n/**\n * If `timer` parameter is set, returns number of milliseconds of timer remained.\n * Otherwise, returns undefined.\n *\n * @returns {number | undefined}\n */ const getTimerLeft = ()=>{\n    return globalState.timeout && globalState.timeout.getTimerLeft();\n};\n/**\n * Stop timer. Returns number of milliseconds of timer remained.\n * If `timer` parameter isn't set, returns undefined.\n *\n * @returns {number | undefined}\n */ const stopTimer = ()=>{\n    if (globalState.timeout) {\n        stopTimerProgressBar();\n        return globalState.timeout.stop();\n    }\n};\n/**\n * Resume timer. Returns number of milliseconds of timer remained.\n * If `timer` parameter isn't set, returns undefined.\n *\n * @returns {number | undefined}\n */ const resumeTimer = ()=>{\n    if (globalState.timeout) {\n        const remaining = globalState.timeout.start();\n        animateTimerProgressBar(remaining);\n        return remaining;\n    }\n};\n/**\n * Resume timer. Returns number of milliseconds of timer remained.\n * If `timer` parameter isn't set, returns undefined.\n *\n * @returns {number | undefined}\n */ const toggleTimer = ()=>{\n    const timer = globalState.timeout;\n    return timer && (timer.running ? stopTimer() : resumeTimer());\n};\n/**\n * Increase timer. Returns number of milliseconds of an updated timer.\n * If `timer` parameter isn't set, returns undefined.\n *\n * @param {number} ms\n * @returns {number | undefined}\n */ const increaseTimer = (ms)=>{\n    if (globalState.timeout) {\n        const remaining = globalState.timeout.increase(ms);\n        animateTimerProgressBar(remaining, true);\n        return remaining;\n    }\n};\n/**\n * Check if timer is running. Returns true if timer is running\n * or false if timer is paused or stopped.\n * If `timer` parameter isn't set, returns undefined\n *\n * @returns {boolean}\n */ const isTimerRunning = ()=>{\n    return !!(globalState.timeout && globalState.timeout.isRunning());\n};\nlet bodyClickListenerAdded = false;\nconst clickHandlers = {};\n/**\n * @param {string} attr\n */ function bindClickHandler(attr = \"data-swal-template\") {\n    clickHandlers[attr] = this;\n    if (!bodyClickListenerAdded) {\n        document.body.addEventListener(\"click\", bodyClickListener);\n        bodyClickListenerAdded = true;\n    }\n}\nconst bodyClickListener = (event)=>{\n    for(let el = event.target; el && el !== document; el = el.parentNode){\n        for(const attr in clickHandlers){\n            const template = el.getAttribute(attr);\n            if (template) {\n                clickHandlers[attr].fire({\n                    template\n                });\n                return;\n            }\n        }\n    }\n};\n// Source: https://gist.github.com/mudge/5830382?permalink_comment_id=2691957#gistcomment-2691957\nclass EventEmitter {\n    constructor(){\n        /** @type {Events} */ this.events = {};\n    }\n    /**\n   * @param {string} eventName\n   * @returns {EventHandlers}\n   */ _getHandlersByEventName(eventName) {\n        if (typeof this.events[eventName] === \"undefined\") {\n            // not Set because we need to keep the FIFO order\n            // https://github.com/sweetalert2/sweetalert2/pull/2763#discussion_r1748990334\n            this.events[eventName] = [];\n        }\n        return this.events[eventName];\n    }\n    /**\n   * @param {string} eventName\n   * @param {EventHandler} eventHandler\n   */ on(eventName, eventHandler) {\n        const currentHandlers = this._getHandlersByEventName(eventName);\n        if (!currentHandlers.includes(eventHandler)) {\n            currentHandlers.push(eventHandler);\n        }\n    }\n    /**\n   * @param {string} eventName\n   * @param {EventHandler} eventHandler\n   */ once(eventName, eventHandler) {\n        /**\n     * @param {Array} args\n     */ const onceFn = (...args)=>{\n            this.removeListener(eventName, onceFn);\n            eventHandler.apply(this, args);\n        };\n        this.on(eventName, onceFn);\n    }\n    /**\n   * @param {string} eventName\n   * @param {Array} args\n   */ emit(eventName, ...args) {\n        this._getHandlersByEventName(eventName).forEach(/**\n     * @param {EventHandler} eventHandler\n     */ (eventHandler)=>{\n            try {\n                eventHandler.apply(this, args);\n            } catch (error) {\n                console.error(error);\n            }\n        });\n    }\n    /**\n   * @param {string} eventName\n   * @param {EventHandler} eventHandler\n   */ removeListener(eventName, eventHandler) {\n        const currentHandlers = this._getHandlersByEventName(eventName);\n        const index = currentHandlers.indexOf(eventHandler);\n        if (index > -1) {\n            currentHandlers.splice(index, 1);\n        }\n    }\n    /**\n   * @param {string} eventName\n   */ removeAllListeners(eventName) {\n        if (this.events[eventName] !== undefined) {\n            // https://github.com/sweetalert2/sweetalert2/pull/2763#discussion_r1749239222\n            this.events[eventName].length = 0;\n        }\n    }\n    reset() {\n        this.events = {};\n    }\n}\nglobalState.eventEmitter = new EventEmitter();\n/**\n * @param {string} eventName\n * @param {EventHandler} eventHandler\n */ const on = (eventName, eventHandler)=>{\n    globalState.eventEmitter.on(eventName, eventHandler);\n};\n/**\n * @param {string} eventName\n * @param {EventHandler} eventHandler\n */ const once = (eventName, eventHandler)=>{\n    globalState.eventEmitter.once(eventName, eventHandler);\n};\n/**\n * @param {string} [eventName]\n * @param {EventHandler} [eventHandler]\n */ const off = (eventName, eventHandler)=>{\n    // Remove all handlers for all events\n    if (!eventName) {\n        globalState.eventEmitter.reset();\n        return;\n    }\n    if (eventHandler) {\n        // Remove a specific handler\n        globalState.eventEmitter.removeListener(eventName, eventHandler);\n    } else {\n        // Remove all handlers for a specific event\n        globalState.eventEmitter.removeAllListeners(eventName);\n    }\n};\nvar staticMethods = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    argsToParams: argsToParams,\n    bindClickHandler: bindClickHandler,\n    clickCancel: clickCancel,\n    clickConfirm: clickConfirm,\n    clickDeny: clickDeny,\n    enableLoading: showLoading,\n    fire: fire,\n    getActions: getActions,\n    getCancelButton: getCancelButton,\n    getCloseButton: getCloseButton,\n    getConfirmButton: getConfirmButton,\n    getContainer: getContainer,\n    getDenyButton: getDenyButton,\n    getFocusableElements: getFocusableElements,\n    getFooter: getFooter,\n    getHtmlContainer: getHtmlContainer,\n    getIcon: getIcon,\n    getIconContent: getIconContent,\n    getImage: getImage,\n    getInputLabel: getInputLabel,\n    getLoader: getLoader,\n    getPopup: getPopup,\n    getProgressSteps: getProgressSteps,\n    getTimerLeft: getTimerLeft,\n    getTimerProgressBar: getTimerProgressBar,\n    getTitle: getTitle,\n    getValidationMessage: getValidationMessage,\n    increaseTimer: increaseTimer,\n    isDeprecatedParameter: isDeprecatedParameter,\n    isLoading: isLoading,\n    isTimerRunning: isTimerRunning,\n    isUpdatableParameter: isUpdatableParameter,\n    isValidParameter: isValidParameter,\n    isVisible: isVisible,\n    mixin: mixin,\n    off: off,\n    on: on,\n    once: once,\n    resumeTimer: resumeTimer,\n    showLoading: showLoading,\n    stopTimer: stopTimer,\n    toggleTimer: toggleTimer\n});\nclass Timer {\n    /**\n   * @param {() => void} callback\n   * @param {number} delay\n   */ constructor(callback, delay){\n        this.callback = callback;\n        this.remaining = delay;\n        this.running = false;\n        this.start();\n    }\n    /**\n   * @returns {number}\n   */ start() {\n        if (!this.running) {\n            this.running = true;\n            this.started = new Date();\n            this.id = setTimeout(this.callback, this.remaining);\n        }\n        return this.remaining;\n    }\n    /**\n   * @returns {number}\n   */ stop() {\n        if (this.started && this.running) {\n            this.running = false;\n            clearTimeout(this.id);\n            this.remaining -= new Date().getTime() - this.started.getTime();\n        }\n        return this.remaining;\n    }\n    /**\n   * @param {number} n\n   * @returns {number}\n   */ increase(n) {\n        const running = this.running;\n        if (running) {\n            this.stop();\n        }\n        this.remaining += n;\n        if (running) {\n            this.start();\n        }\n        return this.remaining;\n    }\n    /**\n   * @returns {number}\n   */ getTimerLeft() {\n        if (this.running) {\n            this.stop();\n            this.start();\n        }\n        return this.remaining;\n    }\n    /**\n   * @returns {boolean}\n   */ isRunning() {\n        return this.running;\n    }\n}\nconst swalStringParams = [\n    \"swal-title\",\n    \"swal-html\",\n    \"swal-footer\"\n];\n/**\n * @param {SweetAlertOptions} params\n * @returns {SweetAlertOptions}\n */ const getTemplateParams = (params)=>{\n    const template = typeof params.template === \"string\" ? /** @type {HTMLTemplateElement} */ document.querySelector(params.template) : params.template;\n    if (!template) {\n        return {};\n    }\n    /** @type {DocumentFragment} */ const templateContent = template.content;\n    showWarningsForElements(templateContent);\n    const result = Object.assign(getSwalParams(templateContent), getSwalFunctionParams(templateContent), getSwalButtons(templateContent), getSwalImage(templateContent), getSwalIcon(templateContent), getSwalInput(templateContent), getSwalStringParams(templateContent, swalStringParams));\n    return result;\n};\n/**\n * @param {DocumentFragment} templateContent\n * @returns {Record<string, string | boolean | number>}\n */ const getSwalParams = (templateContent)=>{\n    /** @type {Record<string, string | boolean | number>} */ const result = {};\n    /** @type {HTMLElement[]} */ const swalParams = Array.from(templateContent.querySelectorAll(\"swal-param\"));\n    swalParams.forEach((param)=>{\n        showWarningsForAttributes(param, [\n            \"name\",\n            \"value\"\n        ]);\n        const paramName = /** @type {keyof SweetAlertOptions} */ param.getAttribute(\"name\");\n        const value = param.getAttribute(\"value\");\n        if (!paramName || !value) {\n            return;\n        }\n        if (typeof defaultParams[paramName] === \"boolean\") {\n            result[paramName] = value !== \"false\";\n        } else if (typeof defaultParams[paramName] === \"object\") {\n            result[paramName] = JSON.parse(value);\n        } else {\n            result[paramName] = value;\n        }\n    });\n    return result;\n};\n/**\n * @param {DocumentFragment} templateContent\n * @returns {Record<string, () => void>}\n */ const getSwalFunctionParams = (templateContent)=>{\n    /** @type {Record<string, () => void>} */ const result = {};\n    /** @type {HTMLElement[]} */ const swalFunctions = Array.from(templateContent.querySelectorAll(\"swal-function-param\"));\n    swalFunctions.forEach((param)=>{\n        const paramName = /** @type {keyof SweetAlertOptions} */ param.getAttribute(\"name\");\n        const value = param.getAttribute(\"value\");\n        if (!paramName || !value) {\n            return;\n        }\n        result[paramName] = new Function(`return ${value}`)();\n    });\n    return result;\n};\n/**\n * @param {DocumentFragment} templateContent\n * @returns {Record<string, string | boolean>}\n */ const getSwalButtons = (templateContent)=>{\n    /** @type {Record<string, string | boolean>} */ const result = {};\n    /** @type {HTMLElement[]} */ const swalButtons = Array.from(templateContent.querySelectorAll(\"swal-button\"));\n    swalButtons.forEach((button)=>{\n        showWarningsForAttributes(button, [\n            \"type\",\n            \"color\",\n            \"aria-label\"\n        ]);\n        const type = button.getAttribute(\"type\");\n        if (!type || ![\n            \"confirm\",\n            \"cancel\",\n            \"deny\"\n        ].includes(type)) {\n            return;\n        }\n        result[`${type}ButtonText`] = button.innerHTML;\n        result[`show${capitalizeFirstLetter(type)}Button`] = true;\n        if (button.hasAttribute(\"color\")) {\n            result[`${type}ButtonColor`] = button.getAttribute(\"color\");\n        }\n        if (button.hasAttribute(\"aria-label\")) {\n            result[`${type}ButtonAriaLabel`] = button.getAttribute(\"aria-label\");\n        }\n    });\n    return result;\n};\n/**\n * @param {DocumentFragment} templateContent\n * @returns {Pick<SweetAlertOptions, 'imageUrl' | 'imageWidth' | 'imageHeight' | 'imageAlt'>}\n */ const getSwalImage = (templateContent)=>{\n    const result = {};\n    /** @type {HTMLElement | null} */ const image = templateContent.querySelector(\"swal-image\");\n    if (image) {\n        showWarningsForAttributes(image, [\n            \"src\",\n            \"width\",\n            \"height\",\n            \"alt\"\n        ]);\n        if (image.hasAttribute(\"src\")) {\n            result.imageUrl = image.getAttribute(\"src\") || undefined;\n        }\n        if (image.hasAttribute(\"width\")) {\n            result.imageWidth = image.getAttribute(\"width\") || undefined;\n        }\n        if (image.hasAttribute(\"height\")) {\n            result.imageHeight = image.getAttribute(\"height\") || undefined;\n        }\n        if (image.hasAttribute(\"alt\")) {\n            result.imageAlt = image.getAttribute(\"alt\") || undefined;\n        }\n    }\n    return result;\n};\n/**\n * @param {DocumentFragment} templateContent\n * @returns {object}\n */ const getSwalIcon = (templateContent)=>{\n    const result = {};\n    /** @type {HTMLElement | null} */ const icon = templateContent.querySelector(\"swal-icon\");\n    if (icon) {\n        showWarningsForAttributes(icon, [\n            \"type\",\n            \"color\"\n        ]);\n        if (icon.hasAttribute(\"type\")) {\n            result.icon = icon.getAttribute(\"type\");\n        }\n        if (icon.hasAttribute(\"color\")) {\n            result.iconColor = icon.getAttribute(\"color\");\n        }\n        result.iconHtml = icon.innerHTML;\n    }\n    return result;\n};\n/**\n * @param {DocumentFragment} templateContent\n * @returns {object}\n */ const getSwalInput = (templateContent)=>{\n    /** @type {object} */ const result = {};\n    /** @type {HTMLElement | null} */ const input = templateContent.querySelector(\"swal-input\");\n    if (input) {\n        showWarningsForAttributes(input, [\n            \"type\",\n            \"label\",\n            \"placeholder\",\n            \"value\"\n        ]);\n        result.input = input.getAttribute(\"type\") || \"text\";\n        if (input.hasAttribute(\"label\")) {\n            result.inputLabel = input.getAttribute(\"label\");\n        }\n        if (input.hasAttribute(\"placeholder\")) {\n            result.inputPlaceholder = input.getAttribute(\"placeholder\");\n        }\n        if (input.hasAttribute(\"value\")) {\n            result.inputValue = input.getAttribute(\"value\");\n        }\n    }\n    /** @type {HTMLElement[]} */ const inputOptions = Array.from(templateContent.querySelectorAll(\"swal-input-option\"));\n    if (inputOptions.length) {\n        result.inputOptions = {};\n        inputOptions.forEach((option)=>{\n            showWarningsForAttributes(option, [\n                \"value\"\n            ]);\n            const optionValue = option.getAttribute(\"value\");\n            if (!optionValue) {\n                return;\n            }\n            const optionName = option.innerHTML;\n            result.inputOptions[optionValue] = optionName;\n        });\n    }\n    return result;\n};\n/**\n * @param {DocumentFragment} templateContent\n * @param {string[]} paramNames\n * @returns {Record<string, string>}\n */ const getSwalStringParams = (templateContent, paramNames)=>{\n    /** @type {Record<string, string>} */ const result = {};\n    for(const i in paramNames){\n        const paramName = paramNames[i];\n        /** @type {HTMLElement | null} */ const tag = templateContent.querySelector(paramName);\n        if (tag) {\n            showWarningsForAttributes(tag, []);\n            result[paramName.replace(/^swal-/, \"\")] = tag.innerHTML.trim();\n        }\n    }\n    return result;\n};\n/**\n * @param {DocumentFragment} templateContent\n */ const showWarningsForElements = (templateContent)=>{\n    const allowedElements = swalStringParams.concat([\n        \"swal-param\",\n        \"swal-function-param\",\n        \"swal-button\",\n        \"swal-image\",\n        \"swal-icon\",\n        \"swal-input\",\n        \"swal-input-option\"\n    ]);\n    Array.from(templateContent.children).forEach((el)=>{\n        const tagName = el.tagName.toLowerCase();\n        if (!allowedElements.includes(tagName)) {\n            warn(`Unrecognized element <${tagName}>`);\n        }\n    });\n};\n/**\n * @param {HTMLElement} el\n * @param {string[]} allowedAttributes\n */ const showWarningsForAttributes = (el, allowedAttributes)=>{\n    Array.from(el.attributes).forEach((attribute)=>{\n        if (allowedAttributes.indexOf(attribute.name) === -1) {\n            warn([\n                `Unrecognized attribute \"${attribute.name}\" on <${el.tagName.toLowerCase()}>.`,\n                `${allowedAttributes.length ? `Allowed attributes are: ${allowedAttributes.join(\", \")}` : \"To set the value, use HTML within the element.\"}`\n            ]);\n        }\n    });\n};\nconst SHOW_CLASS_TIMEOUT = 10;\n/**\n * Open popup, add necessary classes and styles, fix scrollbar\n *\n * @param {SweetAlertOptions} params\n */ const openPopup = (params)=>{\n    const container = getContainer();\n    const popup = getPopup();\n    if (typeof params.willOpen === \"function\") {\n        params.willOpen(popup);\n    }\n    globalState.eventEmitter.emit(\"willOpen\", popup);\n    const bodyStyles = window.getComputedStyle(document.body);\n    const initialBodyOverflow = bodyStyles.overflowY;\n    addClasses(container, popup, params);\n    // scrolling is 'hidden' until animation is done, after that 'auto'\n    setTimeout(()=>{\n        setScrollingVisibility(container, popup);\n    }, SHOW_CLASS_TIMEOUT);\n    if (isModal()) {\n        fixScrollContainer(container, params.scrollbarPadding, initialBodyOverflow);\n        setAriaHidden();\n    }\n    if (!isToast() && !globalState.previousActiveElement) {\n        globalState.previousActiveElement = document.activeElement;\n    }\n    if (typeof params.didOpen === \"function\") {\n        setTimeout(()=>params.didOpen(popup));\n    }\n    globalState.eventEmitter.emit(\"didOpen\", popup);\n};\n/**\n * @param {AnimationEvent} event\n */ const swalOpenAnimationFinished = (event)=>{\n    const popup = getPopup();\n    if (event.target !== popup) {\n        return;\n    }\n    const container = getContainer();\n    popup.removeEventListener(\"animationend\", swalOpenAnimationFinished);\n    popup.removeEventListener(\"transitionend\", swalOpenAnimationFinished);\n    container.style.overflowY = \"auto\";\n    // no-transition is added in init() in case one swal is opened right after another\n    removeClass(container, swalClasses[\"no-transition\"]);\n};\n/**\n * @param {HTMLElement} container\n * @param {HTMLElement} popup\n */ const setScrollingVisibility = (container, popup)=>{\n    if (hasCssAnimation(popup)) {\n        container.style.overflowY = \"hidden\";\n        popup.addEventListener(\"animationend\", swalOpenAnimationFinished);\n        popup.addEventListener(\"transitionend\", swalOpenAnimationFinished);\n    } else {\n        container.style.overflowY = \"auto\";\n    }\n};\n/**\n * @param {HTMLElement} container\n * @param {boolean} scrollbarPadding\n * @param {string} initialBodyOverflow\n */ const fixScrollContainer = (container, scrollbarPadding, initialBodyOverflow)=>{\n    iOSfix();\n    if (scrollbarPadding && initialBodyOverflow !== \"hidden\") {\n        replaceScrollbarWithPadding(initialBodyOverflow);\n    }\n    // sweetalert2/issues/1247\n    setTimeout(()=>{\n        container.scrollTop = 0;\n    });\n};\n/**\n * @param {HTMLElement} container\n * @param {HTMLElement} popup\n * @param {SweetAlertOptions} params\n */ const addClasses = (container, popup, params)=>{\n    addClass(container, params.showClass.backdrop);\n    if (params.animation) {\n        // this workaround with opacity is needed for https://github.com/sweetalert2/sweetalert2/issues/2059\n        popup.style.setProperty(\"opacity\", \"0\", \"important\");\n        show(popup, \"grid\");\n        setTimeout(()=>{\n            // Animate popup right after showing it\n            addClass(popup, params.showClass.popup);\n            // and remove the opacity workaround\n            popup.style.removeProperty(\"opacity\");\n        }, SHOW_CLASS_TIMEOUT); // 10ms in order to fix #2062\n    } else {\n        show(popup, \"grid\");\n    }\n    addClass([\n        document.documentElement,\n        document.body\n    ], swalClasses.shown);\n    if (params.heightAuto && params.backdrop && !params.toast) {\n        addClass([\n            document.documentElement,\n            document.body\n        ], swalClasses[\"height-auto\"]);\n    }\n};\nvar defaultInputValidators = {\n    /**\n   * @param {string} string\n   * @param {string} [validationMessage]\n   * @returns {Promise<string | void>}\n   */ email: (string, validationMessage)=>{\n        return /^[a-zA-Z0-9.+_'-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z0-9-]+$/.test(string) ? Promise.resolve() : Promise.resolve(validationMessage || \"Invalid email address\");\n    },\n    /**\n   * @param {string} string\n   * @param {string} [validationMessage]\n   * @returns {Promise<string | void>}\n   */ url: (string, validationMessage)=>{\n        // taken from https://stackoverflow.com/a/3809435 with a small change from #1306 and #2013\n        return /^https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-z]{2,63}\\b([-a-zA-Z0-9@:%_+.~#?&/=]*)$/.test(string) ? Promise.resolve() : Promise.resolve(validationMessage || \"Invalid URL\");\n    }\n};\n/**\n * @param {SweetAlertOptions} params\n */ function setDefaultInputValidators(params) {\n    // Use default `inputValidator` for supported input types if not provided\n    if (params.inputValidator) {\n        return;\n    }\n    if (params.input === \"email\") {\n        params.inputValidator = defaultInputValidators[\"email\"];\n    }\n    if (params.input === \"url\") {\n        params.inputValidator = defaultInputValidators[\"url\"];\n    }\n}\n/**\n * @param {SweetAlertOptions} params\n */ function validateCustomTargetElement(params) {\n    // Determine if the custom target element is valid\n    if (!params.target || typeof params.target === \"string\" && !document.querySelector(params.target) || typeof params.target !== \"string\" && !params.target.appendChild) {\n        warn('Target parameter is not valid, defaulting to \"body\"');\n        params.target = \"body\";\n    }\n}\n/**\n * Set type, text and actions on popup\n *\n * @param {SweetAlertOptions} params\n */ function setParameters(params) {\n    setDefaultInputValidators(params);\n    // showLoaderOnConfirm && preConfirm\n    if (params.showLoaderOnConfirm && !params.preConfirm) {\n        warn(\"showLoaderOnConfirm is set to true, but preConfirm is not defined.\\n\" + \"showLoaderOnConfirm should be used together with preConfirm, see usage example:\\n\" + \"https://sweetalert2.github.io/#ajax-request\");\n    }\n    validateCustomTargetElement(params);\n    // Replace newlines with <br> in title\n    if (typeof params.title === \"string\") {\n        params.title = params.title.split(\"\\n\").join(\"<br />\");\n    }\n    init(params);\n}\n/** @type {SweetAlert} */ let currentInstance;\nvar _promise = /*#__PURE__*/ new WeakMap();\nclass SweetAlert {\n    /**\n   * @param {...(SweetAlertOptions | string)} args\n   * @this {SweetAlert}\n   */ constructor(...args){\n        /**\n     * @type {Promise<SweetAlertResult>}\n     */ _classPrivateFieldInitSpec(this, _promise, void 0);\n        // Prevent run in Node env\n        if (true) {\n            return;\n        }\n        currentInstance = this;\n        // @ts-ignore\n        const outerParams = Object.freeze(this.constructor.argsToParams(args));\n        /** @type {Readonly<SweetAlertOptions>} */ this.params = outerParams;\n        /** @type {boolean} */ this.isAwaitingPromise = false;\n        _classPrivateFieldSet2(_promise, this, this._main(currentInstance.params));\n    }\n    _main(userParams, mixinParams = {}) {\n        showWarningsForParams(Object.assign({}, mixinParams, userParams));\n        if (globalState.currentInstance) {\n            const swalPromiseResolve = privateMethods.swalPromiseResolve.get(globalState.currentInstance);\n            const { isAwaitingPromise } = globalState.currentInstance;\n            globalState.currentInstance._destroy();\n            if (!isAwaitingPromise) {\n                swalPromiseResolve({\n                    isDismissed: true\n                });\n            }\n            if (isModal()) {\n                unsetAriaHidden();\n            }\n        }\n        globalState.currentInstance = currentInstance;\n        const innerParams = prepareParams(userParams, mixinParams);\n        setParameters(innerParams);\n        Object.freeze(innerParams);\n        // clear the previous timer\n        if (globalState.timeout) {\n            globalState.timeout.stop();\n            delete globalState.timeout;\n        }\n        // clear the restore focus timeout\n        clearTimeout(globalState.restoreFocusTimeout);\n        const domCache = populateDomCache(currentInstance);\n        render(currentInstance, innerParams);\n        privateProps.innerParams.set(currentInstance, innerParams);\n        return swalPromise(currentInstance, domCache, innerParams);\n    }\n    // `catch` cannot be the name of a module export, so we define our thenable methods here instead\n    then(onFulfilled) {\n        return _classPrivateFieldGet2(_promise, this).then(onFulfilled);\n    }\n    finally(onFinally) {\n        return _classPrivateFieldGet2(_promise, this).finally(onFinally);\n    }\n}\n/**\n * @param {SweetAlert} instance\n * @param {DomCache} domCache\n * @param {SweetAlertOptions} innerParams\n * @returns {Promise}\n */ const swalPromise = (instance, domCache, innerParams)=>{\n    return new Promise((resolve, reject)=>{\n        // functions to handle all closings/dismissals\n        /**\n     * @param {DismissReason} dismiss\n     */ const dismissWith = (dismiss)=>{\n            instance.close({\n                isDismissed: true,\n                dismiss,\n                isConfirmed: false,\n                isDenied: false\n            });\n        };\n        privateMethods.swalPromiseResolve.set(instance, resolve);\n        privateMethods.swalPromiseReject.set(instance, reject);\n        domCache.confirmButton.onclick = ()=>{\n            handleConfirmButtonClick(instance);\n        };\n        domCache.denyButton.onclick = ()=>{\n            handleDenyButtonClick(instance);\n        };\n        domCache.cancelButton.onclick = ()=>{\n            handleCancelButtonClick(instance, dismissWith);\n        };\n        domCache.closeButton.onclick = ()=>{\n            dismissWith(DismissReason.close);\n        };\n        handlePopupClick(innerParams, domCache, dismissWith);\n        addKeydownHandler(globalState, innerParams, dismissWith);\n        handleInputOptionsAndValue(instance, innerParams);\n        openPopup(innerParams);\n        setupTimer(globalState, innerParams, dismissWith);\n        initFocus(domCache, innerParams);\n        // Scroll container to top on open (#1247, #1946)\n        setTimeout(()=>{\n            domCache.container.scrollTop = 0;\n        });\n    });\n};\n/**\n * @param {SweetAlertOptions} userParams\n * @param {SweetAlertOptions} mixinParams\n * @returns {SweetAlertOptions}\n */ const prepareParams = (userParams, mixinParams)=>{\n    const templateParams = getTemplateParams(userParams);\n    const params = Object.assign({}, defaultParams, mixinParams, templateParams, userParams); // precedence is described in #2131\n    params.showClass = Object.assign({}, defaultParams.showClass, params.showClass);\n    params.hideClass = Object.assign({}, defaultParams.hideClass, params.hideClass);\n    if (params.animation === false) {\n        params.showClass = {\n            backdrop: \"swal2-noanimation\"\n        };\n        params.hideClass = {};\n    }\n    return params;\n};\n/**\n * @param {SweetAlert} instance\n * @returns {DomCache}\n */ const populateDomCache = (instance)=>{\n    const domCache = {\n        popup: getPopup(),\n        container: getContainer(),\n        actions: getActions(),\n        confirmButton: getConfirmButton(),\n        denyButton: getDenyButton(),\n        cancelButton: getCancelButton(),\n        loader: getLoader(),\n        closeButton: getCloseButton(),\n        validationMessage: getValidationMessage(),\n        progressSteps: getProgressSteps()\n    };\n    privateProps.domCache.set(instance, domCache);\n    return domCache;\n};\n/**\n * @param {GlobalState} globalState\n * @param {SweetAlertOptions} innerParams\n * @param {(dismiss: DismissReason) => void} dismissWith\n */ const setupTimer = (globalState, innerParams, dismissWith)=>{\n    const timerProgressBar = getTimerProgressBar();\n    hide(timerProgressBar);\n    if (innerParams.timer) {\n        globalState.timeout = new Timer(()=>{\n            dismissWith(\"timer\");\n            delete globalState.timeout;\n        }, innerParams.timer);\n        if (innerParams.timerProgressBar) {\n            show(timerProgressBar);\n            applyCustomClass(timerProgressBar, innerParams, \"timerProgressBar\");\n            setTimeout(()=>{\n                if (globalState.timeout && globalState.timeout.running) {\n                    // timer can be already stopped or unset at this point\n                    animateTimerProgressBar(innerParams.timer);\n                }\n            });\n        }\n    }\n};\n/**\n * Initialize focus in the popup:\n *\n * 1. If `toast` is `true`, don't steal focus from the document.\n * 2. Else if there is an [autofocus] element, focus it.\n * 3. Else if `focusConfirm` is `true` and confirm button is visible, focus it.\n * 4. Else if `focusDeny` is `true` and deny button is visible, focus it.\n * 5. Else if `focusCancel` is `true` and cancel button is visible, focus it.\n * 6. Else focus the first focusable element in a popup (if any).\n *\n * @param {DomCache} domCache\n * @param {SweetAlertOptions} innerParams\n */ const initFocus = (domCache, innerParams)=>{\n    if (innerParams.toast) {\n        return;\n    }\n    // TODO: this is dumb, remove `allowEnterKey` param in the next major version\n    if (!callIfFunction(innerParams.allowEnterKey)) {\n        warnAboutDeprecation(\"allowEnterKey\");\n        blurActiveElement();\n        return;\n    }\n    if (focusAutofocus(domCache)) {\n        return;\n    }\n    if (focusButton(domCache, innerParams)) {\n        return;\n    }\n    setFocus(-1, 1);\n};\n/**\n * @param {DomCache} domCache\n * @returns {boolean}\n */ const focusAutofocus = (domCache)=>{\n    const autofocusElements = Array.from(domCache.popup.querySelectorAll(\"[autofocus]\"));\n    for (const autofocusElement of autofocusElements){\n        if (autofocusElement instanceof HTMLElement && isVisible$1(autofocusElement)) {\n            autofocusElement.focus();\n            return true;\n        }\n    }\n    return false;\n};\n/**\n * @param {DomCache} domCache\n * @param {SweetAlertOptions} innerParams\n * @returns {boolean}\n */ const focusButton = (domCache, innerParams)=>{\n    if (innerParams.focusDeny && isVisible$1(domCache.denyButton)) {\n        domCache.denyButton.focus();\n        return true;\n    }\n    if (innerParams.focusCancel && isVisible$1(domCache.cancelButton)) {\n        domCache.cancelButton.focus();\n        return true;\n    }\n    if (innerParams.focusConfirm && isVisible$1(domCache.confirmButton)) {\n        domCache.confirmButton.focus();\n        return true;\n    }\n    return false;\n};\nconst blurActiveElement = ()=>{\n    if (document.activeElement instanceof HTMLElement && typeof document.activeElement.blur === \"function\") {\n        document.activeElement.blur();\n    }\n};\n// Assign instance methods from src/instanceMethods/*.js to prototype\nSweetAlert.prototype.disableButtons = disableButtons;\nSweetAlert.prototype.enableButtons = enableButtons;\nSweetAlert.prototype.getInput = getInput;\nSweetAlert.prototype.disableInput = disableInput;\nSweetAlert.prototype.enableInput = enableInput;\nSweetAlert.prototype.hideLoading = hideLoading;\nSweetAlert.prototype.disableLoading = hideLoading;\nSweetAlert.prototype.showValidationMessage = showValidationMessage;\nSweetAlert.prototype.resetValidationMessage = resetValidationMessage;\nSweetAlert.prototype.close = close;\nSweetAlert.prototype.closePopup = close;\nSweetAlert.prototype.closeModal = close;\nSweetAlert.prototype.closeToast = close;\nSweetAlert.prototype.rejectPromise = rejectPromise;\nSweetAlert.prototype.update = update;\nSweetAlert.prototype._destroy = _destroy;\n// Assign static methods from src/staticMethods/*.js to constructor\nObject.assign(SweetAlert, staticMethods);\n// Proxy to instance methods to constructor, for now, for backwards compatibility\nObject.keys(instanceMethods).forEach((key)=>{\n    /**\n   * @param {...(SweetAlertOptions | string | undefined)} args\n   * @returns {SweetAlertResult | Promise<SweetAlertResult> | undefined}\n   */ SweetAlert[key] = function(...args) {\n        if (currentInstance && currentInstance[key]) {\n            return currentInstance[key](...args);\n        }\n        return null;\n    };\n});\nSweetAlert.DismissReason = DismissReason;\nSweetAlert.version = \"11.26.10\";\nconst Swal = SweetAlert;\n// @ts-ignore\nSwal.default = Swal;\n\n\"undefined\" != typeof document && function(e, t) {\n    var n = e.createElement(\"style\");\n    if (e.getElementsByTagName(\"head\")[0].appendChild(n), n.styleSheet) n.styleSheet.disabled || (n.styleSheet.cssText = t);\n    else try {\n        n.innerHTML = t;\n    } catch (e) {\n        n.innerText = t;\n    }\n}(document, ':root{--swal2-outline: 0 0 0 3px rgba(100, 150, 200, 0.5);--swal2-container-padding: 0.625em;--swal2-backdrop: rgba(0, 0, 0, 0.4);--swal2-backdrop-transition: background-color 0.15s;--swal2-width: 32em;--swal2-padding: 0 0 1.25em;--swal2-border: none;--swal2-border-radius: 0.3125rem;--swal2-background: white;--swal2-color: #545454;--swal2-show-animation: swal2-show 0.3s;--swal2-hide-animation: swal2-hide 0.15s forwards;--swal2-icon-zoom: 1;--swal2-icon-animations: true;--swal2-title-padding: 0.8em 1em 0;--swal2-html-container-padding: 1em 1.6em 0.3em;--swal2-input-border: 1px solid #d9d9d9;--swal2-input-border-radius: 0.1875em;--swal2-input-box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.06), 0 0 0 3px transparent;--swal2-input-background: transparent;--swal2-input-transition: border-color 0.2s, box-shadow 0.2s;--swal2-input-hover-box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.06), 0 0 0 3px transparent;--swal2-input-focus-border: 1px solid #b4dbed;--swal2-input-focus-box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.06), 0 0 0 3px rgba(100, 150, 200, 0.5);--swal2-progress-step-background: #add8e6;--swal2-validation-message-background: #f0f0f0;--swal2-validation-message-color: #666;--swal2-footer-border-color: #eee;--swal2-footer-background: transparent;--swal2-footer-color: inherit;--swal2-timer-progress-bar-background: rgba(0, 0, 0, 0.3);--swal2-close-button-position: initial;--swal2-close-button-inset: auto;--swal2-close-button-font-size: 2.5em;--swal2-close-button-color: #ccc;--swal2-close-button-transition: color 0.2s, box-shadow 0.2s;--swal2-close-button-outline: initial;--swal2-close-button-box-shadow: inset 0 0 0 3px transparent;--swal2-close-button-focus-box-shadow: inset var(--swal2-outline);--swal2-close-button-hover-transform: none;--swal2-actions-justify-content: center;--swal2-actions-width: auto;--swal2-actions-margin: 1.25em auto 0;--swal2-actions-padding: 0;--swal2-actions-border-radius: 0;--swal2-actions-background: transparent;--swal2-action-button-transition: background-color 0.2s, box-shadow 0.2s;--swal2-action-button-hover: black 10%;--swal2-action-button-active: black 10%;--swal2-confirm-button-box-shadow: none;--swal2-confirm-button-border-radius: 0.25em;--swal2-confirm-button-background-color: #7066e0;--swal2-confirm-button-color: #fff;--swal2-deny-button-box-shadow: none;--swal2-deny-button-border-radius: 0.25em;--swal2-deny-button-background-color: #dc3741;--swal2-deny-button-color: #fff;--swal2-cancel-button-box-shadow: none;--swal2-cancel-button-border-radius: 0.25em;--swal2-cancel-button-background-color: #6e7881;--swal2-cancel-button-color: #fff;--swal2-toast-show-animation: swal2-toast-show 0.5s;--swal2-toast-hide-animation: swal2-toast-hide 0.1s forwards;--swal2-toast-border: none;--swal2-toast-box-shadow: 0 0 1px hsl(0deg 0% 0% / 0.075), 0 1px 2px hsl(0deg 0% 0% / 0.075), 1px 2px 4px hsl(0deg 0% 0% / 0.075), 1px 3px 8px hsl(0deg 0% 0% / 0.075), 2px 4px 16px hsl(0deg 0% 0% / 0.075)}[data-swal2-theme=dark]{--swal2-dark-theme-black: #19191a;--swal2-dark-theme-white: #e1e1e1;--swal2-background: var(--swal2-dark-theme-black);--swal2-color: var(--swal2-dark-theme-white);--swal2-footer-border-color: #555;--swal2-input-background: color-mix(in srgb, var(--swal2-dark-theme-black), var(--swal2-dark-theme-white) 10%);--swal2-validation-message-background: color-mix( in srgb, var(--swal2-dark-theme-black), var(--swal2-dark-theme-white) 10% );--swal2-validation-message-color: var(--swal2-dark-theme-white);--swal2-timer-progress-bar-background: rgba(255, 255, 255, 0.7)}@media(prefers-color-scheme: dark){[data-swal2-theme=auto]{--swal2-dark-theme-black: #19191a;--swal2-dark-theme-white: #e1e1e1;--swal2-background: var(--swal2-dark-theme-black);--swal2-color: var(--swal2-dark-theme-white);--swal2-footer-border-color: #555;--swal2-input-background: color-mix(in srgb, var(--swal2-dark-theme-black), var(--swal2-dark-theme-white) 10%);--swal2-validation-message-background: color-mix( in srgb, var(--swal2-dark-theme-black), var(--swal2-dark-theme-white) 10% );--swal2-validation-message-color: var(--swal2-dark-theme-white);--swal2-timer-progress-bar-background: rgba(255, 255, 255, 0.7)}}body.swal2-shown:not(.swal2-no-backdrop,.swal2-toast-shown){overflow:hidden}body.swal2-height-auto{height:auto !important}body.swal2-no-backdrop .swal2-container{background-color:rgba(0,0,0,0) !important;pointer-events:none}body.swal2-no-backdrop .swal2-container .swal2-popup{pointer-events:all}body.swal2-no-backdrop .swal2-container .swal2-modal{box-shadow:0 0 10px var(--swal2-backdrop)}body.swal2-toast-shown .swal2-container{box-sizing:border-box;width:360px;max-width:100%;background-color:rgba(0,0,0,0);pointer-events:none}body.swal2-toast-shown .swal2-container.swal2-top{inset:0 auto auto 50%;transform:translateX(-50%)}body.swal2-toast-shown .swal2-container.swal2-top-end,body.swal2-toast-shown .swal2-container.swal2-top-right{inset:0 0 auto auto}body.swal2-toast-shown .swal2-container.swal2-top-start,body.swal2-toast-shown .swal2-container.swal2-top-left{inset:0 auto auto 0}body.swal2-toast-shown .swal2-container.swal2-center-start,body.swal2-toast-shown .swal2-container.swal2-center-left{inset:50% auto auto 0;transform:translateY(-50%)}body.swal2-toast-shown .swal2-container.swal2-center{inset:50% auto auto 50%;transform:translate(-50%, -50%)}body.swal2-toast-shown .swal2-container.swal2-center-end,body.swal2-toast-shown .swal2-container.swal2-center-right{inset:50% 0 auto auto;transform:translateY(-50%)}body.swal2-toast-shown .swal2-container.swal2-bottom-start,body.swal2-toast-shown .swal2-container.swal2-bottom-left{inset:auto auto 0 0}body.swal2-toast-shown .swal2-container.swal2-bottom{inset:auto auto 0 50%;transform:translateX(-50%)}body.swal2-toast-shown .swal2-container.swal2-bottom-end,body.swal2-toast-shown .swal2-container.swal2-bottom-right{inset:auto 0 0 auto}@media print{body.swal2-shown:not(.swal2-no-backdrop,.swal2-toast-shown){overflow-y:scroll !important}body.swal2-shown:not(.swal2-no-backdrop,.swal2-toast-shown)>[aria-hidden=true]{display:none}body.swal2-shown:not(.swal2-no-backdrop,.swal2-toast-shown) .swal2-container{position:static !important}}div:where(.swal2-container){display:grid;position:fixed;z-index:1060;inset:0;box-sizing:border-box;grid-template-areas:\"top-start     top            top-end\" \"center-start  center         center-end\" \"bottom-start  bottom-center  bottom-end\";grid-template-rows:minmax(min-content, auto) minmax(min-content, auto) minmax(min-content, auto);height:100%;padding:var(--swal2-container-padding);overflow-x:hidden;transition:var(--swal2-backdrop-transition);-webkit-overflow-scrolling:touch}div:where(.swal2-container).swal2-backdrop-show,div:where(.swal2-container).swal2-noanimation{background:var(--swal2-backdrop)}div:where(.swal2-container).swal2-backdrop-hide{background:rgba(0,0,0,0) !important}div:where(.swal2-container).swal2-top-start,div:where(.swal2-container).swal2-center-start,div:where(.swal2-container).swal2-bottom-start{grid-template-columns:minmax(0, 1fr) auto auto}div:where(.swal2-container).swal2-top,div:where(.swal2-container).swal2-center,div:where(.swal2-container).swal2-bottom{grid-template-columns:auto minmax(0, 1fr) auto}div:where(.swal2-container).swal2-top-end,div:where(.swal2-container).swal2-center-end,div:where(.swal2-container).swal2-bottom-end{grid-template-columns:auto auto minmax(0, 1fr)}div:where(.swal2-container).swal2-top-start>.swal2-popup{align-self:start}div:where(.swal2-container).swal2-top>.swal2-popup{grid-column:2;place-self:start center}div:where(.swal2-container).swal2-top-end>.swal2-popup,div:where(.swal2-container).swal2-top-right>.swal2-popup{grid-column:3;place-self:start end}div:where(.swal2-container).swal2-center-start>.swal2-popup,div:where(.swal2-container).swal2-center-left>.swal2-popup{grid-row:2;align-self:center}div:where(.swal2-container).swal2-center>.swal2-popup{grid-column:2;grid-row:2;place-self:center center}div:where(.swal2-container).swal2-center-end>.swal2-popup,div:where(.swal2-container).swal2-center-right>.swal2-popup{grid-column:3;grid-row:2;place-self:center end}div:where(.swal2-container).swal2-bottom-start>.swal2-popup,div:where(.swal2-container).swal2-bottom-left>.swal2-popup{grid-column:1;grid-row:3;align-self:end}div:where(.swal2-container).swal2-bottom>.swal2-popup{grid-column:2;grid-row:3;place-self:end center}div:where(.swal2-container).swal2-bottom-end>.swal2-popup,div:where(.swal2-container).swal2-bottom-right>.swal2-popup{grid-column:3;grid-row:3;place-self:end end}div:where(.swal2-container).swal2-grow-row>.swal2-popup,div:where(.swal2-container).swal2-grow-fullscreen>.swal2-popup{grid-column:1/4;width:100%}div:where(.swal2-container).swal2-grow-column>.swal2-popup,div:where(.swal2-container).swal2-grow-fullscreen>.swal2-popup{grid-row:1/4;align-self:stretch}div:where(.swal2-container).swal2-no-transition{transition:none !important}div:where(.swal2-container)[popover]{width:auto;border:0}div:where(.swal2-container) div:where(.swal2-popup){display:none;position:relative;box-sizing:border-box;grid-template-columns:minmax(0, 100%);width:var(--swal2-width);max-width:100%;padding:var(--swal2-padding);border:var(--swal2-border);border-radius:var(--swal2-border-radius);background:var(--swal2-background);color:var(--swal2-color);font-family:inherit;font-size:1rem;container-name:swal2-popup}div:where(.swal2-container) div:where(.swal2-popup):focus{outline:none}div:where(.swal2-container) div:where(.swal2-popup).swal2-loading{overflow-y:hidden}div:where(.swal2-container) div:where(.swal2-popup).swal2-draggable{cursor:grab}div:where(.swal2-container) div:where(.swal2-popup).swal2-draggable div:where(.swal2-icon){cursor:grab}div:where(.swal2-container) div:where(.swal2-popup).swal2-dragging{cursor:grabbing}div:where(.swal2-container) div:where(.swal2-popup).swal2-dragging div:where(.swal2-icon){cursor:grabbing}div:where(.swal2-container) h2:where(.swal2-title){position:relative;max-width:100%;margin:0;padding:var(--swal2-title-padding);color:inherit;font-size:1.875em;font-weight:600;text-align:center;text-transform:none;overflow-wrap:break-word;cursor:initial}div:where(.swal2-container) div:where(.swal2-actions){display:flex;z-index:1;box-sizing:border-box;flex-wrap:wrap;align-items:center;justify-content:var(--swal2-actions-justify-content);width:var(--swal2-actions-width);margin:var(--swal2-actions-margin);padding:var(--swal2-actions-padding);border-radius:var(--swal2-actions-border-radius);background:var(--swal2-actions-background)}div:where(.swal2-container) div:where(.swal2-loader){display:none;align-items:center;justify-content:center;width:2.2em;height:2.2em;margin:0 1.875em;animation:swal2-rotate-loading 1.5s linear 0s infinite normal;border-width:.25em;border-style:solid;border-radius:100%;border-color:#2778c4 rgba(0,0,0,0) #2778c4 rgba(0,0,0,0)}div:where(.swal2-container) button:where(.swal2-styled){margin:.3125em;padding:.625em 1.1em;transition:var(--swal2-action-button-transition);border:none;box-shadow:0 0 0 3px rgba(0,0,0,0);font-weight:500}div:where(.swal2-container) button:where(.swal2-styled):not([disabled]){cursor:pointer}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-confirm){border-radius:var(--swal2-confirm-button-border-radius);background:initial;background-color:var(--swal2-confirm-button-background-color);box-shadow:var(--swal2-confirm-button-box-shadow);color:var(--swal2-confirm-button-color);font-size:1em}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-confirm):hover{background-color:color-mix(in srgb, var(--swal2-confirm-button-background-color), var(--swal2-action-button-hover))}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-confirm):active{background-color:color-mix(in srgb, var(--swal2-confirm-button-background-color), var(--swal2-action-button-active))}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-deny){border-radius:var(--swal2-deny-button-border-radius);background:initial;background-color:var(--swal2-deny-button-background-color);box-shadow:var(--swal2-deny-button-box-shadow);color:var(--swal2-deny-button-color);font-size:1em}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-deny):hover{background-color:color-mix(in srgb, var(--swal2-deny-button-background-color), var(--swal2-action-button-hover))}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-deny):active{background-color:color-mix(in srgb, var(--swal2-deny-button-background-color), var(--swal2-action-button-active))}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-cancel){border-radius:var(--swal2-cancel-button-border-radius);background:initial;background-color:var(--swal2-cancel-button-background-color);box-shadow:var(--swal2-cancel-button-box-shadow);color:var(--swal2-cancel-button-color);font-size:1em}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-cancel):hover{background-color:color-mix(in srgb, var(--swal2-cancel-button-background-color), var(--swal2-action-button-hover))}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-cancel):active{background-color:color-mix(in srgb, var(--swal2-cancel-button-background-color), var(--swal2-action-button-active))}div:where(.swal2-container) button:where(.swal2-styled):focus-visible{outline:none;box-shadow:var(--swal2-action-button-focus-box-shadow)}div:where(.swal2-container) button:where(.swal2-styled)[disabled]:not(.swal2-loading){opacity:.4}div:where(.swal2-container) button:where(.swal2-styled)::-moz-focus-inner{border:0}div:where(.swal2-container) div:where(.swal2-footer){margin:1em 0 0;padding:1em 1em 0;border-top:1px solid var(--swal2-footer-border-color);background:var(--swal2-footer-background);color:var(--swal2-footer-color);font-size:1em;text-align:center;cursor:initial}div:where(.swal2-container) .swal2-timer-progress-bar-container{position:absolute;right:0;bottom:0;left:0;grid-column:auto !important;overflow:hidden;border-bottom-right-radius:var(--swal2-border-radius);border-bottom-left-radius:var(--swal2-border-radius)}div:where(.swal2-container) div:where(.swal2-timer-progress-bar){width:100%;height:.25em;background:var(--swal2-timer-progress-bar-background)}div:where(.swal2-container) img:where(.swal2-image){max-width:100%;margin:2em auto 1em;cursor:initial}div:where(.swal2-container) button:where(.swal2-close){position:var(--swal2-close-button-position);inset:var(--swal2-close-button-inset);z-index:2;align-items:center;justify-content:center;width:1.2em;height:1.2em;margin-top:0;margin-right:0;margin-bottom:-1.2em;padding:0;overflow:hidden;transition:var(--swal2-close-button-transition);border:none;border-radius:var(--swal2-border-radius);outline:var(--swal2-close-button-outline);background:rgba(0,0,0,0);color:var(--swal2-close-button-color);font-family:monospace;font-size:var(--swal2-close-button-font-size);cursor:pointer;justify-self:end}div:where(.swal2-container) button:where(.swal2-close):hover{transform:var(--swal2-close-button-hover-transform);background:rgba(0,0,0,0);color:#f27474}div:where(.swal2-container) button:where(.swal2-close):focus-visible{outline:none;box-shadow:var(--swal2-close-button-focus-box-shadow)}div:where(.swal2-container) button:where(.swal2-close)::-moz-focus-inner{border:0}div:where(.swal2-container) div:where(.swal2-html-container){z-index:1;justify-content:center;margin:0;padding:var(--swal2-html-container-padding);overflow:auto;color:inherit;font-size:1.125em;font-weight:normal;line-height:normal;text-align:center;overflow-wrap:break-word;word-break:break-word;cursor:initial}div:where(.swal2-container) input:where(.swal2-input),div:where(.swal2-container) input:where(.swal2-file),div:where(.swal2-container) textarea:where(.swal2-textarea),div:where(.swal2-container) select:where(.swal2-select),div:where(.swal2-container) div:where(.swal2-radio),div:where(.swal2-container) label:where(.swal2-checkbox){margin:1em 2em 3px}div:where(.swal2-container) input:where(.swal2-input),div:where(.swal2-container) input:where(.swal2-file),div:where(.swal2-container) textarea:where(.swal2-textarea){box-sizing:border-box;width:auto;transition:var(--swal2-input-transition);border:var(--swal2-input-border);border-radius:var(--swal2-input-border-radius);background:var(--swal2-input-background);box-shadow:var(--swal2-input-box-shadow);color:inherit;font-size:1.125em}div:where(.swal2-container) input:where(.swal2-input).swal2-inputerror,div:where(.swal2-container) input:where(.swal2-file).swal2-inputerror,div:where(.swal2-container) textarea:where(.swal2-textarea).swal2-inputerror{border-color:#f27474 !important;box-shadow:0 0 2px #f27474 !important}div:where(.swal2-container) input:where(.swal2-input):hover,div:where(.swal2-container) input:where(.swal2-file):hover,div:where(.swal2-container) textarea:where(.swal2-textarea):hover{box-shadow:var(--swal2-input-hover-box-shadow)}div:where(.swal2-container) input:where(.swal2-input):focus,div:where(.swal2-container) input:where(.swal2-file):focus,div:where(.swal2-container) textarea:where(.swal2-textarea):focus{border:var(--swal2-input-focus-border);outline:none;box-shadow:var(--swal2-input-focus-box-shadow)}div:where(.swal2-container) input:where(.swal2-input)::placeholder,div:where(.swal2-container) input:where(.swal2-file)::placeholder,div:where(.swal2-container) textarea:where(.swal2-textarea)::placeholder{color:#ccc}div:where(.swal2-container) .swal2-range{margin:1em 2em 3px;background:var(--swal2-background)}div:where(.swal2-container) .swal2-range input{width:80%}div:where(.swal2-container) .swal2-range output{width:20%;color:inherit;font-weight:600;text-align:center}div:where(.swal2-container) .swal2-range input,div:where(.swal2-container) .swal2-range output{height:2.625em;padding:0;font-size:1.125em;line-height:2.625em}div:where(.swal2-container) .swal2-input{height:2.625em;padding:0 .75em}div:where(.swal2-container) .swal2-file{width:75%;margin-right:auto;margin-left:auto;background:var(--swal2-input-background);font-size:1.125em}div:where(.swal2-container) .swal2-textarea{height:6.75em;padding:.75em}div:where(.swal2-container) .swal2-select{min-width:50%;max-width:100%;padding:.375em .625em;background:var(--swal2-input-background);color:inherit;font-size:1.125em}div:where(.swal2-container) .swal2-radio,div:where(.swal2-container) .swal2-checkbox{align-items:center;justify-content:center;background:var(--swal2-background);color:inherit}div:where(.swal2-container) .swal2-radio label,div:where(.swal2-container) .swal2-checkbox label{margin:0 .6em;font-size:1.125em}div:where(.swal2-container) .swal2-radio input,div:where(.swal2-container) .swal2-checkbox input{flex-shrink:0;margin:0 .4em}div:where(.swal2-container) label:where(.swal2-input-label){display:flex;justify-content:center;margin:1em auto 0}div:where(.swal2-container) div:where(.swal2-validation-message){align-items:center;justify-content:center;margin:1em 0 0;padding:.625em;overflow:hidden;background:var(--swal2-validation-message-background);color:var(--swal2-validation-message-color);font-size:1em;font-weight:300}div:where(.swal2-container) div:where(.swal2-validation-message)::before{content:\"!\";display:inline-block;width:1.5em;min-width:1.5em;height:1.5em;margin:0 .625em;border-radius:50%;background-color:#f27474;color:#fff;font-weight:600;line-height:1.5em;text-align:center}div:where(.swal2-container) .swal2-progress-steps{flex-wrap:wrap;align-items:center;max-width:100%;margin:1.25em auto;padding:0;background:rgba(0,0,0,0);font-weight:600}div:where(.swal2-container) .swal2-progress-steps li{display:inline-block;position:relative}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step{z-index:20;flex-shrink:0;width:2em;height:2em;border-radius:2em;background:#2778c4;color:#fff;line-height:2em;text-align:center}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step.swal2-active-progress-step{background:#2778c4}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step.swal2-active-progress-step~.swal2-progress-step{background:var(--swal2-progress-step-background);color:#fff}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step.swal2-active-progress-step~.swal2-progress-step-line{background:var(--swal2-progress-step-background)}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step-line{z-index:10;flex-shrink:0;width:2.5em;height:.4em;margin:0 -1px;background:#2778c4}div:where(.swal2-icon){position:relative;box-sizing:content-box;justify-content:center;width:5em;height:5em;margin:2.5em auto .6em;zoom:var(--swal2-icon-zoom);border:.25em solid rgba(0,0,0,0);border-radius:50%;border-color:#000;font-family:inherit;line-height:5em;cursor:default;user-select:none}div:where(.swal2-icon) .swal2-icon-content{display:flex;align-items:center;font-size:3.75em}div:where(.swal2-icon).swal2-error{border-color:#f27474;color:#f27474}div:where(.swal2-icon).swal2-error .swal2-x-mark{position:relative;flex-grow:1}div:where(.swal2-icon).swal2-error [class^=swal2-x-mark-line]{display:block;position:absolute;top:2.3125em;width:2.9375em;height:.3125em;border-radius:.125em;background-color:#f27474}div:where(.swal2-icon).swal2-error [class^=swal2-x-mark-line][class$=left]{left:1.0625em;transform:rotate(45deg)}div:where(.swal2-icon).swal2-error [class^=swal2-x-mark-line][class$=right]{right:1em;transform:rotate(-45deg)}@container swal2-popup style(--swal2-icon-animations:true){div:where(.swal2-icon).swal2-error.swal2-icon-show{animation:swal2-animate-error-icon .5s}div:where(.swal2-icon).swal2-error.swal2-icon-show .swal2-x-mark{animation:swal2-animate-error-x-mark .5s}}div:where(.swal2-icon).swal2-warning{border-color:#f8bb86;color:#f8bb86}@container swal2-popup style(--swal2-icon-animations:true){div:where(.swal2-icon).swal2-warning.swal2-icon-show{animation:swal2-animate-error-icon .5s}div:where(.swal2-icon).swal2-warning.swal2-icon-show .swal2-icon-content{animation:swal2-animate-i-mark .5s}}div:where(.swal2-icon).swal2-info{border-color:#3fc3ee;color:#3fc3ee}@container swal2-popup style(--swal2-icon-animations:true){div:where(.swal2-icon).swal2-info.swal2-icon-show{animation:swal2-animate-error-icon .5s}div:where(.swal2-icon).swal2-info.swal2-icon-show .swal2-icon-content{animation:swal2-animate-i-mark .8s}}div:where(.swal2-icon).swal2-question{border-color:#87adbd;color:#87adbd}@container swal2-popup style(--swal2-icon-animations:true){div:where(.swal2-icon).swal2-question.swal2-icon-show{animation:swal2-animate-error-icon .5s}div:where(.swal2-icon).swal2-question.swal2-icon-show .swal2-icon-content{animation:swal2-animate-question-mark .8s}}div:where(.swal2-icon).swal2-success{border-color:#a5dc86;color:#a5dc86}div:where(.swal2-icon).swal2-success [class^=swal2-success-circular-line]{position:absolute;width:3.75em;height:7.5em;border-radius:50%}div:where(.swal2-icon).swal2-success [class^=swal2-success-circular-line][class$=left]{top:-0.4375em;left:-2.0635em;transform:rotate(-45deg);transform-origin:3.75em 3.75em;border-radius:7.5em 0 0 7.5em}div:where(.swal2-icon).swal2-success [class^=swal2-success-circular-line][class$=right]{top:-0.6875em;left:1.875em;transform:rotate(-45deg);transform-origin:0 3.75em;border-radius:0 7.5em 7.5em 0}div:where(.swal2-icon).swal2-success .swal2-success-ring{position:absolute;z-index:2;top:-0.25em;left:-0.25em;box-sizing:content-box;width:100%;height:100%;border:.25em solid rgba(165,220,134,.3);border-radius:50%}div:where(.swal2-icon).swal2-success .swal2-success-fix{position:absolute;z-index:1;top:.5em;left:1.625em;width:.4375em;height:5.625em;transform:rotate(-45deg)}div:where(.swal2-icon).swal2-success [class^=swal2-success-line]{display:block;position:absolute;z-index:2;height:.3125em;border-radius:.125em;background-color:#a5dc86}div:where(.swal2-icon).swal2-success [class^=swal2-success-line][class$=tip]{top:2.875em;left:.8125em;width:1.5625em;transform:rotate(45deg)}div:where(.swal2-icon).swal2-success [class^=swal2-success-line][class$=long]{top:2.375em;right:.5em;width:2.9375em;transform:rotate(-45deg)}@container swal2-popup style(--swal2-icon-animations:true){div:where(.swal2-icon).swal2-success.swal2-icon-show .swal2-success-line-tip{animation:swal2-animate-success-line-tip .75s}div:where(.swal2-icon).swal2-success.swal2-icon-show .swal2-success-line-long{animation:swal2-animate-success-line-long .75s}div:where(.swal2-icon).swal2-success.swal2-icon-show .swal2-success-circular-line-right{animation:swal2-rotate-success-circular-line 4.25s ease-in}}[class^=swal2]{-webkit-tap-highlight-color:rgba(0,0,0,0)}.swal2-show{animation:var(--swal2-show-animation)}.swal2-hide{animation:var(--swal2-hide-animation)}.swal2-noanimation{transition:none}.swal2-scrollbar-measure{position:absolute;top:-9999px;width:50px;height:50px;overflow:scroll}.swal2-rtl .swal2-close{margin-right:initial;margin-left:0}.swal2-rtl .swal2-timer-progress-bar{right:0;left:auto}.swal2-toast{box-sizing:border-box;grid-column:1/4 !important;grid-row:1/4 !important;grid-template-columns:min-content auto min-content;padding:1em;overflow-y:hidden;border:var(--swal2-toast-border);background:var(--swal2-background);box-shadow:var(--swal2-toast-box-shadow);pointer-events:all}.swal2-toast>*{grid-column:2}.swal2-toast h2:where(.swal2-title){margin:.5em 1em;padding:0;font-size:1em;text-align:initial}.swal2-toast .swal2-loading{justify-content:center}.swal2-toast input:where(.swal2-input){height:2em;margin:.5em;font-size:1em}.swal2-toast .swal2-validation-message{font-size:1em}.swal2-toast div:where(.swal2-footer){margin:.5em 0 0;padding:.5em 0 0;font-size:.8em}.swal2-toast button:where(.swal2-close){grid-column:3/3;grid-row:1/99;align-self:center;width:.8em;height:.8em;margin:0;font-size:2em}.swal2-toast div:where(.swal2-html-container){margin:.5em 1em;padding:0;overflow:initial;font-size:1em;text-align:initial}.swal2-toast div:where(.swal2-html-container):empty{padding:0}.swal2-toast .swal2-loader{grid-column:1;grid-row:1/99;align-self:center;width:2em;height:2em;margin:.25em}.swal2-toast .swal2-icon{grid-column:1;grid-row:1/99;align-self:center;width:2em;min-width:2em;height:2em;margin:0 .5em 0 0}.swal2-toast .swal2-icon .swal2-icon-content{display:flex;align-items:center;font-size:1.8em;font-weight:bold}.swal2-toast .swal2-icon.swal2-success .swal2-success-ring{width:2em;height:2em}.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line]{top:.875em;width:1.375em}.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=left]{left:.3125em}.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=right]{right:.3125em}.swal2-toast div:where(.swal2-actions){justify-content:flex-start;height:auto;margin:0;margin-top:.5em;padding:0 .5em}.swal2-toast button:where(.swal2-styled){margin:.25em .5em;padding:.4em .6em;font-size:1em}.swal2-toast .swal2-success{border-color:#a5dc86}.swal2-toast .swal2-success [class^=swal2-success-circular-line]{position:absolute;width:1.6em;height:3em;border-radius:50%}.swal2-toast .swal2-success [class^=swal2-success-circular-line][class$=left]{top:-0.8em;left:-0.5em;transform:rotate(-45deg);transform-origin:2em 2em;border-radius:4em 0 0 4em}.swal2-toast .swal2-success [class^=swal2-success-circular-line][class$=right]{top:-0.25em;left:.9375em;transform-origin:0 1.5em;border-radius:0 4em 4em 0}.swal2-toast .swal2-success .swal2-success-ring{width:2em;height:2em}.swal2-toast .swal2-success .swal2-success-fix{top:0;left:.4375em;width:.4375em;height:2.6875em}.swal2-toast .swal2-success [class^=swal2-success-line]{height:.3125em}.swal2-toast .swal2-success [class^=swal2-success-line][class$=tip]{top:1.125em;left:.1875em;width:.75em}.swal2-toast .swal2-success [class^=swal2-success-line][class$=long]{top:.9375em;right:.1875em;width:1.375em}@container swal2-popup style(--swal2-icon-animations:true){.swal2-toast .swal2-success.swal2-icon-show .swal2-success-line-tip{animation:swal2-toast-animate-success-line-tip .75s}.swal2-toast .swal2-success.swal2-icon-show .swal2-success-line-long{animation:swal2-toast-animate-success-line-long .75s}}.swal2-toast.swal2-show{animation:var(--swal2-toast-show-animation)}.swal2-toast.swal2-hide{animation:var(--swal2-toast-hide-animation)}@keyframes swal2-show{0%{transform:translate3d(0, -50px, 0) scale(0.9);opacity:0}100%{transform:translate3d(0, 0, 0) scale(1);opacity:1}}@keyframes swal2-hide{0%{transform:translate3d(0, 0, 0) scale(1);opacity:1}100%{transform:translate3d(0, -50px, 0) scale(0.9);opacity:0}}@keyframes swal2-animate-success-line-tip{0%{top:1.1875em;left:.0625em;width:0}54%{top:1.0625em;left:.125em;width:0}70%{top:2.1875em;left:-0.375em;width:3.125em}84%{top:3em;left:1.3125em;width:1.0625em}100%{top:2.8125em;left:.8125em;width:1.5625em}}@keyframes swal2-animate-success-line-long{0%{top:3.375em;right:2.875em;width:0}65%{top:3.375em;right:2.875em;width:0}84%{top:2.1875em;right:0;width:3.4375em}100%{top:2.375em;right:.5em;width:2.9375em}}@keyframes swal2-rotate-success-circular-line{0%{transform:rotate(-45deg)}5%{transform:rotate(-45deg)}12%{transform:rotate(-405deg)}100%{transform:rotate(-405deg)}}@keyframes swal2-animate-error-x-mark{0%{margin-top:1.625em;transform:scale(0.4);opacity:0}50%{margin-top:1.625em;transform:scale(0.4);opacity:0}80%{margin-top:-0.375em;transform:scale(1.15)}100%{margin-top:0;transform:scale(1);opacity:1}}@keyframes swal2-animate-error-icon{0%{transform:rotateX(100deg);opacity:0}100%{transform:rotateX(0deg);opacity:1}}@keyframes swal2-rotate-loading{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}@keyframes swal2-animate-question-mark{0%{transform:rotateY(-360deg)}100%{transform:rotateY(0)}}@keyframes swal2-animate-i-mark{0%{transform:rotateZ(45deg);opacity:0}25%{transform:rotateZ(-25deg);opacity:.4}50%{transform:rotateZ(15deg);opacity:.8}75%{transform:rotateZ(-5deg);opacity:1}100%{transform:rotateX(0);opacity:1}}@keyframes swal2-toast-show{0%{transform:translateY(-0.625em) rotateZ(2deg)}33%{transform:translateY(0) rotateZ(-2deg)}66%{transform:translateY(0.3125em) rotateZ(2deg)}100%{transform:translateY(0) rotateZ(0deg)}}@keyframes swal2-toast-hide{100%{transform:rotateZ(1deg);opacity:0}}@keyframes swal2-toast-animate-success-line-tip{0%{top:.5625em;left:.0625em;width:0}54%{top:.125em;left:.125em;width:0}70%{top:.625em;left:-0.25em;width:1.625em}84%{top:1.0625em;left:.75em;width:.5em}100%{top:1.125em;left:.1875em;width:.75em}}@keyframes swal2-toast-animate-success-line-long{0%{top:1.625em;right:1.375em;width:0}65%{top:1.25em;right:.9375em;width:0}84%{top:.9375em;right:0;width:1.125em}100%{top:.9375em;right:.1875em;width:1.375em}}');\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dlZXRhbGVydDIvZGlzdC9zd2VldGFsZXJ0Mi5lc20uYWxsLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7O0FBR0EsR0FDQSxTQUFTQSxrQkFBa0JDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDO0lBQ2hDLElBQUksY0FBYyxPQUFPRixJQUFJQSxNQUFNQyxJQUFJRCxFQUFFRyxHQUFHLENBQUNGLElBQUksT0FBT0csVUFBVUMsTUFBTSxHQUFHLElBQUlKLElBQUlDO0lBQ25GLE1BQU0sSUFBSUksVUFBVTtBQUN0QjtBQUNBLFNBQVNDLDJCQUEyQlAsQ0FBQyxFQUFFQyxDQUFDO0lBQ3RDLElBQUlBLEVBQUVFLEdBQUcsQ0FBQ0gsSUFBSSxNQUFNLElBQUlNLFVBQVU7QUFDcEM7QUFDQSxTQUFTRSx1QkFBdUJDLENBQUMsRUFBRUMsQ0FBQztJQUNsQyxPQUFPRCxFQUFFRSxHQUFHLENBQUNaLGtCQUFrQlUsR0FBR0M7QUFDcEM7QUFDQSxTQUFTRSwyQkFBMkJaLENBQUMsRUFBRUMsQ0FBQyxFQUFFUyxDQUFDO0lBQ3pDSCwyQkFBMkJQLEdBQUdDLElBQUlBLEVBQUVZLEdBQUcsQ0FBQ2IsR0FBR1U7QUFDN0M7QUFDQSxTQUFTSSx1QkFBdUJMLENBQUMsRUFBRUMsQ0FBQyxFQUFFSyxDQUFDO0lBQ3JDLE9BQU9OLEVBQUVJLEdBQUcsQ0FBQ2Qsa0JBQWtCVSxHQUFHQyxJQUFJSyxJQUFJQTtBQUM1QztBQUVBLE1BQU1DLHdCQUF3QjtBQUU5Qix3QkFBd0IsR0FDeEIsTUFBTUMsY0FBYyxDQUFDO0FBQ3JCLE1BQU1DLDZCQUE2QjtJQUNqQyxJQUFJRCxZQUFZRSxxQkFBcUIsWUFBWUMsYUFBYTtRQUM1REgsWUFBWUUscUJBQXFCLENBQUNFLEtBQUs7UUFDdkNKLFlBQVlFLHFCQUFxQixHQUFHO0lBQ3RDLE9BQU8sSUFBSUcsU0FBU0MsSUFBSSxFQUFFO1FBQ3hCRCxTQUFTQyxJQUFJLENBQUNGLEtBQUs7SUFDckI7QUFD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Q0UsRUFBRXdVLFNBQVMsR0FBQ3pVO0lBQUM7QUFBQyxFQUFFcUIsVUFBUyIsInNvdXJjZXMiOlsid2VicGFjazovL3ByYXNvYnBhaS13ZWIvLi9ub2RlX21vZHVsZXMvc3dlZXRhbGVydDIvZGlzdC9zd2VldGFsZXJ0Mi5lc20uYWxsLmpzPzYxMTgiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4qIHN3ZWV0YWxlcnQyIHYxMS4yNi4xMFxuKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4qL1xuZnVuY3Rpb24gX2Fzc2VydENsYXNzQnJhbmQoZSwgdCwgbikge1xuICBpZiAoXCJmdW5jdGlvblwiID09IHR5cGVvZiBlID8gZSA9PT0gdCA6IGUuaGFzKHQpKSByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB0IDogbjtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgZWxlbWVudCBpcyBub3QgcHJlc2VudCBvbiB0aGlzIG9iamVjdFwiKTtcbn1cbmZ1bmN0aW9uIF9jaGVja1ByaXZhdGVSZWRlY2xhcmF0aW9uKGUsIHQpIHtcbiAgaWYgKHQuaGFzKGUpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGluaXRpYWxpemUgdGhlIHNhbWUgcHJpdmF0ZSBlbGVtZW50cyB0d2ljZSBvbiBhbiBvYmplY3RcIik7XG59XG5mdW5jdGlvbiBfY2xhc3NQcml2YXRlRmllbGRHZXQyKHMsIGEpIHtcbiAgcmV0dXJuIHMuZ2V0KF9hc3NlcnRDbGFzc0JyYW5kKHMsIGEpKTtcbn1cbmZ1bmN0aW9uIF9jbGFzc1ByaXZhdGVGaWVsZEluaXRTcGVjKGUsIHQsIGEpIHtcbiAgX2NoZWNrUHJpdmF0ZVJlZGVjbGFyYXRpb24oZSwgdCksIHQuc2V0KGUsIGEpO1xufVxuZnVuY3Rpb24gX2NsYXNzUHJpdmF0ZUZpZWxkU2V0MihzLCBhLCByKSB7XG4gIHJldHVybiBzLnNldChfYXNzZXJ0Q2xhc3NCcmFuZChzLCBhKSwgciksIHI7XG59XG5cbmNvbnN0IFJFU1RPUkVfRk9DVVNfVElNRU9VVCA9IDEwMDtcblxuLyoqIEB0eXBlIHtHbG9iYWxTdGF0ZX0gKi9cbmNvbnN0IGdsb2JhbFN0YXRlID0ge307XG5jb25zdCBmb2N1c1ByZXZpb3VzQWN0aXZlRWxlbWVudCA9ICgpID0+IHtcbiAgaWYgKGdsb2JhbFN0YXRlLnByZXZpb3VzQWN0aXZlRWxlbWVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgZ2xvYmFsU3RhdGUucHJldmlvdXNBY3RpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgZ2xvYmFsU3RhdGUucHJldmlvdXNBY3RpdmVFbGVtZW50ID0gbnVsbDtcbiAgfSBlbHNlIGlmIChkb2N1bWVudC5ib2R5KSB7XG4gICAgZG9jdW1lbnQuYm9keS5mb2N1cygpO1xuICB9XG59O1xuXG4vKipcbiAqIFJlc3RvcmUgcHJldmlvdXMgYWN0aXZlIChmb2N1c2VkKSBlbGVtZW50XG4gKlxuICogQHBhcmFtIHtib29sZWFufSByZXR1cm5Gb2N1c1xuICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gKi9cbmNvbnN0IHJlc3RvcmVBY3RpdmVFbGVtZW50ID0gcmV0dXJuRm9jdXMgPT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgaWYgKCFyZXR1cm5Gb2N1cykge1xuICAgICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgICB9XG4gICAgY29uc3QgeCA9IHdpbmRvdy5zY3JvbGxYO1xuICAgIGNvbnN0IHkgPSB3aW5kb3cuc2Nyb2xsWTtcbiAgICBnbG9iYWxTdGF0ZS5yZXN0b3JlRm9jdXNUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBmb2N1c1ByZXZpb3VzQWN0aXZlRWxlbWVudCgpO1xuICAgICAgcmVzb2x2ZSgpO1xuICAgIH0sIFJFU1RPUkVfRk9DVVNfVElNRU9VVCk7IC8vIGlzc3Vlcy85MDBcblxuICAgIHdpbmRvdy5zY3JvbGxUbyh4LCB5KTtcbiAgfSk7XG59O1xuXG5jb25zdCBzd2FsUHJlZml4ID0gJ3N3YWwyLSc7XG5cbi8qKlxuICogQHR5cGVkZWYge1JlY29yZDxTd2FsQ2xhc3MsIHN0cmluZz59IFN3YWxDbGFzc2VzXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7J3N1Y2Nlc3MnIHwgJ3dhcm5pbmcnIHwgJ2luZm8nIHwgJ3F1ZXN0aW9uJyB8ICdlcnJvcid9IFN3YWxJY29uXG4gKiBAdHlwZWRlZiB7UmVjb3JkPFN3YWxJY29uLCBzdHJpbmc+fSBTd2FsSWNvbnNcbiAqL1xuXG4vKiogQHR5cGUge1N3YWxDbGFzc1tdfSAqL1xuY29uc3QgY2xhc3NOYW1lcyA9IFsnY29udGFpbmVyJywgJ3Nob3duJywgJ2hlaWdodC1hdXRvJywgJ2lvc2ZpeCcsICdwb3B1cCcsICdtb2RhbCcsICduby1iYWNrZHJvcCcsICduby10cmFuc2l0aW9uJywgJ3RvYXN0JywgJ3RvYXN0LXNob3duJywgJ3Nob3cnLCAnaGlkZScsICdjbG9zZScsICd0aXRsZScsICdodG1sLWNvbnRhaW5lcicsICdhY3Rpb25zJywgJ2NvbmZpcm0nLCAnZGVueScsICdjYW5jZWwnLCAnZm9vdGVyJywgJ2ljb24nLCAnaWNvbi1jb250ZW50JywgJ2ltYWdlJywgJ2lucHV0JywgJ2ZpbGUnLCAncmFuZ2UnLCAnc2VsZWN0JywgJ3JhZGlvJywgJ2NoZWNrYm94JywgJ2xhYmVsJywgJ3RleHRhcmVhJywgJ2lucHV0ZXJyb3InLCAnaW5wdXQtbGFiZWwnLCAndmFsaWRhdGlvbi1tZXNzYWdlJywgJ3Byb2dyZXNzLXN0ZXBzJywgJ2FjdGl2ZS1wcm9ncmVzcy1zdGVwJywgJ3Byb2dyZXNzLXN0ZXAnLCAncHJvZ3Jlc3Mtc3RlcC1saW5lJywgJ2xvYWRlcicsICdsb2FkaW5nJywgJ3N0eWxlZCcsICd0b3AnLCAndG9wLXN0YXJ0JywgJ3RvcC1lbmQnLCAndG9wLWxlZnQnLCAndG9wLXJpZ2h0JywgJ2NlbnRlcicsICdjZW50ZXItc3RhcnQnLCAnY2VudGVyLWVuZCcsICdjZW50ZXItbGVmdCcsICdjZW50ZXItcmlnaHQnLCAnYm90dG9tJywgJ2JvdHRvbS1zdGFydCcsICdib3R0b20tZW5kJywgJ2JvdHRvbS1sZWZ0JywgJ2JvdHRvbS1yaWdodCcsICdncm93LXJvdycsICdncm93LWNvbHVtbicsICdncm93LWZ1bGxzY3JlZW4nLCAncnRsJywgJ3RpbWVyLXByb2dyZXNzLWJhcicsICd0aW1lci1wcm9ncmVzcy1iYXItY29udGFpbmVyJywgJ3Njcm9sbGJhci1tZWFzdXJlJywgJ2ljb24tc3VjY2VzcycsICdpY29uLXdhcm5pbmcnLCAnaWNvbi1pbmZvJywgJ2ljb24tcXVlc3Rpb24nLCAnaWNvbi1lcnJvcicsICdkcmFnZ2FibGUnLCAnZHJhZ2dpbmcnXTtcbmNvbnN0IHN3YWxDbGFzc2VzID0gY2xhc3NOYW1lcy5yZWR1Y2UoKGFjYywgY2xhc3NOYW1lKSA9PiB7XG4gIGFjY1tjbGFzc05hbWVdID0gc3dhbFByZWZpeCArIGNsYXNzTmFtZTtcbiAgcmV0dXJuIGFjYztcbn0sIC8qKiBAdHlwZSB7U3dhbENsYXNzZXN9ICove30pO1xuXG4vKiogQHR5cGUge1N3YWxJY29uW119ICovXG5jb25zdCBpY29ucyA9IFsnc3VjY2VzcycsICd3YXJuaW5nJywgJ2luZm8nLCAncXVlc3Rpb24nLCAnZXJyb3InXTtcbmNvbnN0IGljb25UeXBlcyA9IGljb25zLnJlZHVjZSgoYWNjLCBpY29uKSA9PiB7XG4gIGFjY1tpY29uXSA9IHN3YWxQcmVmaXggKyBpY29uO1xuICByZXR1cm4gYWNjO1xufSwgLyoqIEB0eXBlIHtTd2FsSWNvbnN9ICove30pO1xuXG5jb25zdCBjb25zb2xlUHJlZml4ID0gJ1N3ZWV0QWxlcnQyOic7XG5cbi8qKlxuICogQ2FwaXRhbGl6ZSB0aGUgZmlyc3QgbGV0dGVyIG9mIGEgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuY29uc3QgY2FwaXRhbGl6ZUZpcnN0TGV0dGVyID0gc3RyID0+IHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcblxuLyoqXG4gKiBTdGFuZGFyZGl6ZSBjb25zb2xlIHdhcm5pbmdzXG4gKlxuICogQHBhcmFtIHtzdHJpbmcgfCBzdHJpbmdbXX0gbWVzc2FnZVxuICovXG5jb25zdCB3YXJuID0gbWVzc2FnZSA9PiB7XG4gIGNvbnNvbGUud2FybihgJHtjb25zb2xlUHJlZml4fSAke3R5cGVvZiBtZXNzYWdlID09PSAnb2JqZWN0JyA/IG1lc3NhZ2Uuam9pbignICcpIDogbWVzc2FnZX1gKTtcbn07XG5cbi8qKlxuICogU3RhbmRhcmRpemUgY29uc29sZSBlcnJvcnNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZVxuICovXG5jb25zdCBlcnJvciA9IG1lc3NhZ2UgPT4ge1xuICBjb25zb2xlLmVycm9yKGAke2NvbnNvbGVQcmVmaXh9ICR7bWVzc2FnZX1gKTtcbn07XG5cbi8qKlxuICogUHJpdmF0ZSBnbG9iYWwgc3RhdGUgZm9yIGB3YXJuT25jZWBcbiAqXG4gKiBAdHlwZSB7c3RyaW5nW119XG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBwcmV2aW91c1dhcm5PbmNlTWVzc2FnZXMgPSBbXTtcblxuLyoqXG4gKiBTaG93IGEgY29uc29sZSB3YXJuaW5nLCBidXQgb25seSBpZiBpdCBoYXNuJ3QgYWxyZWFkeSBiZWVuIHNob3duXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VcbiAqL1xuY29uc3Qgd2Fybk9uY2UgPSBtZXNzYWdlID0+IHtcbiAgaWYgKCFwcmV2aW91c1dhcm5PbmNlTWVzc2FnZXMuaW5jbHVkZXMobWVzc2FnZSkpIHtcbiAgICBwcmV2aW91c1dhcm5PbmNlTWVzc2FnZXMucHVzaChtZXNzYWdlKTtcbiAgICB3YXJuKG1lc3NhZ2UpO1xuICB9XG59O1xuXG4vKipcbiAqIFNob3cgYSBvbmUtdGltZSBjb25zb2xlIHdhcm5pbmcgYWJvdXQgZGVwcmVjYXRlZCBwYXJhbXMvbWV0aG9kc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBkZXByZWNhdGVkUGFyYW1cbiAqIEBwYXJhbSB7c3RyaW5nP30gdXNlSW5zdGVhZFxuICovXG5jb25zdCB3YXJuQWJvdXREZXByZWNhdGlvbiA9IChkZXByZWNhdGVkUGFyYW0sIHVzZUluc3RlYWQgPSBudWxsKSA9PiB7XG4gIHdhcm5PbmNlKGBcIiR7ZGVwcmVjYXRlZFBhcmFtfVwiIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLiR7dXNlSW5zdGVhZCA/IGAgVXNlIFwiJHt1c2VJbnN0ZWFkfVwiIGluc3RlYWQuYCA6ICcnfWApO1xufTtcblxuLyoqXG4gKiBJZiBgYXJnYCBpcyBhIGZ1bmN0aW9uLCBjYWxsIGl0ICh3aXRoIG5vIGFyZ3VtZW50cyBvciBjb250ZXh0KSBhbmQgcmV0dXJuIHRoZSByZXN1bHQuXG4gKiBPdGhlcndpc2UsIGp1c3QgcGFzcyB0aGUgdmFsdWUgdGhyb3VnaFxuICpcbiAqIEBwYXJhbSB7KCgpID0+ICopIHwgKn0gYXJnXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuY29uc3QgY2FsbElmRnVuY3Rpb24gPSBhcmcgPT4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJyA/IGFyZygpIDogYXJnO1xuXG4vKipcbiAqIEBwYXJhbSB7Kn0gYXJnXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuY29uc3QgaGFzVG9Qcm9taXNlRm4gPSBhcmcgPT4gYXJnICYmIHR5cGVvZiBhcmcudG9Qcm9taXNlID09PSAnZnVuY3Rpb24nO1xuXG4vKipcbiAqIEBwYXJhbSB7Kn0gYXJnXG4gKiBAcmV0dXJucyB7UHJvbWlzZTwqPn1cbiAqL1xuY29uc3QgYXNQcm9taXNlID0gYXJnID0+IGhhc1RvUHJvbWlzZUZuKGFyZykgPyBhcmcudG9Qcm9taXNlKCkgOiBQcm9taXNlLnJlc29sdmUoYXJnKTtcblxuLyoqXG4gKiBAcGFyYW0geyp9IGFyZ1xuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmNvbnN0IGlzUHJvbWlzZSA9IGFyZyA9PiBhcmcgJiYgUHJvbWlzZS5yZXNvbHZlKGFyZykgPT09IGFyZztcblxuLyoqXG4gKiBHZXRzIHRoZSBwb3B1cCBjb250YWluZXIgd2hpY2ggY29udGFpbnMgdGhlIGJhY2tkcm9wIGFuZCB0aGUgcG9wdXAgaXRzZWxmLlxuICpcbiAqIEByZXR1cm5zIHtIVE1MRWxlbWVudCB8IG51bGx9XG4gKi9cbmNvbnN0IGdldENvbnRhaW5lciA9ICgpID0+IGRvY3VtZW50LmJvZHkucXVlcnlTZWxlY3RvcihgLiR7c3dhbENsYXNzZXMuY29udGFpbmVyfWApO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvclN0cmluZ1xuICogQHJldHVybnMge0hUTUxFbGVtZW50IHwgbnVsbH1cbiAqL1xuY29uc3QgZWxlbWVudEJ5U2VsZWN0b3IgPSBzZWxlY3RvclN0cmluZyA9PiB7XG4gIGNvbnN0IGNvbnRhaW5lciA9IGdldENvbnRhaW5lcigpO1xuICByZXR1cm4gY29udGFpbmVyID8gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3JTdHJpbmcpIDogbnVsbDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICogQHJldHVybnMge0hUTUxFbGVtZW50IHwgbnVsbH1cbiAqL1xuY29uc3QgZWxlbWVudEJ5Q2xhc3MgPSBjbGFzc05hbWUgPT4ge1xuICByZXR1cm4gZWxlbWVudEJ5U2VsZWN0b3IoYC4ke2NsYXNzTmFtZX1gKTtcbn07XG5cbi8qKlxuICogQHJldHVybnMge0hUTUxFbGVtZW50IHwgbnVsbH1cbiAqL1xuY29uc3QgZ2V0UG9wdXAgPSAoKSA9PiBlbGVtZW50QnlDbGFzcyhzd2FsQ2xhc3Nlcy5wb3B1cCk7XG5cbi8qKlxuICogQHJldHVybnMge0hUTUxFbGVtZW50IHwgbnVsbH1cbiAqL1xuY29uc3QgZ2V0SWNvbiA9ICgpID0+IGVsZW1lbnRCeUNsYXNzKHN3YWxDbGFzc2VzLmljb24pO1xuXG4vKipcbiAqIEByZXR1cm5zIHtIVE1MRWxlbWVudCB8IG51bGx9XG4gKi9cbmNvbnN0IGdldEljb25Db250ZW50ID0gKCkgPT4gZWxlbWVudEJ5Q2xhc3Moc3dhbENsYXNzZXNbJ2ljb24tY29udGVudCddKTtcblxuLyoqXG4gKiBAcmV0dXJucyB7SFRNTEVsZW1lbnQgfCBudWxsfVxuICovXG5jb25zdCBnZXRUaXRsZSA9ICgpID0+IGVsZW1lbnRCeUNsYXNzKHN3YWxDbGFzc2VzLnRpdGxlKTtcblxuLyoqXG4gKiBAcmV0dXJucyB7SFRNTEVsZW1lbnQgfCBudWxsfVxuICovXG5jb25zdCBnZXRIdG1sQ29udGFpbmVyID0gKCkgPT4gZWxlbWVudEJ5Q2xhc3Moc3dhbENsYXNzZXNbJ2h0bWwtY29udGFpbmVyJ10pO1xuXG4vKipcbiAqIEByZXR1cm5zIHtIVE1MRWxlbWVudCB8IG51bGx9XG4gKi9cbmNvbnN0IGdldEltYWdlID0gKCkgPT4gZWxlbWVudEJ5Q2xhc3Moc3dhbENsYXNzZXMuaW1hZ2UpO1xuXG4vKipcbiAqIEByZXR1cm5zIHtIVE1MRWxlbWVudCB8IG51bGx9XG4gKi9cbmNvbnN0IGdldFByb2dyZXNzU3RlcHMgPSAoKSA9PiBlbGVtZW50QnlDbGFzcyhzd2FsQ2xhc3Nlc1sncHJvZ3Jlc3Mtc3RlcHMnXSk7XG5cbi8qKlxuICogQHJldHVybnMge0hUTUxFbGVtZW50IHwgbnVsbH1cbiAqL1xuY29uc3QgZ2V0VmFsaWRhdGlvbk1lc3NhZ2UgPSAoKSA9PiBlbGVtZW50QnlDbGFzcyhzd2FsQ2xhc3Nlc1sndmFsaWRhdGlvbi1tZXNzYWdlJ10pO1xuXG4vKipcbiAqIEByZXR1cm5zIHtIVE1MQnV0dG9uRWxlbWVudCB8IG51bGx9XG4gKi9cbmNvbnN0IGdldENvbmZpcm1CdXR0b24gPSAoKSA9PiAoLyoqIEB0eXBlIHtIVE1MQnV0dG9uRWxlbWVudH0gKi9lbGVtZW50QnlTZWxlY3RvcihgLiR7c3dhbENsYXNzZXMuYWN0aW9uc30gLiR7c3dhbENsYXNzZXMuY29uZmlybX1gKSk7XG5cbi8qKlxuICogQHJldHVybnMge0hUTUxCdXR0b25FbGVtZW50IHwgbnVsbH1cbiAqL1xuY29uc3QgZ2V0Q2FuY2VsQnV0dG9uID0gKCkgPT4gKC8qKiBAdHlwZSB7SFRNTEJ1dHRvbkVsZW1lbnR9ICovZWxlbWVudEJ5U2VsZWN0b3IoYC4ke3N3YWxDbGFzc2VzLmFjdGlvbnN9IC4ke3N3YWxDbGFzc2VzLmNhbmNlbH1gKSk7XG5cbi8qKlxuICogQHJldHVybnMge0hUTUxCdXR0b25FbGVtZW50IHwgbnVsbH1cbiAqL1xuY29uc3QgZ2V0RGVueUJ1dHRvbiA9ICgpID0+ICgvKiogQHR5cGUge0hUTUxCdXR0b25FbGVtZW50fSAqL2VsZW1lbnRCeVNlbGVjdG9yKGAuJHtzd2FsQ2xhc3Nlcy5hY3Rpb25zfSAuJHtzd2FsQ2xhc3Nlcy5kZW55fWApKTtcblxuLyoqXG4gKiBAcmV0dXJucyB7SFRNTEVsZW1lbnQgfCBudWxsfVxuICovXG5jb25zdCBnZXRJbnB1dExhYmVsID0gKCkgPT4gZWxlbWVudEJ5Q2xhc3Moc3dhbENsYXNzZXNbJ2lucHV0LWxhYmVsJ10pO1xuXG4vKipcbiAqIEByZXR1cm5zIHtIVE1MRWxlbWVudCB8IG51bGx9XG4gKi9cbmNvbnN0IGdldExvYWRlciA9ICgpID0+IGVsZW1lbnRCeVNlbGVjdG9yKGAuJHtzd2FsQ2xhc3Nlcy5sb2FkZXJ9YCk7XG5cbi8qKlxuICogQHJldHVybnMge0hUTUxFbGVtZW50IHwgbnVsbH1cbiAqL1xuY29uc3QgZ2V0QWN0aW9ucyA9ICgpID0+IGVsZW1lbnRCeUNsYXNzKHN3YWxDbGFzc2VzLmFjdGlvbnMpO1xuXG4vKipcbiAqIEByZXR1cm5zIHtIVE1MRWxlbWVudCB8IG51bGx9XG4gKi9cbmNvbnN0IGdldEZvb3RlciA9ICgpID0+IGVsZW1lbnRCeUNsYXNzKHN3YWxDbGFzc2VzLmZvb3Rlcik7XG5cbi8qKlxuICogQHJldHVybnMge0hUTUxFbGVtZW50IHwgbnVsbH1cbiAqL1xuY29uc3QgZ2V0VGltZXJQcm9ncmVzc0JhciA9ICgpID0+IGVsZW1lbnRCeUNsYXNzKHN3YWxDbGFzc2VzWyd0aW1lci1wcm9ncmVzcy1iYXInXSk7XG5cbi8qKlxuICogQHJldHVybnMge0hUTUxFbGVtZW50IHwgbnVsbH1cbiAqL1xuY29uc3QgZ2V0Q2xvc2VCdXR0b24gPSAoKSA9PiBlbGVtZW50QnlDbGFzcyhzd2FsQ2xhc3Nlcy5jbG9zZSk7XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qa3VwL2ZvY3VzYWJsZS9ibG9iL21hc3Rlci9pbmRleC5qc1xuY29uc3QgZm9jdXNhYmxlID0gYFxuICBhW2hyZWZdLFxuICBhcmVhW2hyZWZdLFxuICBpbnB1dDpub3QoW2Rpc2FibGVkXSksXG4gIHNlbGVjdDpub3QoW2Rpc2FibGVkXSksXG4gIHRleHRhcmVhOm5vdChbZGlzYWJsZWRdKSxcbiAgYnV0dG9uOm5vdChbZGlzYWJsZWRdKSxcbiAgaWZyYW1lLFxuICBvYmplY3QsXG4gIGVtYmVkLFxuICBbdGFiaW5kZXg9XCIwXCJdLFxuICBbY29udGVudGVkaXRhYmxlXSxcbiAgYXVkaW9bY29udHJvbHNdLFxuICB2aWRlb1tjb250cm9sc10sXG4gIHN1bW1hcnlcbmA7XG4vKipcbiAqIEByZXR1cm5zIHtIVE1MRWxlbWVudFtdfVxuICovXG5jb25zdCBnZXRGb2N1c2FibGVFbGVtZW50cyA9ICgpID0+IHtcbiAgY29uc3QgcG9wdXAgPSBnZXRQb3B1cCgpO1xuICBpZiAoIXBvcHVwKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIC8qKiBAdHlwZSB7Tm9kZUxpc3RPZjxIVE1MRWxlbWVudD59ICovXG4gIGNvbnN0IGZvY3VzYWJsZUVsZW1lbnRzV2l0aFRhYmluZGV4ID0gcG9wdXAucXVlcnlTZWxlY3RvckFsbCgnW3RhYmluZGV4XTpub3QoW3RhYmluZGV4PVwiLTFcIl0pOm5vdChbdGFiaW5kZXg9XCIwXCJdKScpO1xuICBjb25zdCBmb2N1c2FibGVFbGVtZW50c1dpdGhUYWJpbmRleFNvcnRlZCA9IEFycmF5LmZyb20oZm9jdXNhYmxlRWxlbWVudHNXaXRoVGFiaW5kZXgpXG4gIC8vIHNvcnQgYWNjb3JkaW5nIHRvIHRhYmluZGV4XG4gIC5zb3J0KChhLCBiKSA9PiB7XG4gICAgY29uc3QgdGFiaW5kZXhBID0gcGFyc2VJbnQoYS5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JykgfHwgJzAnKTtcbiAgICBjb25zdCB0YWJpbmRleEIgPSBwYXJzZUludChiLmdldEF0dHJpYnV0ZSgndGFiaW5kZXgnKSB8fCAnMCcpO1xuICAgIGlmICh0YWJpbmRleEEgPiB0YWJpbmRleEIpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAodGFiaW5kZXhBIDwgdGFiaW5kZXhCKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9KTtcblxuICAvKiogQHR5cGUge05vZGVMaXN0T2Y8SFRNTEVsZW1lbnQ+fSAqL1xuICBjb25zdCBvdGhlckZvY3VzYWJsZUVsZW1lbnRzID0gcG9wdXAucXVlcnlTZWxlY3RvckFsbChmb2N1c2FibGUpO1xuICBjb25zdCBvdGhlckZvY3VzYWJsZUVsZW1lbnRzRmlsdGVyZWQgPSBBcnJheS5mcm9tKG90aGVyRm9jdXNhYmxlRWxlbWVudHMpLmZpbHRlcihlbCA9PiBlbC5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JykgIT09ICctMScpO1xuICByZXR1cm4gWy4uLm5ldyBTZXQoZm9jdXNhYmxlRWxlbWVudHNXaXRoVGFiaW5kZXhTb3J0ZWQuY29uY2F0KG90aGVyRm9jdXNhYmxlRWxlbWVudHNGaWx0ZXJlZCkpXS5maWx0ZXIoZWwgPT4gaXNWaXNpYmxlJDEoZWwpKTtcbn07XG5cbi8qKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmNvbnN0IGlzTW9kYWwgPSAoKSA9PiB7XG4gIHJldHVybiBoYXNDbGFzcyhkb2N1bWVudC5ib2R5LCBzd2FsQ2xhc3Nlcy5zaG93bikgJiYgIWhhc0NsYXNzKGRvY3VtZW50LmJvZHksIHN3YWxDbGFzc2VzWyd0b2FzdC1zaG93biddKSAmJiAhaGFzQ2xhc3MoZG9jdW1lbnQuYm9keSwgc3dhbENsYXNzZXNbJ25vLWJhY2tkcm9wJ10pO1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuY29uc3QgaXNUb2FzdCA9ICgpID0+IHtcbiAgY29uc3QgcG9wdXAgPSBnZXRQb3B1cCgpO1xuICBpZiAoIXBvcHVwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBoYXNDbGFzcyhwb3B1cCwgc3dhbENsYXNzZXMudG9hc3QpO1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuY29uc3QgaXNMb2FkaW5nID0gKCkgPT4ge1xuICBjb25zdCBwb3B1cCA9IGdldFBvcHVwKCk7XG4gIGlmICghcG9wdXApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHBvcHVwLmhhc0F0dHJpYnV0ZSgnZGF0YS1sb2FkaW5nJyk7XG59O1xuXG4vKipcbiAqIFNlY3VyZWx5IHNldCBpbm5lckhUTUwgb2YgYW4gZWxlbWVudFxuICogaHR0cHM6Ly9naXRodWIuY29tL3N3ZWV0YWxlcnQyL3N3ZWV0YWxlcnQyL2lzc3Vlcy8xOTI2XG4gKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbVxuICogQHBhcmFtIHtzdHJpbmd9IGh0bWxcbiAqL1xuY29uc3Qgc2V0SW5uZXJIdG1sID0gKGVsZW0sIGh0bWwpID0+IHtcbiAgZWxlbS50ZXh0Q29udGVudCA9ICcnO1xuICBpZiAoaHRtbCkge1xuICAgIGNvbnN0IHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcbiAgICBjb25zdCBwYXJzZWQgPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKGh0bWwsIGB0ZXh0L2h0bWxgKTtcbiAgICBjb25zdCBoZWFkID0gcGFyc2VkLnF1ZXJ5U2VsZWN0b3IoJ2hlYWQnKTtcbiAgICBpZiAoaGVhZCkge1xuICAgICAgQXJyYXkuZnJvbShoZWFkLmNoaWxkTm9kZXMpLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgICBlbGVtLmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBib2R5ID0gcGFyc2VkLnF1ZXJ5U2VsZWN0b3IoJ2JvZHknKTtcbiAgICBpZiAoYm9keSkge1xuICAgICAgQXJyYXkuZnJvbShib2R5LmNoaWxkTm9kZXMpLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50IHx8IGNoaWxkIGluc3RhbmNlb2YgSFRNTEF1ZGlvRWxlbWVudCkge1xuICAgICAgICAgIGVsZW0uYXBwZW5kQ2hpbGQoY2hpbGQuY2xvbmVOb2RlKHRydWUpKTsgLy8gaHR0cHM6Ly9naXRodWIuY29tL3N3ZWV0YWxlcnQyL3N3ZWV0YWxlcnQyL2lzc3Vlcy8yNTA3XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWxlbS5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtXG4gKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuY29uc3QgaGFzQ2xhc3MgPSAoZWxlbSwgY2xhc3NOYW1lKSA9PiB7XG4gIGlmICghY2xhc3NOYW1lKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGNsYXNzTGlzdCA9IGNsYXNzTmFtZS5zcGxpdCgvXFxzKy8pO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNsYXNzTGlzdC5sZW5ndGg7IGkrKykge1xuICAgIGlmICghZWxlbS5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NMaXN0W2ldKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbVxuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gKi9cbmNvbnN0IHJlbW92ZUN1c3RvbUNsYXNzZXMgPSAoZWxlbSwgcGFyYW1zKSA9PiB7XG4gIEFycmF5LmZyb20oZWxlbS5jbGFzc0xpc3QpLmZvckVhY2goY2xhc3NOYW1lID0+IHtcbiAgICBpZiAoIU9iamVjdC52YWx1ZXMoc3dhbENsYXNzZXMpLmluY2x1ZGVzKGNsYXNzTmFtZSkgJiYgIU9iamVjdC52YWx1ZXMoaWNvblR5cGVzKS5pbmNsdWRlcyhjbGFzc05hbWUpICYmICFPYmplY3QudmFsdWVzKHBhcmFtcy5zaG93Q2xhc3MgfHwge30pLmluY2x1ZGVzKGNsYXNzTmFtZSkpIHtcbiAgICAgIGVsZW0uY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1cbiAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICovXG5jb25zdCBhcHBseUN1c3RvbUNsYXNzID0gKGVsZW0sIHBhcmFtcywgY2xhc3NOYW1lKSA9PiB7XG4gIHJlbW92ZUN1c3RvbUNsYXNzZXMoZWxlbSwgcGFyYW1zKTtcbiAgaWYgKCFwYXJhbXMuY3VzdG9tQ2xhc3MpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgY3VzdG9tQ2xhc3MgPSBwYXJhbXMuY3VzdG9tQ2xhc3NbKC8qKiBAdHlwZSB7a2V5b2YgU3dlZXRBbGVydEN1c3RvbUNsYXNzfSAqL2NsYXNzTmFtZSldO1xuICBpZiAoIWN1c3RvbUNsYXNzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh0eXBlb2YgY3VzdG9tQ2xhc3MgIT09ICdzdHJpbmcnICYmICFjdXN0b21DbGFzcy5mb3JFYWNoKSB7XG4gICAgd2FybihgSW52YWxpZCB0eXBlIG9mIGN1c3RvbUNsYXNzLiR7Y2xhc3NOYW1lfSEgRXhwZWN0ZWQgc3RyaW5nIG9yIGl0ZXJhYmxlIG9iamVjdCwgZ290IFwiJHt0eXBlb2YgY3VzdG9tQ2xhc3N9XCJgKTtcbiAgICByZXR1cm47XG4gIH1cbiAgYWRkQ2xhc3MoZWxlbSwgY3VzdG9tQ2xhc3MpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwb3B1cFxuICogQHBhcmFtIHtpbXBvcnQoJy4vcmVuZGVyZXJzL3JlbmRlcklucHV0JykuSW5wdXRDbGFzcyB8IFN3ZWV0QWxlcnRJbnB1dH0gaW5wdXRDbGFzc1xuICogQHJldHVybnMge0hUTUxJbnB1dEVsZW1lbnQgfCBudWxsfVxuICovXG5jb25zdCBnZXRJbnB1dCQxID0gKHBvcHVwLCBpbnB1dENsYXNzKSA9PiB7XG4gIGlmICghaW5wdXRDbGFzcykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHN3aXRjaCAoaW5wdXRDbGFzcykge1xuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgIGNhc2UgJ2ZpbGUnOlxuICAgICAgcmV0dXJuIHBvcHVwLnF1ZXJ5U2VsZWN0b3IoYC4ke3N3YWxDbGFzc2VzLnBvcHVwfSA+IC4ke3N3YWxDbGFzc2VzW2lucHV0Q2xhc3NdfWApO1xuICAgIGNhc2UgJ2NoZWNrYm94JzpcbiAgICAgIHJldHVybiBwb3B1cC5xdWVyeVNlbGVjdG9yKGAuJHtzd2FsQ2xhc3Nlcy5wb3B1cH0gPiAuJHtzd2FsQ2xhc3Nlcy5jaGVja2JveH0gaW5wdXRgKTtcbiAgICBjYXNlICdyYWRpbyc6XG4gICAgICByZXR1cm4gcG9wdXAucXVlcnlTZWxlY3RvcihgLiR7c3dhbENsYXNzZXMucG9wdXB9ID4gLiR7c3dhbENsYXNzZXMucmFkaW99IGlucHV0OmNoZWNrZWRgKSB8fCBwb3B1cC5xdWVyeVNlbGVjdG9yKGAuJHtzd2FsQ2xhc3Nlcy5wb3B1cH0gPiAuJHtzd2FsQ2xhc3Nlcy5yYWRpb30gaW5wdXQ6Zmlyc3QtY2hpbGRgKTtcbiAgICBjYXNlICdyYW5nZSc6XG4gICAgICByZXR1cm4gcG9wdXAucXVlcnlTZWxlY3RvcihgLiR7c3dhbENsYXNzZXMucG9wdXB9ID4gLiR7c3dhbENsYXNzZXMucmFuZ2V9IGlucHV0YCk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBwb3B1cC5xdWVyeVNlbGVjdG9yKGAuJHtzd2FsQ2xhc3Nlcy5wb3B1cH0gPiAuJHtzd2FsQ2xhc3Nlcy5pbnB1dH1gKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxJbnB1dEVsZW1lbnQgfCBIVE1MVGV4dEFyZWFFbGVtZW50IHwgSFRNTFNlbGVjdEVsZW1lbnR9IGlucHV0XG4gKi9cbmNvbnN0IGZvY3VzSW5wdXQgPSBpbnB1dCA9PiB7XG4gIGlucHV0LmZvY3VzKCk7XG5cbiAgLy8gcGxhY2UgY3Vyc29yIGF0IGVuZCBvZiB0ZXh0IGluIHRleHQgaW5wdXRcbiAgaWYgKGlucHV0LnR5cGUgIT09ICdmaWxlJykge1xuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIzNDU5MTVcbiAgICBjb25zdCB2YWwgPSBpbnB1dC52YWx1ZTtcbiAgICBpbnB1dC52YWx1ZSA9ICcnO1xuICAgIGlucHV0LnZhbHVlID0gdmFsO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnQgfCBIVE1MRWxlbWVudFtdIHwgbnVsbH0gdGFyZ2V0XG4gKiBAcGFyYW0ge3N0cmluZyB8IHN0cmluZ1tdIHwgcmVhZG9ubHkgc3RyaW5nW10gfCB1bmRlZmluZWR9IGNsYXNzTGlzdFxuICogQHBhcmFtIHtib29sZWFufSBjb25kaXRpb25cbiAqL1xuY29uc3QgdG9nZ2xlQ2xhc3MgPSAodGFyZ2V0LCBjbGFzc0xpc3QsIGNvbmRpdGlvbikgPT4ge1xuICBpZiAoIXRhcmdldCB8fCAhY2xhc3NMaXN0KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh0eXBlb2YgY2xhc3NMaXN0ID09PSAnc3RyaW5nJykge1xuICAgIGNsYXNzTGlzdCA9IGNsYXNzTGlzdC5zcGxpdCgvXFxzKy8pLmZpbHRlcihCb29sZWFuKTtcbiAgfVxuICBjbGFzc0xpc3QuZm9yRWFjaChjbGFzc05hbWUgPT4ge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkpIHtcbiAgICAgIHRhcmdldC5mb3JFYWNoKGVsZW0gPT4ge1xuICAgICAgICBpZiAoY29uZGl0aW9uKSB7XG4gICAgICAgICAgZWxlbS5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWxlbS5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY29uZGl0aW9uKSB7XG4gICAgICAgIHRhcmdldC5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YXJnZXQuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnQgfCBIVE1MRWxlbWVudFtdIHwgbnVsbH0gdGFyZ2V0XG4gKiBAcGFyYW0ge3N0cmluZyB8IHN0cmluZ1tdIHwgcmVhZG9ubHkgc3RyaW5nW10gfCB1bmRlZmluZWR9IGNsYXNzTGlzdFxuICovXG5jb25zdCBhZGRDbGFzcyA9ICh0YXJnZXQsIGNsYXNzTGlzdCkgPT4ge1xuICB0b2dnbGVDbGFzcyh0YXJnZXQsIGNsYXNzTGlzdCwgdHJ1ZSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnQgfCBIVE1MRWxlbWVudFtdIHwgbnVsbH0gdGFyZ2V0XG4gKiBAcGFyYW0ge3N0cmluZyB8IHN0cmluZ1tdIHwgcmVhZG9ubHkgc3RyaW5nW10gfCB1bmRlZmluZWR9IGNsYXNzTGlzdFxuICovXG5jb25zdCByZW1vdmVDbGFzcyA9ICh0YXJnZXQsIGNsYXNzTGlzdCkgPT4ge1xuICB0b2dnbGVDbGFzcyh0YXJnZXQsIGNsYXNzTGlzdCwgZmFsc2UpO1xufTtcblxuLyoqXG4gKiBHZXQgZGlyZWN0IGNoaWxkIG9mIGFuIGVsZW1lbnQgYnkgY2xhc3MgbmFtZVxuICpcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1cbiAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAqIEByZXR1cm5zIHtIVE1MRWxlbWVudCB8IHVuZGVmaW5lZH1cbiAqL1xuY29uc3QgZ2V0RGlyZWN0Q2hpbGRCeUNsYXNzID0gKGVsZW0sIGNsYXNzTmFtZSkgPT4ge1xuICBjb25zdCBjaGlsZHJlbiA9IEFycmF5LmZyb20oZWxlbS5jaGlsZHJlbik7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmIGhhc0NsYXNzKGNoaWxkLCBjbGFzc05hbWUpKSB7XG4gICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eVxuICogQHBhcmFtIHtzdHJpbmcgfCBudW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkfSB2YWx1ZVxuICovXG5jb25zdCBhcHBseU51bWVyaWNhbFN0eWxlID0gKGVsZW0sIHByb3BlcnR5LCB2YWx1ZSkgPT4ge1xuICBpZiAodmFsdWUgPT09IGAke3BhcnNlSW50KGAke3ZhbHVlfWApfWApIHtcbiAgICB2YWx1ZSA9IHBhcnNlSW50KHZhbHVlKTtcbiAgfVxuICBpZiAodmFsdWUgfHwgcGFyc2VJbnQoYCR7dmFsdWV9YCkgPT09IDApIHtcbiAgICBlbGVtLnN0eWxlLnNldFByb3BlcnR5KHByb3BlcnR5LCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInID8gYCR7dmFsdWV9cHhgIDogdmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIGVsZW0uc3R5bGUucmVtb3ZlUHJvcGVydHkocHJvcGVydHkpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnQgfCBudWxsfSBlbGVtXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGxheVxuICovXG5jb25zdCBzaG93ID0gKGVsZW0sIGRpc3BsYXkgPSAnZmxleCcpID0+IHtcbiAgaWYgKCFlbGVtKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGVsZW0uc3R5bGUuZGlzcGxheSA9IGRpc3BsYXk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnQgfCBudWxsfSBlbGVtXG4gKi9cbmNvbnN0IGhpZGUgPSBlbGVtID0+IHtcbiAgaWYgKCFlbGVtKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGVsZW0uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbn07XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudCB8IG51bGx9IGVsZW1cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwbGF5XG4gKi9cbmNvbnN0IHNob3dXaGVuSW5uZXJIdG1sUHJlc2VudCA9IChlbGVtLCBkaXNwbGF5ID0gJ2Jsb2NrJykgPT4ge1xuICBpZiAoIWVsZW0pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKCkgPT4ge1xuICAgIHRvZ2dsZShlbGVtLCBlbGVtLmlubmVySFRNTCwgZGlzcGxheSk7XG4gIH0pLm9ic2VydmUoZWxlbSwge1xuICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICBzdWJ0cmVlOiB0cnVlXG4gIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJlbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvclxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5XG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqL1xuY29uc3Qgc2V0U3R5bGUgPSAocGFyZW50LCBzZWxlY3RvciwgcHJvcGVydHksIHZhbHVlKSA9PiB7XG4gIC8qKiBAdHlwZSB7SFRNTEVsZW1lbnQgfCBudWxsfSAqL1xuICBjb25zdCBlbCA9IHBhcmVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgaWYgKGVsKSB7XG4gICAgZWwuc3R5bGUuc2V0UHJvcGVydHkocHJvcGVydHksIHZhbHVlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtXG4gKiBAcGFyYW0ge2Jvb2xlYW4gfCBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkfSBjb25kaXRpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwbGF5XG4gKi9cbmNvbnN0IHRvZ2dsZSA9IChlbGVtLCBjb25kaXRpb24sIGRpc3BsYXkgPSAnZmxleCcpID0+IHtcbiAgaWYgKGNvbmRpdGlvbikge1xuICAgIHNob3coZWxlbSwgZGlzcGxheSk7XG4gIH0gZWxzZSB7XG4gICAgaGlkZShlbGVtKTtcbiAgfVxufTtcblxuLyoqXG4gKiBib3Jyb3dlZCBmcm9tIGpxdWVyeSAkKGVsZW0pLmlzKCc6dmlzaWJsZScpIGltcGxlbWVudGF0aW9uXG4gKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudCB8IG51bGx9IGVsZW1cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5jb25zdCBpc1Zpc2libGUkMSA9IGVsZW0gPT4gISEoZWxlbSAmJiAoZWxlbS5vZmZzZXRXaWR0aCB8fCBlbGVtLm9mZnNldEhlaWdodCB8fCBlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoKSk7XG5cbi8qKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmNvbnN0IGFsbEJ1dHRvbnNBcmVIaWRkZW4gPSAoKSA9PiAhaXNWaXNpYmxlJDEoZ2V0Q29uZmlybUJ1dHRvbigpKSAmJiAhaXNWaXNpYmxlJDEoZ2V0RGVueUJ1dHRvbigpKSAmJiAhaXNWaXNpYmxlJDEoZ2V0Q2FuY2VsQnV0dG9uKCkpO1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5jb25zdCBpc1Njcm9sbGFibGUgPSBlbGVtID0+ICEhKGVsZW0uc2Nyb2xsSGVpZ2h0ID4gZWxlbS5jbGllbnRIZWlnaHQpO1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHN0b3BFbGVtZW50XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuY29uc3Qgc2VsZk9yUGFyZW50SXNTY3JvbGxhYmxlID0gKGVsZW1lbnQsIHN0b3BFbGVtZW50KSA9PiB7XG4gIGxldCBwYXJlbnQgPSBlbGVtZW50O1xuICB3aGlsZSAocGFyZW50ICYmIHBhcmVudCAhPT0gc3RvcEVsZW1lbnQpIHtcbiAgICBpZiAoaXNTY3JvbGxhYmxlKHBhcmVudCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50RWxlbWVudDtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIGJvcnJvd2VkIGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzQ2MzUyMTE5XG4gKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmNvbnN0IGhhc0Nzc0FuaW1hdGlvbiA9IGVsZW0gPT4ge1xuICBjb25zdCBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW0pO1xuICBjb25zdCBhbmltRHVyYXRpb24gPSBwYXJzZUZsb2F0KHN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ2FuaW1hdGlvbi1kdXJhdGlvbicpIHx8ICcwJyk7XG4gIGNvbnN0IHRyYW5zRHVyYXRpb24gPSBwYXJzZUZsb2F0KHN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ3RyYW5zaXRpb24tZHVyYXRpb24nKSB8fCAnMCcpO1xuICByZXR1cm4gYW5pbUR1cmF0aW9uID4gMCB8fCB0cmFuc0R1cmF0aW9uID4gMDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHRpbWVyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHJlc2V0XG4gKi9cbmNvbnN0IGFuaW1hdGVUaW1lclByb2dyZXNzQmFyID0gKHRpbWVyLCByZXNldCA9IGZhbHNlKSA9PiB7XG4gIGNvbnN0IHRpbWVyUHJvZ3Jlc3NCYXIgPSBnZXRUaW1lclByb2dyZXNzQmFyKCk7XG4gIGlmICghdGltZXJQcm9ncmVzc0Jhcikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoaXNWaXNpYmxlJDEodGltZXJQcm9ncmVzc0JhcikpIHtcbiAgICBpZiAocmVzZXQpIHtcbiAgICAgIHRpbWVyUHJvZ3Jlc3NCYXIuc3R5bGUudHJhbnNpdGlvbiA9ICdub25lJztcbiAgICAgIHRpbWVyUHJvZ3Jlc3NCYXIuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgfVxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGltZXJQcm9ncmVzc0Jhci5zdHlsZS50cmFuc2l0aW9uID0gYHdpZHRoICR7dGltZXIgLyAxMDAwfXMgbGluZWFyYDtcbiAgICAgIHRpbWVyUHJvZ3Jlc3NCYXIuc3R5bGUud2lkdGggPSAnMCUnO1xuICAgIH0sIDEwKTtcbiAgfVxufTtcbmNvbnN0IHN0b3BUaW1lclByb2dyZXNzQmFyID0gKCkgPT4ge1xuICBjb25zdCB0aW1lclByb2dyZXNzQmFyID0gZ2V0VGltZXJQcm9ncmVzc0JhcigpO1xuICBpZiAoIXRpbWVyUHJvZ3Jlc3NCYXIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgdGltZXJQcm9ncmVzc0JhcldpZHRoID0gcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUodGltZXJQcm9ncmVzc0Jhcikud2lkdGgpO1xuICB0aW1lclByb2dyZXNzQmFyLnN0eWxlLnJlbW92ZVByb3BlcnR5KCd0cmFuc2l0aW9uJyk7XG4gIHRpbWVyUHJvZ3Jlc3NCYXIuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gIGNvbnN0IHRpbWVyUHJvZ3Jlc3NCYXJGdWxsV2lkdGggPSBwYXJzZUludCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aW1lclByb2dyZXNzQmFyKS53aWR0aCk7XG4gIGNvbnN0IHRpbWVyUHJvZ3Jlc3NCYXJQZXJjZW50ID0gdGltZXJQcm9ncmVzc0JhcldpZHRoIC8gdGltZXJQcm9ncmVzc0JhckZ1bGxXaWR0aCAqIDEwMDtcbiAgdGltZXJQcm9ncmVzc0Jhci5zdHlsZS53aWR0aCA9IGAke3RpbWVyUHJvZ3Jlc3NCYXJQZXJjZW50fSVgO1xufTtcblxuLyoqXG4gKiBEZXRlY3QgTm9kZSBlbnZcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuY29uc3QgaXNOb2RlRW52ID0gKCkgPT4gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJztcblxuY29uc3Qgc3dlZXRIVE1MID0gYFxuIDxkaXYgYXJpYS1sYWJlbGxlZGJ5PVwiJHtzd2FsQ2xhc3Nlcy50aXRsZX1cIiBhcmlhLWRlc2NyaWJlZGJ5PVwiJHtzd2FsQ2xhc3Nlc1snaHRtbC1jb250YWluZXInXX1cIiBjbGFzcz1cIiR7c3dhbENsYXNzZXMucG9wdXB9XCIgdGFiaW5kZXg9XCItMVwiPlxuICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCIke3N3YWxDbGFzc2VzLmNsb3NlfVwiPjwvYnV0dG9uPlxuICAgPHVsIGNsYXNzPVwiJHtzd2FsQ2xhc3Nlc1sncHJvZ3Jlc3Mtc3RlcHMnXX1cIj48L3VsPlxuICAgPGRpdiBjbGFzcz1cIiR7c3dhbENsYXNzZXMuaWNvbn1cIj48L2Rpdj5cbiAgIDxpbWcgY2xhc3M9XCIke3N3YWxDbGFzc2VzLmltYWdlfVwiIC8+XG4gICA8aDIgY2xhc3M9XCIke3N3YWxDbGFzc2VzLnRpdGxlfVwiIGlkPVwiJHtzd2FsQ2xhc3Nlcy50aXRsZX1cIj48L2gyPlxuICAgPGRpdiBjbGFzcz1cIiR7c3dhbENsYXNzZXNbJ2h0bWwtY29udGFpbmVyJ119XCIgaWQ9XCIke3N3YWxDbGFzc2VzWydodG1sLWNvbnRhaW5lciddfVwiPjwvZGl2PlxuICAgPGlucHV0IGNsYXNzPVwiJHtzd2FsQ2xhc3Nlcy5pbnB1dH1cIiBpZD1cIiR7c3dhbENsYXNzZXMuaW5wdXR9XCIgLz5cbiAgIDxpbnB1dCB0eXBlPVwiZmlsZVwiIGNsYXNzPVwiJHtzd2FsQ2xhc3Nlcy5maWxlfVwiIC8+XG4gICA8ZGl2IGNsYXNzPVwiJHtzd2FsQ2xhc3Nlcy5yYW5nZX1cIj5cbiAgICAgPGlucHV0IHR5cGU9XCJyYW5nZVwiIC8+XG4gICAgIDxvdXRwdXQ+PC9vdXRwdXQ+XG4gICA8L2Rpdj5cbiAgIDxzZWxlY3QgY2xhc3M9XCIke3N3YWxDbGFzc2VzLnNlbGVjdH1cIiBpZD1cIiR7c3dhbENsYXNzZXMuc2VsZWN0fVwiPjwvc2VsZWN0PlxuICAgPGRpdiBjbGFzcz1cIiR7c3dhbENsYXNzZXMucmFkaW99XCI+PC9kaXY+XG4gICA8bGFiZWwgY2xhc3M9XCIke3N3YWxDbGFzc2VzLmNoZWNrYm94fVwiPlxuICAgICA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgaWQ9XCIke3N3YWxDbGFzc2VzLmNoZWNrYm94fVwiIC8+XG4gICAgIDxzcGFuIGNsYXNzPVwiJHtzd2FsQ2xhc3Nlcy5sYWJlbH1cIj48L3NwYW4+XG4gICA8L2xhYmVsPlxuICAgPHRleHRhcmVhIGNsYXNzPVwiJHtzd2FsQ2xhc3Nlcy50ZXh0YXJlYX1cIiBpZD1cIiR7c3dhbENsYXNzZXMudGV4dGFyZWF9XCI+PC90ZXh0YXJlYT5cbiAgIDxkaXYgY2xhc3M9XCIke3N3YWxDbGFzc2VzWyd2YWxpZGF0aW9uLW1lc3NhZ2UnXX1cIiBpZD1cIiR7c3dhbENsYXNzZXNbJ3ZhbGlkYXRpb24tbWVzc2FnZSddfVwiPjwvZGl2PlxuICAgPGRpdiBjbGFzcz1cIiR7c3dhbENsYXNzZXMuYWN0aW9uc31cIj5cbiAgICAgPGRpdiBjbGFzcz1cIiR7c3dhbENsYXNzZXMubG9hZGVyfVwiPjwvZGl2PlxuICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cIiR7c3dhbENsYXNzZXMuY29uZmlybX1cIj48L2J1dHRvbj5cbiAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCIke3N3YWxDbGFzc2VzLmRlbnl9XCI+PC9idXR0b24+XG4gICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiJHtzd2FsQ2xhc3Nlcy5jYW5jZWx9XCI+PC9idXR0b24+XG4gICA8L2Rpdj5cbiAgIDxkaXYgY2xhc3M9XCIke3N3YWxDbGFzc2VzLmZvb3Rlcn1cIj48L2Rpdj5cbiAgIDxkaXYgY2xhc3M9XCIke3N3YWxDbGFzc2VzWyd0aW1lci1wcm9ncmVzcy1iYXItY29udGFpbmVyJ119XCI+XG4gICAgIDxkaXYgY2xhc3M9XCIke3N3YWxDbGFzc2VzWyd0aW1lci1wcm9ncmVzcy1iYXInXX1cIj48L2Rpdj5cbiAgIDwvZGl2PlxuIDwvZGl2PlxuYC5yZXBsYWNlKC8oXnxcXG4pXFxzKi9nLCAnJyk7XG5cbi8qKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmNvbnN0IHJlc2V0T2xkQ29udGFpbmVyID0gKCkgPT4ge1xuICBjb25zdCBvbGRDb250YWluZXIgPSBnZXRDb250YWluZXIoKTtcbiAgaWYgKCFvbGRDb250YWluZXIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgb2xkQ29udGFpbmVyLnJlbW92ZSgpO1xuICByZW1vdmVDbGFzcyhbZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBkb2N1bWVudC5ib2R5XSwgW3N3YWxDbGFzc2VzWyduby1iYWNrZHJvcCddLCBzd2FsQ2xhc3Nlc1sndG9hc3Qtc2hvd24nXSwgc3dhbENsYXNzZXNbJ2hhcy1jb2x1bW4nXV0pO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5jb25zdCByZXNldFZhbGlkYXRpb25NZXNzYWdlJDEgPSAoKSA9PiB7XG4gIGdsb2JhbFN0YXRlLmN1cnJlbnRJbnN0YW5jZS5yZXNldFZhbGlkYXRpb25NZXNzYWdlKCk7XG59O1xuY29uc3QgYWRkSW5wdXRDaGFuZ2VMaXN0ZW5lcnMgPSAoKSA9PiB7XG4gIGNvbnN0IHBvcHVwID0gZ2V0UG9wdXAoKTtcbiAgY29uc3QgaW5wdXQgPSBnZXREaXJlY3RDaGlsZEJ5Q2xhc3MocG9wdXAsIHN3YWxDbGFzc2VzLmlucHV0KTtcbiAgY29uc3QgZmlsZSA9IGdldERpcmVjdENoaWxkQnlDbGFzcyhwb3B1cCwgc3dhbENsYXNzZXMuZmlsZSk7XG4gIC8qKiBAdHlwZSB7SFRNTElucHV0RWxlbWVudH0gKi9cbiAgY29uc3QgcmFuZ2UgPSBwb3B1cC5xdWVyeVNlbGVjdG9yKGAuJHtzd2FsQ2xhc3Nlcy5yYW5nZX0gaW5wdXRgKTtcbiAgLyoqIEB0eXBlIHtIVE1MT3V0cHV0RWxlbWVudH0gKi9cbiAgY29uc3QgcmFuZ2VPdXRwdXQgPSBwb3B1cC5xdWVyeVNlbGVjdG9yKGAuJHtzd2FsQ2xhc3Nlcy5yYW5nZX0gb3V0cHV0YCk7XG4gIGNvbnN0IHNlbGVjdCA9IGdldERpcmVjdENoaWxkQnlDbGFzcyhwb3B1cCwgc3dhbENsYXNzZXMuc2VsZWN0KTtcbiAgLyoqIEB0eXBlIHtIVE1MSW5wdXRFbGVtZW50fSAqL1xuICBjb25zdCBjaGVja2JveCA9IHBvcHVwLnF1ZXJ5U2VsZWN0b3IoYC4ke3N3YWxDbGFzc2VzLmNoZWNrYm94fSBpbnB1dGApO1xuICBjb25zdCB0ZXh0YXJlYSA9IGdldERpcmVjdENoaWxkQnlDbGFzcyhwb3B1cCwgc3dhbENsYXNzZXMudGV4dGFyZWEpO1xuICBpbnB1dC5vbmlucHV0ID0gcmVzZXRWYWxpZGF0aW9uTWVzc2FnZSQxO1xuICBmaWxlLm9uY2hhbmdlID0gcmVzZXRWYWxpZGF0aW9uTWVzc2FnZSQxO1xuICBzZWxlY3Qub25jaGFuZ2UgPSByZXNldFZhbGlkYXRpb25NZXNzYWdlJDE7XG4gIGNoZWNrYm94Lm9uY2hhbmdlID0gcmVzZXRWYWxpZGF0aW9uTWVzc2FnZSQxO1xuICB0ZXh0YXJlYS5vbmlucHV0ID0gcmVzZXRWYWxpZGF0aW9uTWVzc2FnZSQxO1xuICByYW5nZS5vbmlucHV0ID0gKCkgPT4ge1xuICAgIHJlc2V0VmFsaWRhdGlvbk1lc3NhZ2UkMSgpO1xuICAgIHJhbmdlT3V0cHV0LnZhbHVlID0gcmFuZ2UudmFsdWU7XG4gIH07XG4gIHJhbmdlLm9uY2hhbmdlID0gKCkgPT4ge1xuICAgIHJlc2V0VmFsaWRhdGlvbk1lc3NhZ2UkMSgpO1xuICAgIHJhbmdlT3V0cHV0LnZhbHVlID0gcmFuZ2UudmFsdWU7XG4gIH07XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nIHwgSFRNTEVsZW1lbnR9IHRhcmdldFxuICogQHJldHVybnMge0hUTUxFbGVtZW50fVxuICovXG5jb25zdCBnZXRUYXJnZXQgPSB0YXJnZXQgPT4gdHlwZW9mIHRhcmdldCA9PT0gJ3N0cmluZycgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCkgOiB0YXJnZXQ7XG5cbi8qKlxuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gKi9cbmNvbnN0IHNldHVwQWNjZXNzaWJpbGl0eSA9IHBhcmFtcyA9PiB7XG4gIGNvbnN0IHBvcHVwID0gZ2V0UG9wdXAoKTtcbiAgcG9wdXAuc2V0QXR0cmlidXRlKCdyb2xlJywgcGFyYW1zLnRvYXN0ID8gJ2FsZXJ0JyA6ICdkaWFsb2cnKTtcbiAgcG9wdXAuc2V0QXR0cmlidXRlKCdhcmlhLWxpdmUnLCBwYXJhbXMudG9hc3QgPyAncG9saXRlJyA6ICdhc3NlcnRpdmUnKTtcbiAgaWYgKCFwYXJhbXMudG9hc3QpIHtcbiAgICBwb3B1cC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbW9kYWwnLCAndHJ1ZScpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhcmdldEVsZW1lbnRcbiAqL1xuY29uc3Qgc2V0dXBSVEwgPSB0YXJnZXRFbGVtZW50ID0+IHtcbiAgaWYgKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRhcmdldEVsZW1lbnQpLmRpcmVjdGlvbiA9PT0gJ3J0bCcpIHtcbiAgICBhZGRDbGFzcyhnZXRDb250YWluZXIoKSwgc3dhbENsYXNzZXMucnRsKTtcbiAgICBnbG9iYWxTdGF0ZS5pc1JUTCA9IHRydWU7XG4gIH1cbn07XG5cbi8qKlxuICogQWRkIG1vZGFsICsgYmFja2Ryb3AgdG8gRE9NXG4gKlxuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gKi9cbmNvbnN0IGluaXQgPSBwYXJhbXMgPT4ge1xuICAvLyBDbGVhbiB1cCB0aGUgb2xkIHBvcHVwIGNvbnRhaW5lciBpZiBpdCBleGlzdHNcbiAgY29uc3Qgb2xkQ29udGFpbmVyRXhpc3RlZCA9IHJlc2V0T2xkQ29udGFpbmVyKCk7XG4gIGlmIChpc05vZGVFbnYoKSkge1xuICAgIGVycm9yKCdTd2VldEFsZXJ0MiByZXF1aXJlcyBkb2N1bWVudCB0byBpbml0aWFsaXplJyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBjb250YWluZXIuY2xhc3NOYW1lID0gc3dhbENsYXNzZXMuY29udGFpbmVyO1xuICBpZiAob2xkQ29udGFpbmVyRXhpc3RlZCkge1xuICAgIGFkZENsYXNzKGNvbnRhaW5lciwgc3dhbENsYXNzZXNbJ25vLXRyYW5zaXRpb24nXSk7XG4gIH1cbiAgc2V0SW5uZXJIdG1sKGNvbnRhaW5lciwgc3dlZXRIVE1MKTtcbiAgY29udGFpbmVyLmRhdGFzZXRbJ3N3YWwyVGhlbWUnXSA9IHBhcmFtcy50aGVtZTtcbiAgY29uc3QgdGFyZ2V0RWxlbWVudCA9IGdldFRhcmdldChwYXJhbXMudGFyZ2V0KTtcbiAgdGFyZ2V0RWxlbWVudC5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuICBpZiAocGFyYW1zLnRvcExheWVyKSB7XG4gICAgY29udGFpbmVyLnNldEF0dHJpYnV0ZSgncG9wb3ZlcicsICcnKTtcbiAgICBjb250YWluZXIuc2hvd1BvcG92ZXIoKTtcbiAgfVxuICBzZXR1cEFjY2Vzc2liaWxpdHkocGFyYW1zKTtcbiAgc2V0dXBSVEwodGFyZ2V0RWxlbWVudCk7XG4gIGFkZElucHV0Q2hhbmdlTGlzdGVuZXJzKCk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnQgfCBvYmplY3QgfCBzdHJpbmd9IHBhcmFtXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXRcbiAqL1xuY29uc3QgcGFyc2VIdG1sVG9Db250YWluZXIgPSAocGFyYW0sIHRhcmdldCkgPT4ge1xuICAvLyBET00gZWxlbWVudFxuICBpZiAocGFyYW0gaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgIHRhcmdldC5hcHBlbmRDaGlsZChwYXJhbSk7XG4gIH1cblxuICAvLyBPYmplY3RcbiAgZWxzZSBpZiAodHlwZW9mIHBhcmFtID09PSAnb2JqZWN0Jykge1xuICAgIGhhbmRsZU9iamVjdChwYXJhbSwgdGFyZ2V0KTtcbiAgfVxuXG4gIC8vIFBsYWluIHN0cmluZ1xuICBlbHNlIGlmIChwYXJhbSkge1xuICAgIHNldElubmVySHRtbCh0YXJnZXQsIHBhcmFtKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhcmdldFxuICovXG5jb25zdCBoYW5kbGVPYmplY3QgPSAocGFyYW0sIHRhcmdldCkgPT4ge1xuICAvLyBKUXVlcnkgZWxlbWVudChzKVxuICBpZiAocGFyYW0uanF1ZXJ5KSB7XG4gICAgaGFuZGxlSnF1ZXJ5RWxlbSh0YXJnZXQsIHBhcmFtKTtcbiAgfVxuXG4gIC8vIEZvciBvdGhlciBvYmplY3RzIHVzZSB0aGVpciBzdHJpbmcgcmVwcmVzZW50YXRpb25cbiAgZWxzZSB7XG4gICAgc2V0SW5uZXJIdG1sKHRhcmdldCwgcGFyYW0udG9TdHJpbmcoKSk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFyZ2V0XG4gKiBAcGFyYW0ge29iamVjdH0gZWxlbVxuICovXG5jb25zdCBoYW5kbGVKcXVlcnlFbGVtID0gKHRhcmdldCwgZWxlbSkgPT4ge1xuICB0YXJnZXQudGV4dENvbnRlbnQgPSAnJztcbiAgaWYgKDAgaW4gZWxlbSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIGluIGVsZW07IGkrKykge1xuICAgICAgdGFyZ2V0LmFwcGVuZENoaWxkKGVsZW1baV0uY2xvbmVOb2RlKHRydWUpKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0LmFwcGVuZENoaWxkKGVsZW0uY2xvbmVOb2RlKHRydWUpKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnR9IGluc3RhbmNlXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAqL1xuY29uc3QgcmVuZGVyQWN0aW9ucyA9IChpbnN0YW5jZSwgcGFyYW1zKSA9PiB7XG4gIGNvbnN0IGFjdGlvbnMgPSBnZXRBY3Rpb25zKCk7XG4gIGNvbnN0IGxvYWRlciA9IGdldExvYWRlcigpO1xuICBpZiAoIWFjdGlvbnMgfHwgIWxvYWRlcikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEFjdGlvbnMgKGJ1dHRvbnMpIHdyYXBwZXJcbiAgaWYgKCFwYXJhbXMuc2hvd0NvbmZpcm1CdXR0b24gJiYgIXBhcmFtcy5zaG93RGVueUJ1dHRvbiAmJiAhcGFyYW1zLnNob3dDYW5jZWxCdXR0b24pIHtcbiAgICBoaWRlKGFjdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIHNob3coYWN0aW9ucyk7XG4gIH1cblxuICAvLyBDdXN0b20gY2xhc3NcbiAgYXBwbHlDdXN0b21DbGFzcyhhY3Rpb25zLCBwYXJhbXMsICdhY3Rpb25zJyk7XG5cbiAgLy8gUmVuZGVyIGFsbCB0aGUgYnV0dG9uc1xuICByZW5kZXJCdXR0b25zKGFjdGlvbnMsIGxvYWRlciwgcGFyYW1zKTtcblxuICAvLyBMb2FkZXJcbiAgc2V0SW5uZXJIdG1sKGxvYWRlciwgcGFyYW1zLmxvYWRlckh0bWwgfHwgJycpO1xuICBhcHBseUN1c3RvbUNsYXNzKGxvYWRlciwgcGFyYW1zLCAnbG9hZGVyJyk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGFjdGlvbnNcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGxvYWRlclxuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gKi9cbmZ1bmN0aW9uIHJlbmRlckJ1dHRvbnMoYWN0aW9ucywgbG9hZGVyLCBwYXJhbXMpIHtcbiAgY29uc3QgY29uZmlybUJ1dHRvbiA9IGdldENvbmZpcm1CdXR0b24oKTtcbiAgY29uc3QgZGVueUJ1dHRvbiA9IGdldERlbnlCdXR0b24oKTtcbiAgY29uc3QgY2FuY2VsQnV0dG9uID0gZ2V0Q2FuY2VsQnV0dG9uKCk7XG4gIGlmICghY29uZmlybUJ1dHRvbiB8fCAhZGVueUJ1dHRvbiB8fCAhY2FuY2VsQnV0dG9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gUmVuZGVyIGJ1dHRvbnNcbiAgcmVuZGVyQnV0dG9uKGNvbmZpcm1CdXR0b24sICdjb25maXJtJywgcGFyYW1zKTtcbiAgcmVuZGVyQnV0dG9uKGRlbnlCdXR0b24sICdkZW55JywgcGFyYW1zKTtcbiAgcmVuZGVyQnV0dG9uKGNhbmNlbEJ1dHRvbiwgJ2NhbmNlbCcsIHBhcmFtcyk7XG4gIGhhbmRsZUJ1dHRvbnNTdHlsaW5nKGNvbmZpcm1CdXR0b24sIGRlbnlCdXR0b24sIGNhbmNlbEJ1dHRvbiwgcGFyYW1zKTtcbiAgaWYgKHBhcmFtcy5yZXZlcnNlQnV0dG9ucykge1xuICAgIGlmIChwYXJhbXMudG9hc3QpIHtcbiAgICAgIGFjdGlvbnMuaW5zZXJ0QmVmb3JlKGNhbmNlbEJ1dHRvbiwgY29uZmlybUJ1dHRvbik7XG4gICAgICBhY3Rpb25zLmluc2VydEJlZm9yZShkZW55QnV0dG9uLCBjb25maXJtQnV0dG9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWN0aW9ucy5pbnNlcnRCZWZvcmUoY2FuY2VsQnV0dG9uLCBsb2FkZXIpO1xuICAgICAgYWN0aW9ucy5pbnNlcnRCZWZvcmUoZGVueUJ1dHRvbiwgbG9hZGVyKTtcbiAgICAgIGFjdGlvbnMuaW5zZXJ0QmVmb3JlKGNvbmZpcm1CdXR0b24sIGxvYWRlcik7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29uZmlybUJ1dHRvblxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZGVueUJ1dHRvblxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY2FuY2VsQnV0dG9uXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAqL1xuZnVuY3Rpb24gaGFuZGxlQnV0dG9uc1N0eWxpbmcoY29uZmlybUJ1dHRvbiwgZGVueUJ1dHRvbiwgY2FuY2VsQnV0dG9uLCBwYXJhbXMpIHtcbiAgaWYgKCFwYXJhbXMuYnV0dG9uc1N0eWxpbmcpIHtcbiAgICByZW1vdmVDbGFzcyhbY29uZmlybUJ1dHRvbiwgZGVueUJ1dHRvbiwgY2FuY2VsQnV0dG9uXSwgc3dhbENsYXNzZXMuc3R5bGVkKTtcbiAgICByZXR1cm47XG4gIH1cbiAgYWRkQ2xhc3MoW2NvbmZpcm1CdXR0b24sIGRlbnlCdXR0b24sIGNhbmNlbEJ1dHRvbl0sIHN3YWxDbGFzc2VzLnN0eWxlZCk7XG5cbiAgLy8gQXBwbHkgY3VzdG9tIGJhY2tncm91bmQgY29sb3JzIHRvIGFjdGlvbiBidXR0b25zXG4gIGlmIChwYXJhbXMuY29uZmlybUJ1dHRvbkNvbG9yKSB7XG4gICAgY29uZmlybUJ1dHRvbi5zdHlsZS5zZXRQcm9wZXJ0eSgnLS1zd2FsMi1jb25maXJtLWJ1dHRvbi1iYWNrZ3JvdW5kLWNvbG9yJywgcGFyYW1zLmNvbmZpcm1CdXR0b25Db2xvcik7XG4gIH1cbiAgaWYgKHBhcmFtcy5kZW55QnV0dG9uQ29sb3IpIHtcbiAgICBkZW55QnV0dG9uLnN0eWxlLnNldFByb3BlcnR5KCctLXN3YWwyLWRlbnktYnV0dG9uLWJhY2tncm91bmQtY29sb3InLCBwYXJhbXMuZGVueUJ1dHRvbkNvbG9yKTtcbiAgfVxuICBpZiAocGFyYW1zLmNhbmNlbEJ1dHRvbkNvbG9yKSB7XG4gICAgY2FuY2VsQnV0dG9uLnN0eWxlLnNldFByb3BlcnR5KCctLXN3YWwyLWNhbmNlbC1idXR0b24tYmFja2dyb3VuZC1jb2xvcicsIHBhcmFtcy5jYW5jZWxCdXR0b25Db2xvcik7XG4gIH1cblxuICAvLyBBcHBseSB0aGUgb3V0bGluZSBjb2xvciB0byBhY3Rpb24gYnV0dG9uc1xuICBhcHBseU91dGxpbmVDb2xvcihjb25maXJtQnV0dG9uKTtcbiAgYXBwbHlPdXRsaW5lQ29sb3IoZGVueUJ1dHRvbik7XG4gIGFwcGx5T3V0bGluZUNvbG9yKGNhbmNlbEJ1dHRvbik7XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gYnV0dG9uXG4gKi9cbmZ1bmN0aW9uIGFwcGx5T3V0bGluZUNvbG9yKGJ1dHRvbikge1xuICBjb25zdCBidXR0b25TdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGJ1dHRvbik7XG4gIGlmIChidXR0b25TdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCctLXN3YWwyLWFjdGlvbi1idXR0b24tZm9jdXMtYm94LXNoYWRvdycpKSB7XG4gICAgLy8gSWYgdGhlIGJ1dHRvbiBhbHJlYWR5IGhhcyBhIGN1c3RvbSBvdXRsaW5lIGNvbG9yLCBubyBuZWVkIHRvIGNoYW5nZSBpdFxuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBvdXRsaW5lQ29sb3IgPSBidXR0b25TdHlsZS5iYWNrZ3JvdW5kQ29sb3IucmVwbGFjZSgvcmdiYT9cXCgoXFxkKyksIChcXGQrKSwgKFxcZCspLiovLCAncmdiYSgkMSwgJDIsICQzLCAwLjUpJyk7XG4gIGJ1dHRvbi5zdHlsZS5zZXRQcm9wZXJ0eSgnLS1zd2FsMi1hY3Rpb24tYnV0dG9uLWZvY3VzLWJveC1zaGFkb3cnLCBidXR0b25TdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCctLXN3YWwyLW91dGxpbmUnKS5yZXBsYWNlKC8gcmdiYVxcKC4qLywgYCAke291dGxpbmVDb2xvcn1gKSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gYnV0dG9uXG4gKiBAcGFyYW0geydjb25maXJtJyB8ICdkZW55JyB8ICdjYW5jZWwnfSBidXR0b25UeXBlXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAqL1xuZnVuY3Rpb24gcmVuZGVyQnV0dG9uKGJ1dHRvbiwgYnV0dG9uVHlwZSwgcGFyYW1zKSB7XG4gIGNvbnN0IGJ1dHRvbk5hbWUgPSAvKiogQHR5cGUgeydDb25maXJtJyB8ICdEZW55JyB8ICdDYW5jZWwnfSAqL2NhcGl0YWxpemVGaXJzdExldHRlcihidXR0b25UeXBlKTtcbiAgdG9nZ2xlKGJ1dHRvbiwgcGFyYW1zW2BzaG93JHtidXR0b25OYW1lfUJ1dHRvbmBdLCAnaW5saW5lLWJsb2NrJyk7XG4gIHNldElubmVySHRtbChidXR0b24sIHBhcmFtc1tgJHtidXR0b25UeXBlfUJ1dHRvblRleHRgXSB8fCAnJyk7IC8vIFNldCBjYXB0aW9uIHRleHRcbiAgYnV0dG9uLnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsIHBhcmFtc1tgJHtidXR0b25UeXBlfUJ1dHRvbkFyaWFMYWJlbGBdIHx8ICcnKTsgLy8gQVJJQSBsYWJlbFxuXG4gIC8vIEFkZCBidXR0b25zIGN1c3RvbSBjbGFzc2VzXG4gIGJ1dHRvbi5jbGFzc05hbWUgPSBzd2FsQ2xhc3Nlc1tidXR0b25UeXBlXTtcbiAgYXBwbHlDdXN0b21DbGFzcyhidXR0b24sIHBhcmFtcywgYCR7YnV0dG9uVHlwZX1CdXR0b25gKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnR9IGluc3RhbmNlXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAqL1xuY29uc3QgcmVuZGVyQ2xvc2VCdXR0b24gPSAoaW5zdGFuY2UsIHBhcmFtcykgPT4ge1xuICBjb25zdCBjbG9zZUJ1dHRvbiA9IGdldENsb3NlQnV0dG9uKCk7XG4gIGlmICghY2xvc2VCdXR0b24pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgc2V0SW5uZXJIdG1sKGNsb3NlQnV0dG9uLCBwYXJhbXMuY2xvc2VCdXR0b25IdG1sIHx8ICcnKTtcblxuICAvLyBDdXN0b20gY2xhc3NcbiAgYXBwbHlDdXN0b21DbGFzcyhjbG9zZUJ1dHRvbiwgcGFyYW1zLCAnY2xvc2VCdXR0b24nKTtcbiAgdG9nZ2xlKGNsb3NlQnV0dG9uLCBwYXJhbXMuc2hvd0Nsb3NlQnV0dG9uKTtcbiAgY2xvc2VCdXR0b24uc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgcGFyYW1zLmNsb3NlQnV0dG9uQXJpYUxhYmVsIHx8ICcnKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTd2VldEFsZXJ0fSBpbnN0YW5jZVxuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gKi9cbmNvbnN0IHJlbmRlckNvbnRhaW5lciA9IChpbnN0YW5jZSwgcGFyYW1zKSA9PiB7XG4gIGNvbnN0IGNvbnRhaW5lciA9IGdldENvbnRhaW5lcigpO1xuICBpZiAoIWNvbnRhaW5lcikge1xuICAgIHJldHVybjtcbiAgfVxuICBoYW5kbGVCYWNrZHJvcFBhcmFtKGNvbnRhaW5lciwgcGFyYW1zLmJhY2tkcm9wKTtcbiAgaGFuZGxlUG9zaXRpb25QYXJhbShjb250YWluZXIsIHBhcmFtcy5wb3NpdGlvbik7XG4gIGhhbmRsZUdyb3dQYXJhbShjb250YWluZXIsIHBhcmFtcy5ncm93KTtcblxuICAvLyBDdXN0b20gY2xhc3NcbiAgYXBwbHlDdXN0b21DbGFzcyhjb250YWluZXIsIHBhcmFtcywgJ2NvbnRhaW5lcicpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXJcbiAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnNbJ2JhY2tkcm9wJ119IGJhY2tkcm9wXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZUJhY2tkcm9wUGFyYW0oY29udGFpbmVyLCBiYWNrZHJvcCkge1xuICBpZiAodHlwZW9mIGJhY2tkcm9wID09PSAnc3RyaW5nJykge1xuICAgIGNvbnRhaW5lci5zdHlsZS5iYWNrZ3JvdW5kID0gYmFja2Ryb3A7XG4gIH0gZWxzZSBpZiAoIWJhY2tkcm9wKSB7XG4gICAgYWRkQ2xhc3MoW2RvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgZG9jdW1lbnQuYm9keV0sIHN3YWxDbGFzc2VzWyduby1iYWNrZHJvcCddKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lclxuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc1sncG9zaXRpb24nXX0gcG9zaXRpb25cbiAqL1xuZnVuY3Rpb24gaGFuZGxlUG9zaXRpb25QYXJhbShjb250YWluZXIsIHBvc2l0aW9uKSB7XG4gIGlmICghcG9zaXRpb24pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHBvc2l0aW9uIGluIHN3YWxDbGFzc2VzKSB7XG4gICAgYWRkQ2xhc3MoY29udGFpbmVyLCBzd2FsQ2xhc3Nlc1twb3NpdGlvbl0pO1xuICB9IGVsc2Uge1xuICAgIHdhcm4oJ1RoZSBcInBvc2l0aW9uXCIgcGFyYW1ldGVyIGlzIG5vdCB2YWxpZCwgZGVmYXVsdGluZyB0byBcImNlbnRlclwiJyk7XG4gICAgYWRkQ2xhc3MoY29udGFpbmVyLCBzd2FsQ2xhc3Nlcy5jZW50ZXIpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zWydncm93J119IGdyb3dcbiAqL1xuZnVuY3Rpb24gaGFuZGxlR3Jvd1BhcmFtKGNvbnRhaW5lciwgZ3Jvdykge1xuICBpZiAoIWdyb3cpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYWRkQ2xhc3MoY29udGFpbmVyLCBzd2FsQ2xhc3Nlc1tgZ3Jvdy0ke2dyb3d9YF0pO1xufVxuXG4vKipcbiAqIFRoaXMgbW9kdWxlIGNvbnRhaW5zIGBXZWFrTWFwYHMgZm9yIGVhY2ggZWZmZWN0aXZlbHktXCJwcml2YXRlICBwcm9wZXJ0eVwiIHRoYXQgYSBgU3dhbGAgaGFzLlxuICogRm9yIGV4YW1wbGUsIHRvIHNldCB0aGUgcHJpdmF0ZSBwcm9wZXJ0eSBcImZvb1wiIG9mIGB0aGlzYCB0byBcImJhclwiLCB5b3UgY2FuIGBwcml2YXRlUHJvcHMuZm9vLnNldCh0aGlzLCAnYmFyJylgXG4gKiBUaGlzIGlzIHRoZSBhcHByb2FjaCB0aGF0IEJhYmVsIHdpbGwgcHJvYmFibHkgdGFrZSB0byBpbXBsZW1lbnQgcHJpdmF0ZSBtZXRob2RzL2ZpZWxkc1xuICogICBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1wcml2YXRlLW1ldGhvZHNcbiAqICAgaHR0cHM6Ly9naXRodWIuY29tL2JhYmVsL2JhYmVsL3B1bGwvNzU1NVxuICogT25jZSB3ZSBoYXZlIHRoZSBjaGFuZ2VzIGZyb20gdGhhdCBQUiBpbiBCYWJlbCwgYW5kIG91ciBjb3JlIGNsYXNzIGZpdHMgcmVhc29uYWJsZSBpbiAqb25lIG1vZHVsZSpcbiAqICAgdGhlbiB3ZSBjYW4gdXNlIHRoYXQgbGFuZ3VhZ2UgZmVhdHVyZS5cbiAqL1xuXG52YXIgcHJpdmF0ZVByb3BzID0ge1xuICBpbm5lclBhcmFtczogbmV3IFdlYWtNYXAoKSxcbiAgZG9tQ2FjaGU6IG5ldyBXZWFrTWFwKClcbn07XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi8uLi8uLi8uLi9zd2VldGFsZXJ0Mi5kLnRzXCIvPlxuXG5cbi8qKiBAdHlwZSB7SW5wdXRDbGFzc1tdfSAqL1xuY29uc3QgaW5wdXRDbGFzc2VzID0gWydpbnB1dCcsICdmaWxlJywgJ3JhbmdlJywgJ3NlbGVjdCcsICdyYWRpbycsICdjaGVja2JveCcsICd0ZXh0YXJlYSddO1xuXG4vKipcbiAqIEBwYXJhbSB7U3dlZXRBbGVydH0gaW5zdGFuY2VcbiAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICovXG5jb25zdCByZW5kZXJJbnB1dCA9IChpbnN0YW5jZSwgcGFyYW1zKSA9PiB7XG4gIGNvbnN0IHBvcHVwID0gZ2V0UG9wdXAoKTtcbiAgaWYgKCFwb3B1cCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBpbm5lclBhcmFtcyA9IHByaXZhdGVQcm9wcy5pbm5lclBhcmFtcy5nZXQoaW5zdGFuY2UpO1xuICBjb25zdCByZXJlbmRlciA9ICFpbm5lclBhcmFtcyB8fCBwYXJhbXMuaW5wdXQgIT09IGlubmVyUGFyYW1zLmlucHV0O1xuICBpbnB1dENsYXNzZXMuZm9yRWFjaChpbnB1dENsYXNzID0+IHtcbiAgICBjb25zdCBpbnB1dENvbnRhaW5lciA9IGdldERpcmVjdENoaWxkQnlDbGFzcyhwb3B1cCwgc3dhbENsYXNzZXNbaW5wdXRDbGFzc10pO1xuICAgIGlmICghaW5wdXRDb250YWluZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBzZXQgYXR0cmlidXRlc1xuICAgIHNldEF0dHJpYnV0ZXMoaW5wdXRDbGFzcywgcGFyYW1zLmlucHV0QXR0cmlidXRlcyk7XG5cbiAgICAvLyBzZXQgY2xhc3NcbiAgICBpbnB1dENvbnRhaW5lci5jbGFzc05hbWUgPSBzd2FsQ2xhc3Nlc1tpbnB1dENsYXNzXTtcbiAgICBpZiAocmVyZW5kZXIpIHtcbiAgICAgIGhpZGUoaW5wdXRDb250YWluZXIpO1xuICAgIH1cbiAgfSk7XG4gIGlmIChwYXJhbXMuaW5wdXQpIHtcbiAgICBpZiAocmVyZW5kZXIpIHtcbiAgICAgIHNob3dJbnB1dChwYXJhbXMpO1xuICAgIH1cbiAgICAvLyBzZXQgY3VzdG9tIGNsYXNzXG4gICAgc2V0Q3VzdG9tQ2xhc3MocGFyYW1zKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAqL1xuY29uc3Qgc2hvd0lucHV0ID0gcGFyYW1zID0+IHtcbiAgaWYgKCFwYXJhbXMuaW5wdXQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCFyZW5kZXJJbnB1dFR5cGVbcGFyYW1zLmlucHV0XSkge1xuICAgIGVycm9yKGBVbmV4cGVjdGVkIHR5cGUgb2YgaW5wdXQhIEV4cGVjdGVkICR7T2JqZWN0LmtleXMocmVuZGVySW5wdXRUeXBlKS5qb2luKCcgfCAnKX0sIGdvdCBcIiR7cGFyYW1zLmlucHV0fVwiYCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGlucHV0Q29udGFpbmVyID0gZ2V0SW5wdXRDb250YWluZXIocGFyYW1zLmlucHV0KTtcbiAgaWYgKCFpbnB1dENvbnRhaW5lcikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBpbnB1dCA9IHJlbmRlcklucHV0VHlwZVtwYXJhbXMuaW5wdXRdKGlucHV0Q29udGFpbmVyLCBwYXJhbXMpO1xuICBzaG93KGlucHV0Q29udGFpbmVyKTtcblxuICAvLyBpbnB1dCBhdXRvZm9jdXNcbiAgaWYgKHBhcmFtcy5pbnB1dEF1dG9Gb2N1cykge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgZm9jdXNJbnB1dChpbnB1dCk7XG4gICAgfSk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MSW5wdXRFbGVtZW50fSBpbnB1dFxuICovXG5jb25zdCByZW1vdmVBdHRyaWJ1dGVzID0gaW5wdXQgPT4ge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0LmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBhdHRyTmFtZSA9IGlucHV0LmF0dHJpYnV0ZXNbaV0ubmFtZTtcbiAgICBpZiAoIVsnaWQnLCAndHlwZScsICd2YWx1ZScsICdzdHlsZSddLmluY2x1ZGVzKGF0dHJOYW1lKSkge1xuICAgICAgaW5wdXQucmVtb3ZlQXR0cmlidXRlKGF0dHJOYW1lKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtJbnB1dENsYXNzfSBpbnB1dENsYXNzXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zWydpbnB1dEF0dHJpYnV0ZXMnXX0gaW5wdXRBdHRyaWJ1dGVzXG4gKi9cbmNvbnN0IHNldEF0dHJpYnV0ZXMgPSAoaW5wdXRDbGFzcywgaW5wdXRBdHRyaWJ1dGVzKSA9PiB7XG4gIGNvbnN0IHBvcHVwID0gZ2V0UG9wdXAoKTtcbiAgaWYgKCFwb3B1cCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBpbnB1dCA9IGdldElucHV0JDEocG9wdXAsIGlucHV0Q2xhc3MpO1xuICBpZiAoIWlucHV0KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJlbW92ZUF0dHJpYnV0ZXMoaW5wdXQpO1xuICBmb3IgKGNvbnN0IGF0dHIgaW4gaW5wdXRBdHRyaWJ1dGVzKSB7XG4gICAgaW5wdXQuc2V0QXR0cmlidXRlKGF0dHIsIGlucHV0QXR0cmlidXRlc1thdHRyXSk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gKi9cbmNvbnN0IHNldEN1c3RvbUNsYXNzID0gcGFyYW1zID0+IHtcbiAgaWYgKCFwYXJhbXMuaW5wdXQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgaW5wdXRDb250YWluZXIgPSBnZXRJbnB1dENvbnRhaW5lcihwYXJhbXMuaW5wdXQpO1xuICBpZiAoaW5wdXRDb250YWluZXIpIHtcbiAgICBhcHBseUN1c3RvbUNsYXNzKGlucHV0Q29udGFpbmVyLCBwYXJhbXMsICdpbnB1dCcpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTElucHV0RWxlbWVudCB8IEhUTUxUZXh0QXJlYUVsZW1lbnR9IGlucHV0XG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAqL1xuY29uc3Qgc2V0SW5wdXRQbGFjZWhvbGRlciA9IChpbnB1dCwgcGFyYW1zKSA9PiB7XG4gIGlmICghaW5wdXQucGxhY2Vob2xkZXIgJiYgcGFyYW1zLmlucHV0UGxhY2Vob2xkZXIpIHtcbiAgICBpbnB1dC5wbGFjZWhvbGRlciA9IHBhcmFtcy5pbnB1dFBsYWNlaG9sZGVyO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7SW5wdXR9IGlucHV0XG4gKiBAcGFyYW0ge0lucHV0fSBwcmVwZW5kVG9cbiAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICovXG5jb25zdCBzZXRJbnB1dExhYmVsID0gKGlucHV0LCBwcmVwZW5kVG8sIHBhcmFtcykgPT4ge1xuICBpZiAocGFyYW1zLmlucHV0TGFiZWwpIHtcbiAgICBjb25zdCBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgY29uc3QgbGFiZWxDbGFzcyA9IHN3YWxDbGFzc2VzWydpbnB1dC1sYWJlbCddO1xuICAgIGxhYmVsLnNldEF0dHJpYnV0ZSgnZm9yJywgaW5wdXQuaWQpO1xuICAgIGxhYmVsLmNsYXNzTmFtZSA9IGxhYmVsQ2xhc3M7XG4gICAgaWYgKHR5cGVvZiBwYXJhbXMuY3VzdG9tQ2xhc3MgPT09ICdvYmplY3QnKSB7XG4gICAgICBhZGRDbGFzcyhsYWJlbCwgcGFyYW1zLmN1c3RvbUNsYXNzLmlucHV0TGFiZWwpO1xuICAgIH1cbiAgICBsYWJlbC5pbm5lclRleHQgPSBwYXJhbXMuaW5wdXRMYWJlbDtcbiAgICBwcmVwZW5kVG8uaW5zZXJ0QWRqYWNlbnRFbGVtZW50KCdiZWZvcmViZWdpbicsIGxhYmVsKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRJbnB1dH0gaW5wdXRUeXBlXG4gKiBAcmV0dXJucyB7SFRNTEVsZW1lbnQgfCB1bmRlZmluZWR9XG4gKi9cbmNvbnN0IGdldElucHV0Q29udGFpbmVyID0gaW5wdXRUeXBlID0+IHtcbiAgY29uc3QgcG9wdXAgPSBnZXRQb3B1cCgpO1xuICBpZiAoIXBvcHVwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJldHVybiBnZXREaXJlY3RDaGlsZEJ5Q2xhc3MocG9wdXAsIHN3YWxDbGFzc2VzWygvKiogQHR5cGUge1N3YWxDbGFzc30gKi9pbnB1dFR5cGUpXSB8fCBzd2FsQ2xhc3Nlcy5pbnB1dCk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTElucHV0RWxlbWVudCB8IEhUTUxPdXRwdXRFbGVtZW50IHwgSFRNTFRleHRBcmVhRWxlbWVudH0gaW5wdXRcbiAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnNbJ2lucHV0VmFsdWUnXX0gaW5wdXRWYWx1ZVxuICovXG5jb25zdCBjaGVja0FuZFNldElucHV0VmFsdWUgPSAoaW5wdXQsIGlucHV0VmFsdWUpID0+IHtcbiAgaWYgKFsnc3RyaW5nJywgJ251bWJlciddLmluY2x1ZGVzKHR5cGVvZiBpbnB1dFZhbHVlKSkge1xuICAgIGlucHV0LnZhbHVlID0gYCR7aW5wdXRWYWx1ZX1gO1xuICB9IGVsc2UgaWYgKCFpc1Byb21pc2UoaW5wdXRWYWx1ZSkpIHtcbiAgICB3YXJuKGBVbmV4cGVjdGVkIHR5cGUgb2YgaW5wdXRWYWx1ZSEgRXhwZWN0ZWQgXCJzdHJpbmdcIiwgXCJudW1iZXJcIiBvciBcIlByb21pc2VcIiwgZ290IFwiJHt0eXBlb2YgaW5wdXRWYWx1ZX1cImApO1xuICB9XG59O1xuXG4vKiogQHR5cGUge1JlY29yZDxTd2VldEFsZXJ0SW5wdXQsIChpbnB1dDogSW5wdXQgfCBIVE1MRWxlbWVudCwgcGFyYW1zOiBTd2VldEFsZXJ0T3B0aW9ucykgPT4gSW5wdXQ+fSAqL1xuY29uc3QgcmVuZGVySW5wdXRUeXBlID0ge307XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MSW5wdXRFbGVtZW50fSBpbnB1dFxuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gKiBAcmV0dXJucyB7SFRNTElucHV0RWxlbWVudH1cbiAqL1xucmVuZGVySW5wdXRUeXBlLnRleHQgPSByZW5kZXJJbnB1dFR5cGUuZW1haWwgPSByZW5kZXJJbnB1dFR5cGUucGFzc3dvcmQgPSByZW5kZXJJbnB1dFR5cGUubnVtYmVyID0gcmVuZGVySW5wdXRUeXBlLnRlbCA9IHJlbmRlcklucHV0VHlwZS51cmwgPSByZW5kZXJJbnB1dFR5cGUuc2VhcmNoID0gcmVuZGVySW5wdXRUeXBlLmRhdGUgPSByZW5kZXJJbnB1dFR5cGVbJ2RhdGV0aW1lLWxvY2FsJ10gPSByZW5kZXJJbnB1dFR5cGUudGltZSA9IHJlbmRlcklucHV0VHlwZS53ZWVrID0gcmVuZGVySW5wdXRUeXBlLm1vbnRoID0gLyoqIEB0eXBlIHsoaW5wdXQ6IElucHV0IHwgSFRNTEVsZW1lbnQsIHBhcmFtczogU3dlZXRBbGVydE9wdGlvbnMpID0+IElucHV0fSAqL1xuKGlucHV0LCBwYXJhbXMpID0+IHtcbiAgY2hlY2tBbmRTZXRJbnB1dFZhbHVlKGlucHV0LCBwYXJhbXMuaW5wdXRWYWx1ZSk7XG4gIHNldElucHV0TGFiZWwoaW5wdXQsIGlucHV0LCBwYXJhbXMpO1xuICBzZXRJbnB1dFBsYWNlaG9sZGVyKGlucHV0LCBwYXJhbXMpO1xuICBpbnB1dC50eXBlID0gcGFyYW1zLmlucHV0O1xuICByZXR1cm4gaW5wdXQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTElucHV0RWxlbWVudH0gaW5wdXRcbiAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICogQHJldHVybnMge0hUTUxJbnB1dEVsZW1lbnR9XG4gKi9cbnJlbmRlcklucHV0VHlwZS5maWxlID0gKGlucHV0LCBwYXJhbXMpID0+IHtcbiAgc2V0SW5wdXRMYWJlbChpbnB1dCwgaW5wdXQsIHBhcmFtcyk7XG4gIHNldElucHV0UGxhY2Vob2xkZXIoaW5wdXQsIHBhcmFtcyk7XG4gIHJldHVybiBpbnB1dDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MSW5wdXRFbGVtZW50fSByYW5nZVxuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gKiBAcmV0dXJucyB7SFRNTElucHV0RWxlbWVudH1cbiAqL1xucmVuZGVySW5wdXRUeXBlLnJhbmdlID0gKHJhbmdlLCBwYXJhbXMpID0+IHtcbiAgY29uc3QgcmFuZ2VJbnB1dCA9IHJhbmdlLnF1ZXJ5U2VsZWN0b3IoJ2lucHV0Jyk7XG4gIGNvbnN0IHJhbmdlT3V0cHV0ID0gcmFuZ2UucXVlcnlTZWxlY3Rvcignb3V0cHV0Jyk7XG4gIGNoZWNrQW5kU2V0SW5wdXRWYWx1ZShyYW5nZUlucHV0LCBwYXJhbXMuaW5wdXRWYWx1ZSk7XG4gIHJhbmdlSW5wdXQudHlwZSA9IHBhcmFtcy5pbnB1dDtcbiAgY2hlY2tBbmRTZXRJbnB1dFZhbHVlKHJhbmdlT3V0cHV0LCBwYXJhbXMuaW5wdXRWYWx1ZSk7XG4gIHNldElucHV0TGFiZWwocmFuZ2VJbnB1dCwgcmFuZ2UsIHBhcmFtcyk7XG4gIHJldHVybiByYW5nZTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MU2VsZWN0RWxlbWVudH0gc2VsZWN0XG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAqIEByZXR1cm5zIHtIVE1MU2VsZWN0RWxlbWVudH1cbiAqL1xucmVuZGVySW5wdXRUeXBlLnNlbGVjdCA9IChzZWxlY3QsIHBhcmFtcykgPT4ge1xuICBzZWxlY3QudGV4dENvbnRlbnQgPSAnJztcbiAgaWYgKHBhcmFtcy5pbnB1dFBsYWNlaG9sZGVyKSB7XG4gICAgY29uc3QgcGxhY2Vob2xkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvcHRpb24nKTtcbiAgICBzZXRJbm5lckh0bWwocGxhY2Vob2xkZXIsIHBhcmFtcy5pbnB1dFBsYWNlaG9sZGVyKTtcbiAgICBwbGFjZWhvbGRlci52YWx1ZSA9ICcnO1xuICAgIHBsYWNlaG9sZGVyLmRpc2FibGVkID0gdHJ1ZTtcbiAgICBwbGFjZWhvbGRlci5zZWxlY3RlZCA9IHRydWU7XG4gICAgc2VsZWN0LmFwcGVuZENoaWxkKHBsYWNlaG9sZGVyKTtcbiAgfVxuICBzZXRJbnB1dExhYmVsKHNlbGVjdCwgc2VsZWN0LCBwYXJhbXMpO1xuICByZXR1cm4gc2VsZWN0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxJbnB1dEVsZW1lbnR9IHJhZGlvXG4gKiBAcmV0dXJucyB7SFRNTElucHV0RWxlbWVudH1cbiAqL1xucmVuZGVySW5wdXRUeXBlLnJhZGlvID0gcmFkaW8gPT4ge1xuICByYWRpby50ZXh0Q29udGVudCA9ICcnO1xuICByZXR1cm4gcmFkaW87XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTExhYmVsRWxlbWVudH0gY2hlY2tib3hDb250YWluZXJcbiAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICogQHJldHVybnMge0hUTUxJbnB1dEVsZW1lbnR9XG4gKi9cbnJlbmRlcklucHV0VHlwZS5jaGVja2JveCA9IChjaGVja2JveENvbnRhaW5lciwgcGFyYW1zKSA9PiB7XG4gIGNvbnN0IGNoZWNrYm94ID0gZ2V0SW5wdXQkMShnZXRQb3B1cCgpLCAnY2hlY2tib3gnKTtcbiAgY2hlY2tib3gudmFsdWUgPSAnMSc7XG4gIGNoZWNrYm94LmNoZWNrZWQgPSBCb29sZWFuKHBhcmFtcy5pbnB1dFZhbHVlKTtcbiAgY29uc3QgbGFiZWwgPSBjaGVja2JveENvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCdzcGFuJyk7XG4gIHNldElubmVySHRtbChsYWJlbCwgcGFyYW1zLmlucHV0UGxhY2Vob2xkZXIgfHwgcGFyYW1zLmlucHV0TGFiZWwpO1xuICByZXR1cm4gY2hlY2tib3g7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTFRleHRBcmVhRWxlbWVudH0gdGV4dGFyZWFcbiAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICogQHJldHVybnMge0hUTUxUZXh0QXJlYUVsZW1lbnR9XG4gKi9cbnJlbmRlcklucHV0VHlwZS50ZXh0YXJlYSA9ICh0ZXh0YXJlYSwgcGFyYW1zKSA9PiB7XG4gIGNoZWNrQW5kU2V0SW5wdXRWYWx1ZSh0ZXh0YXJlYSwgcGFyYW1zLmlucHV0VmFsdWUpO1xuICBzZXRJbnB1dFBsYWNlaG9sZGVyKHRleHRhcmVhLCBwYXJhbXMpO1xuICBzZXRJbnB1dExhYmVsKHRleHRhcmVhLCB0ZXh0YXJlYSwgcGFyYW1zKTtcblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIGNvbnN0IGdldE1hcmdpbiA9IGVsID0+IHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKS5tYXJnaW5MZWZ0KSArIHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKS5tYXJnaW5SaWdodCk7XG5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3N3ZWV0YWxlcnQyL3N3ZWV0YWxlcnQyL2lzc3Vlcy8yMjkxXG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zd2VldGFsZXJ0Mi9zd2VldGFsZXJ0Mi9pc3N1ZXMvMTY5OVxuICAgIGlmICgnTXV0YXRpb25PYnNlcnZlcicgaW4gd2luZG93KSB7XG4gICAgICBjb25zdCBpbml0aWFsUG9wdXBXaWR0aCA9IHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGdldFBvcHVwKCkpLndpZHRoKTtcbiAgICAgIGNvbnN0IHRleHRhcmVhUmVzaXplSGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgLy8gY2hlY2sgaWYgdGV4YXJlYSBpcyBzdGlsbCBpbiBkb2N1bWVudCAoaS5lLiBwb3B1cCB3YXNuJ3QgY2xvc2VkIGluIHRoZSBtZWFudGltZSlcbiAgICAgICAgaWYgKCFkb2N1bWVudC5ib2R5LmNvbnRhaW5zKHRleHRhcmVhKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0ZXh0YXJlYVdpZHRoID0gdGV4dGFyZWEub2Zmc2V0V2lkdGggKyBnZXRNYXJnaW4odGV4dGFyZWEpO1xuICAgICAgICBpZiAodGV4dGFyZWFXaWR0aCA+IGluaXRpYWxQb3B1cFdpZHRoKSB7XG4gICAgICAgICAgZ2V0UG9wdXAoKS5zdHlsZS53aWR0aCA9IGAke3RleHRhcmVhV2lkdGh9cHhgO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFwcGx5TnVtZXJpY2FsU3R5bGUoZ2V0UG9wdXAoKSwgJ3dpZHRoJywgcGFyYW1zLndpZHRoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIG5ldyBNdXRhdGlvbk9ic2VydmVyKHRleHRhcmVhUmVzaXplSGFuZGxlcikub2JzZXJ2ZSh0ZXh0YXJlYSwge1xuICAgICAgICBhdHRyaWJ1dGVzOiB0cnVlLFxuICAgICAgICBhdHRyaWJ1dGVGaWx0ZXI6IFsnc3R5bGUnXVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHRleHRhcmVhO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnR9IGluc3RhbmNlXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAqL1xuY29uc3QgcmVuZGVyQ29udGVudCA9IChpbnN0YW5jZSwgcGFyYW1zKSA9PiB7XG4gIGNvbnN0IGh0bWxDb250YWluZXIgPSBnZXRIdG1sQ29udGFpbmVyKCk7XG4gIGlmICghaHRtbENvbnRhaW5lcikge1xuICAgIHJldHVybjtcbiAgfVxuICBzaG93V2hlbklubmVySHRtbFByZXNlbnQoaHRtbENvbnRhaW5lcik7XG4gIGFwcGx5Q3VzdG9tQ2xhc3MoaHRtbENvbnRhaW5lciwgcGFyYW1zLCAnaHRtbENvbnRhaW5lcicpO1xuXG4gIC8vIENvbnRlbnQgYXMgSFRNTFxuICBpZiAocGFyYW1zLmh0bWwpIHtcbiAgICBwYXJzZUh0bWxUb0NvbnRhaW5lcihwYXJhbXMuaHRtbCwgaHRtbENvbnRhaW5lcik7XG4gICAgc2hvdyhodG1sQ29udGFpbmVyLCAnYmxvY2snKTtcbiAgfVxuXG4gIC8vIENvbnRlbnQgYXMgcGxhaW4gdGV4dFxuICBlbHNlIGlmIChwYXJhbXMudGV4dCkge1xuICAgIGh0bWxDb250YWluZXIudGV4dENvbnRlbnQgPSBwYXJhbXMudGV4dDtcbiAgICBzaG93KGh0bWxDb250YWluZXIsICdibG9jaycpO1xuICB9XG5cbiAgLy8gTm8gY29udGVudFxuICBlbHNlIHtcbiAgICBoaWRlKGh0bWxDb250YWluZXIpO1xuICB9XG4gIHJlbmRlcklucHV0KGluc3RhbmNlLCBwYXJhbXMpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnR9IGluc3RhbmNlXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAqL1xuY29uc3QgcmVuZGVyRm9vdGVyID0gKGluc3RhbmNlLCBwYXJhbXMpID0+IHtcbiAgY29uc3QgZm9vdGVyID0gZ2V0Rm9vdGVyKCk7XG4gIGlmICghZm9vdGVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHNob3dXaGVuSW5uZXJIdG1sUHJlc2VudChmb290ZXIpO1xuICB0b2dnbGUoZm9vdGVyLCBCb29sZWFuKHBhcmFtcy5mb290ZXIpLCAnYmxvY2snKTtcbiAgaWYgKHBhcmFtcy5mb290ZXIpIHtcbiAgICBwYXJzZUh0bWxUb0NvbnRhaW5lcihwYXJhbXMuZm9vdGVyLCBmb290ZXIpO1xuICB9XG5cbiAgLy8gQ3VzdG9tIGNsYXNzXG4gIGFwcGx5Q3VzdG9tQ2xhc3MoZm9vdGVyLCBwYXJhbXMsICdmb290ZXInKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTd2VldEFsZXJ0fSBpbnN0YW5jZVxuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gKi9cbmNvbnN0IHJlbmRlckljb24gPSAoaW5zdGFuY2UsIHBhcmFtcykgPT4ge1xuICBjb25zdCBpbm5lclBhcmFtcyA9IHByaXZhdGVQcm9wcy5pbm5lclBhcmFtcy5nZXQoaW5zdGFuY2UpO1xuICBjb25zdCBpY29uID0gZ2V0SWNvbigpO1xuICBpZiAoIWljb24pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBpZiB0aGUgZ2l2ZW4gaWNvbiBhbHJlYWR5IHJlbmRlcmVkLCBhcHBseSB0aGUgc3R5bGluZyB3aXRob3V0IHJlLXJlbmRlcmluZyB0aGUgaWNvblxuICBpZiAoaW5uZXJQYXJhbXMgJiYgcGFyYW1zLmljb24gPT09IGlubmVyUGFyYW1zLmljb24pIHtcbiAgICAvLyBDdXN0b20gb3IgZGVmYXVsdCBjb250ZW50XG4gICAgc2V0Q29udGVudChpY29uLCBwYXJhbXMpO1xuICAgIGFwcGx5U3R5bGVzKGljb24sIHBhcmFtcyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghcGFyYW1zLmljb24gJiYgIXBhcmFtcy5pY29uSHRtbCkge1xuICAgIGhpZGUoaWNvbik7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChwYXJhbXMuaWNvbiAmJiBPYmplY3Qua2V5cyhpY29uVHlwZXMpLmluZGV4T2YocGFyYW1zLmljb24pID09PSAtMSkge1xuICAgIGVycm9yKGBVbmtub3duIGljb24hIEV4cGVjdGVkIFwic3VjY2Vzc1wiLCBcImVycm9yXCIsIFwid2FybmluZ1wiLCBcImluZm9cIiBvciBcInF1ZXN0aW9uXCIsIGdvdCBcIiR7cGFyYW1zLmljb259XCJgKTtcbiAgICBoaWRlKGljb24pO1xuICAgIHJldHVybjtcbiAgfVxuICBzaG93KGljb24pO1xuXG4gIC8vIEN1c3RvbSBvciBkZWZhdWx0IGNvbnRlbnRcbiAgc2V0Q29udGVudChpY29uLCBwYXJhbXMpO1xuICBhcHBseVN0eWxlcyhpY29uLCBwYXJhbXMpO1xuXG4gIC8vIEFuaW1hdGUgaWNvblxuICBhZGRDbGFzcyhpY29uLCBwYXJhbXMuc2hvd0NsYXNzICYmIHBhcmFtcy5zaG93Q2xhc3MuaWNvbik7XG5cbiAgLy8gUmUtYWRqdXN0IHRoZSBzdWNjZXNzIGljb24gb24gc3lzdGVtIHRoZW1lIGNoYW5nZVxuICBjb25zdCBjb2xvclNjaGVtZVF1ZXJ5TGlzdCA9IHdpbmRvdy5tYXRjaE1lZGlhKCcocHJlZmVycy1jb2xvci1zY2hlbWU6IGRhcmspJyk7XG4gIGNvbG9yU2NoZW1lUXVlcnlMaXN0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGFkanVzdFN1Y2Nlc3NJY29uQmFja2dyb3VuZENvbG9yKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gaWNvblxuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gKi9cbmNvbnN0IGFwcGx5U3R5bGVzID0gKGljb24sIHBhcmFtcykgPT4ge1xuICBmb3IgKGNvbnN0IFtpY29uVHlwZSwgaWNvbkNsYXNzTmFtZV0gb2YgT2JqZWN0LmVudHJpZXMoaWNvblR5cGVzKSkge1xuICAgIGlmIChwYXJhbXMuaWNvbiAhPT0gaWNvblR5cGUpIHtcbiAgICAgIHJlbW92ZUNsYXNzKGljb24sIGljb25DbGFzc05hbWUpO1xuICAgIH1cbiAgfVxuICBhZGRDbGFzcyhpY29uLCBwYXJhbXMuaWNvbiAmJiBpY29uVHlwZXNbcGFyYW1zLmljb25dKTtcblxuICAvLyBJY29uIGNvbG9yXG4gIHNldENvbG9yKGljb24sIHBhcmFtcyk7XG5cbiAgLy8gU3VjY2VzcyBpY29uIGJhY2tncm91bmQgY29sb3JcbiAgYWRqdXN0U3VjY2Vzc0ljb25CYWNrZ3JvdW5kQ29sb3IoKTtcblxuICAvLyBDdXN0b20gY2xhc3NcbiAgYXBwbHlDdXN0b21DbGFzcyhpY29uLCBwYXJhbXMsICdpY29uJyk7XG59O1xuXG4vLyBBZGp1c3Qgc3VjY2VzcyBpY29uIGJhY2tncm91bmQgY29sb3IgdG8gbWF0Y2ggdGhlIHBvcHVwIGJhY2tncm91bmQgY29sb3JcbmNvbnN0IGFkanVzdFN1Y2Nlc3NJY29uQmFja2dyb3VuZENvbG9yID0gKCkgPT4ge1xuICBjb25zdCBwb3B1cCA9IGdldFBvcHVwKCk7XG4gIGlmICghcG9wdXApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcG9wdXBCYWNrZ3JvdW5kQ29sb3IgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShwb3B1cCkuZ2V0UHJvcGVydHlWYWx1ZSgnYmFja2dyb3VuZC1jb2xvcicpO1xuICAvKiogQHR5cGUge05vZGVMaXN0T2Y8SFRNTEVsZW1lbnQ+fSAqL1xuICBjb25zdCBzdWNjZXNzSWNvblBhcnRzID0gcG9wdXAucXVlcnlTZWxlY3RvckFsbCgnW2NsYXNzXj1zd2FsMi1zdWNjZXNzLWNpcmN1bGFyLWxpbmVdLCAuc3dhbDItc3VjY2Vzcy1maXgnKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdWNjZXNzSWNvblBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgc3VjY2Vzc0ljb25QYXJ0c1tpXS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBwb3B1cEJhY2tncm91bmRDb2xvcjtcbiAgfVxufTtcblxuLyoqXG4gKlxuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5jb25zdCBzdWNjZXNzSWNvbkh0bWwgPSBwYXJhbXMgPT4gYFxuICAke3BhcmFtcy5hbmltYXRpb24gPyAnPGRpdiBjbGFzcz1cInN3YWwyLXN1Y2Nlc3MtY2lyY3VsYXItbGluZS1sZWZ0XCI+PC9kaXY+JyA6ICcnfVxuICA8c3BhbiBjbGFzcz1cInN3YWwyLXN1Y2Nlc3MtbGluZS10aXBcIj48L3NwYW4+IDxzcGFuIGNsYXNzPVwic3dhbDItc3VjY2Vzcy1saW5lLWxvbmdcIj48L3NwYW4+XG4gIDxkaXYgY2xhc3M9XCJzd2FsMi1zdWNjZXNzLXJpbmdcIj48L2Rpdj5cbiAgJHtwYXJhbXMuYW5pbWF0aW9uID8gJzxkaXYgY2xhc3M9XCJzd2FsMi1zdWNjZXNzLWZpeFwiPjwvZGl2PicgOiAnJ31cbiAgJHtwYXJhbXMuYW5pbWF0aW9uID8gJzxkaXYgY2xhc3M9XCJzd2FsMi1zdWNjZXNzLWNpcmN1bGFyLWxpbmUtcmlnaHRcIj48L2Rpdj4nIDogJyd9XG5gO1xuY29uc3QgZXJyb3JJY29uSHRtbCA9IGBcbiAgPHNwYW4gY2xhc3M9XCJzd2FsMi14LW1hcmtcIj5cbiAgICA8c3BhbiBjbGFzcz1cInN3YWwyLXgtbWFyay1saW5lLWxlZnRcIj48L3NwYW4+XG4gICAgPHNwYW4gY2xhc3M9XCJzd2FsMi14LW1hcmstbGluZS1yaWdodFwiPjwvc3Bhbj5cbiAgPC9zcGFuPlxuYDtcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBpY29uXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAqL1xuY29uc3Qgc2V0Q29udGVudCA9IChpY29uLCBwYXJhbXMpID0+IHtcbiAgaWYgKCFwYXJhbXMuaWNvbiAmJiAhcGFyYW1zLmljb25IdG1sKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBvbGRDb250ZW50ID0gaWNvbi5pbm5lckhUTUw7XG4gIGxldCBuZXdDb250ZW50ID0gJyc7XG4gIGlmIChwYXJhbXMuaWNvbkh0bWwpIHtcbiAgICBuZXdDb250ZW50ID0gaWNvbkNvbnRlbnQocGFyYW1zLmljb25IdG1sKTtcbiAgfSBlbHNlIGlmIChwYXJhbXMuaWNvbiA9PT0gJ3N1Y2Nlc3MnKSB7XG4gICAgbmV3Q29udGVudCA9IHN1Y2Nlc3NJY29uSHRtbChwYXJhbXMpO1xuICAgIG9sZENvbnRlbnQgPSBvbGRDb250ZW50LnJlcGxhY2UoLyBzdHlsZT1cIi4qP1wiL2csICcnKTsgLy8gdW5kbyBhZGp1c3RTdWNjZXNzSWNvbkJhY2tncm91bmRDb2xvcigpXG4gIH0gZWxzZSBpZiAocGFyYW1zLmljb24gPT09ICdlcnJvcicpIHtcbiAgICBuZXdDb250ZW50ID0gZXJyb3JJY29uSHRtbDtcbiAgfSBlbHNlIGlmIChwYXJhbXMuaWNvbikge1xuICAgIGNvbnN0IGRlZmF1bHRJY29uSHRtbCA9IHtcbiAgICAgIHF1ZXN0aW9uOiAnPycsXG4gICAgICB3YXJuaW5nOiAnIScsXG4gICAgICBpbmZvOiAnaSdcbiAgICB9O1xuICAgIG5ld0NvbnRlbnQgPSBpY29uQ29udGVudChkZWZhdWx0SWNvbkh0bWxbcGFyYW1zLmljb25dKTtcbiAgfVxuICBpZiAob2xkQ29udGVudC50cmltKCkgIT09IG5ld0NvbnRlbnQudHJpbSgpKSB7XG4gICAgc2V0SW5uZXJIdG1sKGljb24sIG5ld0NvbnRlbnQpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGljb25cbiAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICovXG5jb25zdCBzZXRDb2xvciA9IChpY29uLCBwYXJhbXMpID0+IHtcbiAgaWYgKCFwYXJhbXMuaWNvbkNvbG9yKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGljb24uc3R5bGUuY29sb3IgPSBwYXJhbXMuaWNvbkNvbG9yO1xuICBpY29uLnN0eWxlLmJvcmRlckNvbG9yID0gcGFyYW1zLmljb25Db2xvcjtcbiAgZm9yIChjb25zdCBzZWwgb2YgWycuc3dhbDItc3VjY2Vzcy1saW5lLXRpcCcsICcuc3dhbDItc3VjY2Vzcy1saW5lLWxvbmcnLCAnLnN3YWwyLXgtbWFyay1saW5lLWxlZnQnLCAnLnN3YWwyLXgtbWFyay1saW5lLXJpZ2h0J10pIHtcbiAgICBzZXRTdHlsZShpY29uLCBzZWwsICdiYWNrZ3JvdW5kLWNvbG9yJywgcGFyYW1zLmljb25Db2xvcik7XG4gIH1cbiAgc2V0U3R5bGUoaWNvbiwgJy5zd2FsMi1zdWNjZXNzLXJpbmcnLCAnYm9yZGVyLWNvbG9yJywgcGFyYW1zLmljb25Db2xvcik7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50XG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5jb25zdCBpY29uQ29udGVudCA9IGNvbnRlbnQgPT4gYDxkaXYgY2xhc3M9XCIke3N3YWxDbGFzc2VzWydpY29uLWNvbnRlbnQnXX1cIj4ke2NvbnRlbnR9PC9kaXY+YDtcblxuLyoqXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnR9IGluc3RhbmNlXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAqL1xuY29uc3QgcmVuZGVySW1hZ2UgPSAoaW5zdGFuY2UsIHBhcmFtcykgPT4ge1xuICBjb25zdCBpbWFnZSA9IGdldEltYWdlKCk7XG4gIGlmICghaW1hZ2UpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCFwYXJhbXMuaW1hZ2VVcmwpIHtcbiAgICBoaWRlKGltYWdlKTtcbiAgICByZXR1cm47XG4gIH1cbiAgc2hvdyhpbWFnZSwgJycpO1xuXG4gIC8vIFNyYywgYWx0XG4gIGltYWdlLnNldEF0dHJpYnV0ZSgnc3JjJywgcGFyYW1zLmltYWdlVXJsKTtcbiAgaW1hZ2Uuc2V0QXR0cmlidXRlKCdhbHQnLCBwYXJhbXMuaW1hZ2VBbHQgfHwgJycpO1xuXG4gIC8vIFdpZHRoLCBoZWlnaHRcbiAgYXBwbHlOdW1lcmljYWxTdHlsZShpbWFnZSwgJ3dpZHRoJywgcGFyYW1zLmltYWdlV2lkdGgpO1xuICBhcHBseU51bWVyaWNhbFN0eWxlKGltYWdlLCAnaGVpZ2h0JywgcGFyYW1zLmltYWdlSGVpZ2h0KTtcblxuICAvLyBDbGFzc1xuICBpbWFnZS5jbGFzc05hbWUgPSBzd2FsQ2xhc3Nlcy5pbWFnZTtcbiAgYXBwbHlDdXN0b21DbGFzcyhpbWFnZSwgcGFyYW1zLCAnaW1hZ2UnKTtcbn07XG5cbmxldCBkcmFnZ2luZyA9IGZhbHNlO1xubGV0IG1vdXNlZG93blggPSAwO1xubGV0IG1vdXNlZG93blkgPSAwO1xubGV0IGluaXRpYWxYID0gMDtcbmxldCBpbml0aWFsWSA9IDA7XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcG9wdXBcbiAqL1xuY29uc3QgYWRkRHJhZ2dhYmxlTGlzdGVuZXJzID0gcG9wdXAgPT4ge1xuICBwb3B1cC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBkb3duKTtcbiAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBtb3ZlKTtcbiAgcG9wdXAuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHVwKTtcbiAgcG9wdXAuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIGRvd24pO1xuICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIG1vdmUpO1xuICBwb3B1cC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHVwKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcG9wdXBcbiAqL1xuY29uc3QgcmVtb3ZlRHJhZ2dhYmxlTGlzdGVuZXJzID0gcG9wdXAgPT4ge1xuICBwb3B1cC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBkb3duKTtcbiAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBtb3ZlKTtcbiAgcG9wdXAucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHVwKTtcbiAgcG9wdXAucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIGRvd24pO1xuICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIG1vdmUpO1xuICBwb3B1cC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHVwKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtNb3VzZUV2ZW50IHwgVG91Y2hFdmVudH0gZXZlbnRcbiAqL1xuY29uc3QgZG93biA9IGV2ZW50ID0+IHtcbiAgY29uc3QgcG9wdXAgPSBnZXRQb3B1cCgpO1xuICBpZiAoZXZlbnQudGFyZ2V0ID09PSBwb3B1cCB8fCBnZXRJY29uKCkuY29udGFpbnMoLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi9ldmVudC50YXJnZXQpKSB7XG4gICAgZHJhZ2dpbmcgPSB0cnVlO1xuICAgIGNvbnN0IGNsaWVudFhZID0gZ2V0Q2xpZW50WFkoZXZlbnQpO1xuICAgIG1vdXNlZG93blggPSBjbGllbnRYWS5jbGllbnRYO1xuICAgIG1vdXNlZG93blkgPSBjbGllbnRYWS5jbGllbnRZO1xuICAgIGluaXRpYWxYID0gcGFyc2VJbnQocG9wdXAuc3R5bGUuaW5zZXRJbmxpbmVTdGFydCkgfHwgMDtcbiAgICBpbml0aWFsWSA9IHBhcnNlSW50KHBvcHVwLnN0eWxlLmluc2V0QmxvY2tTdGFydCkgfHwgMDtcbiAgICBhZGRDbGFzcyhwb3B1cCwgJ3N3YWwyLWRyYWdnaW5nJyk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtNb3VzZUV2ZW50IHwgVG91Y2hFdmVudH0gZXZlbnRcbiAqL1xuY29uc3QgbW92ZSA9IGV2ZW50ID0+IHtcbiAgY29uc3QgcG9wdXAgPSBnZXRQb3B1cCgpO1xuICBpZiAoZHJhZ2dpbmcpIHtcbiAgICBsZXQge1xuICAgICAgY2xpZW50WCxcbiAgICAgIGNsaWVudFlcbiAgICB9ID0gZ2V0Q2xpZW50WFkoZXZlbnQpO1xuICAgIGNvbnN0IGRlbHRhWCA9IGNsaWVudFggLSBtb3VzZWRvd25YO1xuICAgIC8vIEluIFJUTCBtb2RlLCBuZWdhdGUgdGhlIGhvcml6b250YWwgZGVsdGEgc2luY2UgaW5zZXRJbmxpbmVTdGFydCByZWZlcnMgdG8gdGhlIHJpZ2h0IGVkZ2VcbiAgICBwb3B1cC5zdHlsZS5pbnNldElubGluZVN0YXJ0ID0gYCR7aW5pdGlhbFggKyAoZ2xvYmFsU3RhdGUuaXNSVEwgPyAtZGVsdGFYIDogZGVsdGFYKX1weGA7XG4gICAgcG9wdXAuc3R5bGUuaW5zZXRCbG9ja1N0YXJ0ID0gYCR7aW5pdGlhbFkgKyAoY2xpZW50WSAtIG1vdXNlZG93blkpfXB4YDtcbiAgfVxufTtcbmNvbnN0IHVwID0gKCkgPT4ge1xuICBjb25zdCBwb3B1cCA9IGdldFBvcHVwKCk7XG4gIGRyYWdnaW5nID0gZmFsc2U7XG4gIHJlbW92ZUNsYXNzKHBvcHVwLCAnc3dhbDItZHJhZ2dpbmcnKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtNb3VzZUV2ZW50IHwgVG91Y2hFdmVudH0gZXZlbnRcbiAqIEByZXR1cm5zIHt7IGNsaWVudFg6IG51bWJlciwgY2xpZW50WTogbnVtYmVyIH19XG4gKi9cbmNvbnN0IGdldENsaWVudFhZID0gZXZlbnQgPT4ge1xuICBsZXQgY2xpZW50WCA9IDAsXG4gICAgY2xpZW50WSA9IDA7XG4gIGlmIChldmVudC50eXBlLnN0YXJ0c1dpdGgoJ21vdXNlJykpIHtcbiAgICBjbGllbnRYID0gLyoqIEB0eXBlIHtNb3VzZUV2ZW50fSAqL2V2ZW50LmNsaWVudFg7XG4gICAgY2xpZW50WSA9IC8qKiBAdHlwZSB7TW91c2VFdmVudH0gKi9ldmVudC5jbGllbnRZO1xuICB9IGVsc2UgaWYgKGV2ZW50LnR5cGUuc3RhcnRzV2l0aCgndG91Y2gnKSkge1xuICAgIGNsaWVudFggPSAvKiogQHR5cGUge1RvdWNoRXZlbnR9ICovZXZlbnQudG91Y2hlc1swXS5jbGllbnRYO1xuICAgIGNsaWVudFkgPSAvKiogQHR5cGUge1RvdWNoRXZlbnR9ICovZXZlbnQudG91Y2hlc1swXS5jbGllbnRZO1xuICB9XG4gIHJldHVybiB7XG4gICAgY2xpZW50WCxcbiAgICBjbGllbnRZXG4gIH07XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3dlZXRBbGVydH0gaW5zdGFuY2VcbiAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICovXG5jb25zdCByZW5kZXJQb3B1cCA9IChpbnN0YW5jZSwgcGFyYW1zKSA9PiB7XG4gIGNvbnN0IGNvbnRhaW5lciA9IGdldENvbnRhaW5lcigpO1xuICBjb25zdCBwb3B1cCA9IGdldFBvcHVwKCk7XG4gIGlmICghY29udGFpbmVyIHx8ICFwb3B1cCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFdpZHRoXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zd2VldGFsZXJ0Mi9zd2VldGFsZXJ0Mi9pc3N1ZXMvMjE3MFxuICBpZiAocGFyYW1zLnRvYXN0KSB7XG4gICAgYXBwbHlOdW1lcmljYWxTdHlsZShjb250YWluZXIsICd3aWR0aCcsIHBhcmFtcy53aWR0aCk7XG4gICAgcG9wdXAuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgY29uc3QgbG9hZGVyID0gZ2V0TG9hZGVyKCk7XG4gICAgaWYgKGxvYWRlcikge1xuICAgICAgcG9wdXAuaW5zZXJ0QmVmb3JlKGxvYWRlciwgZ2V0SWNvbigpKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYXBwbHlOdW1lcmljYWxTdHlsZShwb3B1cCwgJ3dpZHRoJywgcGFyYW1zLndpZHRoKTtcbiAgfVxuXG4gIC8vIFBhZGRpbmdcbiAgYXBwbHlOdW1lcmljYWxTdHlsZShwb3B1cCwgJ3BhZGRpbmcnLCBwYXJhbXMucGFkZGluZyk7XG5cbiAgLy8gQ29sb3JcbiAgaWYgKHBhcmFtcy5jb2xvcikge1xuICAgIHBvcHVwLnN0eWxlLmNvbG9yID0gcGFyYW1zLmNvbG9yO1xuICB9XG5cbiAgLy8gQmFja2dyb3VuZFxuICBpZiAocGFyYW1zLmJhY2tncm91bmQpIHtcbiAgICBwb3B1cC5zdHlsZS5iYWNrZ3JvdW5kID0gcGFyYW1zLmJhY2tncm91bmQ7XG4gIH1cbiAgaGlkZShnZXRWYWxpZGF0aW9uTWVzc2FnZSgpKTtcblxuICAvLyBDbGFzc2VzXG4gIGFkZENsYXNzZXMkMShwb3B1cCwgcGFyYW1zKTtcbiAgaWYgKHBhcmFtcy5kcmFnZ2FibGUgJiYgIXBhcmFtcy50b2FzdCkge1xuICAgIGFkZENsYXNzKHBvcHVwLCBzd2FsQ2xhc3Nlcy5kcmFnZ2FibGUpO1xuICAgIGFkZERyYWdnYWJsZUxpc3RlbmVycyhwb3B1cCk7XG4gIH0gZWxzZSB7XG4gICAgcmVtb3ZlQ2xhc3MocG9wdXAsIHN3YWxDbGFzc2VzLmRyYWdnYWJsZSk7XG4gICAgcmVtb3ZlRHJhZ2dhYmxlTGlzdGVuZXJzKHBvcHVwKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwb3B1cFxuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gKi9cbmNvbnN0IGFkZENsYXNzZXMkMSA9IChwb3B1cCwgcGFyYW1zKSA9PiB7XG4gIGNvbnN0IHNob3dDbGFzcyA9IHBhcmFtcy5zaG93Q2xhc3MgfHwge307XG4gIC8vIERlZmF1bHQgQ2xhc3MgKyBzaG93Q2xhc3Mgd2hlbiB1cGRhdGluZyBTd2FsLnVwZGF0ZSh7fSlcbiAgcG9wdXAuY2xhc3NOYW1lID0gYCR7c3dhbENsYXNzZXMucG9wdXB9ICR7aXNWaXNpYmxlJDEocG9wdXApID8gc2hvd0NsYXNzLnBvcHVwIDogJyd9YDtcbiAgaWYgKHBhcmFtcy50b2FzdCkge1xuICAgIGFkZENsYXNzKFtkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIGRvY3VtZW50LmJvZHldLCBzd2FsQ2xhc3Nlc1sndG9hc3Qtc2hvd24nXSk7XG4gICAgYWRkQ2xhc3MocG9wdXAsIHN3YWxDbGFzc2VzLnRvYXN0KTtcbiAgfSBlbHNlIHtcbiAgICBhZGRDbGFzcyhwb3B1cCwgc3dhbENsYXNzZXMubW9kYWwpO1xuICB9XG5cbiAgLy8gQ3VzdG9tIGNsYXNzXG4gIGFwcGx5Q3VzdG9tQ2xhc3MocG9wdXAsIHBhcmFtcywgJ3BvcHVwJyk7XG4gIC8vIFRPRE86IHJlbW92ZSBpbiB0aGUgbmV4dCBtYWpvclxuICBpZiAodHlwZW9mIHBhcmFtcy5jdXN0b21DbGFzcyA9PT0gJ3N0cmluZycpIHtcbiAgICBhZGRDbGFzcyhwb3B1cCwgcGFyYW1zLmN1c3RvbUNsYXNzKTtcbiAgfVxuXG4gIC8vIEljb24gY2xhc3MgKCMxODQyKVxuICBpZiAocGFyYW1zLmljb24pIHtcbiAgICBhZGRDbGFzcyhwb3B1cCwgc3dhbENsYXNzZXNbYGljb24tJHtwYXJhbXMuaWNvbn1gXSk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtTd2VldEFsZXJ0fSBpbnN0YW5jZVxuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gKi9cbmNvbnN0IHJlbmRlclByb2dyZXNzU3RlcHMgPSAoaW5zdGFuY2UsIHBhcmFtcykgPT4ge1xuICBjb25zdCBwcm9ncmVzc1N0ZXBzQ29udGFpbmVyID0gZ2V0UHJvZ3Jlc3NTdGVwcygpO1xuICBpZiAoIXByb2dyZXNzU3RlcHNDb250YWluZXIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qge1xuICAgIHByb2dyZXNzU3RlcHMsXG4gICAgY3VycmVudFByb2dyZXNzU3RlcFxuICB9ID0gcGFyYW1zO1xuICBpZiAoIXByb2dyZXNzU3RlcHMgfHwgcHJvZ3Jlc3NTdGVwcy5sZW5ndGggPT09IDAgfHwgY3VycmVudFByb2dyZXNzU3RlcCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaGlkZShwcm9ncmVzc1N0ZXBzQ29udGFpbmVyKTtcbiAgICByZXR1cm47XG4gIH1cbiAgc2hvdyhwcm9ncmVzc1N0ZXBzQ29udGFpbmVyKTtcbiAgcHJvZ3Jlc3NTdGVwc0NvbnRhaW5lci50ZXh0Q29udGVudCA9ICcnO1xuICBpZiAoY3VycmVudFByb2dyZXNzU3RlcCA+PSBwcm9ncmVzc1N0ZXBzLmxlbmd0aCkge1xuICAgIHdhcm4oJ0ludmFsaWQgY3VycmVudFByb2dyZXNzU3RlcCBwYXJhbWV0ZXIsIGl0IHNob3VsZCBiZSBsZXNzIHRoYW4gcHJvZ3Jlc3NTdGVwcy5sZW5ndGggJyArICcoY3VycmVudFByb2dyZXNzU3RlcCBsaWtlIEpTIGFycmF5cyBzdGFydHMgZnJvbSAwKScpO1xuICB9XG4gIHByb2dyZXNzU3RlcHMuZm9yRWFjaCgoc3RlcCwgaW5kZXgpID0+IHtcbiAgICBjb25zdCBzdGVwRWwgPSBjcmVhdGVTdGVwRWxlbWVudChzdGVwKTtcbiAgICBwcm9ncmVzc1N0ZXBzQ29udGFpbmVyLmFwcGVuZENoaWxkKHN0ZXBFbCk7XG4gICAgaWYgKGluZGV4ID09PSBjdXJyZW50UHJvZ3Jlc3NTdGVwKSB7XG4gICAgICBhZGRDbGFzcyhzdGVwRWwsIHN3YWxDbGFzc2VzWydhY3RpdmUtcHJvZ3Jlc3Mtc3RlcCddKTtcbiAgICB9XG4gICAgaWYgKGluZGV4ICE9PSBwcm9ncmVzc1N0ZXBzLmxlbmd0aCAtIDEpIHtcbiAgICAgIGNvbnN0IGxpbmVFbCA9IGNyZWF0ZUxpbmVFbGVtZW50KHBhcmFtcyk7XG4gICAgICBwcm9ncmVzc1N0ZXBzQ29udGFpbmVyLmFwcGVuZENoaWxkKGxpbmVFbCk7XG4gICAgfVxuICB9KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ZXBcbiAqIEByZXR1cm5zIHtIVE1MTElFbGVtZW50fVxuICovXG5jb25zdCBjcmVhdGVTdGVwRWxlbWVudCA9IHN0ZXAgPT4ge1xuICBjb25zdCBzdGVwRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xuICBhZGRDbGFzcyhzdGVwRWwsIHN3YWxDbGFzc2VzWydwcm9ncmVzcy1zdGVwJ10pO1xuICBzZXRJbm5lckh0bWwoc3RlcEVsLCBzdGVwKTtcbiAgcmV0dXJuIHN0ZXBFbDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gKiBAcmV0dXJucyB7SFRNTExJRWxlbWVudH1cbiAqL1xuY29uc3QgY3JlYXRlTGluZUVsZW1lbnQgPSBwYXJhbXMgPT4ge1xuICBjb25zdCBsaW5lRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xuICBhZGRDbGFzcyhsaW5lRWwsIHN3YWxDbGFzc2VzWydwcm9ncmVzcy1zdGVwLWxpbmUnXSk7XG4gIGlmIChwYXJhbXMucHJvZ3Jlc3NTdGVwc0Rpc3RhbmNlKSB7XG4gICAgYXBwbHlOdW1lcmljYWxTdHlsZShsaW5lRWwsICd3aWR0aCcsIHBhcmFtcy5wcm9ncmVzc1N0ZXBzRGlzdGFuY2UpO1xuICB9XG4gIHJldHVybiBsaW5lRWw7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3dlZXRBbGVydH0gaW5zdGFuY2VcbiAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICovXG5jb25zdCByZW5kZXJUaXRsZSA9IChpbnN0YW5jZSwgcGFyYW1zKSA9PiB7XG4gIGNvbnN0IHRpdGxlID0gZ2V0VGl0bGUoKTtcbiAgaWYgKCF0aXRsZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBzaG93V2hlbklubmVySHRtbFByZXNlbnQodGl0bGUpO1xuICB0b2dnbGUodGl0bGUsIEJvb2xlYW4ocGFyYW1zLnRpdGxlIHx8IHBhcmFtcy50aXRsZVRleHQpLCAnYmxvY2snKTtcbiAgaWYgKHBhcmFtcy50aXRsZSkge1xuICAgIHBhcnNlSHRtbFRvQ29udGFpbmVyKHBhcmFtcy50aXRsZSwgdGl0bGUpO1xuICB9XG4gIGlmIChwYXJhbXMudGl0bGVUZXh0KSB7XG4gICAgdGl0bGUuaW5uZXJUZXh0ID0gcGFyYW1zLnRpdGxlVGV4dDtcbiAgfVxuXG4gIC8vIEN1c3RvbSBjbGFzc1xuICBhcHBseUN1c3RvbUNsYXNzKHRpdGxlLCBwYXJhbXMsICd0aXRsZScpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnR9IGluc3RhbmNlXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAqL1xuY29uc3QgcmVuZGVyID0gKGluc3RhbmNlLCBwYXJhbXMpID0+IHtcbiAgcmVuZGVyUG9wdXAoaW5zdGFuY2UsIHBhcmFtcyk7XG4gIHJlbmRlckNvbnRhaW5lcihpbnN0YW5jZSwgcGFyYW1zKTtcbiAgcmVuZGVyUHJvZ3Jlc3NTdGVwcyhpbnN0YW5jZSwgcGFyYW1zKTtcbiAgcmVuZGVySWNvbihpbnN0YW5jZSwgcGFyYW1zKTtcbiAgcmVuZGVySW1hZ2UoaW5zdGFuY2UsIHBhcmFtcyk7XG4gIHJlbmRlclRpdGxlKGluc3RhbmNlLCBwYXJhbXMpO1xuICByZW5kZXJDbG9zZUJ1dHRvbihpbnN0YW5jZSwgcGFyYW1zKTtcbiAgcmVuZGVyQ29udGVudChpbnN0YW5jZSwgcGFyYW1zKTtcbiAgcmVuZGVyQWN0aW9ucyhpbnN0YW5jZSwgcGFyYW1zKTtcbiAgcmVuZGVyRm9vdGVyKGluc3RhbmNlLCBwYXJhbXMpO1xuICBjb25zdCBwb3B1cCA9IGdldFBvcHVwKCk7XG4gIGlmICh0eXBlb2YgcGFyYW1zLmRpZFJlbmRlciA9PT0gJ2Z1bmN0aW9uJyAmJiBwb3B1cCkge1xuICAgIHBhcmFtcy5kaWRSZW5kZXIocG9wdXApO1xuICB9XG4gIGdsb2JhbFN0YXRlLmV2ZW50RW1pdHRlci5lbWl0KCdkaWRSZW5kZXInLCBwb3B1cCk7XG59O1xuXG4vKlxuICogR2xvYmFsIGZ1bmN0aW9uIHRvIGRldGVybWluZSBpZiBTd2VldEFsZXJ0MiBwb3B1cCBpcyBzaG93blxuICovXG5jb25zdCBpc1Zpc2libGUgPSAoKSA9PiB7XG4gIHJldHVybiBpc1Zpc2libGUkMShnZXRQb3B1cCgpKTtcbn07XG5cbi8qXG4gKiBHbG9iYWwgZnVuY3Rpb24gdG8gY2xpY2sgJ0NvbmZpcm0nIGJ1dHRvblxuICovXG5jb25zdCBjbGlja0NvbmZpcm0gPSAoKSA9PiB7XG4gIHZhciBfZG9tJGdldENvbmZpcm1CdXR0b247XG4gIHJldHVybiAoX2RvbSRnZXRDb25maXJtQnV0dG9uID0gZ2V0Q29uZmlybUJ1dHRvbigpKSA9PT0gbnVsbCB8fCBfZG9tJGdldENvbmZpcm1CdXR0b24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kb20kZ2V0Q29uZmlybUJ1dHRvbi5jbGljaygpO1xufTtcblxuLypcbiAqIEdsb2JhbCBmdW5jdGlvbiB0byBjbGljayAnRGVueScgYnV0dG9uXG4gKi9cbmNvbnN0IGNsaWNrRGVueSA9ICgpID0+IHtcbiAgdmFyIF9kb20kZ2V0RGVueUJ1dHRvbjtcbiAgcmV0dXJuIChfZG9tJGdldERlbnlCdXR0b24gPSBnZXREZW55QnV0dG9uKCkpID09PSBudWxsIHx8IF9kb20kZ2V0RGVueUJ1dHRvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2RvbSRnZXREZW55QnV0dG9uLmNsaWNrKCk7XG59O1xuXG4vKlxuICogR2xvYmFsIGZ1bmN0aW9uIHRvIGNsaWNrICdDYW5jZWwnIGJ1dHRvblxuICovXG5jb25zdCBjbGlja0NhbmNlbCA9ICgpID0+IHtcbiAgdmFyIF9kb20kZ2V0Q2FuY2VsQnV0dG9uO1xuICByZXR1cm4gKF9kb20kZ2V0Q2FuY2VsQnV0dG9uID0gZ2V0Q2FuY2VsQnV0dG9uKCkpID09PSBudWxsIHx8IF9kb20kZ2V0Q2FuY2VsQnV0dG9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZG9tJGdldENhbmNlbEJ1dHRvbi5jbGljaygpO1xufTtcblxuLyoqIEB0eXBlIHtSZWNvcmQ8RGlzbWlzc1JlYXNvbiwgRGlzbWlzc1JlYXNvbj59ICovXG5jb25zdCBEaXNtaXNzUmVhc29uID0gT2JqZWN0LmZyZWV6ZSh7XG4gIGNhbmNlbDogJ2NhbmNlbCcsXG4gIGJhY2tkcm9wOiAnYmFja2Ryb3AnLFxuICBjbG9zZTogJ2Nsb3NlJyxcbiAgZXNjOiAnZXNjJyxcbiAgdGltZXI6ICd0aW1lcidcbn0pO1xuXG4vKipcbiAqIEBwYXJhbSB7R2xvYmFsU3RhdGV9IGdsb2JhbFN0YXRlXG4gKi9cbmNvbnN0IHJlbW92ZUtleWRvd25IYW5kbGVyID0gZ2xvYmFsU3RhdGUgPT4ge1xuICBpZiAoZ2xvYmFsU3RhdGUua2V5ZG93blRhcmdldCAmJiBnbG9iYWxTdGF0ZS5rZXlkb3duSGFuZGxlckFkZGVkKSB7XG4gICAgZ2xvYmFsU3RhdGUua2V5ZG93blRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZ2xvYmFsU3RhdGUua2V5ZG93bkhhbmRsZXIsIHtcbiAgICAgIGNhcHR1cmU6IGdsb2JhbFN0YXRlLmtleWRvd25MaXN0ZW5lckNhcHR1cmVcbiAgICB9KTtcbiAgICBnbG9iYWxTdGF0ZS5rZXlkb3duSGFuZGxlckFkZGVkID0gZmFsc2U7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtHbG9iYWxTdGF0ZX0gZ2xvYmFsU3RhdGVcbiAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IGlubmVyUGFyYW1zXG4gKiBAcGFyYW0geyhkaXNtaXNzOiBEaXNtaXNzUmVhc29uKSA9PiB2b2lkfSBkaXNtaXNzV2l0aFxuICovXG5jb25zdCBhZGRLZXlkb3duSGFuZGxlciA9IChnbG9iYWxTdGF0ZSwgaW5uZXJQYXJhbXMsIGRpc21pc3NXaXRoKSA9PiB7XG4gIHJlbW92ZUtleWRvd25IYW5kbGVyKGdsb2JhbFN0YXRlKTtcbiAgaWYgKCFpbm5lclBhcmFtcy50b2FzdCkge1xuICAgIGdsb2JhbFN0YXRlLmtleWRvd25IYW5kbGVyID0gZSA9PiBrZXlkb3duSGFuZGxlcihpbm5lclBhcmFtcywgZSwgZGlzbWlzc1dpdGgpO1xuICAgIGdsb2JhbFN0YXRlLmtleWRvd25UYXJnZXQgPSBpbm5lclBhcmFtcy5rZXlkb3duTGlzdGVuZXJDYXB0dXJlID8gd2luZG93IDogZ2V0UG9wdXAoKTtcbiAgICBnbG9iYWxTdGF0ZS5rZXlkb3duTGlzdGVuZXJDYXB0dXJlID0gaW5uZXJQYXJhbXMua2V5ZG93bkxpc3RlbmVyQ2FwdHVyZTtcbiAgICBnbG9iYWxTdGF0ZS5rZXlkb3duVGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBnbG9iYWxTdGF0ZS5rZXlkb3duSGFuZGxlciwge1xuICAgICAgY2FwdHVyZTogZ2xvYmFsU3RhdGUua2V5ZG93bkxpc3RlbmVyQ2FwdHVyZVxuICAgIH0pO1xuICAgIGdsb2JhbFN0YXRlLmtleWRvd25IYW5kbGVyQWRkZWQgPSB0cnVlO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IGluY3JlbWVudFxuICovXG5jb25zdCBzZXRGb2N1cyA9IChpbmRleCwgaW5jcmVtZW50KSA9PiB7XG4gIHZhciBfZG9tJGdldFBvcHVwO1xuICBjb25zdCBmb2N1c2FibGVFbGVtZW50cyA9IGdldEZvY3VzYWJsZUVsZW1lbnRzKCk7XG4gIC8vIHNlYXJjaCBmb3IgdmlzaWJsZSBlbGVtZW50cyBhbmQgc2VsZWN0IHRoZSBuZXh0IHBvc3NpYmxlIG1hdGNoXG4gIGlmIChmb2N1c2FibGVFbGVtZW50cy5sZW5ndGgpIHtcbiAgICBpbmRleCA9IGluZGV4ICsgaW5jcmVtZW50O1xuXG4gICAgLy8gc2hpZnQgKyB0YWIgd2hlbiAuc3dhbDItcG9wdXAgaXMgZm9jdXNlZFxuICAgIGlmIChpbmRleCA9PT0gLTIpIHtcbiAgICAgIGluZGV4ID0gZm9jdXNhYmxlRWxlbWVudHMubGVuZ3RoIC0gMTtcbiAgICB9XG5cbiAgICAvLyByb2xsb3ZlciB0byBmaXJzdCBpdGVtXG4gICAgaWYgKGluZGV4ID09PSBmb2N1c2FibGVFbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgIGluZGV4ID0gMDtcblxuICAgICAgLy8gZ28gdG8gbGFzdCBpdGVtXG4gICAgfSBlbHNlIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgIGluZGV4ID0gZm9jdXNhYmxlRWxlbWVudHMubGVuZ3RoIC0gMTtcbiAgICB9XG4gICAgZm9jdXNhYmxlRWxlbWVudHNbaW5kZXhdLmZvY3VzKCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIG5vIHZpc2libGUgZm9jdXNhYmxlIGVsZW1lbnRzLCBmb2N1cyB0aGUgcG9wdXBcbiAgKF9kb20kZ2V0UG9wdXAgPSBnZXRQb3B1cCgpKSA9PT0gbnVsbCB8fCBfZG9tJGdldFBvcHVwID09PSB2b2lkIDAgfHwgX2RvbSRnZXRQb3B1cC5mb2N1cygpO1xufTtcbmNvbnN0IGFycm93S2V5c05leHRCdXR0b24gPSBbJ0Fycm93UmlnaHQnLCAnQXJyb3dEb3duJ107XG5jb25zdCBhcnJvd0tleXNQcmV2aW91c0J1dHRvbiA9IFsnQXJyb3dMZWZ0JywgJ0Fycm93VXAnXTtcblxuLyoqXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBpbm5lclBhcmFtc1xuICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldmVudFxuICogQHBhcmFtIHsoZGlzbWlzczogRGlzbWlzc1JlYXNvbikgPT4gdm9pZH0gZGlzbWlzc1dpdGhcbiAqL1xuY29uc3Qga2V5ZG93bkhhbmRsZXIgPSAoaW5uZXJQYXJhbXMsIGV2ZW50LCBkaXNtaXNzV2l0aCkgPT4ge1xuICBpZiAoIWlubmVyUGFyYW1zKSB7XG4gICAgcmV0dXJuOyAvLyBUaGlzIGluc3RhbmNlIGhhcyBhbHJlYWR5IGJlZW4gZGVzdHJveWVkXG4gIH1cblxuICAvLyBJZ25vcmUga2V5ZG93biBkdXJpbmcgSU1FIGNvbXBvc2l0aW9uXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Eb2N1bWVudC9rZXlkb3duX2V2ZW50I2lnbm9yaW5nX2tleWRvd25fZHVyaW5nX2ltZV9jb21wb3NpdGlvblxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vc3dlZXRhbGVydDIvc3dlZXRhbGVydDIvaXNzdWVzLzcyMFxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vc3dlZXRhbGVydDIvc3dlZXRhbGVydDIvaXNzdWVzLzI0MDZcbiAgaWYgKGV2ZW50LmlzQ29tcG9zaW5nIHx8IGV2ZW50LmtleUNvZGUgPT09IDIyOSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoaW5uZXJQYXJhbXMuc3RvcEtleWRvd25Qcm9wYWdhdGlvbikge1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICB9XG5cbiAgLy8gRU5URVJcbiAgaWYgKGV2ZW50LmtleSA9PT0gJ0VudGVyJykge1xuICAgIGhhbmRsZUVudGVyKGV2ZW50LCBpbm5lclBhcmFtcyk7XG4gIH1cblxuICAvLyBUQUJcbiAgZWxzZSBpZiAoZXZlbnQua2V5ID09PSAnVGFiJykge1xuICAgIGhhbmRsZVRhYihldmVudCk7XG4gIH1cblxuICAvLyBBUlJPV1MgLSBzd2l0Y2ggZm9jdXMgYmV0d2VlbiBidXR0b25zXG4gIGVsc2UgaWYgKFsuLi5hcnJvd0tleXNOZXh0QnV0dG9uLCAuLi5hcnJvd0tleXNQcmV2aW91c0J1dHRvbl0uaW5jbHVkZXMoZXZlbnQua2V5KSkge1xuICAgIGhhbmRsZUFycm93cyhldmVudC5rZXkpO1xuICB9XG5cbiAgLy8gRVNDXG4gIGVsc2UgaWYgKGV2ZW50LmtleSA9PT0gJ0VzY2FwZScpIHtcbiAgICBoYW5kbGVFc2MoZXZlbnQsIGlubmVyUGFyYW1zLCBkaXNtaXNzV2l0aCk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldmVudFxuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gaW5uZXJQYXJhbXNcbiAqL1xuY29uc3QgaGFuZGxlRW50ZXIgPSAoZXZlbnQsIGlubmVyUGFyYW1zKSA9PiB7XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zd2VldGFsZXJ0Mi9zd2VldGFsZXJ0Mi9pc3N1ZXMvMjM4NlxuICBpZiAoIWNhbGxJZkZ1bmN0aW9uKGlubmVyUGFyYW1zLmFsbG93RW50ZXJLZXkpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGlucHV0ID0gZ2V0SW5wdXQkMShnZXRQb3B1cCgpLCBpbm5lclBhcmFtcy5pbnB1dCk7XG4gIGlmIChldmVudC50YXJnZXQgJiYgaW5wdXQgJiYgZXZlbnQudGFyZ2V0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgZXZlbnQudGFyZ2V0Lm91dGVySFRNTCA9PT0gaW5wdXQub3V0ZXJIVE1MKSB7XG4gICAgaWYgKFsndGV4dGFyZWEnLCAnZmlsZSddLmluY2x1ZGVzKGlubmVyUGFyYW1zLmlucHV0KSkge1xuICAgICAgcmV0dXJuOyAvLyBkbyBub3Qgc3VibWl0XG4gICAgfVxuICAgIGNsaWNrQ29uZmlybSgpO1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldmVudFxuICovXG5jb25zdCBoYW5kbGVUYWIgPSBldmVudCA9PiB7XG4gIGNvbnN0IHRhcmdldEVsZW1lbnQgPSBldmVudC50YXJnZXQ7XG4gIGNvbnN0IGZvY3VzYWJsZUVsZW1lbnRzID0gZ2V0Rm9jdXNhYmxlRWxlbWVudHMoKTtcbiAgbGV0IGJ0bkluZGV4ID0gLTE7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZm9jdXNhYmxlRWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAodGFyZ2V0RWxlbWVudCA9PT0gZm9jdXNhYmxlRWxlbWVudHNbaV0pIHtcbiAgICAgIGJ0bkluZGV4ID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8vIEN5Y2xlIHRvIHRoZSBuZXh0IGJ1dHRvblxuICBpZiAoIWV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgc2V0Rm9jdXMoYnRuSW5kZXgsIDEpO1xuICB9XG5cbiAgLy8gQ3ljbGUgdG8gdGhlIHByZXYgYnV0dG9uXG4gIGVsc2Uge1xuICAgIHNldEZvY3VzKGJ0bkluZGV4LCAtMSk7XG4gIH1cbiAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuY29uc3QgaGFuZGxlQXJyb3dzID0ga2V5ID0+IHtcbiAgY29uc3QgYWN0aW9ucyA9IGdldEFjdGlvbnMoKTtcbiAgY29uc3QgY29uZmlybUJ1dHRvbiA9IGdldENvbmZpcm1CdXR0b24oKTtcbiAgY29uc3QgZGVueUJ1dHRvbiA9IGdldERlbnlCdXR0b24oKTtcbiAgY29uc3QgY2FuY2VsQnV0dG9uID0gZ2V0Q2FuY2VsQnV0dG9uKCk7XG4gIGlmICghYWN0aW9ucyB8fCAhY29uZmlybUJ1dHRvbiB8fCAhZGVueUJ1dHRvbiB8fCAhY2FuY2VsQnV0dG9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8qKiBAdHlwZSBIVE1MRWxlbWVudFtdICovXG4gIGNvbnN0IGJ1dHRvbnMgPSBbY29uZmlybUJ1dHRvbiwgZGVueUJ1dHRvbiwgY2FuY2VsQnV0dG9uXTtcbiAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJiAhYnV0dG9ucy5pbmNsdWRlcyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBzaWJsaW5nID0gYXJyb3dLZXlzTmV4dEJ1dHRvbi5pbmNsdWRlcyhrZXkpID8gJ25leHRFbGVtZW50U2libGluZycgOiAncHJldmlvdXNFbGVtZW50U2libGluZyc7XG4gIGxldCBidXR0b25Ub0ZvY3VzID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgaWYgKCFidXR0b25Ub0ZvY3VzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYWN0aW9ucy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGJ1dHRvblRvRm9jdXMgPSBidXR0b25Ub0ZvY3VzW3NpYmxpbmddO1xuICAgIGlmICghYnV0dG9uVG9Gb2N1cykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoYnV0dG9uVG9Gb2N1cyBpbnN0YW5jZW9mIEhUTUxCdXR0b25FbGVtZW50ICYmIGlzVmlzaWJsZSQxKGJ1dHRvblRvRm9jdXMpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKGJ1dHRvblRvRm9jdXMgaW5zdGFuY2VvZiBIVE1MQnV0dG9uRWxlbWVudCkge1xuICAgIGJ1dHRvblRvRm9jdXMuZm9jdXMoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGV2ZW50XG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBpbm5lclBhcmFtc1xuICogQHBhcmFtIHsoZGlzbWlzczogRGlzbWlzc1JlYXNvbikgPT4gdm9pZH0gZGlzbWlzc1dpdGhcbiAqL1xuY29uc3QgaGFuZGxlRXNjID0gKGV2ZW50LCBpbm5lclBhcmFtcywgZGlzbWlzc1dpdGgpID0+IHtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgaWYgKGNhbGxJZkZ1bmN0aW9uKGlubmVyUGFyYW1zLmFsbG93RXNjYXBlS2V5KSkge1xuICAgIGRpc21pc3NXaXRoKERpc21pc3NSZWFzb24uZXNjKTtcbiAgfVxufTtcblxuLyoqXG4gKiBUaGlzIG1vZHVsZSBjb250YWlucyBgV2Vha01hcGBzIGZvciBlYWNoIGVmZmVjdGl2ZWx5LVwicHJpdmF0ZSAgcHJvcGVydHlcIiB0aGF0IGEgYFN3YWxgIGhhcy5cbiAqIEZvciBleGFtcGxlLCB0byBzZXQgdGhlIHByaXZhdGUgcHJvcGVydHkgXCJmb29cIiBvZiBgdGhpc2AgdG8gXCJiYXJcIiwgeW91IGNhbiBgcHJpdmF0ZVByb3BzLmZvby5zZXQodGhpcywgJ2JhcicpYFxuICogVGhpcyBpcyB0aGUgYXBwcm9hY2ggdGhhdCBCYWJlbCB3aWxsIHByb2JhYmx5IHRha2UgdG8gaW1wbGVtZW50IHByaXZhdGUgbWV0aG9kcy9maWVsZHNcbiAqICAgaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtcHJpdmF0ZS1tZXRob2RzXG4gKiAgIGh0dHBzOi8vZ2l0aHViLmNvbS9iYWJlbC9iYWJlbC9wdWxsLzc1NTVcbiAqIE9uY2Ugd2UgaGF2ZSB0aGUgY2hhbmdlcyBmcm9tIHRoYXQgUFIgaW4gQmFiZWwsIGFuZCBvdXIgY29yZSBjbGFzcyBmaXRzIHJlYXNvbmFibGUgaW4gKm9uZSBtb2R1bGUqXG4gKiAgIHRoZW4gd2UgY2FuIHVzZSB0aGF0IGxhbmd1YWdlIGZlYXR1cmUuXG4gKi9cblxudmFyIHByaXZhdGVNZXRob2RzID0ge1xuICBzd2FsUHJvbWlzZVJlc29sdmU6IG5ldyBXZWFrTWFwKCksXG4gIHN3YWxQcm9taXNlUmVqZWN0OiBuZXcgV2Vha01hcCgpXG59O1xuXG4vLyBGcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLnBhY2llbGxvZ3JvdXAuY29tL2Jsb2cvMjAxOC8wNi90aGUtY3VycmVudC1zdGF0ZS1vZi1tb2RhbC1kaWFsb2ctYWNjZXNzaWJpbGl0eS9cbi8vIEFkZGluZyBhcmlhLWhpZGRlbj1cInRydWVcIiB0byBlbGVtZW50cyBvdXRzaWRlIG9mIHRoZSBhY3RpdmUgbW9kYWwgZGlhbG9nIGVuc3VyZXMgdGhhdFxuLy8gZWxlbWVudHMgbm90IHdpdGhpbiB0aGUgYWN0aXZlIG1vZGFsIGRpYWxvZyB3aWxsIG5vdCBiZSBzdXJmYWNlZCBpZiBhIHVzZXIgb3BlbnMgYSBzY3JlZW5cbi8vIHJlYWRlcuKAmXMgbGlzdCBvZiBlbGVtZW50cyAoaGVhZGluZ3MsIGZvcm0gY29udHJvbHMsIGxhbmRtYXJrcywgZXRjLikgaW4gdGhlIGRvY3VtZW50LlxuXG5jb25zdCBzZXRBcmlhSGlkZGVuID0gKCkgPT4ge1xuICBjb25zdCBjb250YWluZXIgPSBnZXRDb250YWluZXIoKTtcbiAgY29uc3QgYm9keUNoaWxkcmVuID0gQXJyYXkuZnJvbShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAgYm9keUNoaWxkcmVuLmZvckVhY2goZWwgPT4ge1xuICAgIGlmIChlbC5jb250YWlucyhjb250YWluZXIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlbC5oYXNBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJykpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnZGF0YS1wcmV2aW91cy1hcmlhLWhpZGRlbicsIGVsLmdldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKSB8fCAnJyk7XG4gICAgfVxuICAgIGVsLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuICB9KTtcbn07XG5jb25zdCB1bnNldEFyaWFIaWRkZW4gPSAoKSA9PiB7XG4gIGNvbnN0IGJvZHlDaGlsZHJlbiA9IEFycmF5LmZyb20oZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gIGJvZHlDaGlsZHJlbi5mb3JFYWNoKGVsID0+IHtcbiAgICBpZiAoZWwuaGFzQXR0cmlidXRlKCdkYXRhLXByZXZpb3VzLWFyaWEtaGlkZGVuJykpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCBlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtcHJldmlvdXMtYXJpYS1oaWRkZW4nKSB8fCAnJyk7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtcHJldmlvdXMtYXJpYS1oaWRkZW4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWhpZGRlbicpO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vLyBAdHMtaWdub3JlXG5jb25zdCBpc1NhZmFyaU9ySU9TID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgISF3aW5kb3cuR2VzdHVyZUV2ZW50OyAvLyB0cnVlIGZvciBTYWZhcmkgZGVza3RvcCArIGFsbCBpT1MgYnJvd3NlcnMgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzcwNTg1Mzk0XG5cbi8qKlxuICogRml4IGlPUyBzY3JvbGxpbmdcbiAqIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xLzM5NjI2MzAyXG4gKi9cbmNvbnN0IGlPU2ZpeCA9ICgpID0+IHtcbiAgaWYgKGlzU2FmYXJpT3JJT1MgJiYgIWhhc0NsYXNzKGRvY3VtZW50LmJvZHksIHN3YWxDbGFzc2VzLmlvc2ZpeCkpIHtcbiAgICBjb25zdCBvZmZzZXQgPSBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcDtcbiAgICBkb2N1bWVudC5ib2R5LnN0eWxlLnRvcCA9IGAke29mZnNldCAqIC0xfXB4YDtcbiAgICBhZGRDbGFzcyhkb2N1bWVudC5ib2R5LCBzd2FsQ2xhc3Nlcy5pb3NmaXgpO1xuICAgIGxvY2tCb2R5U2Nyb2xsKCk7XG4gIH1cbn07XG5cbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3N3ZWV0YWxlcnQyL3N3ZWV0YWxlcnQyL2lzc3Vlcy8xMjQ2XG4gKi9cbmNvbnN0IGxvY2tCb2R5U2Nyb2xsID0gKCkgPT4ge1xuICBjb25zdCBjb250YWluZXIgPSBnZXRDb250YWluZXIoKTtcbiAgaWYgKCFjb250YWluZXIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICBsZXQgcHJldmVudFRvdWNoTW92ZTtcbiAgLyoqXG4gICAqIEBwYXJhbSB7VG91Y2hFdmVudH0gZXZlbnRcbiAgICovXG4gIGNvbnRhaW5lci5vbnRvdWNoc3RhcnQgPSBldmVudCA9PiB7XG4gICAgcHJldmVudFRvdWNoTW92ZSA9IHNob3VsZFByZXZlbnRUb3VjaE1vdmUoZXZlbnQpO1xuICB9O1xuICAvKipcbiAgICogQHBhcmFtIHtUb3VjaEV2ZW50fSBldmVudFxuICAgKi9cbiAgY29udGFpbmVyLm9udG91Y2htb3ZlID0gZXZlbnQgPT4ge1xuICAgIGlmIChwcmV2ZW50VG91Y2hNb3ZlKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuICB9O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1RvdWNoRXZlbnR9IGV2ZW50XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuY29uc3Qgc2hvdWxkUHJldmVudFRvdWNoTW92ZSA9IGV2ZW50ID0+IHtcbiAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICBjb25zdCBjb250YWluZXIgPSBnZXRDb250YWluZXIoKTtcbiAgY29uc3QgaHRtbENvbnRhaW5lciA9IGdldEh0bWxDb250YWluZXIoKTtcbiAgaWYgKCFjb250YWluZXIgfHwgIWh0bWxDb250YWluZXIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGlzU3R5bHVzKGV2ZW50KSB8fCBpc1pvb20oZXZlbnQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0YXJnZXQgPT09IGNvbnRhaW5lcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICghaXNTY3JvbGxhYmxlKGNvbnRhaW5lcikgJiYgdGFyZ2V0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgIXNlbGZPclBhcmVudElzU2Nyb2xsYWJsZSh0YXJnZXQsIGh0bWxDb250YWluZXIpICYmXG4gIC8vICMyODIzXG4gIHRhcmdldC50YWdOYW1lICE9PSAnSU5QVVQnICYmXG4gIC8vICMxNjAzXG4gIHRhcmdldC50YWdOYW1lICE9PSAnVEVYVEFSRUEnICYmXG4gIC8vICMyMjY2XG4gICEoaXNTY3JvbGxhYmxlKGh0bWxDb250YWluZXIpICYmXG4gIC8vICMxOTQ0XG4gIGh0bWxDb250YWluZXIuY29udGFpbnModGFyZ2V0KSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9zd2VldGFsZXJ0Mi9zd2VldGFsZXJ0Mi9pc3N1ZXMvMTc4NlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBldmVudFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmNvbnN0IGlzU3R5bHVzID0gZXZlbnQgPT4ge1xuICByZXR1cm4gZXZlbnQudG91Y2hlcyAmJiBldmVudC50b3VjaGVzLmxlbmd0aCAmJiBldmVudC50b3VjaGVzWzBdLnRvdWNoVHlwZSA9PT0gJ3N0eWx1cyc7XG59O1xuXG4vKipcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9zd2VldGFsZXJ0Mi9zd2VldGFsZXJ0Mi9pc3N1ZXMvMTg5MVxuICpcbiAqIEBwYXJhbSB7VG91Y2hFdmVudH0gZXZlbnRcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5jb25zdCBpc1pvb20gPSBldmVudCA9PiB7XG4gIHJldHVybiBldmVudC50b3VjaGVzICYmIGV2ZW50LnRvdWNoZXMubGVuZ3RoID4gMTtcbn07XG5jb25zdCB1bmRvSU9TZml4ID0gKCkgPT4ge1xuICBpZiAoaGFzQ2xhc3MoZG9jdW1lbnQuYm9keSwgc3dhbENsYXNzZXMuaW9zZml4KSkge1xuICAgIGNvbnN0IG9mZnNldCA9IHBhcnNlSW50KGRvY3VtZW50LmJvZHkuc3R5bGUudG9wLCAxMCk7XG4gICAgcmVtb3ZlQ2xhc3MoZG9jdW1lbnQuYm9keSwgc3dhbENsYXNzZXMuaW9zZml4KTtcbiAgICBkb2N1bWVudC5ib2R5LnN0eWxlLnRvcCA9ICcnO1xuICAgIGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wID0gb2Zmc2V0ICogLTE7XG4gIH1cbn07XG5cbi8qKlxuICogTWVhc3VyZSBzY3JvbGxiYXIgd2lkdGggZm9yIHBhZGRpbmcgYm9keSBkdXJpbmcgbW9kYWwgc2hvdy9oaWRlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvanMvc3JjL21vZGFsLmpzXG4gKlxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuY29uc3QgbWVhc3VyZVNjcm9sbGJhciA9ICgpID0+IHtcbiAgY29uc3Qgc2Nyb2xsRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHNjcm9sbERpdi5jbGFzc05hbWUgPSBzd2FsQ2xhc3Nlc1snc2Nyb2xsYmFyLW1lYXN1cmUnXTtcbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzY3JvbGxEaXYpO1xuICBjb25zdCBzY3JvbGxiYXJXaWR0aCA9IHNjcm9sbERpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCAtIHNjcm9sbERpdi5jbGllbnRXaWR0aDtcbiAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChzY3JvbGxEaXYpO1xuICByZXR1cm4gc2Nyb2xsYmFyV2lkdGg7XG59O1xuXG4vKipcbiAqIFJlbWVtYmVyIHN0YXRlIGluIGNhc2VzIHdoZXJlIG9wZW5pbmcgYW5kIGhhbmRsaW5nIGEgbW9kYWwgd2lsbCBmaWRkbGUgd2l0aCBpdC5cbiAqIEB0eXBlIHtudW1iZXIgfCBudWxsfVxuICovXG5sZXQgcHJldmlvdXNCb2R5UGFkZGluZyA9IG51bGw7XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGluaXRpYWxCb2R5T3ZlcmZsb3dcbiAqL1xuY29uc3QgcmVwbGFjZVNjcm9sbGJhcldpdGhQYWRkaW5nID0gaW5pdGlhbEJvZHlPdmVyZmxvdyA9PiB7XG4gIC8vIGZvciBxdWV1ZXMsIGRvIG5vdCBkbyB0aGlzIG1vcmUgdGhhbiBvbmNlXG4gIGlmIChwcmV2aW91c0JvZHlQYWRkaW5nICE9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIGlmIHRoZSBib2R5IGhhcyBvdmVyZmxvd1xuICBpZiAoZG9jdW1lbnQuYm9keS5zY3JvbGxIZWlnaHQgPiB3aW5kb3cuaW5uZXJIZWlnaHQgfHwgaW5pdGlhbEJvZHlPdmVyZmxvdyA9PT0gJ3Njcm9sbCcgLy8gaHR0cHM6Ly9naXRodWIuY29tL3N3ZWV0YWxlcnQyL3N3ZWV0YWxlcnQyL2lzc3Vlcy8yNjYzXG4gICkge1xuICAgIC8vIGFkZCBwYWRkaW5nIHNvIHRoZSBjb250ZW50IGRvZXNuJ3Qgc2hpZnQgYWZ0ZXIgcmVtb3ZhbCBvZiBzY3JvbGxiYXJcbiAgICBwcmV2aW91c0JvZHlQYWRkaW5nID0gcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuYm9keSkuZ2V0UHJvcGVydHlWYWx1ZSgncGFkZGluZy1yaWdodCcpKTtcbiAgICBkb2N1bWVudC5ib2R5LnN0eWxlLnBhZGRpbmdSaWdodCA9IGAke3ByZXZpb3VzQm9keVBhZGRpbmcgKyBtZWFzdXJlU2Nyb2xsYmFyKCl9cHhgO1xuICB9XG59O1xuY29uc3QgdW5kb1JlcGxhY2VTY3JvbGxiYXJXaXRoUGFkZGluZyA9ICgpID0+IHtcbiAgaWYgKHByZXZpb3VzQm9keVBhZGRpbmcgIT09IG51bGwpIHtcbiAgICBkb2N1bWVudC5ib2R5LnN0eWxlLnBhZGRpbmdSaWdodCA9IGAke3ByZXZpb3VzQm9keVBhZGRpbmd9cHhgO1xuICAgIHByZXZpb3VzQm9keVBhZGRpbmcgPSBudWxsO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3dlZXRBbGVydH0gaW5zdGFuY2VcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lclxuICogQHBhcmFtIHtib29sZWFufSByZXR1cm5Gb2N1c1xuICogQHBhcmFtIHsoKSA9PiB2b2lkfSBkaWRDbG9zZVxuICovXG5mdW5jdGlvbiByZW1vdmVQb3B1cEFuZFJlc2V0U3RhdGUoaW5zdGFuY2UsIGNvbnRhaW5lciwgcmV0dXJuRm9jdXMsIGRpZENsb3NlKSB7XG4gIGlmIChpc1RvYXN0KCkpIHtcbiAgICB0cmlnZ2VyRGlkQ2xvc2VBbmREaXNwb3NlKGluc3RhbmNlLCBkaWRDbG9zZSk7XG4gIH0gZWxzZSB7XG4gICAgcmVzdG9yZUFjdGl2ZUVsZW1lbnQocmV0dXJuRm9jdXMpLnRoZW4oKCkgPT4gdHJpZ2dlckRpZENsb3NlQW5kRGlzcG9zZShpbnN0YW5jZSwgZGlkQ2xvc2UpKTtcbiAgICByZW1vdmVLZXlkb3duSGFuZGxlcihnbG9iYWxTdGF0ZSk7XG4gIH1cblxuICAvLyB3b3JrYXJvdW5kIGZvciBodHRwczovL2dpdGh1Yi5jb20vc3dlZXRhbGVydDIvc3dlZXRhbGVydDIvaXNzdWVzLzIwODhcbiAgLy8gZm9yIHNvbWUgcmVhc29uIHJlbW92aW5nIHRoZSBjb250YWluZXIgaW4gU2FmYXJpIHdpbGwgc2Nyb2xsIHRoZSBkb2N1bWVudCB0byBib3R0b21cbiAgaWYgKGlzU2FmYXJpT3JJT1MpIHtcbiAgICBjb250YWluZXIuc2V0QXR0cmlidXRlKCdzdHlsZScsICdkaXNwbGF5Om5vbmUgIWltcG9ydGFudCcpO1xuICAgIGNvbnRhaW5lci5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XG4gICAgY29udGFpbmVyLmlubmVySFRNTCA9ICcnO1xuICB9IGVsc2Uge1xuICAgIGNvbnRhaW5lci5yZW1vdmUoKTtcbiAgfVxuICBpZiAoaXNNb2RhbCgpKSB7XG4gICAgdW5kb1JlcGxhY2VTY3JvbGxiYXJXaXRoUGFkZGluZygpO1xuICAgIHVuZG9JT1NmaXgoKTtcbiAgICB1bnNldEFyaWFIaWRkZW4oKTtcbiAgfVxuICByZW1vdmVCb2R5Q2xhc3NlcygpO1xufVxuXG4vKipcbiAqIFJlbW92ZSBTd2VldEFsZXJ0MiBjbGFzc2VzIGZyb20gYm9keVxuICovXG5mdW5jdGlvbiByZW1vdmVCb2R5Q2xhc3NlcygpIHtcbiAgcmVtb3ZlQ2xhc3MoW2RvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgZG9jdW1lbnQuYm9keV0sIFtzd2FsQ2xhc3Nlcy5zaG93biwgc3dhbENsYXNzZXNbJ2hlaWdodC1hdXRvJ10sIHN3YWxDbGFzc2VzWyduby1iYWNrZHJvcCddLCBzd2FsQ2xhc3Nlc1sndG9hc3Qtc2hvd24nXV0pO1xufVxuXG4vKipcbiAqIEluc3RhbmNlIG1ldGhvZCB0byBjbG9zZSBzd2VldEFsZXJ0XG4gKlxuICogQHBhcmFtIHtTd2VldEFsZXJ0UmVzdWx0IHwgdW5kZWZpbmVkfSByZXNvbHZlVmFsdWVcbiAqL1xuZnVuY3Rpb24gY2xvc2UocmVzb2x2ZVZhbHVlKSB7XG4gIHJlc29sdmVWYWx1ZSA9IHByZXBhcmVSZXNvbHZlVmFsdWUocmVzb2x2ZVZhbHVlKTtcbiAgY29uc3Qgc3dhbFByb21pc2VSZXNvbHZlID0gcHJpdmF0ZU1ldGhvZHMuc3dhbFByb21pc2VSZXNvbHZlLmdldCh0aGlzKTtcbiAgY29uc3QgZGlkQ2xvc2UgPSB0cmlnZ2VyQ2xvc2VQb3B1cCh0aGlzKTtcbiAgaWYgKHRoaXMuaXNBd2FpdGluZ1Byb21pc2UpIHtcbiAgICAvLyBBIHN3YWwgYXdhaXRpbmcgZm9yIGEgcHJvbWlzZSAoYWZ0ZXIgYSBjbGljayBvbiBDb25maXJtIG9yIERlbnkpIGNhbm5vdCBiZSBkaXNtaXNzZWQgYW55bW9yZSAjMjMzNVxuICAgIGlmICghcmVzb2x2ZVZhbHVlLmlzRGlzbWlzc2VkKSB7XG4gICAgICBoYW5kbGVBd2FpdGluZ1Byb21pc2UodGhpcyk7XG4gICAgICBzd2FsUHJvbWlzZVJlc29sdmUocmVzb2x2ZVZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZGlkQ2xvc2UpIHtcbiAgICAvLyBSZXNvbHZlIFN3YWwgcHJvbWlzZVxuICAgIHN3YWxQcm9taXNlUmVzb2x2ZShyZXNvbHZlVmFsdWUpO1xuICB9XG59XG5jb25zdCB0cmlnZ2VyQ2xvc2VQb3B1cCA9IGluc3RhbmNlID0+IHtcbiAgY29uc3QgcG9wdXAgPSBnZXRQb3B1cCgpO1xuICBpZiAoIXBvcHVwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGlubmVyUGFyYW1zID0gcHJpdmF0ZVByb3BzLmlubmVyUGFyYW1zLmdldChpbnN0YW5jZSk7XG4gIGlmICghaW5uZXJQYXJhbXMgfHwgaGFzQ2xhc3MocG9wdXAsIGlubmVyUGFyYW1zLmhpZGVDbGFzcy5wb3B1cCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmVtb3ZlQ2xhc3MocG9wdXAsIGlubmVyUGFyYW1zLnNob3dDbGFzcy5wb3B1cCk7XG4gIGFkZENsYXNzKHBvcHVwLCBpbm5lclBhcmFtcy5oaWRlQ2xhc3MucG9wdXApO1xuICBjb25zdCBiYWNrZHJvcCA9IGdldENvbnRhaW5lcigpO1xuICByZW1vdmVDbGFzcyhiYWNrZHJvcCwgaW5uZXJQYXJhbXMuc2hvd0NsYXNzLmJhY2tkcm9wKTtcbiAgYWRkQ2xhc3MoYmFja2Ryb3AsIGlubmVyUGFyYW1zLmhpZGVDbGFzcy5iYWNrZHJvcCk7XG4gIGhhbmRsZVBvcHVwQW5pbWF0aW9uKGluc3RhbmNlLCBwb3B1cCwgaW5uZXJQYXJhbXMpO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtFcnJvciB8IHN0cmluZ30gZXJyb3JcbiAqL1xuZnVuY3Rpb24gcmVqZWN0UHJvbWlzZShlcnJvcikge1xuICBjb25zdCByZWplY3RQcm9taXNlID0gcHJpdmF0ZU1ldGhvZHMuc3dhbFByb21pc2VSZWplY3QuZ2V0KHRoaXMpO1xuICBoYW5kbGVBd2FpdGluZ1Byb21pc2UodGhpcyk7XG4gIGlmIChyZWplY3RQcm9taXNlKSB7XG4gICAgLy8gUmVqZWN0IFN3YWwgcHJvbWlzZVxuICAgIHJlamVjdFByb21pc2UoZXJyb3IpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtTd2VldEFsZXJ0fSBpbnN0YW5jZVxuICovXG5jb25zdCBoYW5kbGVBd2FpdGluZ1Byb21pc2UgPSBpbnN0YW5jZSA9PiB7XG4gIGlmIChpbnN0YW5jZS5pc0F3YWl0aW5nUHJvbWlzZSkge1xuICAgIGRlbGV0ZSBpbnN0YW5jZS5pc0F3YWl0aW5nUHJvbWlzZTtcbiAgICAvLyBUaGUgaW5zdGFuY2UgbWlnaHQgaGF2ZSBiZWVuIHByZXZpb3VzbHkgcGFydGx5IGRlc3Ryb3llZCwgd2UgbXVzdCByZXN1bWUgdGhlIGRlc3Ryb3kgcHJvY2VzcyBpbiB0aGlzIGNhc2UgIzIzMzVcbiAgICBpZiAoIXByaXZhdGVQcm9wcy5pbm5lclBhcmFtcy5nZXQoaW5zdGFuY2UpKSB7XG4gICAgICBpbnN0YW5jZS5fZGVzdHJveSgpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRSZXN1bHQgfCB1bmRlZmluZWR9IHJlc29sdmVWYWx1ZVxuICogQHJldHVybnMge1N3ZWV0QWxlcnRSZXN1bHR9XG4gKi9cbmNvbnN0IHByZXBhcmVSZXNvbHZlVmFsdWUgPSByZXNvbHZlVmFsdWUgPT4ge1xuICAvLyBXaGVuIHVzZXIgY2FsbHMgU3dhbC5jbG9zZSgpXG4gIGlmICh0eXBlb2YgcmVzb2x2ZVZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiB7XG4gICAgICBpc0NvbmZpcm1lZDogZmFsc2UsXG4gICAgICBpc0RlbmllZDogZmFsc2UsXG4gICAgICBpc0Rpc21pc3NlZDogdHJ1ZVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe1xuICAgIGlzQ29uZmlybWVkOiBmYWxzZSxcbiAgICBpc0RlbmllZDogZmFsc2UsXG4gICAgaXNEaXNtaXNzZWQ6IGZhbHNlXG4gIH0sIHJlc29sdmVWYWx1ZSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3dlZXRBbGVydH0gaW5zdGFuY2VcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBvcHVwXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBpbm5lclBhcmFtc1xuICovXG5jb25zdCBoYW5kbGVQb3B1cEFuaW1hdGlvbiA9IChpbnN0YW5jZSwgcG9wdXAsIGlubmVyUGFyYW1zKSA9PiB7XG4gIHZhciBfZ2xvYmFsU3RhdGUkZXZlbnRFbWk7XG4gIGNvbnN0IGNvbnRhaW5lciA9IGdldENvbnRhaW5lcigpO1xuICAvLyBJZiBhbmltYXRpb24gaXMgc3VwcG9ydGVkLCBhbmltYXRlXG4gIGNvbnN0IGFuaW1hdGlvbklzU3VwcG9ydGVkID0gaGFzQ3NzQW5pbWF0aW9uKHBvcHVwKTtcbiAgaWYgKHR5cGVvZiBpbm5lclBhcmFtcy53aWxsQ2xvc2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpbm5lclBhcmFtcy53aWxsQ2xvc2UocG9wdXApO1xuICB9XG4gIChfZ2xvYmFsU3RhdGUkZXZlbnRFbWkgPSBnbG9iYWxTdGF0ZS5ldmVudEVtaXR0ZXIpID09PSBudWxsIHx8IF9nbG9iYWxTdGF0ZSRldmVudEVtaSA9PT0gdm9pZCAwIHx8IF9nbG9iYWxTdGF0ZSRldmVudEVtaS5lbWl0KCd3aWxsQ2xvc2UnLCBwb3B1cCk7XG4gIGlmIChhbmltYXRpb25Jc1N1cHBvcnRlZCkge1xuICAgIGFuaW1hdGVQb3B1cChpbnN0YW5jZSwgcG9wdXAsIGNvbnRhaW5lciwgaW5uZXJQYXJhbXMucmV0dXJuRm9jdXMsIGlubmVyUGFyYW1zLmRpZENsb3NlKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBPdGhlcndpc2UsIHJlbW92ZSBpbW1lZGlhdGVseVxuICAgIHJlbW92ZVBvcHVwQW5kUmVzZXRTdGF0ZShpbnN0YW5jZSwgY29udGFpbmVyLCBpbm5lclBhcmFtcy5yZXR1cm5Gb2N1cywgaW5uZXJQYXJhbXMuZGlkQ2xvc2UpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3dlZXRBbGVydH0gaW5zdGFuY2VcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBvcHVwXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcmV0dXJuRm9jdXNcbiAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gZGlkQ2xvc2VcbiAqL1xuY29uc3QgYW5pbWF0ZVBvcHVwID0gKGluc3RhbmNlLCBwb3B1cCwgY29udGFpbmVyLCByZXR1cm5Gb2N1cywgZGlkQ2xvc2UpID0+IHtcbiAgZ2xvYmFsU3RhdGUuc3dhbENsb3NlRXZlbnRGaW5pc2hlZENhbGxiYWNrID0gcmVtb3ZlUG9wdXBBbmRSZXNldFN0YXRlLmJpbmQobnVsbCwgaW5zdGFuY2UsIGNvbnRhaW5lciwgcmV0dXJuRm9jdXMsIGRpZENsb3NlKTtcbiAgLyoqXG4gICAqIEBwYXJhbSB7QW5pbWF0aW9uRXZlbnQgfCBUcmFuc2l0aW9uRXZlbnR9IGVcbiAgICovXG4gIGNvbnN0IHN3YWxDbG9zZUFuaW1hdGlvbkZpbmlzaGVkID0gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS50YXJnZXQgPT09IHBvcHVwKSB7XG4gICAgICB2YXIgX2dsb2JhbFN0YXRlJHN3YWxDbG9zO1xuICAgICAgKF9nbG9iYWxTdGF0ZSRzd2FsQ2xvcyA9IGdsb2JhbFN0YXRlLnN3YWxDbG9zZUV2ZW50RmluaXNoZWRDYWxsYmFjaykgPT09IG51bGwgfHwgX2dsb2JhbFN0YXRlJHN3YWxDbG9zID09PSB2b2lkIDAgfHwgX2dsb2JhbFN0YXRlJHN3YWxDbG9zLmNhbGwoZ2xvYmFsU3RhdGUpO1xuICAgICAgZGVsZXRlIGdsb2JhbFN0YXRlLnN3YWxDbG9zZUV2ZW50RmluaXNoZWRDYWxsYmFjaztcbiAgICAgIHBvcHVwLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2FuaW1hdGlvbmVuZCcsIHN3YWxDbG9zZUFuaW1hdGlvbkZpbmlzaGVkKTtcbiAgICAgIHBvcHVwLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBzd2FsQ2xvc2VBbmltYXRpb25GaW5pc2hlZCk7XG4gICAgfVxuICB9O1xuICBwb3B1cC5hZGRFdmVudExpc3RlbmVyKCdhbmltYXRpb25lbmQnLCBzd2FsQ2xvc2VBbmltYXRpb25GaW5pc2hlZCk7XG4gIHBvcHVwLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBzd2FsQ2xvc2VBbmltYXRpb25GaW5pc2hlZCk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3dlZXRBbGVydH0gaW5zdGFuY2VcbiAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gZGlkQ2xvc2VcbiAqL1xuY29uc3QgdHJpZ2dlckRpZENsb3NlQW5kRGlzcG9zZSA9IChpbnN0YW5jZSwgZGlkQ2xvc2UpID0+IHtcbiAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgdmFyIF9nbG9iYWxTdGF0ZSRldmVudEVtaTI7XG4gICAgaWYgKHR5cGVvZiBkaWRDbG9zZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZGlkQ2xvc2UuYmluZChpbnN0YW5jZS5wYXJhbXMpKCk7XG4gICAgfVxuICAgIChfZ2xvYmFsU3RhdGUkZXZlbnRFbWkyID0gZ2xvYmFsU3RhdGUuZXZlbnRFbWl0dGVyKSA9PT0gbnVsbCB8fCBfZ2xvYmFsU3RhdGUkZXZlbnRFbWkyID09PSB2b2lkIDAgfHwgX2dsb2JhbFN0YXRlJGV2ZW50RW1pMi5lbWl0KCdkaWRDbG9zZScpO1xuICAgIC8vIGluc3RhbmNlIG1pZ2h0IGhhdmUgYmVlbiBkZXN0cm95ZWQgYWxyZWFkeVxuICAgIGlmIChpbnN0YW5jZS5fZGVzdHJveSkge1xuICAgICAgaW5zdGFuY2UuX2Rlc3Ryb3koKTtcbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiBTaG93cyBsb2FkZXIgKHNwaW5uZXIpLCB0aGlzIGlzIHVzZWZ1bCB3aXRoIEFKQVggcmVxdWVzdHMuXG4gKiBCeSBkZWZhdWx0IHRoZSBsb2FkZXIgYmUgc2hvd24gaW5zdGVhZCBvZiB0aGUgXCJDb25maXJtXCIgYnV0dG9uLlxuICpcbiAqIEBwYXJhbSB7SFRNTEJ1dHRvbkVsZW1lbnQgfCBudWxsfSBbYnV0dG9uVG9SZXBsYWNlXVxuICovXG5jb25zdCBzaG93TG9hZGluZyA9IGJ1dHRvblRvUmVwbGFjZSA9PiB7XG4gIGxldCBwb3B1cCA9IGdldFBvcHVwKCk7XG4gIGlmICghcG9wdXApIHtcbiAgICBuZXcgU3dhbCgpO1xuICB9XG4gIHBvcHVwID0gZ2V0UG9wdXAoKTtcbiAgaWYgKCFwb3B1cCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBsb2FkZXIgPSBnZXRMb2FkZXIoKTtcbiAgaWYgKGlzVG9hc3QoKSkge1xuICAgIGhpZGUoZ2V0SWNvbigpKTtcbiAgfSBlbHNlIHtcbiAgICByZXBsYWNlQnV0dG9uKHBvcHVwLCBidXR0b25Ub1JlcGxhY2UpO1xuICB9XG4gIHNob3cobG9hZGVyKTtcbiAgcG9wdXAuc2V0QXR0cmlidXRlKCdkYXRhLWxvYWRpbmcnLCAndHJ1ZScpO1xuICBwb3B1cC5zZXRBdHRyaWJ1dGUoJ2FyaWEtYnVzeScsICd0cnVlJyk7XG4gIHBvcHVwLmZvY3VzKCk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBvcHVwXG4gKiBAcGFyYW0ge0hUTUxCdXR0b25FbGVtZW50IHwgbnVsbH0gW2J1dHRvblRvUmVwbGFjZV1cbiAqL1xuY29uc3QgcmVwbGFjZUJ1dHRvbiA9IChwb3B1cCwgYnV0dG9uVG9SZXBsYWNlKSA9PiB7XG4gIGNvbnN0IGFjdGlvbnMgPSBnZXRBY3Rpb25zKCk7XG4gIGNvbnN0IGxvYWRlciA9IGdldExvYWRlcigpO1xuICBpZiAoIWFjdGlvbnMgfHwgIWxvYWRlcikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIWJ1dHRvblRvUmVwbGFjZSAmJiBpc1Zpc2libGUkMShnZXRDb25maXJtQnV0dG9uKCkpKSB7XG4gICAgYnV0dG9uVG9SZXBsYWNlID0gZ2V0Q29uZmlybUJ1dHRvbigpO1xuICB9XG4gIHNob3coYWN0aW9ucyk7XG4gIGlmIChidXR0b25Ub1JlcGxhY2UpIHtcbiAgICBoaWRlKGJ1dHRvblRvUmVwbGFjZSk7XG4gICAgbG9hZGVyLnNldEF0dHJpYnV0ZSgnZGF0YS1idXR0b24tdG8tcmVwbGFjZScsIGJ1dHRvblRvUmVwbGFjZS5jbGFzc05hbWUpO1xuICAgIGFjdGlvbnMuaW5zZXJ0QmVmb3JlKGxvYWRlciwgYnV0dG9uVG9SZXBsYWNlKTtcbiAgfVxuICBhZGRDbGFzcyhbcG9wdXAsIGFjdGlvbnNdLCBzd2FsQ2xhc3Nlcy5sb2FkaW5nKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTd2VldEFsZXJ0fSBpbnN0YW5jZVxuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gKi9cbmNvbnN0IGhhbmRsZUlucHV0T3B0aW9uc0FuZFZhbHVlID0gKGluc3RhbmNlLCBwYXJhbXMpID0+IHtcbiAgaWYgKHBhcmFtcy5pbnB1dCA9PT0gJ3NlbGVjdCcgfHwgcGFyYW1zLmlucHV0ID09PSAncmFkaW8nKSB7XG4gICAgaGFuZGxlSW5wdXRPcHRpb25zKGluc3RhbmNlLCBwYXJhbXMpO1xuICB9IGVsc2UgaWYgKFsndGV4dCcsICdlbWFpbCcsICdudW1iZXInLCAndGVsJywgJ3RleHRhcmVhJ10uc29tZShpID0+IGkgPT09IHBhcmFtcy5pbnB1dCkgJiYgKGhhc1RvUHJvbWlzZUZuKHBhcmFtcy5pbnB1dFZhbHVlKSB8fCBpc1Byb21pc2UocGFyYW1zLmlucHV0VmFsdWUpKSkge1xuICAgIHNob3dMb2FkaW5nKGdldENvbmZpcm1CdXR0b24oKSk7XG4gICAgaGFuZGxlSW5wdXRWYWx1ZShpbnN0YW5jZSwgcGFyYW1zKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnR9IGluc3RhbmNlXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBpbm5lclBhcmFtc1xuICogQHJldHVybnMge1N3ZWV0QWxlcnRJbnB1dFZhbHVlfVxuICovXG5jb25zdCBnZXRJbnB1dFZhbHVlID0gKGluc3RhbmNlLCBpbm5lclBhcmFtcykgPT4ge1xuICBjb25zdCBpbnB1dCA9IGluc3RhbmNlLmdldElucHV0KCk7XG4gIGlmICghaW5wdXQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBzd2l0Y2ggKGlubmVyUGFyYW1zLmlucHV0KSB7XG4gICAgY2FzZSAnY2hlY2tib3gnOlxuICAgICAgcmV0dXJuIGdldENoZWNrYm94VmFsdWUoaW5wdXQpO1xuICAgIGNhc2UgJ3JhZGlvJzpcbiAgICAgIHJldHVybiBnZXRSYWRpb1ZhbHVlKGlucHV0KTtcbiAgICBjYXNlICdmaWxlJzpcbiAgICAgIHJldHVybiBnZXRGaWxlVmFsdWUoaW5wdXQpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gaW5uZXJQYXJhbXMuaW5wdXRBdXRvVHJpbSA/IGlucHV0LnZhbHVlLnRyaW0oKSA6IGlucHV0LnZhbHVlO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTElucHV0RWxlbWVudH0gaW5wdXRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmNvbnN0IGdldENoZWNrYm94VmFsdWUgPSBpbnB1dCA9PiBpbnB1dC5jaGVja2VkID8gMSA6IDA7XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MSW5wdXRFbGVtZW50fSBpbnB1dFxuICogQHJldHVybnMge3N0cmluZyB8IG51bGx9XG4gKi9cbmNvbnN0IGdldFJhZGlvVmFsdWUgPSBpbnB1dCA9PiBpbnB1dC5jaGVja2VkID8gaW5wdXQudmFsdWUgOiBudWxsO1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTElucHV0RWxlbWVudH0gaW5wdXRcbiAqIEByZXR1cm5zIHtGaWxlTGlzdCB8IEZpbGUgfCBudWxsfVxuICovXG5jb25zdCBnZXRGaWxlVmFsdWUgPSBpbnB1dCA9PiBpbnB1dC5maWxlcyAmJiBpbnB1dC5maWxlcy5sZW5ndGggPyBpbnB1dC5nZXRBdHRyaWJ1dGUoJ211bHRpcGxlJykgIT09IG51bGwgPyBpbnB1dC5maWxlcyA6IGlucHV0LmZpbGVzWzBdIDogbnVsbDtcblxuLyoqXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnR9IGluc3RhbmNlXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAqL1xuY29uc3QgaGFuZGxlSW5wdXRPcHRpb25zID0gKGluc3RhbmNlLCBwYXJhbXMpID0+IHtcbiAgY29uc3QgcG9wdXAgPSBnZXRQb3B1cCgpO1xuICBpZiAoIXBvcHVwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0geyp9IGlucHV0T3B0aW9uc1xuICAgKi9cbiAgY29uc3QgcHJvY2Vzc0lucHV0T3B0aW9ucyA9IGlucHV0T3B0aW9ucyA9PiB7XG4gICAgaWYgKHBhcmFtcy5pbnB1dCA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgIHBvcHVsYXRlU2VsZWN0T3B0aW9ucyhwb3B1cCwgZm9ybWF0SW5wdXRPcHRpb25zKGlucHV0T3B0aW9ucyksIHBhcmFtcyk7XG4gICAgfSBlbHNlIGlmIChwYXJhbXMuaW5wdXQgPT09ICdyYWRpbycpIHtcbiAgICAgIHBvcHVsYXRlUmFkaW9PcHRpb25zKHBvcHVwLCBmb3JtYXRJbnB1dE9wdGlvbnMoaW5wdXRPcHRpb25zKSwgcGFyYW1zKTtcbiAgICB9XG4gIH07XG4gIGlmIChoYXNUb1Byb21pc2VGbihwYXJhbXMuaW5wdXRPcHRpb25zKSB8fCBpc1Byb21pc2UocGFyYW1zLmlucHV0T3B0aW9ucykpIHtcbiAgICBzaG93TG9hZGluZyhnZXRDb25maXJtQnV0dG9uKCkpO1xuICAgIGFzUHJvbWlzZShwYXJhbXMuaW5wdXRPcHRpb25zKS50aGVuKGlucHV0T3B0aW9ucyA9PiB7XG4gICAgICBpbnN0YW5jZS5oaWRlTG9hZGluZygpO1xuICAgICAgcHJvY2Vzc0lucHV0T3B0aW9ucyhpbnB1dE9wdGlvbnMpO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBwYXJhbXMuaW5wdXRPcHRpb25zID09PSAnb2JqZWN0Jykge1xuICAgIHByb2Nlc3NJbnB1dE9wdGlvbnMocGFyYW1zLmlucHV0T3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgZXJyb3IoYFVuZXhwZWN0ZWQgdHlwZSBvZiBpbnB1dE9wdGlvbnMhIEV4cGVjdGVkIG9iamVjdCwgTWFwIG9yIFByb21pc2UsIGdvdCAke3R5cGVvZiBwYXJhbXMuaW5wdXRPcHRpb25zfWApO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3dlZXRBbGVydH0gaW5zdGFuY2VcbiAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICovXG5jb25zdCBoYW5kbGVJbnB1dFZhbHVlID0gKGluc3RhbmNlLCBwYXJhbXMpID0+IHtcbiAgY29uc3QgaW5wdXQgPSBpbnN0YW5jZS5nZXRJbnB1dCgpO1xuICBpZiAoIWlucHV0KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGhpZGUoaW5wdXQpO1xuICBhc1Byb21pc2UocGFyYW1zLmlucHV0VmFsdWUpLnRoZW4oaW5wdXRWYWx1ZSA9PiB7XG4gICAgaW5wdXQudmFsdWUgPSBwYXJhbXMuaW5wdXQgPT09ICdudW1iZXInID8gYCR7cGFyc2VGbG9hdChpbnB1dFZhbHVlKSB8fCAwfWAgOiBgJHtpbnB1dFZhbHVlfWA7XG4gICAgc2hvdyhpbnB1dCk7XG4gICAgaW5wdXQuZm9jdXMoKTtcbiAgICBpbnN0YW5jZS5oaWRlTG9hZGluZygpO1xuICB9KS5jYXRjaChlcnIgPT4ge1xuICAgIGVycm9yKGBFcnJvciBpbiBpbnB1dFZhbHVlIHByb21pc2U6ICR7ZXJyfWApO1xuICAgIGlucHV0LnZhbHVlID0gJyc7XG4gICAgc2hvdyhpbnB1dCk7XG4gICAgaW5wdXQuZm9jdXMoKTtcbiAgICBpbnN0YW5jZS5oaWRlTG9hZGluZygpO1xuICB9KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcG9wdXBcbiAqIEBwYXJhbSB7SW5wdXRPcHRpb25GbGF0dGVuZWRbXX0gaW5wdXRPcHRpb25zXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAqL1xuZnVuY3Rpb24gcG9wdWxhdGVTZWxlY3RPcHRpb25zKHBvcHVwLCBpbnB1dE9wdGlvbnMsIHBhcmFtcykge1xuICBjb25zdCBzZWxlY3QgPSBnZXREaXJlY3RDaGlsZEJ5Q2xhc3MocG9wdXAsIHN3YWxDbGFzc2VzLnNlbGVjdCk7XG4gIGlmICghc2VsZWN0KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJlbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbkxhYmVsXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25WYWx1ZVxuICAgKi9cbiAgY29uc3QgcmVuZGVyT3B0aW9uID0gKHBhcmVudCwgb3B0aW9uTGFiZWwsIG9wdGlvblZhbHVlKSA9PiB7XG4gICAgY29uc3Qgb3B0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb3B0aW9uJyk7XG4gICAgb3B0aW9uLnZhbHVlID0gb3B0aW9uVmFsdWU7XG4gICAgc2V0SW5uZXJIdG1sKG9wdGlvbiwgb3B0aW9uTGFiZWwpO1xuICAgIG9wdGlvbi5zZWxlY3RlZCA9IGlzU2VsZWN0ZWQob3B0aW9uVmFsdWUsIHBhcmFtcy5pbnB1dFZhbHVlKTtcbiAgICBwYXJlbnQuYXBwZW5kQ2hpbGQob3B0aW9uKTtcbiAgfTtcbiAgaW5wdXRPcHRpb25zLmZvckVhY2goaW5wdXRPcHRpb24gPT4ge1xuICAgIGNvbnN0IG9wdGlvblZhbHVlID0gaW5wdXRPcHRpb25bMF07XG4gICAgY29uc3Qgb3B0aW9uTGFiZWwgPSBpbnB1dE9wdGlvblsxXTtcbiAgICAvLyA8b3B0Z3JvdXA+IHNwZWM6XG4gICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw0MDEvaW50ZXJhY3QvZm9ybXMuaHRtbCNoLTE3LjZcbiAgICAvLyBcIi4uLmFsbCBPUFRHUk9VUCBlbGVtZW50cyBtdXN0IGJlIHNwZWNpZmllZCBkaXJlY3RseSB3aXRoaW4gYSBTRUxFQ1QgZWxlbWVudCAoaS5lLiwgZ3JvdXBzIG1heSBub3QgYmUgbmVzdGVkKS4uLlwiXG4gICAgLy8gY2hlY2sgd2hldGhlciB0aGlzIGlzIGEgPG9wdGdyb3VwPlxuICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbkxhYmVsKSkge1xuICAgICAgLy8gaWYgaXQgaXMgYW4gYXJyYXksIHRoZW4gaXQgaXMgYW4gPG9wdGdyb3VwPlxuICAgICAgY29uc3Qgb3B0Z3JvdXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvcHRncm91cCcpO1xuICAgICAgb3B0Z3JvdXAubGFiZWwgPSBvcHRpb25WYWx1ZTtcbiAgICAgIG9wdGdyb3VwLmRpc2FibGVkID0gZmFsc2U7IC8vIG5vdCBjb25maWd1cmFibGUgZm9yIG5vd1xuICAgICAgc2VsZWN0LmFwcGVuZENoaWxkKG9wdGdyb3VwKTtcbiAgICAgIG9wdGlvbkxhYmVsLmZvckVhY2gobyA9PiByZW5kZXJPcHRpb24ob3B0Z3JvdXAsIG9bMV0sIG9bMF0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY2FzZSBvZiA8b3B0aW9uPlxuICAgICAgcmVuZGVyT3B0aW9uKHNlbGVjdCwgb3B0aW9uTGFiZWwsIG9wdGlvblZhbHVlKTtcbiAgICB9XG4gIH0pO1xuICBzZWxlY3QuZm9jdXMoKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwb3B1cFxuICogQHBhcmFtIHtJbnB1dE9wdGlvbkZsYXR0ZW5lZFtdfSBpbnB1dE9wdGlvbnNcbiAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICovXG5mdW5jdGlvbiBwb3B1bGF0ZVJhZGlvT3B0aW9ucyhwb3B1cCwgaW5wdXRPcHRpb25zLCBwYXJhbXMpIHtcbiAgY29uc3QgcmFkaW8gPSBnZXREaXJlY3RDaGlsZEJ5Q2xhc3MocG9wdXAsIHN3YWxDbGFzc2VzLnJhZGlvKTtcbiAgaWYgKCFyYWRpbykge1xuICAgIHJldHVybjtcbiAgfVxuICBpbnB1dE9wdGlvbnMuZm9yRWFjaChpbnB1dE9wdGlvbiA9PiB7XG4gICAgY29uc3QgcmFkaW9WYWx1ZSA9IGlucHV0T3B0aW9uWzBdO1xuICAgIGNvbnN0IHJhZGlvTGFiZWwgPSBpbnB1dE9wdGlvblsxXTtcbiAgICBjb25zdCByYWRpb0lucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICBjb25zdCByYWRpb0xhYmVsRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgcmFkaW9JbnB1dC50eXBlID0gJ3JhZGlvJztcbiAgICByYWRpb0lucHV0Lm5hbWUgPSBzd2FsQ2xhc3Nlcy5yYWRpbztcbiAgICByYWRpb0lucHV0LnZhbHVlID0gcmFkaW9WYWx1ZTtcbiAgICBpZiAoaXNTZWxlY3RlZChyYWRpb1ZhbHVlLCBwYXJhbXMuaW5wdXRWYWx1ZSkpIHtcbiAgICAgIHJhZGlvSW5wdXQuY2hlY2tlZCA9IHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgIHNldElubmVySHRtbChsYWJlbCwgcmFkaW9MYWJlbCk7XG4gICAgbGFiZWwuY2xhc3NOYW1lID0gc3dhbENsYXNzZXMubGFiZWw7XG4gICAgcmFkaW9MYWJlbEVsZW1lbnQuYXBwZW5kQ2hpbGQocmFkaW9JbnB1dCk7XG4gICAgcmFkaW9MYWJlbEVsZW1lbnQuYXBwZW5kQ2hpbGQobGFiZWwpO1xuICAgIHJhZGlvLmFwcGVuZENoaWxkKHJhZGlvTGFiZWxFbGVtZW50KTtcbiAgfSk7XG4gIGNvbnN0IHJhZGlvcyA9IHJhZGlvLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0Jyk7XG4gIGlmIChyYWRpb3MubGVuZ3RoKSB7XG4gICAgcmFkaW9zWzBdLmZvY3VzKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgaW5wdXRPcHRpb25zYCBpbnRvIGFuIGFycmF5IG9mIGBbdmFsdWUsIGxhYmVsXWBzXG4gKlxuICogQHBhcmFtIHsqfSBpbnB1dE9wdGlvbnNcbiAqIEB0eXBlZGVmIHtzdHJpbmdbXX0gSW5wdXRPcHRpb25GbGF0dGVuZWRcbiAqIEByZXR1cm5zIHtJbnB1dE9wdGlvbkZsYXR0ZW5lZFtdfVxuICovXG5jb25zdCBmb3JtYXRJbnB1dE9wdGlvbnMgPSBpbnB1dE9wdGlvbnMgPT4ge1xuICAvKiogQHR5cGUge0lucHV0T3B0aW9uRmxhdHRlbmVkW119ICovXG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBpZiAoaW5wdXRPcHRpb25zIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgaW5wdXRPcHRpb25zLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgIGxldCB2YWx1ZUZvcm1hdHRlZCA9IHZhbHVlO1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZUZvcm1hdHRlZCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgLy8gY2FzZSBvZiA8b3B0Z3JvdXA+XG4gICAgICAgIHZhbHVlRm9ybWF0dGVkID0gZm9ybWF0SW5wdXRPcHRpb25zKHZhbHVlRm9ybWF0dGVkKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wdXNoKFtrZXksIHZhbHVlRm9ybWF0dGVkXSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgT2JqZWN0LmtleXMoaW5wdXRPcHRpb25zKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBsZXQgdmFsdWVGb3JtYXR0ZWQgPSBpbnB1dE9wdGlvbnNba2V5XTtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWVGb3JtYXR0ZWQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vIGNhc2Ugb2YgPG9wdGdyb3VwPlxuICAgICAgICB2YWx1ZUZvcm1hdHRlZCA9IGZvcm1hdElucHV0T3B0aW9ucyh2YWx1ZUZvcm1hdHRlZCk7XG4gICAgICB9XG4gICAgICByZXN1bHQucHVzaChba2V5LCB2YWx1ZUZvcm1hdHRlZF0pO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25WYWx1ZVxuICogQHBhcmFtIHtTd2VldEFsZXJ0SW5wdXRWYWx1ZX0gaW5wdXRWYWx1ZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmNvbnN0IGlzU2VsZWN0ZWQgPSAob3B0aW9uVmFsdWUsIGlucHV0VmFsdWUpID0+IHtcbiAgcmV0dXJuICEhaW5wdXRWYWx1ZSAmJiBpbnB1dFZhbHVlLnRvU3RyaW5nKCkgPT09IG9wdGlvblZhbHVlLnRvU3RyaW5nKCk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3dlZXRBbGVydH0gaW5zdGFuY2VcbiAqL1xuY29uc3QgaGFuZGxlQ29uZmlybUJ1dHRvbkNsaWNrID0gaW5zdGFuY2UgPT4ge1xuICBjb25zdCBpbm5lclBhcmFtcyA9IHByaXZhdGVQcm9wcy5pbm5lclBhcmFtcy5nZXQoaW5zdGFuY2UpO1xuICBpbnN0YW5jZS5kaXNhYmxlQnV0dG9ucygpO1xuICBpZiAoaW5uZXJQYXJhbXMuaW5wdXQpIHtcbiAgICBoYW5kbGVDb25maXJtT3JEZW55V2l0aElucHV0KGluc3RhbmNlLCAnY29uZmlybScpO1xuICB9IGVsc2Uge1xuICAgIGNvbmZpcm0oaW5zdGFuY2UsIHRydWUpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3dlZXRBbGVydH0gaW5zdGFuY2VcbiAqL1xuY29uc3QgaGFuZGxlRGVueUJ1dHRvbkNsaWNrID0gaW5zdGFuY2UgPT4ge1xuICBjb25zdCBpbm5lclBhcmFtcyA9IHByaXZhdGVQcm9wcy5pbm5lclBhcmFtcy5nZXQoaW5zdGFuY2UpO1xuICBpbnN0YW5jZS5kaXNhYmxlQnV0dG9ucygpO1xuICBpZiAoaW5uZXJQYXJhbXMucmV0dXJuSW5wdXRWYWx1ZU9uRGVueSkge1xuICAgIGhhbmRsZUNvbmZpcm1PckRlbnlXaXRoSW5wdXQoaW5zdGFuY2UsICdkZW55Jyk7XG4gIH0gZWxzZSB7XG4gICAgZGVueShpbnN0YW5jZSwgZmFsc2UpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3dlZXRBbGVydH0gaW5zdGFuY2VcbiAqIEBwYXJhbSB7KGRpc21pc3M6IERpc21pc3NSZWFzb24pID0+IHZvaWR9IGRpc21pc3NXaXRoXG4gKi9cbmNvbnN0IGhhbmRsZUNhbmNlbEJ1dHRvbkNsaWNrID0gKGluc3RhbmNlLCBkaXNtaXNzV2l0aCkgPT4ge1xuICBpbnN0YW5jZS5kaXNhYmxlQnV0dG9ucygpO1xuICBkaXNtaXNzV2l0aChEaXNtaXNzUmVhc29uLmNhbmNlbCk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3dlZXRBbGVydH0gaW5zdGFuY2VcbiAqIEBwYXJhbSB7J2NvbmZpcm0nIHwgJ2RlbnknfSB0eXBlXG4gKi9cbmNvbnN0IGhhbmRsZUNvbmZpcm1PckRlbnlXaXRoSW5wdXQgPSAoaW5zdGFuY2UsIHR5cGUpID0+IHtcbiAgY29uc3QgaW5uZXJQYXJhbXMgPSBwcml2YXRlUHJvcHMuaW5uZXJQYXJhbXMuZ2V0KGluc3RhbmNlKTtcbiAgaWYgKCFpbm5lclBhcmFtcy5pbnB1dCkge1xuICAgIGVycm9yKGBUaGUgXCJpbnB1dFwiIHBhcmFtZXRlciBpcyBuZWVkZWQgdG8gYmUgc2V0IHdoZW4gdXNpbmcgcmV0dXJuSW5wdXRWYWx1ZU9uJHtjYXBpdGFsaXplRmlyc3RMZXR0ZXIodHlwZSl9YCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGlucHV0ID0gaW5zdGFuY2UuZ2V0SW5wdXQoKTtcbiAgY29uc3QgaW5wdXRWYWx1ZSA9IGdldElucHV0VmFsdWUoaW5zdGFuY2UsIGlubmVyUGFyYW1zKTtcbiAgaWYgKGlubmVyUGFyYW1zLmlucHV0VmFsaWRhdG9yKSB7XG4gICAgaGFuZGxlSW5wdXRWYWxpZGF0b3IoaW5zdGFuY2UsIGlucHV0VmFsdWUsIHR5cGUpO1xuICB9IGVsc2UgaWYgKGlucHV0ICYmICFpbnB1dC5jaGVja1ZhbGlkaXR5KCkpIHtcbiAgICBpbnN0YW5jZS5lbmFibGVCdXR0b25zKCk7XG4gICAgaW5zdGFuY2Uuc2hvd1ZhbGlkYXRpb25NZXNzYWdlKGlubmVyUGFyYW1zLnZhbGlkYXRpb25NZXNzYWdlIHx8IGlucHV0LnZhbGlkYXRpb25NZXNzYWdlKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnZGVueScpIHtcbiAgICBkZW55KGluc3RhbmNlLCBpbnB1dFZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBjb25maXJtKGluc3RhbmNlLCBpbnB1dFZhbHVlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnR9IGluc3RhbmNlXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRJbnB1dFZhbHVlfSBpbnB1dFZhbHVlXG4gKiBAcGFyYW0geydjb25maXJtJyB8ICdkZW55J30gdHlwZVxuICovXG5jb25zdCBoYW5kbGVJbnB1dFZhbGlkYXRvciA9IChpbnN0YW5jZSwgaW5wdXRWYWx1ZSwgdHlwZSkgPT4ge1xuICBjb25zdCBpbm5lclBhcmFtcyA9IHByaXZhdGVQcm9wcy5pbm5lclBhcmFtcy5nZXQoaW5zdGFuY2UpO1xuICBpbnN0YW5jZS5kaXNhYmxlSW5wdXQoKTtcbiAgY29uc3QgdmFsaWRhdGlvblByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IGFzUHJvbWlzZShpbm5lclBhcmFtcy5pbnB1dFZhbGlkYXRvcihpbnB1dFZhbHVlLCBpbm5lclBhcmFtcy52YWxpZGF0aW9uTWVzc2FnZSkpKTtcbiAgdmFsaWRhdGlvblByb21pc2UudGhlbih2YWxpZGF0aW9uTWVzc2FnZSA9PiB7XG4gICAgaW5zdGFuY2UuZW5hYmxlQnV0dG9ucygpO1xuICAgIGluc3RhbmNlLmVuYWJsZUlucHV0KCk7XG4gICAgaWYgKHZhbGlkYXRpb25NZXNzYWdlKSB7XG4gICAgICBpbnN0YW5jZS5zaG93VmFsaWRhdGlvbk1lc3NhZ2UodmFsaWRhdGlvbk1lc3NhZ2UpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2RlbnknKSB7XG4gICAgICBkZW55KGluc3RhbmNlLCBpbnB1dFZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uZmlybShpbnN0YW5jZSwgaW5wdXRWYWx1ZSk7XG4gICAgfVxuICB9KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTd2VldEFsZXJ0fSBpbnN0YW5jZVxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICovXG5jb25zdCBkZW55ID0gKGluc3RhbmNlLCB2YWx1ZSkgPT4ge1xuICBjb25zdCBpbm5lclBhcmFtcyA9IHByaXZhdGVQcm9wcy5pbm5lclBhcmFtcy5nZXQoaW5zdGFuY2UgfHwgdW5kZWZpbmVkKTtcbiAgaWYgKGlubmVyUGFyYW1zLnNob3dMb2FkZXJPbkRlbnkpIHtcbiAgICBzaG93TG9hZGluZyhnZXREZW55QnV0dG9uKCkpO1xuICB9XG4gIGlmIChpbm5lclBhcmFtcy5wcmVEZW55KSB7XG4gICAgaW5zdGFuY2UuaXNBd2FpdGluZ1Byb21pc2UgPSB0cnVlOyAvLyBGbGFnZ2luZyB0aGUgaW5zdGFuY2UgYXMgYXdhaXRpbmcgYSBwcm9taXNlIHNvIGl0J3Mgb3duIHByb21pc2UncyByZWplY3QvcmVzb2x2ZSBtZXRob2RzIGRvZXNuJ3QgZ2V0IGRlc3Ryb3llZCB1bnRpbCB0aGUgcmVzdWx0IGZyb20gdGhpcyBwcmVEZW55J3MgcHJvbWlzZSBpcyByZWNlaXZlZFxuICAgIGNvbnN0IHByZURlbnlQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiBhc1Byb21pc2UoaW5uZXJQYXJhbXMucHJlRGVueSh2YWx1ZSwgaW5uZXJQYXJhbXMudmFsaWRhdGlvbk1lc3NhZ2UpKSk7XG4gICAgcHJlRGVueVByb21pc2UudGhlbihwcmVEZW55VmFsdWUgPT4ge1xuICAgICAgaWYgKHByZURlbnlWYWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgaW5zdGFuY2UuaGlkZUxvYWRpbmcoKTtcbiAgICAgICAgaGFuZGxlQXdhaXRpbmdQcm9taXNlKGluc3RhbmNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluc3RhbmNlLmNsb3NlKC8qKiBAdHlwZSBTd2VldEFsZXJ0UmVzdWx0ICove1xuICAgICAgICAgIGlzRGVuaWVkOiB0cnVlLFxuICAgICAgICAgIHZhbHVlOiB0eXBlb2YgcHJlRGVueVZhbHVlID09PSAndW5kZWZpbmVkJyA/IHZhbHVlIDogcHJlRGVueVZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pLmNhdGNoKGVycm9yID0+IHJlamVjdFdpdGgoaW5zdGFuY2UgfHwgdW5kZWZpbmVkLCBlcnJvcikpO1xuICB9IGVsc2Uge1xuICAgIGluc3RhbmNlLmNsb3NlKC8qKiBAdHlwZSBTd2VldEFsZXJ0UmVzdWx0ICove1xuICAgICAgaXNEZW5pZWQ6IHRydWUsXG4gICAgICB2YWx1ZVxuICAgIH0pO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3dlZXRBbGVydH0gaW5zdGFuY2VcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqL1xuY29uc3Qgc3VjY2VlZFdpdGggPSAoaW5zdGFuY2UsIHZhbHVlKSA9PiB7XG4gIGluc3RhbmNlLmNsb3NlKC8qKiBAdHlwZSBTd2VldEFsZXJ0UmVzdWx0ICove1xuICAgIGlzQ29uZmlybWVkOiB0cnVlLFxuICAgIHZhbHVlXG4gIH0pO1xufTtcblxuLyoqXG4gKlxuICogQHBhcmFtIHtTd2VldEFsZXJ0fSBpbnN0YW5jZVxuICogQHBhcmFtIHtzdHJpbmd9IGVycm9yXG4gKi9cbmNvbnN0IHJlamVjdFdpdGggPSAoaW5zdGFuY2UsIGVycm9yKSA9PiB7XG4gIGluc3RhbmNlLnJlamVjdFByb21pc2UoZXJyb3IpO1xufTtcblxuLyoqXG4gKlxuICogQHBhcmFtIHtTd2VldEFsZXJ0fSBpbnN0YW5jZVxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICovXG5jb25zdCBjb25maXJtID0gKGluc3RhbmNlLCB2YWx1ZSkgPT4ge1xuICBjb25zdCBpbm5lclBhcmFtcyA9IHByaXZhdGVQcm9wcy5pbm5lclBhcmFtcy5nZXQoaW5zdGFuY2UgfHwgdW5kZWZpbmVkKTtcbiAgaWYgKGlubmVyUGFyYW1zLnNob3dMb2FkZXJPbkNvbmZpcm0pIHtcbiAgICBzaG93TG9hZGluZygpO1xuICB9XG4gIGlmIChpbm5lclBhcmFtcy5wcmVDb25maXJtKSB7XG4gICAgaW5zdGFuY2UucmVzZXRWYWxpZGF0aW9uTWVzc2FnZSgpO1xuICAgIGluc3RhbmNlLmlzQXdhaXRpbmdQcm9taXNlID0gdHJ1ZTsgLy8gRmxhZ2dpbmcgdGhlIGluc3RhbmNlIGFzIGF3YWl0aW5nIGEgcHJvbWlzZSBzbyBpdCdzIG93biBwcm9taXNlJ3MgcmVqZWN0L3Jlc29sdmUgbWV0aG9kcyBkb2Vzbid0IGdldCBkZXN0cm95ZWQgdW50aWwgdGhlIHJlc3VsdCBmcm9tIHRoaXMgcHJlQ29uZmlybSdzIHByb21pc2UgaXMgcmVjZWl2ZWRcbiAgICBjb25zdCBwcmVDb25maXJtUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4gYXNQcm9taXNlKGlubmVyUGFyYW1zLnByZUNvbmZpcm0odmFsdWUsIGlubmVyUGFyYW1zLnZhbGlkYXRpb25NZXNzYWdlKSkpO1xuICAgIHByZUNvbmZpcm1Qcm9taXNlLnRoZW4ocHJlQ29uZmlybVZhbHVlID0+IHtcbiAgICAgIGlmIChpc1Zpc2libGUkMShnZXRWYWxpZGF0aW9uTWVzc2FnZSgpKSB8fCBwcmVDb25maXJtVmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgIGluc3RhbmNlLmhpZGVMb2FkaW5nKCk7XG4gICAgICAgIGhhbmRsZUF3YWl0aW5nUHJvbWlzZShpbnN0YW5jZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdWNjZWVkV2l0aChpbnN0YW5jZSwgdHlwZW9mIHByZUNvbmZpcm1WYWx1ZSA9PT0gJ3VuZGVmaW5lZCcgPyB2YWx1ZSA6IHByZUNvbmZpcm1WYWx1ZSk7XG4gICAgICB9XG4gICAgfSkuY2F0Y2goZXJyb3IgPT4gcmVqZWN0V2l0aChpbnN0YW5jZSB8fCB1bmRlZmluZWQsIGVycm9yKSk7XG4gIH0gZWxzZSB7XG4gICAgc3VjY2VlZFdpdGgoaW5zdGFuY2UsIHZhbHVlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBIaWRlcyBsb2FkZXIgYW5kIHNob3dzIGJhY2sgdGhlIGJ1dHRvbiB3aGljaCB3YXMgaGlkZGVuIGJ5IC5zaG93TG9hZGluZygpXG4gKi9cbmZ1bmN0aW9uIGhpZGVMb2FkaW5nKCkge1xuICAvLyBkbyBub3RoaW5nIGlmIHBvcHVwIGlzIGNsb3NlZFxuICBjb25zdCBpbm5lclBhcmFtcyA9IHByaXZhdGVQcm9wcy5pbm5lclBhcmFtcy5nZXQodGhpcyk7XG4gIGlmICghaW5uZXJQYXJhbXMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgZG9tQ2FjaGUgPSBwcml2YXRlUHJvcHMuZG9tQ2FjaGUuZ2V0KHRoaXMpO1xuICBoaWRlKGRvbUNhY2hlLmxvYWRlcik7XG4gIGlmIChpc1RvYXN0KCkpIHtcbiAgICBpZiAoaW5uZXJQYXJhbXMuaWNvbikge1xuICAgICAgc2hvdyhnZXRJY29uKCkpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzaG93UmVsYXRlZEJ1dHRvbihkb21DYWNoZSk7XG4gIH1cbiAgcmVtb3ZlQ2xhc3MoW2RvbUNhY2hlLnBvcHVwLCBkb21DYWNoZS5hY3Rpb25zXSwgc3dhbENsYXNzZXMubG9hZGluZyk7XG4gIGRvbUNhY2hlLnBvcHVwLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1idXN5Jyk7XG4gIGRvbUNhY2hlLnBvcHVwLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1sb2FkaW5nJyk7XG4gIGRvbUNhY2hlLmNvbmZpcm1CdXR0b24uZGlzYWJsZWQgPSBmYWxzZTtcbiAgZG9tQ2FjaGUuZGVueUJ1dHRvbi5kaXNhYmxlZCA9IGZhbHNlO1xuICBkb21DYWNoZS5jYW5jZWxCdXR0b24uZGlzYWJsZWQgPSBmYWxzZTtcbn1cbmNvbnN0IHNob3dSZWxhdGVkQnV0dG9uID0gZG9tQ2FjaGUgPT4ge1xuICBjb25zdCBidXR0b25Ub1JlcGxhY2UgPSBkb21DYWNoZS5wb3B1cC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGRvbUNhY2hlLmxvYWRlci5nZXRBdHRyaWJ1dGUoJ2RhdGEtYnV0dG9uLXRvLXJlcGxhY2UnKSk7XG4gIGlmIChidXR0b25Ub1JlcGxhY2UubGVuZ3RoKSB7XG4gICAgc2hvdyhidXR0b25Ub1JlcGxhY2VbMF0sICdpbmxpbmUtYmxvY2snKTtcbiAgfSBlbHNlIGlmIChhbGxCdXR0b25zQXJlSGlkZGVuKCkpIHtcbiAgICBoaWRlKGRvbUNhY2hlLmFjdGlvbnMpO1xuICB9XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIGlucHV0IERPTSBub2RlLCB0aGlzIG1ldGhvZCB3b3JrcyB3aXRoIGlucHV0IHBhcmFtZXRlci5cbiAqXG4gKiBAcmV0dXJucyB7SFRNTElucHV0RWxlbWVudCB8IG51bGx9XG4gKi9cbmZ1bmN0aW9uIGdldElucHV0KCkge1xuICBjb25zdCBpbm5lclBhcmFtcyA9IHByaXZhdGVQcm9wcy5pbm5lclBhcmFtcy5nZXQodGhpcyk7XG4gIGNvbnN0IGRvbUNhY2hlID0gcHJpdmF0ZVByb3BzLmRvbUNhY2hlLmdldCh0aGlzKTtcbiAgaWYgKCFkb21DYWNoZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBnZXRJbnB1dCQxKGRvbUNhY2hlLnBvcHVwLCBpbm5lclBhcmFtcy5pbnB1dCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtTd2VldEFsZXJ0fSBpbnN0YW5jZVxuICogQHBhcmFtIHtzdHJpbmdbXX0gYnV0dG9uc1xuICogQHBhcmFtIHtib29sZWFufSBkaXNhYmxlZFxuICovXG5mdW5jdGlvbiBzZXRCdXR0b25zRGlzYWJsZWQoaW5zdGFuY2UsIGJ1dHRvbnMsIGRpc2FibGVkKSB7XG4gIGNvbnN0IGRvbUNhY2hlID0gcHJpdmF0ZVByb3BzLmRvbUNhY2hlLmdldChpbnN0YW5jZSk7XG4gIGJ1dHRvbnMuZm9yRWFjaChidXR0b24gPT4ge1xuICAgIGRvbUNhY2hlW2J1dHRvbl0uZGlzYWJsZWQgPSBkaXNhYmxlZDtcbiAgfSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MSW5wdXRFbGVtZW50IHwgbnVsbH0gaW5wdXRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZGlzYWJsZWRcbiAqL1xuZnVuY3Rpb24gc2V0SW5wdXREaXNhYmxlZChpbnB1dCwgZGlzYWJsZWQpIHtcbiAgY29uc3QgcG9wdXAgPSBnZXRQb3B1cCgpO1xuICBpZiAoIXBvcHVwIHx8ICFpbnB1dCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoaW5wdXQudHlwZSA9PT0gJ3JhZGlvJykge1xuICAgIC8qKiBAdHlwZSB7Tm9kZUxpc3RPZjxIVE1MSW5wdXRFbGVtZW50Pn0gKi9cbiAgICBjb25zdCByYWRpb3MgPSBwb3B1cC5xdWVyeVNlbGVjdG9yQWxsKGBbbmFtZT1cIiR7c3dhbENsYXNzZXMucmFkaW99XCJdYCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYWRpb3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJhZGlvc1tpXS5kaXNhYmxlZCA9IGRpc2FibGVkO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpbnB1dC5kaXNhYmxlZCA9IGRpc2FibGVkO1xuICB9XG59XG5cbi8qKlxuICogRW5hYmxlIGFsbCB0aGUgYnV0dG9uc1xuICogQHRoaXMge1N3ZWV0QWxlcnR9XG4gKi9cbmZ1bmN0aW9uIGVuYWJsZUJ1dHRvbnMoKSB7XG4gIHNldEJ1dHRvbnNEaXNhYmxlZCh0aGlzLCBbJ2NvbmZpcm1CdXR0b24nLCAnZGVueUJ1dHRvbicsICdjYW5jZWxCdXR0b24nXSwgZmFsc2UpO1xufVxuXG4vKipcbiAqIERpc2FibGUgYWxsIHRoZSBidXR0b25zXG4gKiBAdGhpcyB7U3dlZXRBbGVydH1cbiAqL1xuZnVuY3Rpb24gZGlzYWJsZUJ1dHRvbnMoKSB7XG4gIHNldEJ1dHRvbnNEaXNhYmxlZCh0aGlzLCBbJ2NvbmZpcm1CdXR0b24nLCAnZGVueUJ1dHRvbicsICdjYW5jZWxCdXR0b24nXSwgdHJ1ZSk7XG59XG5cbi8qKlxuICogRW5hYmxlIHRoZSBpbnB1dCBmaWVsZFxuICogQHRoaXMge1N3ZWV0QWxlcnR9XG4gKi9cbmZ1bmN0aW9uIGVuYWJsZUlucHV0KCkge1xuICBzZXRJbnB1dERpc2FibGVkKHRoaXMuZ2V0SW5wdXQoKSwgZmFsc2UpO1xufVxuXG4vKipcbiAqIERpc2FibGUgdGhlIGlucHV0IGZpZWxkXG4gKiBAdGhpcyB7U3dlZXRBbGVydH1cbiAqL1xuZnVuY3Rpb24gZGlzYWJsZUlucHV0KCkge1xuICBzZXRJbnB1dERpc2FibGVkKHRoaXMuZ2V0SW5wdXQoKSwgdHJ1ZSk7XG59XG5cbi8qKlxuICogU2hvdyBibG9jayB3aXRoIHZhbGlkYXRpb24gbWVzc2FnZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBlcnJvclxuICogQHRoaXMge1N3ZWV0QWxlcnR9XG4gKi9cbmZ1bmN0aW9uIHNob3dWYWxpZGF0aW9uTWVzc2FnZShlcnJvcikge1xuICBjb25zdCBkb21DYWNoZSA9IHByaXZhdGVQcm9wcy5kb21DYWNoZS5nZXQodGhpcyk7XG4gIGNvbnN0IHBhcmFtcyA9IHByaXZhdGVQcm9wcy5pbm5lclBhcmFtcy5nZXQodGhpcyk7XG4gIHNldElubmVySHRtbChkb21DYWNoZS52YWxpZGF0aW9uTWVzc2FnZSwgZXJyb3IpO1xuICBkb21DYWNoZS52YWxpZGF0aW9uTWVzc2FnZS5jbGFzc05hbWUgPSBzd2FsQ2xhc3Nlc1sndmFsaWRhdGlvbi1tZXNzYWdlJ107XG4gIGlmIChwYXJhbXMuY3VzdG9tQ2xhc3MgJiYgcGFyYW1zLmN1c3RvbUNsYXNzLnZhbGlkYXRpb25NZXNzYWdlKSB7XG4gICAgYWRkQ2xhc3MoZG9tQ2FjaGUudmFsaWRhdGlvbk1lc3NhZ2UsIHBhcmFtcy5jdXN0b21DbGFzcy52YWxpZGF0aW9uTWVzc2FnZSk7XG4gIH1cbiAgc2hvdyhkb21DYWNoZS52YWxpZGF0aW9uTWVzc2FnZSk7XG4gIGNvbnN0IGlucHV0ID0gdGhpcy5nZXRJbnB1dCgpO1xuICBpZiAoaW5wdXQpIHtcbiAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaW52YWxpZCcsICd0cnVlJyk7XG4gICAgaW5wdXQuc2V0QXR0cmlidXRlKCdhcmlhLWRlc2NyaWJlZGJ5Jywgc3dhbENsYXNzZXNbJ3ZhbGlkYXRpb24tbWVzc2FnZSddKTtcbiAgICBmb2N1c0lucHV0KGlucHV0KTtcbiAgICBhZGRDbGFzcyhpbnB1dCwgc3dhbENsYXNzZXMuaW5wdXRlcnJvcik7XG4gIH1cbn1cblxuLyoqXG4gKiBIaWRlIGJsb2NrIHdpdGggdmFsaWRhdGlvbiBtZXNzYWdlXG4gKlxuICogQHRoaXMge1N3ZWV0QWxlcnR9XG4gKi9cbmZ1bmN0aW9uIHJlc2V0VmFsaWRhdGlvbk1lc3NhZ2UoKSB7XG4gIGNvbnN0IGRvbUNhY2hlID0gcHJpdmF0ZVByb3BzLmRvbUNhY2hlLmdldCh0aGlzKTtcbiAgaWYgKGRvbUNhY2hlLnZhbGlkYXRpb25NZXNzYWdlKSB7XG4gICAgaGlkZShkb21DYWNoZS52YWxpZGF0aW9uTWVzc2FnZSk7XG4gIH1cbiAgY29uc3QgaW5wdXQgPSB0aGlzLmdldElucHV0KCk7XG4gIGlmIChpbnB1dCkge1xuICAgIGlucHV0LnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1pbnZhbGlkJyk7XG4gICAgaW5wdXQucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWRlc2NyaWJlZGJ5Jyk7XG4gICAgcmVtb3ZlQ2xhc3MoaW5wdXQsIHN3YWxDbGFzc2VzLmlucHV0ZXJyb3IpO1xuICB9XG59XG5cbmNvbnN0IGRlZmF1bHRQYXJhbXMgPSB7XG4gIHRpdGxlOiAnJyxcbiAgdGl0bGVUZXh0OiAnJyxcbiAgdGV4dDogJycsXG4gIGh0bWw6ICcnLFxuICBmb290ZXI6ICcnLFxuICBpY29uOiB1bmRlZmluZWQsXG4gIGljb25Db2xvcjogdW5kZWZpbmVkLFxuICBpY29uSHRtbDogdW5kZWZpbmVkLFxuICB0ZW1wbGF0ZTogdW5kZWZpbmVkLFxuICB0b2FzdDogZmFsc2UsXG4gIGRyYWdnYWJsZTogZmFsc2UsXG4gIGFuaW1hdGlvbjogdHJ1ZSxcbiAgdGhlbWU6ICdsaWdodCcsXG4gIHNob3dDbGFzczoge1xuICAgIHBvcHVwOiAnc3dhbDItc2hvdycsXG4gICAgYmFja2Ryb3A6ICdzd2FsMi1iYWNrZHJvcC1zaG93JyxcbiAgICBpY29uOiAnc3dhbDItaWNvbi1zaG93J1xuICB9LFxuICBoaWRlQ2xhc3M6IHtcbiAgICBwb3B1cDogJ3N3YWwyLWhpZGUnLFxuICAgIGJhY2tkcm9wOiAnc3dhbDItYmFja2Ryb3AtaGlkZScsXG4gICAgaWNvbjogJ3N3YWwyLWljb24taGlkZSdcbiAgfSxcbiAgY3VzdG9tQ2xhc3M6IHt9LFxuICB0YXJnZXQ6ICdib2R5JyxcbiAgY29sb3I6IHVuZGVmaW5lZCxcbiAgYmFja2Ryb3A6IHRydWUsXG4gIGhlaWdodEF1dG86IHRydWUsXG4gIGFsbG93T3V0c2lkZUNsaWNrOiB0cnVlLFxuICBhbGxvd0VzY2FwZUtleTogdHJ1ZSxcbiAgYWxsb3dFbnRlcktleTogdHJ1ZSxcbiAgc3RvcEtleWRvd25Qcm9wYWdhdGlvbjogdHJ1ZSxcbiAga2V5ZG93bkxpc3RlbmVyQ2FwdHVyZTogZmFsc2UsXG4gIHNob3dDb25maXJtQnV0dG9uOiB0cnVlLFxuICBzaG93RGVueUJ1dHRvbjogZmFsc2UsXG4gIHNob3dDYW5jZWxCdXR0b246IGZhbHNlLFxuICBwcmVDb25maXJtOiB1bmRlZmluZWQsXG4gIHByZURlbnk6IHVuZGVmaW5lZCxcbiAgY29uZmlybUJ1dHRvblRleHQ6ICdPSycsXG4gIGNvbmZpcm1CdXR0b25BcmlhTGFiZWw6ICcnLFxuICBjb25maXJtQnV0dG9uQ29sb3I6IHVuZGVmaW5lZCxcbiAgZGVueUJ1dHRvblRleHQ6ICdObycsXG4gIGRlbnlCdXR0b25BcmlhTGFiZWw6ICcnLFxuICBkZW55QnV0dG9uQ29sb3I6IHVuZGVmaW5lZCxcbiAgY2FuY2VsQnV0dG9uVGV4dDogJ0NhbmNlbCcsXG4gIGNhbmNlbEJ1dHRvbkFyaWFMYWJlbDogJycsXG4gIGNhbmNlbEJ1dHRvbkNvbG9yOiB1bmRlZmluZWQsXG4gIGJ1dHRvbnNTdHlsaW5nOiB0cnVlLFxuICByZXZlcnNlQnV0dG9uczogZmFsc2UsXG4gIGZvY3VzQ29uZmlybTogdHJ1ZSxcbiAgZm9jdXNEZW55OiBmYWxzZSxcbiAgZm9jdXNDYW5jZWw6IGZhbHNlLFxuICByZXR1cm5Gb2N1czogdHJ1ZSxcbiAgc2hvd0Nsb3NlQnV0dG9uOiBmYWxzZSxcbiAgY2xvc2VCdXR0b25IdG1sOiAnJnRpbWVzOycsXG4gIGNsb3NlQnV0dG9uQXJpYUxhYmVsOiAnQ2xvc2UgdGhpcyBkaWFsb2cnLFxuICBsb2FkZXJIdG1sOiAnJyxcbiAgc2hvd0xvYWRlck9uQ29uZmlybTogZmFsc2UsXG4gIHNob3dMb2FkZXJPbkRlbnk6IGZhbHNlLFxuICBpbWFnZVVybDogdW5kZWZpbmVkLFxuICBpbWFnZVdpZHRoOiB1bmRlZmluZWQsXG4gIGltYWdlSGVpZ2h0OiB1bmRlZmluZWQsXG4gIGltYWdlQWx0OiAnJyxcbiAgdGltZXI6IHVuZGVmaW5lZCxcbiAgdGltZXJQcm9ncmVzc0JhcjogZmFsc2UsXG4gIHdpZHRoOiB1bmRlZmluZWQsXG4gIHBhZGRpbmc6IHVuZGVmaW5lZCxcbiAgYmFja2dyb3VuZDogdW5kZWZpbmVkLFxuICBpbnB1dDogdW5kZWZpbmVkLFxuICBpbnB1dFBsYWNlaG9sZGVyOiAnJyxcbiAgaW5wdXRMYWJlbDogJycsXG4gIGlucHV0VmFsdWU6ICcnLFxuICBpbnB1dE9wdGlvbnM6IHt9LFxuICBpbnB1dEF1dG9Gb2N1czogdHJ1ZSxcbiAgaW5wdXRBdXRvVHJpbTogdHJ1ZSxcbiAgaW5wdXRBdHRyaWJ1dGVzOiB7fSxcbiAgaW5wdXRWYWxpZGF0b3I6IHVuZGVmaW5lZCxcbiAgcmV0dXJuSW5wdXRWYWx1ZU9uRGVueTogZmFsc2UsXG4gIHZhbGlkYXRpb25NZXNzYWdlOiB1bmRlZmluZWQsXG4gIGdyb3c6IGZhbHNlLFxuICBwb3NpdGlvbjogJ2NlbnRlcicsXG4gIHByb2dyZXNzU3RlcHM6IFtdLFxuICBjdXJyZW50UHJvZ3Jlc3NTdGVwOiB1bmRlZmluZWQsXG4gIHByb2dyZXNzU3RlcHNEaXN0YW5jZTogdW5kZWZpbmVkLFxuICB3aWxsT3BlbjogdW5kZWZpbmVkLFxuICBkaWRPcGVuOiB1bmRlZmluZWQsXG4gIGRpZFJlbmRlcjogdW5kZWZpbmVkLFxuICB3aWxsQ2xvc2U6IHVuZGVmaW5lZCxcbiAgZGlkQ2xvc2U6IHVuZGVmaW5lZCxcbiAgZGlkRGVzdHJveTogdW5kZWZpbmVkLFxuICBzY3JvbGxiYXJQYWRkaW5nOiB0cnVlLFxuICB0b3BMYXllcjogZmFsc2Vcbn07XG5jb25zdCB1cGRhdGFibGVQYXJhbXMgPSBbJ2FsbG93RXNjYXBlS2V5JywgJ2FsbG93T3V0c2lkZUNsaWNrJywgJ2JhY2tncm91bmQnLCAnYnV0dG9uc1N0eWxpbmcnLCAnY2FuY2VsQnV0dG9uQXJpYUxhYmVsJywgJ2NhbmNlbEJ1dHRvbkNvbG9yJywgJ2NhbmNlbEJ1dHRvblRleHQnLCAnY2xvc2VCdXR0b25BcmlhTGFiZWwnLCAnY2xvc2VCdXR0b25IdG1sJywgJ2NvbG9yJywgJ2NvbmZpcm1CdXR0b25BcmlhTGFiZWwnLCAnY29uZmlybUJ1dHRvbkNvbG9yJywgJ2NvbmZpcm1CdXR0b25UZXh0JywgJ2N1cnJlbnRQcm9ncmVzc1N0ZXAnLCAnY3VzdG9tQ2xhc3MnLCAnZGVueUJ1dHRvbkFyaWFMYWJlbCcsICdkZW55QnV0dG9uQ29sb3InLCAnZGVueUJ1dHRvblRleHQnLCAnZGlkQ2xvc2UnLCAnZGlkRGVzdHJveScsICdkcmFnZ2FibGUnLCAnZm9vdGVyJywgJ2hpZGVDbGFzcycsICdodG1sJywgJ2ljb24nLCAnaWNvbkNvbG9yJywgJ2ljb25IdG1sJywgJ2ltYWdlQWx0JywgJ2ltYWdlSGVpZ2h0JywgJ2ltYWdlVXJsJywgJ2ltYWdlV2lkdGgnLCAncHJlQ29uZmlybScsICdwcmVEZW55JywgJ3Byb2dyZXNzU3RlcHMnLCAncmV0dXJuRm9jdXMnLCAncmV2ZXJzZUJ1dHRvbnMnLCAnc2hvd0NhbmNlbEJ1dHRvbicsICdzaG93Q2xvc2VCdXR0b24nLCAnc2hvd0NvbmZpcm1CdXR0b24nLCAnc2hvd0RlbnlCdXR0b24nLCAndGV4dCcsICd0aXRsZScsICd0aXRsZVRleHQnLCAndGhlbWUnLCAnd2lsbENsb3NlJ107XG5cbi8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgc3RyaW5nIHwgdW5kZWZpbmVkPn0gKi9cbmNvbnN0IGRlcHJlY2F0ZWRQYXJhbXMgPSB7XG4gIGFsbG93RW50ZXJLZXk6IHVuZGVmaW5lZFxufTtcbmNvbnN0IHRvYXN0SW5jb21wYXRpYmxlUGFyYW1zID0gWydhbGxvd091dHNpZGVDbGljaycsICdhbGxvd0VudGVyS2V5JywgJ2JhY2tkcm9wJywgJ2RyYWdnYWJsZScsICdmb2N1c0NvbmZpcm0nLCAnZm9jdXNEZW55JywgJ2ZvY3VzQ2FuY2VsJywgJ3JldHVybkZvY3VzJywgJ2hlaWdodEF1dG8nLCAna2V5ZG93bkxpc3RlbmVyQ2FwdHVyZSddO1xuXG4vKipcbiAqIElzIHZhbGlkIHBhcmFtZXRlclxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbU5hbWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5jb25zdCBpc1ZhbGlkUGFyYW1ldGVyID0gcGFyYW1OYW1lID0+IHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkZWZhdWx0UGFyYW1zLCBwYXJhbU5hbWUpO1xufTtcblxuLyoqXG4gKiBJcyB2YWxpZCBwYXJhbWV0ZXIgZm9yIFN3YWwudXBkYXRlKCkgbWV0aG9kXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtTmFtZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmNvbnN0IGlzVXBkYXRhYmxlUGFyYW1ldGVyID0gcGFyYW1OYW1lID0+IHtcbiAgcmV0dXJuIHVwZGF0YWJsZVBhcmFtcy5pbmRleE9mKHBhcmFtTmFtZSkgIT09IC0xO1xufTtcblxuLyoqXG4gKiBJcyBkZXByZWNhdGVkIHBhcmFtZXRlclxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbU5hbWVcbiAqIEByZXR1cm5zIHtzdHJpbmcgfCB1bmRlZmluZWR9XG4gKi9cbmNvbnN0IGlzRGVwcmVjYXRlZFBhcmFtZXRlciA9IHBhcmFtTmFtZSA9PiB7XG4gIHJldHVybiBkZXByZWNhdGVkUGFyYW1zW3BhcmFtTmFtZV07XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbVxuICovXG5jb25zdCBjaGVja0lmUGFyYW1Jc1ZhbGlkID0gcGFyYW0gPT4ge1xuICBpZiAoIWlzVmFsaWRQYXJhbWV0ZXIocGFyYW0pKSB7XG4gICAgd2FybihgVW5rbm93biBwYXJhbWV0ZXIgXCIke3BhcmFtfVwiYCk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtXG4gKi9cbmNvbnN0IGNoZWNrSWZUb2FzdFBhcmFtSXNWYWxpZCA9IHBhcmFtID0+IHtcbiAgaWYgKHRvYXN0SW5jb21wYXRpYmxlUGFyYW1zLmluY2x1ZGVzKHBhcmFtKSkge1xuICAgIHdhcm4oYFRoZSBwYXJhbWV0ZXIgXCIke3BhcmFtfVwiIGlzIGluY29tcGF0aWJsZSB3aXRoIHRvYXN0c2ApO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbVxuICovXG5jb25zdCBjaGVja0lmUGFyYW1Jc0RlcHJlY2F0ZWQgPSBwYXJhbSA9PiB7XG4gIGNvbnN0IGlzRGVwcmVjYXRlZCA9IGlzRGVwcmVjYXRlZFBhcmFtZXRlcihwYXJhbSk7XG4gIGlmIChpc0RlcHJlY2F0ZWQpIHtcbiAgICB3YXJuQWJvdXREZXByZWNhdGlvbihwYXJhbSwgaXNEZXByZWNhdGVkKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTaG93IHJlbGV2YW50IHdhcm5pbmdzIGZvciBnaXZlbiBwYXJhbXNcbiAqXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAqL1xuY29uc3Qgc2hvd1dhcm5pbmdzRm9yUGFyYW1zID0gcGFyYW1zID0+IHtcbiAgaWYgKHBhcmFtcy5iYWNrZHJvcCA9PT0gZmFsc2UgJiYgcGFyYW1zLmFsbG93T3V0c2lkZUNsaWNrKSB7XG4gICAgd2FybignXCJhbGxvd091dHNpZGVDbGlja1wiIHBhcmFtZXRlciByZXF1aXJlcyBgYmFja2Ryb3BgIHBhcmFtZXRlciB0byBiZSBzZXQgdG8gYHRydWVgJyk7XG4gIH1cbiAgaWYgKHBhcmFtcy50aGVtZSAmJiAhWydsaWdodCcsICdkYXJrJywgJ2F1dG8nLCAnbWluaW1hbCcsICdib3JkZXJsZXNzJywgJ2Jvb3RzdHJhcC00JywgJ2Jvb3RzdHJhcC00LWxpZ2h0JywgJ2Jvb3RzdHJhcC00LWRhcmsnLCAnYm9vdHN0cmFwLTUnLCAnYm9vdHN0cmFwLTUtbGlnaHQnLCAnYm9vdHN0cmFwLTUtZGFyaycsICdtYXRlcmlhbC11aScsICdtYXRlcmlhbC11aS1saWdodCcsICdtYXRlcmlhbC11aS1kYXJrJywgJ2VtYmVkLWlmcmFtZScsICdidWxtYScsICdidWxtYS1saWdodCcsICdidWxtYS1kYXJrJ10uaW5jbHVkZXMocGFyYW1zLnRoZW1lKSkge1xuICAgIHdhcm4oYEludmFsaWQgdGhlbWUgXCIke3BhcmFtcy50aGVtZX1cImApO1xuICB9XG4gIGZvciAoY29uc3QgcGFyYW0gaW4gcGFyYW1zKSB7XG4gICAgY2hlY2tJZlBhcmFtSXNWYWxpZChwYXJhbSk7XG4gICAgaWYgKHBhcmFtcy50b2FzdCkge1xuICAgICAgY2hlY2tJZlRvYXN0UGFyYW1Jc1ZhbGlkKHBhcmFtKTtcbiAgICB9XG4gICAgY2hlY2tJZlBhcmFtSXNEZXByZWNhdGVkKHBhcmFtKTtcbiAgfVxufTtcblxuLyoqXG4gKiBVcGRhdGVzIHBvcHVwIHBhcmFtZXRlcnMuXG4gKlxuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZShwYXJhbXMpIHtcbiAgY29uc3QgY29udGFpbmVyID0gZ2V0Q29udGFpbmVyKCk7XG4gIGNvbnN0IHBvcHVwID0gZ2V0UG9wdXAoKTtcbiAgY29uc3QgaW5uZXJQYXJhbXMgPSBwcml2YXRlUHJvcHMuaW5uZXJQYXJhbXMuZ2V0KHRoaXMpO1xuICBpZiAoIXBvcHVwIHx8IGhhc0NsYXNzKHBvcHVwLCBpbm5lclBhcmFtcy5oaWRlQ2xhc3MucG9wdXApKSB7XG4gICAgd2FybihgWW91J3JlIHRyeWluZyB0byB1cGRhdGUgdGhlIGNsb3NlZCBvciBjbG9zaW5nIHBvcHVwLCB0aGF0IHdvbid0IHdvcmsuIFVzZSB0aGUgdXBkYXRlKCkgbWV0aG9kIGluIHByZUNvbmZpcm0gcGFyYW1ldGVyIG9yIHNob3cgYSBuZXcgcG9wdXAuYCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHZhbGlkVXBkYXRhYmxlUGFyYW1zID0gZmlsdGVyVmFsaWRQYXJhbXMocGFyYW1zKTtcbiAgY29uc3QgdXBkYXRlZFBhcmFtcyA9IE9iamVjdC5hc3NpZ24oe30sIGlubmVyUGFyYW1zLCB2YWxpZFVwZGF0YWJsZVBhcmFtcyk7XG4gIHNob3dXYXJuaW5nc0ZvclBhcmFtcyh1cGRhdGVkUGFyYW1zKTtcbiAgY29udGFpbmVyLmRhdGFzZXRbJ3N3YWwyVGhlbWUnXSA9IHVwZGF0ZWRQYXJhbXMudGhlbWU7XG4gIHJlbmRlcih0aGlzLCB1cGRhdGVkUGFyYW1zKTtcbiAgcHJpdmF0ZVByb3BzLmlubmVyUGFyYW1zLnNldCh0aGlzLCB1cGRhdGVkUGFyYW1zKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgIHBhcmFtczoge1xuICAgICAgdmFsdWU6IE9iamVjdC5hc3NpZ24oe30sIHRoaXMucGFyYW1zLCBwYXJhbXMpLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gKiBAcmV0dXJucyB7U3dlZXRBbGVydE9wdGlvbnN9XG4gKi9cbmNvbnN0IGZpbHRlclZhbGlkUGFyYW1zID0gcGFyYW1zID0+IHtcbiAgY29uc3QgdmFsaWRVcGRhdGFibGVQYXJhbXMgPSB7fTtcbiAgT2JqZWN0LmtleXMocGFyYW1zKS5mb3JFYWNoKHBhcmFtID0+IHtcbiAgICBpZiAoaXNVcGRhdGFibGVQYXJhbWV0ZXIocGFyYW0pKSB7XG4gICAgICB2YWxpZFVwZGF0YWJsZVBhcmFtc1twYXJhbV0gPSBwYXJhbXNbcGFyYW1dO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuKGBJbnZhbGlkIHBhcmFtZXRlciB0byB1cGRhdGU6ICR7cGFyYW19YCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHZhbGlkVXBkYXRhYmxlUGFyYW1zO1xufTtcblxuLyoqXG4gKiBEaXNwb3NlIHRoZSBjdXJyZW50IFN3ZWV0QWxlcnQyIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIF9kZXN0cm95KCkge1xuICBjb25zdCBkb21DYWNoZSA9IHByaXZhdGVQcm9wcy5kb21DYWNoZS5nZXQodGhpcyk7XG4gIGNvbnN0IGlubmVyUGFyYW1zID0gcHJpdmF0ZVByb3BzLmlubmVyUGFyYW1zLmdldCh0aGlzKTtcbiAgaWYgKCFpbm5lclBhcmFtcykge1xuICAgIGRpc3Bvc2VXZWFrTWFwcyh0aGlzKTsgLy8gVGhlIFdlYWtNYXBzIG1pZ2h0IGhhdmUgYmVlbiBwYXJ0bHkgZGVzdHJveWVkLCB3ZSBtdXN0IHJlY2FsbCBpdCB0byBkaXNwb3NlIGFueSByZW1haW5pbmcgV2Vha01hcHMgIzIzMzVcbiAgICByZXR1cm47IC8vIFRoaXMgaW5zdGFuY2UgaGFzIGFscmVhZHkgYmVlbiBkZXN0cm95ZWRcbiAgfVxuXG4gIC8vIENoZWNrIGlmIHRoZXJlIGlzIGFub3RoZXIgU3dhbCBjbG9zaW5nXG4gIGlmIChkb21DYWNoZS5wb3B1cCAmJiBnbG9iYWxTdGF0ZS5zd2FsQ2xvc2VFdmVudEZpbmlzaGVkQ2FsbGJhY2spIHtcbiAgICBnbG9iYWxTdGF0ZS5zd2FsQ2xvc2VFdmVudEZpbmlzaGVkQ2FsbGJhY2soKTtcbiAgICBkZWxldGUgZ2xvYmFsU3RhdGUuc3dhbENsb3NlRXZlbnRGaW5pc2hlZENhbGxiYWNrO1xuICB9XG4gIGlmICh0eXBlb2YgaW5uZXJQYXJhbXMuZGlkRGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlubmVyUGFyYW1zLmRpZERlc3Ryb3koKTtcbiAgfVxuICBnbG9iYWxTdGF0ZS5ldmVudEVtaXR0ZXIuZW1pdCgnZGlkRGVzdHJveScpO1xuICBkaXNwb3NlU3dhbCh0aGlzKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnR9IGluc3RhbmNlXG4gKi9cbmNvbnN0IGRpc3Bvc2VTd2FsID0gaW5zdGFuY2UgPT4ge1xuICBkaXNwb3NlV2Vha01hcHMoaW5zdGFuY2UpO1xuICAvLyBVbnNldCB0aGlzLnBhcmFtcyBzbyBHQyB3aWxsIGRpc3Bvc2UgaXQgKCMxNTY5KVxuICBkZWxldGUgaW5zdGFuY2UucGFyYW1zO1xuICAvLyBVbnNldCBnbG9iYWxTdGF0ZSBwcm9wcyBzbyBHQyB3aWxsIGRpc3Bvc2UgZ2xvYmFsU3RhdGUgKCMxNTY5KVxuICBkZWxldGUgZ2xvYmFsU3RhdGUua2V5ZG93bkhhbmRsZXI7XG4gIGRlbGV0ZSBnbG9iYWxTdGF0ZS5rZXlkb3duVGFyZ2V0O1xuICAvLyBVbnNldCBjdXJyZW50SW5zdGFuY2VcbiAgZGVsZXRlIGdsb2JhbFN0YXRlLmN1cnJlbnRJbnN0YW5jZTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTd2VldEFsZXJ0fSBpbnN0YW5jZVxuICovXG5jb25zdCBkaXNwb3NlV2Vha01hcHMgPSBpbnN0YW5jZSA9PiB7XG4gIC8vIElmIHRoZSBjdXJyZW50IGluc3RhbmNlIGlzIGF3YWl0aW5nIGEgcHJvbWlzZSByZXN1bHQsIHdlIGtlZXAgdGhlIHByaXZhdGVNZXRob2RzIHRvIGNhbGwgdGhlbSBvbmNlIHRoZSBwcm9taXNlIHJlc3VsdCBpcyByZXRyaWV2ZWQgIzIzMzVcbiAgaWYgKGluc3RhbmNlLmlzQXdhaXRpbmdQcm9taXNlKSB7XG4gICAgdW5zZXRXZWFrTWFwcyhwcml2YXRlUHJvcHMsIGluc3RhbmNlKTtcbiAgICBpbnN0YW5jZS5pc0F3YWl0aW5nUHJvbWlzZSA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgdW5zZXRXZWFrTWFwcyhwcml2YXRlTWV0aG9kcywgaW5zdGFuY2UpO1xuICAgIHVuc2V0V2Vha01hcHMocHJpdmF0ZVByb3BzLCBpbnN0YW5jZSk7XG4gICAgZGVsZXRlIGluc3RhbmNlLmlzQXdhaXRpbmdQcm9taXNlO1xuICAgIC8vIFVuc2V0IGluc3RhbmNlIG1ldGhvZHNcbiAgICBkZWxldGUgaW5zdGFuY2UuZGlzYWJsZUJ1dHRvbnM7XG4gICAgZGVsZXRlIGluc3RhbmNlLmVuYWJsZUJ1dHRvbnM7XG4gICAgZGVsZXRlIGluc3RhbmNlLmdldElucHV0O1xuICAgIGRlbGV0ZSBpbnN0YW5jZS5kaXNhYmxlSW5wdXQ7XG4gICAgZGVsZXRlIGluc3RhbmNlLmVuYWJsZUlucHV0O1xuICAgIGRlbGV0ZSBpbnN0YW5jZS5oaWRlTG9hZGluZztcbiAgICBkZWxldGUgaW5zdGFuY2UuZGlzYWJsZUxvYWRpbmc7XG4gICAgZGVsZXRlIGluc3RhbmNlLnNob3dWYWxpZGF0aW9uTWVzc2FnZTtcbiAgICBkZWxldGUgaW5zdGFuY2UucmVzZXRWYWxpZGF0aW9uTWVzc2FnZTtcbiAgICBkZWxldGUgaW5zdGFuY2UuY2xvc2U7XG4gICAgZGVsZXRlIGluc3RhbmNlLmNsb3NlUG9wdXA7XG4gICAgZGVsZXRlIGluc3RhbmNlLmNsb3NlTW9kYWw7XG4gICAgZGVsZXRlIGluc3RhbmNlLmNsb3NlVG9hc3Q7XG4gICAgZGVsZXRlIGluc3RhbmNlLnJlamVjdFByb21pc2U7XG4gICAgZGVsZXRlIGluc3RhbmNlLnVwZGF0ZTtcbiAgICBkZWxldGUgaW5zdGFuY2UuX2Rlc3Ryb3k7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IG9ialxuICogQHBhcmFtIHtTd2VldEFsZXJ0fSBpbnN0YW5jZVxuICovXG5jb25zdCB1bnNldFdlYWtNYXBzID0gKG9iaiwgaW5zdGFuY2UpID0+IHtcbiAgZm9yIChjb25zdCBpIGluIG9iaikge1xuICAgIG9ialtpXS5kZWxldGUoaW5zdGFuY2UpO1xuICB9XG59O1xuXG52YXIgaW5zdGFuY2VNZXRob2RzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIF9kZXN0cm95OiBfZGVzdHJveSxcbiAgY2xvc2U6IGNsb3NlLFxuICBjbG9zZU1vZGFsOiBjbG9zZSxcbiAgY2xvc2VQb3B1cDogY2xvc2UsXG4gIGNsb3NlVG9hc3Q6IGNsb3NlLFxuICBkaXNhYmxlQnV0dG9uczogZGlzYWJsZUJ1dHRvbnMsXG4gIGRpc2FibGVJbnB1dDogZGlzYWJsZUlucHV0LFxuICBkaXNhYmxlTG9hZGluZzogaGlkZUxvYWRpbmcsXG4gIGVuYWJsZUJ1dHRvbnM6IGVuYWJsZUJ1dHRvbnMsXG4gIGVuYWJsZUlucHV0OiBlbmFibGVJbnB1dCxcbiAgZ2V0SW5wdXQ6IGdldElucHV0LFxuICBoYW5kbGVBd2FpdGluZ1Byb21pc2U6IGhhbmRsZUF3YWl0aW5nUHJvbWlzZSxcbiAgaGlkZUxvYWRpbmc6IGhpZGVMb2FkaW5nLFxuICByZWplY3RQcm9taXNlOiByZWplY3RQcm9taXNlLFxuICByZXNldFZhbGlkYXRpb25NZXNzYWdlOiByZXNldFZhbGlkYXRpb25NZXNzYWdlLFxuICBzaG93VmFsaWRhdGlvbk1lc3NhZ2U6IHNob3dWYWxpZGF0aW9uTWVzc2FnZSxcbiAgdXBkYXRlOiB1cGRhdGVcbn0pO1xuXG4vKipcbiAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IGlubmVyUGFyYW1zXG4gKiBAcGFyYW0ge0RvbUNhY2hlfSBkb21DYWNoZVxuICogQHBhcmFtIHsoZGlzbWlzczogRGlzbWlzc1JlYXNvbikgPT4gdm9pZH0gZGlzbWlzc1dpdGhcbiAqL1xuY29uc3QgaGFuZGxlUG9wdXBDbGljayA9IChpbm5lclBhcmFtcywgZG9tQ2FjaGUsIGRpc21pc3NXaXRoKSA9PiB7XG4gIGlmIChpbm5lclBhcmFtcy50b2FzdCkge1xuICAgIGhhbmRsZVRvYXN0Q2xpY2soaW5uZXJQYXJhbXMsIGRvbUNhY2hlLCBkaXNtaXNzV2l0aCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gSWdub3JlIGNsaWNrIGV2ZW50cyB0aGF0IGhhZCBtb3VzZWRvd24gb24gdGhlIHBvcHVwIGJ1dCBtb3VzZXVwIG9uIHRoZSBjb250YWluZXJcbiAgICAvLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiB0aGUgdXNlciBkcmFncyBhIHNsaWRlclxuICAgIGhhbmRsZU1vZGFsTW91c2Vkb3duKGRvbUNhY2hlKTtcblxuICAgIC8vIElnbm9yZSBjbGljayBldmVudHMgdGhhdCBoYWQgbW91c2Vkb3duIG9uIHRoZSBjb250YWluZXIgYnV0IG1vdXNldXAgb24gdGhlIHBvcHVwXG4gICAgaGFuZGxlQ29udGFpbmVyTW91c2Vkb3duKGRvbUNhY2hlKTtcbiAgICBoYW5kbGVNb2RhbENsaWNrKGlubmVyUGFyYW1zLCBkb21DYWNoZSwgZGlzbWlzc1dpdGgpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IGlubmVyUGFyYW1zXG4gKiBAcGFyYW0ge0RvbUNhY2hlfSBkb21DYWNoZVxuICogQHBhcmFtIHsoZGlzbWlzczogRGlzbWlzc1JlYXNvbikgPT4gdm9pZH0gZGlzbWlzc1dpdGhcbiAqL1xuY29uc3QgaGFuZGxlVG9hc3RDbGljayA9IChpbm5lclBhcmFtcywgZG9tQ2FjaGUsIGRpc21pc3NXaXRoKSA9PiB7XG4gIC8vIENsb3NpbmcgdG9hc3QgYnkgaW50ZXJuYWwgY2xpY2tcbiAgZG9tQ2FjaGUucG9wdXAub25jbGljayA9ICgpID0+IHtcbiAgICBpZiAoaW5uZXJQYXJhbXMgJiYgKGlzQW55QnV0dG9uU2hvd24oaW5uZXJQYXJhbXMpIHx8IGlubmVyUGFyYW1zLnRpbWVyIHx8IGlubmVyUGFyYW1zLmlucHV0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaXNtaXNzV2l0aChEaXNtaXNzUmVhc29uLmNsb3NlKTtcbiAgfTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gaW5uZXJQYXJhbXNcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5jb25zdCBpc0FueUJ1dHRvblNob3duID0gaW5uZXJQYXJhbXMgPT4ge1xuICByZXR1cm4gISEoaW5uZXJQYXJhbXMuc2hvd0NvbmZpcm1CdXR0b24gfHwgaW5uZXJQYXJhbXMuc2hvd0RlbnlCdXR0b24gfHwgaW5uZXJQYXJhbXMuc2hvd0NhbmNlbEJ1dHRvbiB8fCBpbm5lclBhcmFtcy5zaG93Q2xvc2VCdXR0b24pO1xufTtcbmxldCBpZ25vcmVPdXRzaWRlQ2xpY2sgPSBmYWxzZTtcblxuLyoqXG4gKiBAcGFyYW0ge0RvbUNhY2hlfSBkb21DYWNoZVxuICovXG5jb25zdCBoYW5kbGVNb2RhbE1vdXNlZG93biA9IGRvbUNhY2hlID0+IHtcbiAgZG9tQ2FjaGUucG9wdXAub25tb3VzZWRvd24gPSAoKSA9PiB7XG4gICAgZG9tQ2FjaGUuY29udGFpbmVyLm9ubW91c2V1cCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBkb21DYWNoZS5jb250YWluZXIub25tb3VzZXVwID0gKCkgPT4ge307XG4gICAgICAvLyBXZSBvbmx5IGNoZWNrIGlmIHRoZSBtb3VzZXVwIHRhcmdldCBpcyB0aGUgY29udGFpbmVyIGJlY2F1c2UgdXN1YWxseSBpdCBkb2Vzbid0XG4gICAgICAvLyBoYXZlIGFueSBvdGhlciBkaXJlY3QgY2hpbGRyZW4gYXNpZGUgb2YgdGhlIHBvcHVwXG4gICAgICBpZiAoZS50YXJnZXQgPT09IGRvbUNhY2hlLmNvbnRhaW5lcikge1xuICAgICAgICBpZ25vcmVPdXRzaWRlQ2xpY2sgPSB0cnVlO1xuICAgICAgfVxuICAgIH07XG4gIH07XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RG9tQ2FjaGV9IGRvbUNhY2hlXG4gKi9cbmNvbnN0IGhhbmRsZUNvbnRhaW5lck1vdXNlZG93biA9IGRvbUNhY2hlID0+IHtcbiAgZG9tQ2FjaGUuY29udGFpbmVyLm9ubW91c2Vkb3duID0gZSA9PiB7XG4gICAgLy8gcHJldmVudCB0aGUgbW9kYWwgdGV4dCBmcm9tIGJlaW5nIHNlbGVjdGVkIG9uIGRvdWJsZSBjbGljayBvbiB0aGUgY29udGFpbmVyIChhbGxvd091dHNpZGVDbGljazogZmFsc2UpXG4gICAgaWYgKGUudGFyZ2V0ID09PSBkb21DYWNoZS5jb250YWluZXIpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gICAgZG9tQ2FjaGUucG9wdXAub25tb3VzZXVwID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGRvbUNhY2hlLnBvcHVwLm9ubW91c2V1cCA9ICgpID0+IHt9O1xuICAgICAgLy8gV2UgYWxzbyBuZWVkIHRvIGNoZWNrIGlmIHRoZSBtb3VzZXVwIHRhcmdldCBpcyBhIGNoaWxkIG9mIHRoZSBwb3B1cFxuICAgICAgaWYgKGUudGFyZ2V0ID09PSBkb21DYWNoZS5wb3B1cCB8fCBlLnRhcmdldCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmIGRvbUNhY2hlLnBvcHVwLmNvbnRhaW5zKGUudGFyZ2V0KSkge1xuICAgICAgICBpZ25vcmVPdXRzaWRlQ2xpY2sgPSB0cnVlO1xuICAgICAgfVxuICAgIH07XG4gIH07XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IGlubmVyUGFyYW1zXG4gKiBAcGFyYW0ge0RvbUNhY2hlfSBkb21DYWNoZVxuICogQHBhcmFtIHsoZGlzbWlzczogRGlzbWlzc1JlYXNvbikgPT4gdm9pZH0gZGlzbWlzc1dpdGhcbiAqL1xuY29uc3QgaGFuZGxlTW9kYWxDbGljayA9IChpbm5lclBhcmFtcywgZG9tQ2FjaGUsIGRpc21pc3NXaXRoKSA9PiB7XG4gIGRvbUNhY2hlLmNvbnRhaW5lci5vbmNsaWNrID0gZSA9PiB7XG4gICAgaWYgKGlnbm9yZU91dHNpZGVDbGljaykge1xuICAgICAgaWdub3JlT3V0c2lkZUNsaWNrID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlLnRhcmdldCA9PT0gZG9tQ2FjaGUuY29udGFpbmVyICYmIGNhbGxJZkZ1bmN0aW9uKGlubmVyUGFyYW1zLmFsbG93T3V0c2lkZUNsaWNrKSkge1xuICAgICAgZGlzbWlzc1dpdGgoRGlzbWlzc1JlYXNvbi5iYWNrZHJvcCk7XG4gICAgfVxuICB9O1xufTtcblxuY29uc3QgaXNKcXVlcnlFbGVtZW50ID0gZWxlbSA9PiB0eXBlb2YgZWxlbSA9PT0gJ29iamVjdCcgJiYgZWxlbS5qcXVlcnk7XG5jb25zdCBpc0VsZW1lbnQgPSBlbGVtID0+IGVsZW0gaW5zdGFuY2VvZiBFbGVtZW50IHx8IGlzSnF1ZXJ5RWxlbWVudChlbGVtKTtcbmNvbnN0IGFyZ3NUb1BhcmFtcyA9IGFyZ3MgPT4ge1xuICBjb25zdCBwYXJhbXMgPSB7fTtcbiAgaWYgKHR5cGVvZiBhcmdzWzBdID09PSAnb2JqZWN0JyAmJiAhaXNFbGVtZW50KGFyZ3NbMF0pKSB7XG4gICAgT2JqZWN0LmFzc2lnbihwYXJhbXMsIGFyZ3NbMF0pO1xuICB9IGVsc2Uge1xuICAgIFsndGl0bGUnLCAnaHRtbCcsICdpY29uJ10uZm9yRWFjaCgobmFtZSwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IGFyZyA9IGFyZ3NbaW5kZXhdO1xuICAgICAgaWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8IGlzRWxlbWVudChhcmcpKSB7XG4gICAgICAgIHBhcmFtc1tuYW1lXSA9IGFyZztcbiAgICAgIH0gZWxzZSBpZiAoYXJnICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZXJyb3IoYFVuZXhwZWN0ZWQgdHlwZSBvZiAke25hbWV9ISBFeHBlY3RlZCBcInN0cmluZ1wiIG9yIFwiRWxlbWVudFwiLCBnb3QgJHt0eXBlb2YgYXJnfWApO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBwYXJhbXM7XG59O1xuXG4vKipcbiAqIE1haW4gbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBTd2VldEFsZXJ0MiBwb3B1cFxuICpcbiAqIEBwYXJhbSAgey4uLlN3ZWV0QWxlcnRPcHRpb25zfSBhcmdzXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxTd2VldEFsZXJ0UmVzdWx0Pn1cbiAqL1xuZnVuY3Rpb24gZmlyZSguLi5hcmdzKSB7XG4gIHJldHVybiBuZXcgdGhpcyguLi5hcmdzKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFuIGV4dGVuZGVkIHZlcnNpb24gb2YgYFN3YWxgIGNvbnRhaW5pbmcgYHBhcmFtc2AgYXMgZGVmYXVsdHMuXG4gKiBVc2VmdWwgZm9yIHJldXNpbmcgU3dhbCBjb25maWd1cmF0aW9uLlxuICpcbiAqIEZvciBleGFtcGxlOlxuICpcbiAqIEJlZm9yZTpcbiAqIGNvbnN0IHRleHRQcm9tcHRPcHRpb25zID0geyBpbnB1dDogJ3RleHQnLCBzaG93Q2FuY2VsQnV0dG9uOiB0cnVlIH1cbiAqIGNvbnN0IHt2YWx1ZTogZmlyc3ROYW1lfSA9IGF3YWl0IFN3YWwuZmlyZSh7IC4uLnRleHRQcm9tcHRPcHRpb25zLCB0aXRsZTogJ1doYXQgaXMgeW91ciBmaXJzdCBuYW1lPycgfSlcbiAqIGNvbnN0IHt2YWx1ZTogbGFzdE5hbWV9ID0gYXdhaXQgU3dhbC5maXJlKHsgLi4udGV4dFByb21wdE9wdGlvbnMsIHRpdGxlOiAnV2hhdCBpcyB5b3VyIGxhc3QgbmFtZT8nIH0pXG4gKlxuICogQWZ0ZXI6XG4gKiBjb25zdCBUZXh0UHJvbXB0ID0gU3dhbC5taXhpbih7IGlucHV0OiAndGV4dCcsIHNob3dDYW5jZWxCdXR0b246IHRydWUgfSlcbiAqIGNvbnN0IHt2YWx1ZTogZmlyc3ROYW1lfSA9IGF3YWl0IFRleHRQcm9tcHQoJ1doYXQgaXMgeW91ciBmaXJzdCBuYW1lPycpXG4gKiBjb25zdCB7dmFsdWU6IGxhc3ROYW1lfSA9IGF3YWl0IFRleHRQcm9tcHQoJ1doYXQgaXMgeW91ciBsYXN0IG5hbWU/JylcbiAqXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBtaXhpblBhcmFtc1xuICogQHJldHVybnMge1N3ZWV0QWxlcnR9XG4gKi9cbmZ1bmN0aW9uIG1peGluKG1peGluUGFyYW1zKSB7XG4gIGNsYXNzIE1peGluU3dhbCBleHRlbmRzIHRoaXMge1xuICAgIF9tYWluKHBhcmFtcywgcHJpb3JpdHlNaXhpblBhcmFtcykge1xuICAgICAgcmV0dXJuIHN1cGVyLl9tYWluKHBhcmFtcywgT2JqZWN0LmFzc2lnbih7fSwgbWl4aW5QYXJhbXMsIHByaW9yaXR5TWl4aW5QYXJhbXMpKTtcbiAgICB9XG4gIH1cbiAgLy8gQHRzLWlnbm9yZVxuICByZXR1cm4gTWl4aW5Td2FsO1xufVxuXG4vKipcbiAqIElmIGB0aW1lcmAgcGFyYW1ldGVyIGlzIHNldCwgcmV0dXJucyBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIG9mIHRpbWVyIHJlbWFpbmVkLlxuICogT3RoZXJ3aXNlLCByZXR1cm5zIHVuZGVmaW5lZC5cbiAqXG4gKiBAcmV0dXJucyB7bnVtYmVyIHwgdW5kZWZpbmVkfVxuICovXG5jb25zdCBnZXRUaW1lckxlZnQgPSAoKSA9PiB7XG4gIHJldHVybiBnbG9iYWxTdGF0ZS50aW1lb3V0ICYmIGdsb2JhbFN0YXRlLnRpbWVvdXQuZ2V0VGltZXJMZWZ0KCk7XG59O1xuXG4vKipcbiAqIFN0b3AgdGltZXIuIFJldHVybnMgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBvZiB0aW1lciByZW1haW5lZC5cbiAqIElmIGB0aW1lcmAgcGFyYW1ldGVyIGlzbid0IHNldCwgcmV0dXJucyB1bmRlZmluZWQuXG4gKlxuICogQHJldHVybnMge251bWJlciB8IHVuZGVmaW5lZH1cbiAqL1xuY29uc3Qgc3RvcFRpbWVyID0gKCkgPT4ge1xuICBpZiAoZ2xvYmFsU3RhdGUudGltZW91dCkge1xuICAgIHN0b3BUaW1lclByb2dyZXNzQmFyKCk7XG4gICAgcmV0dXJuIGdsb2JhbFN0YXRlLnRpbWVvdXQuc3RvcCgpO1xuICB9XG59O1xuXG4vKipcbiAqIFJlc3VtZSB0aW1lci4gUmV0dXJucyBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIG9mIHRpbWVyIHJlbWFpbmVkLlxuICogSWYgYHRpbWVyYCBwYXJhbWV0ZXIgaXNuJ3Qgc2V0LCByZXR1cm5zIHVuZGVmaW5lZC5cbiAqXG4gKiBAcmV0dXJucyB7bnVtYmVyIHwgdW5kZWZpbmVkfVxuICovXG5jb25zdCByZXN1bWVUaW1lciA9ICgpID0+IHtcbiAgaWYgKGdsb2JhbFN0YXRlLnRpbWVvdXQpIHtcbiAgICBjb25zdCByZW1haW5pbmcgPSBnbG9iYWxTdGF0ZS50aW1lb3V0LnN0YXJ0KCk7XG4gICAgYW5pbWF0ZVRpbWVyUHJvZ3Jlc3NCYXIocmVtYWluaW5nKTtcbiAgICByZXR1cm4gcmVtYWluaW5nO1xuICB9XG59O1xuXG4vKipcbiAqIFJlc3VtZSB0aW1lci4gUmV0dXJucyBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIG9mIHRpbWVyIHJlbWFpbmVkLlxuICogSWYgYHRpbWVyYCBwYXJhbWV0ZXIgaXNuJ3Qgc2V0LCByZXR1cm5zIHVuZGVmaW5lZC5cbiAqXG4gKiBAcmV0dXJucyB7bnVtYmVyIHwgdW5kZWZpbmVkfVxuICovXG5jb25zdCB0b2dnbGVUaW1lciA9ICgpID0+IHtcbiAgY29uc3QgdGltZXIgPSBnbG9iYWxTdGF0ZS50aW1lb3V0O1xuICByZXR1cm4gdGltZXIgJiYgKHRpbWVyLnJ1bm5pbmcgPyBzdG9wVGltZXIoKSA6IHJlc3VtZVRpbWVyKCkpO1xufTtcblxuLyoqXG4gKiBJbmNyZWFzZSB0aW1lci4gUmV0dXJucyBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIG9mIGFuIHVwZGF0ZWQgdGltZXIuXG4gKiBJZiBgdGltZXJgIHBhcmFtZXRlciBpc24ndCBzZXQsIHJldHVybnMgdW5kZWZpbmVkLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBtc1xuICogQHJldHVybnMge251bWJlciB8IHVuZGVmaW5lZH1cbiAqL1xuY29uc3QgaW5jcmVhc2VUaW1lciA9IG1zID0+IHtcbiAgaWYgKGdsb2JhbFN0YXRlLnRpbWVvdXQpIHtcbiAgICBjb25zdCByZW1haW5pbmcgPSBnbG9iYWxTdGF0ZS50aW1lb3V0LmluY3JlYXNlKG1zKTtcbiAgICBhbmltYXRlVGltZXJQcm9ncmVzc0JhcihyZW1haW5pbmcsIHRydWUpO1xuICAgIHJldHVybiByZW1haW5pbmc7XG4gIH1cbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGltZXIgaXMgcnVubmluZy4gUmV0dXJucyB0cnVlIGlmIHRpbWVyIGlzIHJ1bm5pbmdcbiAqIG9yIGZhbHNlIGlmIHRpbWVyIGlzIHBhdXNlZCBvciBzdG9wcGVkLlxuICogSWYgYHRpbWVyYCBwYXJhbWV0ZXIgaXNuJ3Qgc2V0LCByZXR1cm5zIHVuZGVmaW5lZFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5jb25zdCBpc1RpbWVyUnVubmluZyA9ICgpID0+IHtcbiAgcmV0dXJuICEhKGdsb2JhbFN0YXRlLnRpbWVvdXQgJiYgZ2xvYmFsU3RhdGUudGltZW91dC5pc1J1bm5pbmcoKSk7XG59O1xuXG5sZXQgYm9keUNsaWNrTGlzdGVuZXJBZGRlZCA9IGZhbHNlO1xuY29uc3QgY2xpY2tIYW5kbGVycyA9IHt9O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyXG4gKi9cbmZ1bmN0aW9uIGJpbmRDbGlja0hhbmRsZXIoYXR0ciA9ICdkYXRhLXN3YWwtdGVtcGxhdGUnKSB7XG4gIGNsaWNrSGFuZGxlcnNbYXR0cl0gPSB0aGlzO1xuICBpZiAoIWJvZHlDbGlja0xpc3RlbmVyQWRkZWQpIHtcbiAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgYm9keUNsaWNrTGlzdGVuZXIpO1xuICAgIGJvZHlDbGlja0xpc3RlbmVyQWRkZWQgPSB0cnVlO1xuICB9XG59XG5jb25zdCBib2R5Q2xpY2tMaXN0ZW5lciA9IGV2ZW50ID0+IHtcbiAgZm9yIChsZXQgZWwgPSBldmVudC50YXJnZXQ7IGVsICYmIGVsICE9PSBkb2N1bWVudDsgZWwgPSBlbC5wYXJlbnROb2RlKSB7XG4gICAgZm9yIChjb25zdCBhdHRyIGluIGNsaWNrSGFuZGxlcnMpIHtcbiAgICAgIGNvbnN0IHRlbXBsYXRlID0gZWwuZ2V0QXR0cmlidXRlKGF0dHIpO1xuICAgICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICAgIGNsaWNrSGFuZGxlcnNbYXR0cl0uZmlyZSh7XG4gICAgICAgICAgdGVtcGxhdGVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8vIFNvdXJjZTogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vbXVkZ2UvNTgzMDM4Mj9wZXJtYWxpbmtfY29tbWVudF9pZD0yNjkxOTU3I2dpc3Rjb21tZW50LTI2OTE5NTdcblxuY2xhc3MgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLyoqIEB0eXBlIHtFdmVudHN9ICovXG4gICAgdGhpcy5ldmVudHMgPSB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gICAqIEByZXR1cm5zIHtFdmVudEhhbmRsZXJzfVxuICAgKi9cbiAgX2dldEhhbmRsZXJzQnlFdmVudE5hbWUoZXZlbnROYW1lKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLmV2ZW50c1tldmVudE5hbWVdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gbm90IFNldCBiZWNhdXNlIHdlIG5lZWQgdG8ga2VlcCB0aGUgRklGTyBvcmRlclxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3N3ZWV0YWxlcnQyL3N3ZWV0YWxlcnQyL3B1bGwvMjc2MyNkaXNjdXNzaW9uX3IxNzQ4OTkwMzM0XG4gICAgICB0aGlzLmV2ZW50c1tldmVudE5hbWVdID0gW107XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmV2ZW50c1tldmVudE5hbWVdO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcbiAgICogQHBhcmFtIHtFdmVudEhhbmRsZXJ9IGV2ZW50SGFuZGxlclxuICAgKi9cbiAgb24oZXZlbnROYW1lLCBldmVudEhhbmRsZXIpIHtcbiAgICBjb25zdCBjdXJyZW50SGFuZGxlcnMgPSB0aGlzLl9nZXRIYW5kbGVyc0J5RXZlbnROYW1lKGV2ZW50TmFtZSk7XG4gICAgaWYgKCFjdXJyZW50SGFuZGxlcnMuaW5jbHVkZXMoZXZlbnRIYW5kbGVyKSkge1xuICAgICAgY3VycmVudEhhbmRsZXJzLnB1c2goZXZlbnRIYW5kbGVyKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVxuICAgKiBAcGFyYW0ge0V2ZW50SGFuZGxlcn0gZXZlbnRIYW5kbGVyXG4gICAqL1xuICBvbmNlKGV2ZW50TmFtZSwgZXZlbnRIYW5kbGVyKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJnc1xuICAgICAqL1xuICAgIGNvbnN0IG9uY2VGbiA9ICguLi5hcmdzKSA9PiB7XG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50TmFtZSwgb25jZUZuKTtcbiAgICAgIGV2ZW50SGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9O1xuICAgIHRoaXMub24oZXZlbnROYW1lLCBvbmNlRm4pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJnc1xuICAgKi9cbiAgZW1pdChldmVudE5hbWUsIC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9nZXRIYW5kbGVyc0J5RXZlbnROYW1lKGV2ZW50TmFtZSkuZm9yRWFjaChcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0V2ZW50SGFuZGxlcn0gZXZlbnRIYW5kbGVyXG4gICAgICovXG4gICAgZXZlbnRIYW5kbGVyID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGV2ZW50SGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcbiAgICogQHBhcmFtIHtFdmVudEhhbmRsZXJ9IGV2ZW50SGFuZGxlclxuICAgKi9cbiAgcmVtb3ZlTGlzdGVuZXIoZXZlbnROYW1lLCBldmVudEhhbmRsZXIpIHtcbiAgICBjb25zdCBjdXJyZW50SGFuZGxlcnMgPSB0aGlzLl9nZXRIYW5kbGVyc0J5RXZlbnROYW1lKGV2ZW50TmFtZSk7XG4gICAgY29uc3QgaW5kZXggPSBjdXJyZW50SGFuZGxlcnMuaW5kZXhPZihldmVudEhhbmRsZXIpO1xuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICBjdXJyZW50SGFuZGxlcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVxuICAgKi9cbiAgcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50TmFtZSkge1xuICAgIGlmICh0aGlzLmV2ZW50c1tldmVudE5hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zd2VldGFsZXJ0Mi9zd2VldGFsZXJ0Mi9wdWxsLzI3NjMjZGlzY3Vzc2lvbl9yMTc0OTIzOTIyMlxuICAgICAgdGhpcy5ldmVudHNbZXZlbnROYW1lXS5sZW5ndGggPSAwO1xuICAgIH1cbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLmV2ZW50cyA9IHt9O1xuICB9XG59XG5cbmdsb2JhbFN0YXRlLmV2ZW50RW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gKiBAcGFyYW0ge0V2ZW50SGFuZGxlcn0gZXZlbnRIYW5kbGVyXG4gKi9cbmNvbnN0IG9uID0gKGV2ZW50TmFtZSwgZXZlbnRIYW5kbGVyKSA9PiB7XG4gIGdsb2JhbFN0YXRlLmV2ZW50RW1pdHRlci5vbihldmVudE5hbWUsIGV2ZW50SGFuZGxlcik7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcbiAqIEBwYXJhbSB7RXZlbnRIYW5kbGVyfSBldmVudEhhbmRsZXJcbiAqL1xuY29uc3Qgb25jZSA9IChldmVudE5hbWUsIGV2ZW50SGFuZGxlcikgPT4ge1xuICBnbG9iYWxTdGF0ZS5ldmVudEVtaXR0ZXIub25jZShldmVudE5hbWUsIGV2ZW50SGFuZGxlcik7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBbZXZlbnROYW1lXVxuICogQHBhcmFtIHtFdmVudEhhbmRsZXJ9IFtldmVudEhhbmRsZXJdXG4gKi9cbmNvbnN0IG9mZiA9IChldmVudE5hbWUsIGV2ZW50SGFuZGxlcikgPT4ge1xuICAvLyBSZW1vdmUgYWxsIGhhbmRsZXJzIGZvciBhbGwgZXZlbnRzXG4gIGlmICghZXZlbnROYW1lKSB7XG4gICAgZ2xvYmFsU3RhdGUuZXZlbnRFbWl0dGVyLnJlc2V0KCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChldmVudEhhbmRsZXIpIHtcbiAgICAvLyBSZW1vdmUgYSBzcGVjaWZpYyBoYW5kbGVyXG4gICAgZ2xvYmFsU3RhdGUuZXZlbnRFbWl0dGVyLnJlbW92ZUxpc3RlbmVyKGV2ZW50TmFtZSwgZXZlbnRIYW5kbGVyKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBSZW1vdmUgYWxsIGhhbmRsZXJzIGZvciBhIHNwZWNpZmljIGV2ZW50XG4gICAgZ2xvYmFsU3RhdGUuZXZlbnRFbWl0dGVyLnJlbW92ZUFsbExpc3RlbmVycyhldmVudE5hbWUpO1xuICB9XG59O1xuXG52YXIgc3RhdGljTWV0aG9kcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBhcmdzVG9QYXJhbXM6IGFyZ3NUb1BhcmFtcyxcbiAgYmluZENsaWNrSGFuZGxlcjogYmluZENsaWNrSGFuZGxlcixcbiAgY2xpY2tDYW5jZWw6IGNsaWNrQ2FuY2VsLFxuICBjbGlja0NvbmZpcm06IGNsaWNrQ29uZmlybSxcbiAgY2xpY2tEZW55OiBjbGlja0RlbnksXG4gIGVuYWJsZUxvYWRpbmc6IHNob3dMb2FkaW5nLFxuICBmaXJlOiBmaXJlLFxuICBnZXRBY3Rpb25zOiBnZXRBY3Rpb25zLFxuICBnZXRDYW5jZWxCdXR0b246IGdldENhbmNlbEJ1dHRvbixcbiAgZ2V0Q2xvc2VCdXR0b246IGdldENsb3NlQnV0dG9uLFxuICBnZXRDb25maXJtQnV0dG9uOiBnZXRDb25maXJtQnV0dG9uLFxuICBnZXRDb250YWluZXI6IGdldENvbnRhaW5lcixcbiAgZ2V0RGVueUJ1dHRvbjogZ2V0RGVueUJ1dHRvbixcbiAgZ2V0Rm9jdXNhYmxlRWxlbWVudHM6IGdldEZvY3VzYWJsZUVsZW1lbnRzLFxuICBnZXRGb290ZXI6IGdldEZvb3RlcixcbiAgZ2V0SHRtbENvbnRhaW5lcjogZ2V0SHRtbENvbnRhaW5lcixcbiAgZ2V0SWNvbjogZ2V0SWNvbixcbiAgZ2V0SWNvbkNvbnRlbnQ6IGdldEljb25Db250ZW50LFxuICBnZXRJbWFnZTogZ2V0SW1hZ2UsXG4gIGdldElucHV0TGFiZWw6IGdldElucHV0TGFiZWwsXG4gIGdldExvYWRlcjogZ2V0TG9hZGVyLFxuICBnZXRQb3B1cDogZ2V0UG9wdXAsXG4gIGdldFByb2dyZXNzU3RlcHM6IGdldFByb2dyZXNzU3RlcHMsXG4gIGdldFRpbWVyTGVmdDogZ2V0VGltZXJMZWZ0LFxuICBnZXRUaW1lclByb2dyZXNzQmFyOiBnZXRUaW1lclByb2dyZXNzQmFyLFxuICBnZXRUaXRsZTogZ2V0VGl0bGUsXG4gIGdldFZhbGlkYXRpb25NZXNzYWdlOiBnZXRWYWxpZGF0aW9uTWVzc2FnZSxcbiAgaW5jcmVhc2VUaW1lcjogaW5jcmVhc2VUaW1lcixcbiAgaXNEZXByZWNhdGVkUGFyYW1ldGVyOiBpc0RlcHJlY2F0ZWRQYXJhbWV0ZXIsXG4gIGlzTG9hZGluZzogaXNMb2FkaW5nLFxuICBpc1RpbWVyUnVubmluZzogaXNUaW1lclJ1bm5pbmcsXG4gIGlzVXBkYXRhYmxlUGFyYW1ldGVyOiBpc1VwZGF0YWJsZVBhcmFtZXRlcixcbiAgaXNWYWxpZFBhcmFtZXRlcjogaXNWYWxpZFBhcmFtZXRlcixcbiAgaXNWaXNpYmxlOiBpc1Zpc2libGUsXG4gIG1peGluOiBtaXhpbixcbiAgb2ZmOiBvZmYsXG4gIG9uOiBvbixcbiAgb25jZTogb25jZSxcbiAgcmVzdW1lVGltZXI6IHJlc3VtZVRpbWVyLFxuICBzaG93TG9hZGluZzogc2hvd0xvYWRpbmcsXG4gIHN0b3BUaW1lcjogc3RvcFRpbWVyLFxuICB0b2dnbGVUaW1lcjogdG9nZ2xlVGltZXJcbn0pO1xuXG5jbGFzcyBUaW1lciB7XG4gIC8qKlxuICAgKiBAcGFyYW0geygpID0+IHZvaWR9IGNhbGxiYWNrXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkZWxheVxuICAgKi9cbiAgY29uc3RydWN0b3IoY2FsbGJhY2ssIGRlbGF5KSB7XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIHRoaXMucmVtYWluaW5nID0gZGVsYXk7XG4gICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgdGhpcy5zdGFydCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuICBzdGFydCgpIHtcbiAgICBpZiAoIXRoaXMucnVubmluZykge1xuICAgICAgdGhpcy5ydW5uaW5nID0gdHJ1ZTtcbiAgICAgIHRoaXMuc3RhcnRlZCA9IG5ldyBEYXRlKCk7XG4gICAgICB0aGlzLmlkID0gc2V0VGltZW91dCh0aGlzLmNhbGxiYWNrLCB0aGlzLnJlbWFpbmluZyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJlbWFpbmluZztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgc3RvcCgpIHtcbiAgICBpZiAodGhpcy5zdGFydGVkICYmIHRoaXMucnVubmluZykge1xuICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5pZCk7XG4gICAgICB0aGlzLnJlbWFpbmluZyAtPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHRoaXMuc3RhcnRlZC5nZXRUaW1lKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJlbWFpbmluZztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gblxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgaW5jcmVhc2Uobikge1xuICAgIGNvbnN0IHJ1bm5pbmcgPSB0aGlzLnJ1bm5pbmc7XG4gICAgaWYgKHJ1bm5pbmcpIHtcbiAgICAgIHRoaXMuc3RvcCgpO1xuICAgIH1cbiAgICB0aGlzLnJlbWFpbmluZyArPSBuO1xuICAgIGlmIChydW5uaW5nKSB7XG4gICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJlbWFpbmluZztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0VGltZXJMZWZ0KCkge1xuICAgIGlmICh0aGlzLnJ1bm5pbmcpIHtcbiAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgdGhpcy5zdGFydCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5yZW1haW5pbmc7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBpc1J1bm5pbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMucnVubmluZztcbiAgfVxufVxuXG5jb25zdCBzd2FsU3RyaW5nUGFyYW1zID0gWydzd2FsLXRpdGxlJywgJ3N3YWwtaHRtbCcsICdzd2FsLWZvb3RlciddO1xuXG4vKipcbiAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICogQHJldHVybnMge1N3ZWV0QWxlcnRPcHRpb25zfVxuICovXG5jb25zdCBnZXRUZW1wbGF0ZVBhcmFtcyA9IHBhcmFtcyA9PiB7XG4gIGNvbnN0IHRlbXBsYXRlID0gdHlwZW9mIHBhcmFtcy50ZW1wbGF0ZSA9PT0gJ3N0cmluZycgPyAoLyoqIEB0eXBlIHtIVE1MVGVtcGxhdGVFbGVtZW50fSAqL2RvY3VtZW50LnF1ZXJ5U2VsZWN0b3IocGFyYW1zLnRlbXBsYXRlKSkgOiBwYXJhbXMudGVtcGxhdGU7XG4gIGlmICghdGVtcGxhdGUpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgLyoqIEB0eXBlIHtEb2N1bWVudEZyYWdtZW50fSAqL1xuICBjb25zdCB0ZW1wbGF0ZUNvbnRlbnQgPSB0ZW1wbGF0ZS5jb250ZW50O1xuICBzaG93V2FybmluZ3NGb3JFbGVtZW50cyh0ZW1wbGF0ZUNvbnRlbnQpO1xuICBjb25zdCByZXN1bHQgPSBPYmplY3QuYXNzaWduKGdldFN3YWxQYXJhbXModGVtcGxhdGVDb250ZW50KSwgZ2V0U3dhbEZ1bmN0aW9uUGFyYW1zKHRlbXBsYXRlQ29udGVudCksIGdldFN3YWxCdXR0b25zKHRlbXBsYXRlQ29udGVudCksIGdldFN3YWxJbWFnZSh0ZW1wbGF0ZUNvbnRlbnQpLCBnZXRTd2FsSWNvbih0ZW1wbGF0ZUNvbnRlbnQpLCBnZXRTd2FsSW5wdXQodGVtcGxhdGVDb250ZW50KSwgZ2V0U3dhbFN0cmluZ1BhcmFtcyh0ZW1wbGF0ZUNvbnRlbnQsIHN3YWxTdHJpbmdQYXJhbXMpKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtEb2N1bWVudEZyYWdtZW50fSB0ZW1wbGF0ZUNvbnRlbnRcbiAqIEByZXR1cm5zIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBib29sZWFuIHwgbnVtYmVyPn1cbiAqL1xuY29uc3QgZ2V0U3dhbFBhcmFtcyA9IHRlbXBsYXRlQ29udGVudCA9PiB7XG4gIC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgc3RyaW5nIHwgYm9vbGVhbiB8IG51bWJlcj59ICovXG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAvKiogQHR5cGUge0hUTUxFbGVtZW50W119ICovXG4gIGNvbnN0IHN3YWxQYXJhbXMgPSBBcnJheS5mcm9tKHRlbXBsYXRlQ29udGVudC5xdWVyeVNlbGVjdG9yQWxsKCdzd2FsLXBhcmFtJykpO1xuICBzd2FsUGFyYW1zLmZvckVhY2gocGFyYW0gPT4ge1xuICAgIHNob3dXYXJuaW5nc0ZvckF0dHJpYnV0ZXMocGFyYW0sIFsnbmFtZScsICd2YWx1ZSddKTtcbiAgICBjb25zdCBwYXJhbU5hbWUgPSAvKiogQHR5cGUge2tleW9mIFN3ZWV0QWxlcnRPcHRpb25zfSAqL3BhcmFtLmdldEF0dHJpYnV0ZSgnbmFtZScpO1xuICAgIGNvbnN0IHZhbHVlID0gcGFyYW0uZ2V0QXR0cmlidXRlKCd2YWx1ZScpO1xuICAgIGlmICghcGFyYW1OYW1lIHx8ICF2YWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGRlZmF1bHRQYXJhbXNbcGFyYW1OYW1lXSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICByZXN1bHRbcGFyYW1OYW1lXSA9IHZhbHVlICE9PSAnZmFsc2UnO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlZmF1bHRQYXJhbXNbcGFyYW1OYW1lXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJlc3VsdFtwYXJhbU5hbWVdID0gSlNPTi5wYXJzZSh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdFtwYXJhbU5hbWVdID0gdmFsdWU7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtEb2N1bWVudEZyYWdtZW50fSB0ZW1wbGF0ZUNvbnRlbnRcbiAqIEByZXR1cm5zIHtSZWNvcmQ8c3RyaW5nLCAoKSA9PiB2b2lkPn1cbiAqL1xuY29uc3QgZ2V0U3dhbEZ1bmN0aW9uUGFyYW1zID0gdGVtcGxhdGVDb250ZW50ID0+IHtcbiAgLyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCAoKSA9PiB2b2lkPn0gKi9cbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIC8qKiBAdHlwZSB7SFRNTEVsZW1lbnRbXX0gKi9cbiAgY29uc3Qgc3dhbEZ1bmN0aW9ucyA9IEFycmF5LmZyb20odGVtcGxhdGVDb250ZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3N3YWwtZnVuY3Rpb24tcGFyYW0nKSk7XG4gIHN3YWxGdW5jdGlvbnMuZm9yRWFjaChwYXJhbSA9PiB7XG4gICAgY29uc3QgcGFyYW1OYW1lID0gLyoqIEB0eXBlIHtrZXlvZiBTd2VldEFsZXJ0T3B0aW9uc30gKi9wYXJhbS5nZXRBdHRyaWJ1dGUoJ25hbWUnKTtcbiAgICBjb25zdCB2YWx1ZSA9IHBhcmFtLmdldEF0dHJpYnV0ZSgndmFsdWUnKTtcbiAgICBpZiAoIXBhcmFtTmFtZSB8fCAhdmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmVzdWx0W3BhcmFtTmFtZV0gPSBuZXcgRnVuY3Rpb24oYHJldHVybiAke3ZhbHVlfWApKCk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0RvY3VtZW50RnJhZ21lbnR9IHRlbXBsYXRlQ29udGVudFxuICogQHJldHVybnMge1JlY29yZDxzdHJpbmcsIHN0cmluZyB8IGJvb2xlYW4+fVxuICovXG5jb25zdCBnZXRTd2FsQnV0dG9ucyA9IHRlbXBsYXRlQ29udGVudCA9PiB7XG4gIC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgc3RyaW5nIHwgYm9vbGVhbj59ICovXG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAvKiogQHR5cGUge0hUTUxFbGVtZW50W119ICovXG4gIGNvbnN0IHN3YWxCdXR0b25zID0gQXJyYXkuZnJvbSh0ZW1wbGF0ZUNvbnRlbnQucXVlcnlTZWxlY3RvckFsbCgnc3dhbC1idXR0b24nKSk7XG4gIHN3YWxCdXR0b25zLmZvckVhY2goYnV0dG9uID0+IHtcbiAgICBzaG93V2FybmluZ3NGb3JBdHRyaWJ1dGVzKGJ1dHRvbiwgWyd0eXBlJywgJ2NvbG9yJywgJ2FyaWEtbGFiZWwnXSk7XG4gICAgY29uc3QgdHlwZSA9IGJ1dHRvbi5nZXRBdHRyaWJ1dGUoJ3R5cGUnKTtcbiAgICBpZiAoIXR5cGUgfHwgIVsnY29uZmlybScsICdjYW5jZWwnLCAnZGVueSddLmluY2x1ZGVzKHR5cGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJlc3VsdFtgJHt0eXBlfUJ1dHRvblRleHRgXSA9IGJ1dHRvbi5pbm5lckhUTUw7XG4gICAgcmVzdWx0W2BzaG93JHtjYXBpdGFsaXplRmlyc3RMZXR0ZXIodHlwZSl9QnV0dG9uYF0gPSB0cnVlO1xuICAgIGlmIChidXR0b24uaGFzQXR0cmlidXRlKCdjb2xvcicpKSB7XG4gICAgICByZXN1bHRbYCR7dHlwZX1CdXR0b25Db2xvcmBdID0gYnV0dG9uLmdldEF0dHJpYnV0ZSgnY29sb3InKTtcbiAgICB9XG4gICAgaWYgKGJ1dHRvbi5oYXNBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnKSkge1xuICAgICAgcmVzdWx0W2Ake3R5cGV9QnV0dG9uQXJpYUxhYmVsYF0gPSBidXR0b24uZ2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJyk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtEb2N1bWVudEZyYWdtZW50fSB0ZW1wbGF0ZUNvbnRlbnRcbiAqIEByZXR1cm5zIHtQaWNrPFN3ZWV0QWxlcnRPcHRpb25zLCAnaW1hZ2VVcmwnIHwgJ2ltYWdlV2lkdGgnIHwgJ2ltYWdlSGVpZ2h0JyB8ICdpbWFnZUFsdCc+fVxuICovXG5jb25zdCBnZXRTd2FsSW1hZ2UgPSB0ZW1wbGF0ZUNvbnRlbnQgPT4ge1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgLyoqIEB0eXBlIHtIVE1MRWxlbWVudCB8IG51bGx9ICovXG4gIGNvbnN0IGltYWdlID0gdGVtcGxhdGVDb250ZW50LnF1ZXJ5U2VsZWN0b3IoJ3N3YWwtaW1hZ2UnKTtcbiAgaWYgKGltYWdlKSB7XG4gICAgc2hvd1dhcm5pbmdzRm9yQXR0cmlidXRlcyhpbWFnZSwgWydzcmMnLCAnd2lkdGgnLCAnaGVpZ2h0JywgJ2FsdCddKTtcbiAgICBpZiAoaW1hZ2UuaGFzQXR0cmlidXRlKCdzcmMnKSkge1xuICAgICAgcmVzdWx0LmltYWdlVXJsID0gaW1hZ2UuZ2V0QXR0cmlidXRlKCdzcmMnKSB8fCB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmIChpbWFnZS5oYXNBdHRyaWJ1dGUoJ3dpZHRoJykpIHtcbiAgICAgIHJlc3VsdC5pbWFnZVdpZHRoID0gaW1hZ2UuZ2V0QXR0cmlidXRlKCd3aWR0aCcpIHx8IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKGltYWdlLmhhc0F0dHJpYnV0ZSgnaGVpZ2h0JykpIHtcbiAgICAgIHJlc3VsdC5pbWFnZUhlaWdodCA9IGltYWdlLmdldEF0dHJpYnV0ZSgnaGVpZ2h0JykgfHwgdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoaW1hZ2UuaGFzQXR0cmlidXRlKCdhbHQnKSkge1xuICAgICAgcmVzdWx0LmltYWdlQWx0ID0gaW1hZ2UuZ2V0QXR0cmlidXRlKCdhbHQnKSB8fCB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RG9jdW1lbnRGcmFnbWVudH0gdGVtcGxhdGVDb250ZW50XG4gKiBAcmV0dXJucyB7b2JqZWN0fVxuICovXG5jb25zdCBnZXRTd2FsSWNvbiA9IHRlbXBsYXRlQ29udGVudCA9PiB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAvKiogQHR5cGUge0hUTUxFbGVtZW50IHwgbnVsbH0gKi9cbiAgY29uc3QgaWNvbiA9IHRlbXBsYXRlQ29udGVudC5xdWVyeVNlbGVjdG9yKCdzd2FsLWljb24nKTtcbiAgaWYgKGljb24pIHtcbiAgICBzaG93V2FybmluZ3NGb3JBdHRyaWJ1dGVzKGljb24sIFsndHlwZScsICdjb2xvciddKTtcbiAgICBpZiAoaWNvbi5oYXNBdHRyaWJ1dGUoJ3R5cGUnKSkge1xuICAgICAgcmVzdWx0Lmljb24gPSBpY29uLmdldEF0dHJpYnV0ZSgndHlwZScpO1xuICAgIH1cbiAgICBpZiAoaWNvbi5oYXNBdHRyaWJ1dGUoJ2NvbG9yJykpIHtcbiAgICAgIHJlc3VsdC5pY29uQ29sb3IgPSBpY29uLmdldEF0dHJpYnV0ZSgnY29sb3InKTtcbiAgICB9XG4gICAgcmVzdWx0Lmljb25IdG1sID0gaWNvbi5pbm5lckhUTUw7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtEb2N1bWVudEZyYWdtZW50fSB0ZW1wbGF0ZUNvbnRlbnRcbiAqIEByZXR1cm5zIHtvYmplY3R9XG4gKi9cbmNvbnN0IGdldFN3YWxJbnB1dCA9IHRlbXBsYXRlQ29udGVudCA9PiB7XG4gIC8qKiBAdHlwZSB7b2JqZWN0fSAqL1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgLyoqIEB0eXBlIHtIVE1MRWxlbWVudCB8IG51bGx9ICovXG4gIGNvbnN0IGlucHV0ID0gdGVtcGxhdGVDb250ZW50LnF1ZXJ5U2VsZWN0b3IoJ3N3YWwtaW5wdXQnKTtcbiAgaWYgKGlucHV0KSB7XG4gICAgc2hvd1dhcm5pbmdzRm9yQXR0cmlidXRlcyhpbnB1dCwgWyd0eXBlJywgJ2xhYmVsJywgJ3BsYWNlaG9sZGVyJywgJ3ZhbHVlJ10pO1xuICAgIHJlc3VsdC5pbnB1dCA9IGlucHV0LmdldEF0dHJpYnV0ZSgndHlwZScpIHx8ICd0ZXh0JztcbiAgICBpZiAoaW5wdXQuaGFzQXR0cmlidXRlKCdsYWJlbCcpKSB7XG4gICAgICByZXN1bHQuaW5wdXRMYWJlbCA9IGlucHV0LmdldEF0dHJpYnV0ZSgnbGFiZWwnKTtcbiAgICB9XG4gICAgaWYgKGlucHV0Lmhhc0F0dHJpYnV0ZSgncGxhY2Vob2xkZXInKSkge1xuICAgICAgcmVzdWx0LmlucHV0UGxhY2Vob2xkZXIgPSBpbnB1dC5nZXRBdHRyaWJ1dGUoJ3BsYWNlaG9sZGVyJyk7XG4gICAgfVxuICAgIGlmIChpbnB1dC5oYXNBdHRyaWJ1dGUoJ3ZhbHVlJykpIHtcbiAgICAgIHJlc3VsdC5pbnB1dFZhbHVlID0gaW5wdXQuZ2V0QXR0cmlidXRlKCd2YWx1ZScpO1xuICAgIH1cbiAgfVxuICAvKiogQHR5cGUge0hUTUxFbGVtZW50W119ICovXG4gIGNvbnN0IGlucHV0T3B0aW9ucyA9IEFycmF5LmZyb20odGVtcGxhdGVDb250ZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3N3YWwtaW5wdXQtb3B0aW9uJykpO1xuICBpZiAoaW5wdXRPcHRpb25zLmxlbmd0aCkge1xuICAgIHJlc3VsdC5pbnB1dE9wdGlvbnMgPSB7fTtcbiAgICBpbnB1dE9wdGlvbnMuZm9yRWFjaChvcHRpb24gPT4ge1xuICAgICAgc2hvd1dhcm5pbmdzRm9yQXR0cmlidXRlcyhvcHRpb24sIFsndmFsdWUnXSk7XG4gICAgICBjb25zdCBvcHRpb25WYWx1ZSA9IG9wdGlvbi5nZXRBdHRyaWJ1dGUoJ3ZhbHVlJyk7XG4gICAgICBpZiAoIW9wdGlvblZhbHVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9wdGlvbk5hbWUgPSBvcHRpb24uaW5uZXJIVE1MO1xuICAgICAgcmVzdWx0LmlucHV0T3B0aW9uc1tvcHRpb25WYWx1ZV0gPSBvcHRpb25OYW1lO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RG9jdW1lbnRGcmFnbWVudH0gdGVtcGxhdGVDb250ZW50XG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXJhbU5hbWVzXG4gKiBAcmV0dXJucyB7UmVjb3JkPHN0cmluZywgc3RyaW5nPn1cbiAqL1xuY29uc3QgZ2V0U3dhbFN0cmluZ1BhcmFtcyA9ICh0ZW1wbGF0ZUNvbnRlbnQsIHBhcmFtTmFtZXMpID0+IHtcbiAgLyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+fSAqL1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgZm9yIChjb25zdCBpIGluIHBhcmFtTmFtZXMpIHtcbiAgICBjb25zdCBwYXJhbU5hbWUgPSBwYXJhbU5hbWVzW2ldO1xuICAgIC8qKiBAdHlwZSB7SFRNTEVsZW1lbnQgfCBudWxsfSAqL1xuICAgIGNvbnN0IHRhZyA9IHRlbXBsYXRlQ29udGVudC5xdWVyeVNlbGVjdG9yKHBhcmFtTmFtZSk7XG4gICAgaWYgKHRhZykge1xuICAgICAgc2hvd1dhcm5pbmdzRm9yQXR0cmlidXRlcyh0YWcsIFtdKTtcbiAgICAgIHJlc3VsdFtwYXJhbU5hbWUucmVwbGFjZSgvXnN3YWwtLywgJycpXSA9IHRhZy5pbm5lckhUTUwudHJpbSgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0RvY3VtZW50RnJhZ21lbnR9IHRlbXBsYXRlQ29udGVudFxuICovXG5jb25zdCBzaG93V2FybmluZ3NGb3JFbGVtZW50cyA9IHRlbXBsYXRlQ29udGVudCA9PiB7XG4gIGNvbnN0IGFsbG93ZWRFbGVtZW50cyA9IHN3YWxTdHJpbmdQYXJhbXMuY29uY2F0KFsnc3dhbC1wYXJhbScsICdzd2FsLWZ1bmN0aW9uLXBhcmFtJywgJ3N3YWwtYnV0dG9uJywgJ3N3YWwtaW1hZ2UnLCAnc3dhbC1pY29uJywgJ3N3YWwtaW5wdXQnLCAnc3dhbC1pbnB1dC1vcHRpb24nXSk7XG4gIEFycmF5LmZyb20odGVtcGxhdGVDb250ZW50LmNoaWxkcmVuKS5mb3JFYWNoKGVsID0+IHtcbiAgICBjb25zdCB0YWdOYW1lID0gZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmICghYWxsb3dlZEVsZW1lbnRzLmluY2x1ZGVzKHRhZ05hbWUpKSB7XG4gICAgICB3YXJuKGBVbnJlY29nbml6ZWQgZWxlbWVudCA8JHt0YWdOYW1lfT5gKTtcbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbFxuICogQHBhcmFtIHtzdHJpbmdbXX0gYWxsb3dlZEF0dHJpYnV0ZXNcbiAqL1xuY29uc3Qgc2hvd1dhcm5pbmdzRm9yQXR0cmlidXRlcyA9IChlbCwgYWxsb3dlZEF0dHJpYnV0ZXMpID0+IHtcbiAgQXJyYXkuZnJvbShlbC5hdHRyaWJ1dGVzKS5mb3JFYWNoKGF0dHJpYnV0ZSA9PiB7XG4gICAgaWYgKGFsbG93ZWRBdHRyaWJ1dGVzLmluZGV4T2YoYXR0cmlidXRlLm5hbWUpID09PSAtMSkge1xuICAgICAgd2FybihbYFVucmVjb2duaXplZCBhdHRyaWJ1dGUgXCIke2F0dHJpYnV0ZS5uYW1lfVwiIG9uIDwke2VsLnRhZ05hbWUudG9Mb3dlckNhc2UoKX0+LmAsIGAke2FsbG93ZWRBdHRyaWJ1dGVzLmxlbmd0aCA/IGBBbGxvd2VkIGF0dHJpYnV0ZXMgYXJlOiAke2FsbG93ZWRBdHRyaWJ1dGVzLmpvaW4oJywgJyl9YCA6ICdUbyBzZXQgdGhlIHZhbHVlLCB1c2UgSFRNTCB3aXRoaW4gdGhlIGVsZW1lbnQuJ31gXSk7XG4gICAgfVxuICB9KTtcbn07XG5cbmNvbnN0IFNIT1dfQ0xBU1NfVElNRU9VVCA9IDEwO1xuXG4vKipcbiAqIE9wZW4gcG9wdXAsIGFkZCBuZWNlc3NhcnkgY2xhc3NlcyBhbmQgc3R5bGVzLCBmaXggc2Nyb2xsYmFyXG4gKlxuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gKi9cbmNvbnN0IG9wZW5Qb3B1cCA9IHBhcmFtcyA9PiB7XG4gIGNvbnN0IGNvbnRhaW5lciA9IGdldENvbnRhaW5lcigpO1xuICBjb25zdCBwb3B1cCA9IGdldFBvcHVwKCk7XG4gIGlmICh0eXBlb2YgcGFyYW1zLndpbGxPcGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcGFyYW1zLndpbGxPcGVuKHBvcHVwKTtcbiAgfVxuICBnbG9iYWxTdGF0ZS5ldmVudEVtaXR0ZXIuZW1pdCgnd2lsbE9wZW4nLCBwb3B1cCk7XG4gIGNvbnN0IGJvZHlTdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5ib2R5KTtcbiAgY29uc3QgaW5pdGlhbEJvZHlPdmVyZmxvdyA9IGJvZHlTdHlsZXMub3ZlcmZsb3dZO1xuICBhZGRDbGFzc2VzKGNvbnRhaW5lciwgcG9wdXAsIHBhcmFtcyk7XG5cbiAgLy8gc2Nyb2xsaW5nIGlzICdoaWRkZW4nIHVudGlsIGFuaW1hdGlvbiBpcyBkb25lLCBhZnRlciB0aGF0ICdhdXRvJ1xuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICBzZXRTY3JvbGxpbmdWaXNpYmlsaXR5KGNvbnRhaW5lciwgcG9wdXApO1xuICB9LCBTSE9XX0NMQVNTX1RJTUVPVVQpO1xuICBpZiAoaXNNb2RhbCgpKSB7XG4gICAgZml4U2Nyb2xsQ29udGFpbmVyKGNvbnRhaW5lciwgcGFyYW1zLnNjcm9sbGJhclBhZGRpbmcsIGluaXRpYWxCb2R5T3ZlcmZsb3cpO1xuICAgIHNldEFyaWFIaWRkZW4oKTtcbiAgfVxuICBpZiAoIWlzVG9hc3QoKSAmJiAhZ2xvYmFsU3RhdGUucHJldmlvdXNBY3RpdmVFbGVtZW50KSB7XG4gICAgZ2xvYmFsU3RhdGUucHJldmlvdXNBY3RpdmVFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgfVxuICBpZiAodHlwZW9mIHBhcmFtcy5kaWRPcGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgc2V0VGltZW91dCgoKSA9PiBwYXJhbXMuZGlkT3Blbihwb3B1cCkpO1xuICB9XG4gIGdsb2JhbFN0YXRlLmV2ZW50RW1pdHRlci5lbWl0KCdkaWRPcGVuJywgcG9wdXApO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0FuaW1hdGlvbkV2ZW50fSBldmVudFxuICovXG5jb25zdCBzd2FsT3BlbkFuaW1hdGlvbkZpbmlzaGVkID0gZXZlbnQgPT4ge1xuICBjb25zdCBwb3B1cCA9IGdldFBvcHVwKCk7XG4gIGlmIChldmVudC50YXJnZXQgIT09IHBvcHVwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGNvbnRhaW5lciA9IGdldENvbnRhaW5lcigpO1xuICBwb3B1cC5yZW1vdmVFdmVudExpc3RlbmVyKCdhbmltYXRpb25lbmQnLCBzd2FsT3BlbkFuaW1hdGlvbkZpbmlzaGVkKTtcbiAgcG9wdXAucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHN3YWxPcGVuQW5pbWF0aW9uRmluaXNoZWQpO1xuICBjb250YWluZXIuc3R5bGUub3ZlcmZsb3dZID0gJ2F1dG8nO1xuXG4gIC8vIG5vLXRyYW5zaXRpb24gaXMgYWRkZWQgaW4gaW5pdCgpIGluIGNhc2Ugb25lIHN3YWwgaXMgb3BlbmVkIHJpZ2h0IGFmdGVyIGFub3RoZXJcbiAgcmVtb3ZlQ2xhc3MoY29udGFpbmVyLCBzd2FsQ2xhc3Nlc1snbm8tdHJhbnNpdGlvbiddKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwb3B1cFxuICovXG5jb25zdCBzZXRTY3JvbGxpbmdWaXNpYmlsaXR5ID0gKGNvbnRhaW5lciwgcG9wdXApID0+IHtcbiAgaWYgKGhhc0Nzc0FuaW1hdGlvbihwb3B1cCkpIHtcbiAgICBjb250YWluZXIuc3R5bGUub3ZlcmZsb3dZID0gJ2hpZGRlbic7XG4gICAgcG9wdXAuYWRkRXZlbnRMaXN0ZW5lcignYW5pbWF0aW9uZW5kJywgc3dhbE9wZW5BbmltYXRpb25GaW5pc2hlZCk7XG4gICAgcG9wdXAuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHN3YWxPcGVuQW5pbWF0aW9uRmluaXNoZWQpO1xuICB9IGVsc2Uge1xuICAgIGNvbnRhaW5lci5zdHlsZS5vdmVyZmxvd1kgPSAnYXV0byc7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNjcm9sbGJhclBhZGRpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBpbml0aWFsQm9keU92ZXJmbG93XG4gKi9cbmNvbnN0IGZpeFNjcm9sbENvbnRhaW5lciA9IChjb250YWluZXIsIHNjcm9sbGJhclBhZGRpbmcsIGluaXRpYWxCb2R5T3ZlcmZsb3cpID0+IHtcbiAgaU9TZml4KCk7XG4gIGlmIChzY3JvbGxiYXJQYWRkaW5nICYmIGluaXRpYWxCb2R5T3ZlcmZsb3cgIT09ICdoaWRkZW4nKSB7XG4gICAgcmVwbGFjZVNjcm9sbGJhcldpdGhQYWRkaW5nKGluaXRpYWxCb2R5T3ZlcmZsb3cpO1xuICB9XG5cbiAgLy8gc3dlZXRhbGVydDIvaXNzdWVzLzEyNDdcbiAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgY29udGFpbmVyLnNjcm9sbFRvcCA9IDA7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBvcHVwXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAqL1xuY29uc3QgYWRkQ2xhc3NlcyA9IChjb250YWluZXIsIHBvcHVwLCBwYXJhbXMpID0+IHtcbiAgYWRkQ2xhc3MoY29udGFpbmVyLCBwYXJhbXMuc2hvd0NsYXNzLmJhY2tkcm9wKTtcbiAgaWYgKHBhcmFtcy5hbmltYXRpb24pIHtcbiAgICAvLyB0aGlzIHdvcmthcm91bmQgd2l0aCBvcGFjaXR5IGlzIG5lZWRlZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL3N3ZWV0YWxlcnQyL3N3ZWV0YWxlcnQyL2lzc3Vlcy8yMDU5XG4gICAgcG9wdXAuc3R5bGUuc2V0UHJvcGVydHkoJ29wYWNpdHknLCAnMCcsICdpbXBvcnRhbnQnKTtcbiAgICBzaG93KHBvcHVwLCAnZ3JpZCcpO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgLy8gQW5pbWF0ZSBwb3B1cCByaWdodCBhZnRlciBzaG93aW5nIGl0XG4gICAgICBhZGRDbGFzcyhwb3B1cCwgcGFyYW1zLnNob3dDbGFzcy5wb3B1cCk7XG4gICAgICAvLyBhbmQgcmVtb3ZlIHRoZSBvcGFjaXR5IHdvcmthcm91bmRcbiAgICAgIHBvcHVwLnN0eWxlLnJlbW92ZVByb3BlcnR5KCdvcGFjaXR5Jyk7XG4gICAgfSwgU0hPV19DTEFTU19USU1FT1VUKTsgLy8gMTBtcyBpbiBvcmRlciB0byBmaXggIzIwNjJcbiAgfSBlbHNlIHtcbiAgICBzaG93KHBvcHVwLCAnZ3JpZCcpO1xuICB9XG4gIGFkZENsYXNzKFtkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIGRvY3VtZW50LmJvZHldLCBzd2FsQ2xhc3Nlcy5zaG93bik7XG4gIGlmIChwYXJhbXMuaGVpZ2h0QXV0byAmJiBwYXJhbXMuYmFja2Ryb3AgJiYgIXBhcmFtcy50b2FzdCkge1xuICAgIGFkZENsYXNzKFtkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIGRvY3VtZW50LmJvZHldLCBzd2FsQ2xhc3Nlc1snaGVpZ2h0LWF1dG8nXSk7XG4gIH1cbn07XG5cbnZhciBkZWZhdWx0SW5wdXRWYWxpZGF0b3JzID0ge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW3ZhbGlkYXRpb25NZXNzYWdlXVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmcgfCB2b2lkPn1cbiAgICovXG4gIGVtYWlsOiAoc3RyaW5nLCB2YWxpZGF0aW9uTWVzc2FnZSkgPT4ge1xuICAgIHJldHVybiAvXlthLXpBLVowLTkuK18nLV0rQFthLXpBLVowLTkuLV0rXFwuW2EtekEtWjAtOS1dKyQvLnRlc3Qoc3RyaW5nKSA/IFByb21pc2UucmVzb2x2ZSgpIDogUHJvbWlzZS5yZXNvbHZlKHZhbGlkYXRpb25NZXNzYWdlIHx8ICdJbnZhbGlkIGVtYWlsIGFkZHJlc3MnKTtcbiAgfSxcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IFt2YWxpZGF0aW9uTWVzc2FnZV1cbiAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nIHwgdm9pZD59XG4gICAqL1xuICB1cmw6IChzdHJpbmcsIHZhbGlkYXRpb25NZXNzYWdlKSA9PiB7XG4gICAgLy8gdGFrZW4gZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzgwOTQzNSB3aXRoIGEgc21hbGwgY2hhbmdlIGZyb20gIzEzMDYgYW5kICMyMDEzXG4gICAgcmV0dXJuIC9eaHR0cHM/OlxcL1xcLyh3d3dcXC4pP1stYS16QS1aMC05QDolLl8rfiM9XXsxLDI1Nn1cXC5bYS16XXsyLDYzfVxcYihbLWEtekEtWjAtOUA6JV8rLn4jPyYvPV0qKSQvLnRlc3Qoc3RyaW5nKSA/IFByb21pc2UucmVzb2x2ZSgpIDogUHJvbWlzZS5yZXNvbHZlKHZhbGlkYXRpb25NZXNzYWdlIHx8ICdJbnZhbGlkIFVSTCcpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICovXG5mdW5jdGlvbiBzZXREZWZhdWx0SW5wdXRWYWxpZGF0b3JzKHBhcmFtcykge1xuICAvLyBVc2UgZGVmYXVsdCBgaW5wdXRWYWxpZGF0b3JgIGZvciBzdXBwb3J0ZWQgaW5wdXQgdHlwZXMgaWYgbm90IHByb3ZpZGVkXG4gIGlmIChwYXJhbXMuaW5wdXRWYWxpZGF0b3IpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHBhcmFtcy5pbnB1dCA9PT0gJ2VtYWlsJykge1xuICAgIHBhcmFtcy5pbnB1dFZhbGlkYXRvciA9IGRlZmF1bHRJbnB1dFZhbGlkYXRvcnNbJ2VtYWlsJ107XG4gIH1cbiAgaWYgKHBhcmFtcy5pbnB1dCA9PT0gJ3VybCcpIHtcbiAgICBwYXJhbXMuaW5wdXRWYWxpZGF0b3IgPSBkZWZhdWx0SW5wdXRWYWxpZGF0b3JzWyd1cmwnXTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUN1c3RvbVRhcmdldEVsZW1lbnQocGFyYW1zKSB7XG4gIC8vIERldGVybWluZSBpZiB0aGUgY3VzdG9tIHRhcmdldCBlbGVtZW50IGlzIHZhbGlkXG4gIGlmICghcGFyYW1zLnRhcmdldCB8fCB0eXBlb2YgcGFyYW1zLnRhcmdldCA9PT0gJ3N0cmluZycgJiYgIWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IocGFyYW1zLnRhcmdldCkgfHwgdHlwZW9mIHBhcmFtcy50YXJnZXQgIT09ICdzdHJpbmcnICYmICFwYXJhbXMudGFyZ2V0LmFwcGVuZENoaWxkKSB7XG4gICAgd2FybignVGFyZ2V0IHBhcmFtZXRlciBpcyBub3QgdmFsaWQsIGRlZmF1bHRpbmcgdG8gXCJib2R5XCInKTtcbiAgICBwYXJhbXMudGFyZ2V0ID0gJ2JvZHknO1xuICB9XG59XG5cbi8qKlxuICogU2V0IHR5cGUsIHRleHQgYW5kIGFjdGlvbnMgb24gcG9wdXBcbiAqXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAqL1xuZnVuY3Rpb24gc2V0UGFyYW1ldGVycyhwYXJhbXMpIHtcbiAgc2V0RGVmYXVsdElucHV0VmFsaWRhdG9ycyhwYXJhbXMpO1xuXG4gIC8vIHNob3dMb2FkZXJPbkNvbmZpcm0gJiYgcHJlQ29uZmlybVxuICBpZiAocGFyYW1zLnNob3dMb2FkZXJPbkNvbmZpcm0gJiYgIXBhcmFtcy5wcmVDb25maXJtKSB7XG4gICAgd2Fybignc2hvd0xvYWRlck9uQ29uZmlybSBpcyBzZXQgdG8gdHJ1ZSwgYnV0IHByZUNvbmZpcm0gaXMgbm90IGRlZmluZWQuXFxuJyArICdzaG93TG9hZGVyT25Db25maXJtIHNob3VsZCBiZSB1c2VkIHRvZ2V0aGVyIHdpdGggcHJlQ29uZmlybSwgc2VlIHVzYWdlIGV4YW1wbGU6XFxuJyArICdodHRwczovL3N3ZWV0YWxlcnQyLmdpdGh1Yi5pby8jYWpheC1yZXF1ZXN0Jyk7XG4gIH1cbiAgdmFsaWRhdGVDdXN0b21UYXJnZXRFbGVtZW50KHBhcmFtcyk7XG5cbiAgLy8gUmVwbGFjZSBuZXdsaW5lcyB3aXRoIDxicj4gaW4gdGl0bGVcbiAgaWYgKHR5cGVvZiBwYXJhbXMudGl0bGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcGFyYW1zLnRpdGxlID0gcGFyYW1zLnRpdGxlLnNwbGl0KCdcXG4nKS5qb2luKCc8YnIgLz4nKTtcbiAgfVxuICBpbml0KHBhcmFtcyk7XG59XG5cbi8qKiBAdHlwZSB7U3dlZXRBbGVydH0gKi9cbmxldCBjdXJyZW50SW5zdGFuY2U7XG52YXIgX3Byb21pc2UgPSAvKiNfX1BVUkVfXyovbmV3IFdlYWtNYXAoKTtcbmNsYXNzIFN3ZWV0QWxlcnQge1xuICAvKipcbiAgICogQHBhcmFtIHsuLi4oU3dlZXRBbGVydE9wdGlvbnMgfCBzdHJpbmcpfSBhcmdzXG4gICAqIEB0aGlzIHtTd2VldEFsZXJ0fVxuICAgKi9cbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtQcm9taXNlPFN3ZWV0QWxlcnRSZXN1bHQ+fVxuICAgICAqL1xuICAgIF9jbGFzc1ByaXZhdGVGaWVsZEluaXRTcGVjKHRoaXMsIF9wcm9taXNlLCB2b2lkIDApO1xuICAgIC8vIFByZXZlbnQgcnVuIGluIE5vZGUgZW52XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGN1cnJlbnRJbnN0YW5jZSA9IHRoaXM7XG5cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc3Qgb3V0ZXJQYXJhbXMgPSBPYmplY3QuZnJlZXplKHRoaXMuY29uc3RydWN0b3IuYXJnc1RvUGFyYW1zKGFyZ3MpKTtcblxuICAgIC8qKiBAdHlwZSB7UmVhZG9ubHk8U3dlZXRBbGVydE9wdGlvbnM+fSAqL1xuICAgIHRoaXMucGFyYW1zID0gb3V0ZXJQYXJhbXM7XG5cbiAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgdGhpcy5pc0F3YWl0aW5nUHJvbWlzZSA9IGZhbHNlO1xuICAgIF9jbGFzc1ByaXZhdGVGaWVsZFNldDIoX3Byb21pc2UsIHRoaXMsIHRoaXMuX21haW4oY3VycmVudEluc3RhbmNlLnBhcmFtcykpO1xuICB9XG4gIF9tYWluKHVzZXJQYXJhbXMsIG1peGluUGFyYW1zID0ge30pIHtcbiAgICBzaG93V2FybmluZ3NGb3JQYXJhbXMoT2JqZWN0LmFzc2lnbih7fSwgbWl4aW5QYXJhbXMsIHVzZXJQYXJhbXMpKTtcbiAgICBpZiAoZ2xvYmFsU3RhdGUuY3VycmVudEluc3RhbmNlKSB7XG4gICAgICBjb25zdCBzd2FsUHJvbWlzZVJlc29sdmUgPSBwcml2YXRlTWV0aG9kcy5zd2FsUHJvbWlzZVJlc29sdmUuZ2V0KGdsb2JhbFN0YXRlLmN1cnJlbnRJbnN0YW5jZSk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGlzQXdhaXRpbmdQcm9taXNlXG4gICAgICB9ID0gZ2xvYmFsU3RhdGUuY3VycmVudEluc3RhbmNlO1xuICAgICAgZ2xvYmFsU3RhdGUuY3VycmVudEluc3RhbmNlLl9kZXN0cm95KCk7XG4gICAgICBpZiAoIWlzQXdhaXRpbmdQcm9taXNlKSB7XG4gICAgICAgIHN3YWxQcm9taXNlUmVzb2x2ZSh7XG4gICAgICAgICAgaXNEaXNtaXNzZWQ6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNNb2RhbCgpKSB7XG4gICAgICAgIHVuc2V0QXJpYUhpZGRlbigpO1xuICAgICAgfVxuICAgIH1cbiAgICBnbG9iYWxTdGF0ZS5jdXJyZW50SW5zdGFuY2UgPSBjdXJyZW50SW5zdGFuY2U7XG4gICAgY29uc3QgaW5uZXJQYXJhbXMgPSBwcmVwYXJlUGFyYW1zKHVzZXJQYXJhbXMsIG1peGluUGFyYW1zKTtcbiAgICBzZXRQYXJhbWV0ZXJzKGlubmVyUGFyYW1zKTtcbiAgICBPYmplY3QuZnJlZXplKGlubmVyUGFyYW1zKTtcblxuICAgIC8vIGNsZWFyIHRoZSBwcmV2aW91cyB0aW1lclxuICAgIGlmIChnbG9iYWxTdGF0ZS50aW1lb3V0KSB7XG4gICAgICBnbG9iYWxTdGF0ZS50aW1lb3V0LnN0b3AoKTtcbiAgICAgIGRlbGV0ZSBnbG9iYWxTdGF0ZS50aW1lb3V0O1xuICAgIH1cblxuICAgIC8vIGNsZWFyIHRoZSByZXN0b3JlIGZvY3VzIHRpbWVvdXRcbiAgICBjbGVhclRpbWVvdXQoZ2xvYmFsU3RhdGUucmVzdG9yZUZvY3VzVGltZW91dCk7XG4gICAgY29uc3QgZG9tQ2FjaGUgPSBwb3B1bGF0ZURvbUNhY2hlKGN1cnJlbnRJbnN0YW5jZSk7XG4gICAgcmVuZGVyKGN1cnJlbnRJbnN0YW5jZSwgaW5uZXJQYXJhbXMpO1xuICAgIHByaXZhdGVQcm9wcy5pbm5lclBhcmFtcy5zZXQoY3VycmVudEluc3RhbmNlLCBpbm5lclBhcmFtcyk7XG4gICAgcmV0dXJuIHN3YWxQcm9taXNlKGN1cnJlbnRJbnN0YW5jZSwgZG9tQ2FjaGUsIGlubmVyUGFyYW1zKTtcbiAgfVxuXG4gIC8vIGBjYXRjaGAgY2Fubm90IGJlIHRoZSBuYW1lIG9mIGEgbW9kdWxlIGV4cG9ydCwgc28gd2UgZGVmaW5lIG91ciB0aGVuYWJsZSBtZXRob2RzIGhlcmUgaW5zdGVhZFxuICB0aGVuKG9uRnVsZmlsbGVkKSB7XG4gICAgcmV0dXJuIF9jbGFzc1ByaXZhdGVGaWVsZEdldDIoX3Byb21pc2UsIHRoaXMpLnRoZW4ob25GdWxmaWxsZWQpO1xuICB9XG4gIGZpbmFsbHkob25GaW5hbGx5KSB7XG4gICAgcmV0dXJuIF9jbGFzc1ByaXZhdGVGaWVsZEdldDIoX3Byb21pc2UsIHRoaXMpLmZpbmFsbHkob25GaW5hbGx5KTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7U3dlZXRBbGVydH0gaW5zdGFuY2VcbiAqIEBwYXJhbSB7RG9tQ2FjaGV9IGRvbUNhY2hlXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBpbm5lclBhcmFtc1xuICogQHJldHVybnMge1Byb21pc2V9XG4gKi9cbmNvbnN0IHN3YWxQcm9taXNlID0gKGluc3RhbmNlLCBkb21DYWNoZSwgaW5uZXJQYXJhbXMpID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAvLyBmdW5jdGlvbnMgdG8gaGFuZGxlIGFsbCBjbG9zaW5ncy9kaXNtaXNzYWxzXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtEaXNtaXNzUmVhc29ufSBkaXNtaXNzXG4gICAgICovXG4gICAgY29uc3QgZGlzbWlzc1dpdGggPSBkaXNtaXNzID0+IHtcbiAgICAgIGluc3RhbmNlLmNsb3NlKHtcbiAgICAgICAgaXNEaXNtaXNzZWQ6IHRydWUsXG4gICAgICAgIGRpc21pc3MsXG4gICAgICAgIGlzQ29uZmlybWVkOiBmYWxzZSxcbiAgICAgICAgaXNEZW5pZWQ6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9O1xuICAgIHByaXZhdGVNZXRob2RzLnN3YWxQcm9taXNlUmVzb2x2ZS5zZXQoaW5zdGFuY2UsIHJlc29sdmUpO1xuICAgIHByaXZhdGVNZXRob2RzLnN3YWxQcm9taXNlUmVqZWN0LnNldChpbnN0YW5jZSwgcmVqZWN0KTtcbiAgICBkb21DYWNoZS5jb25maXJtQnV0dG9uLm9uY2xpY2sgPSAoKSA9PiB7XG4gICAgICBoYW5kbGVDb25maXJtQnV0dG9uQ2xpY2soaW5zdGFuY2UpO1xuICAgIH07XG4gICAgZG9tQ2FjaGUuZGVueUJ1dHRvbi5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgaGFuZGxlRGVueUJ1dHRvbkNsaWNrKGluc3RhbmNlKTtcbiAgICB9O1xuICAgIGRvbUNhY2hlLmNhbmNlbEJ1dHRvbi5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgaGFuZGxlQ2FuY2VsQnV0dG9uQ2xpY2soaW5zdGFuY2UsIGRpc21pc3NXaXRoKTtcbiAgICB9O1xuICAgIGRvbUNhY2hlLmNsb3NlQnV0dG9uLm9uY2xpY2sgPSAoKSA9PiB7XG4gICAgICBkaXNtaXNzV2l0aChEaXNtaXNzUmVhc29uLmNsb3NlKTtcbiAgICB9O1xuICAgIGhhbmRsZVBvcHVwQ2xpY2soaW5uZXJQYXJhbXMsIGRvbUNhY2hlLCBkaXNtaXNzV2l0aCk7XG4gICAgYWRkS2V5ZG93bkhhbmRsZXIoZ2xvYmFsU3RhdGUsIGlubmVyUGFyYW1zLCBkaXNtaXNzV2l0aCk7XG4gICAgaGFuZGxlSW5wdXRPcHRpb25zQW5kVmFsdWUoaW5zdGFuY2UsIGlubmVyUGFyYW1zKTtcbiAgICBvcGVuUG9wdXAoaW5uZXJQYXJhbXMpO1xuICAgIHNldHVwVGltZXIoZ2xvYmFsU3RhdGUsIGlubmVyUGFyYW1zLCBkaXNtaXNzV2l0aCk7XG4gICAgaW5pdEZvY3VzKGRvbUNhY2hlLCBpbm5lclBhcmFtcyk7XG5cbiAgICAvLyBTY3JvbGwgY29udGFpbmVyIHRvIHRvcCBvbiBvcGVuICgjMTI0NywgIzE5NDYpXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBkb21DYWNoZS5jb250YWluZXIuc2Nyb2xsVG9wID0gMDtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHVzZXJQYXJhbXNcbiAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IG1peGluUGFyYW1zXG4gKiBAcmV0dXJucyB7U3dlZXRBbGVydE9wdGlvbnN9XG4gKi9cbmNvbnN0IHByZXBhcmVQYXJhbXMgPSAodXNlclBhcmFtcywgbWl4aW5QYXJhbXMpID0+IHtcbiAgY29uc3QgdGVtcGxhdGVQYXJhbXMgPSBnZXRUZW1wbGF0ZVBhcmFtcyh1c2VyUGFyYW1zKTtcbiAgY29uc3QgcGFyYW1zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFBhcmFtcywgbWl4aW5QYXJhbXMsIHRlbXBsYXRlUGFyYW1zLCB1c2VyUGFyYW1zKTsgLy8gcHJlY2VkZW5jZSBpcyBkZXNjcmliZWQgaW4gIzIxMzFcbiAgcGFyYW1zLnNob3dDbGFzcyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRQYXJhbXMuc2hvd0NsYXNzLCBwYXJhbXMuc2hvd0NsYXNzKTtcbiAgcGFyYW1zLmhpZGVDbGFzcyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRQYXJhbXMuaGlkZUNsYXNzLCBwYXJhbXMuaGlkZUNsYXNzKTtcbiAgaWYgKHBhcmFtcy5hbmltYXRpb24gPT09IGZhbHNlKSB7XG4gICAgcGFyYW1zLnNob3dDbGFzcyA9IHtcbiAgICAgIGJhY2tkcm9wOiAnc3dhbDItbm9hbmltYXRpb24nXG4gICAgfTtcbiAgICBwYXJhbXMuaGlkZUNsYXNzID0ge307XG4gIH1cbiAgcmV0dXJuIHBhcmFtcztcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTd2VldEFsZXJ0fSBpbnN0YW5jZVxuICogQHJldHVybnMge0RvbUNhY2hlfVxuICovXG5jb25zdCBwb3B1bGF0ZURvbUNhY2hlID0gaW5zdGFuY2UgPT4ge1xuICBjb25zdCBkb21DYWNoZSA9IHtcbiAgICBwb3B1cDogZ2V0UG9wdXAoKSxcbiAgICBjb250YWluZXI6IGdldENvbnRhaW5lcigpLFxuICAgIGFjdGlvbnM6IGdldEFjdGlvbnMoKSxcbiAgICBjb25maXJtQnV0dG9uOiBnZXRDb25maXJtQnV0dG9uKCksXG4gICAgZGVueUJ1dHRvbjogZ2V0RGVueUJ1dHRvbigpLFxuICAgIGNhbmNlbEJ1dHRvbjogZ2V0Q2FuY2VsQnV0dG9uKCksXG4gICAgbG9hZGVyOiBnZXRMb2FkZXIoKSxcbiAgICBjbG9zZUJ1dHRvbjogZ2V0Q2xvc2VCdXR0b24oKSxcbiAgICB2YWxpZGF0aW9uTWVzc2FnZTogZ2V0VmFsaWRhdGlvbk1lc3NhZ2UoKSxcbiAgICBwcm9ncmVzc1N0ZXBzOiBnZXRQcm9ncmVzc1N0ZXBzKClcbiAgfTtcbiAgcHJpdmF0ZVByb3BzLmRvbUNhY2hlLnNldChpbnN0YW5jZSwgZG9tQ2FjaGUpO1xuICByZXR1cm4gZG9tQ2FjaGU7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7R2xvYmFsU3RhdGV9IGdsb2JhbFN0YXRlXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBpbm5lclBhcmFtc1xuICogQHBhcmFtIHsoZGlzbWlzczogRGlzbWlzc1JlYXNvbikgPT4gdm9pZH0gZGlzbWlzc1dpdGhcbiAqL1xuY29uc3Qgc2V0dXBUaW1lciA9IChnbG9iYWxTdGF0ZSwgaW5uZXJQYXJhbXMsIGRpc21pc3NXaXRoKSA9PiB7XG4gIGNvbnN0IHRpbWVyUHJvZ3Jlc3NCYXIgPSBnZXRUaW1lclByb2dyZXNzQmFyKCk7XG4gIGhpZGUodGltZXJQcm9ncmVzc0Jhcik7XG4gIGlmIChpbm5lclBhcmFtcy50aW1lcikge1xuICAgIGdsb2JhbFN0YXRlLnRpbWVvdXQgPSBuZXcgVGltZXIoKCkgPT4ge1xuICAgICAgZGlzbWlzc1dpdGgoJ3RpbWVyJyk7XG4gICAgICBkZWxldGUgZ2xvYmFsU3RhdGUudGltZW91dDtcbiAgICB9LCBpbm5lclBhcmFtcy50aW1lcik7XG4gICAgaWYgKGlubmVyUGFyYW1zLnRpbWVyUHJvZ3Jlc3NCYXIpIHtcbiAgICAgIHNob3codGltZXJQcm9ncmVzc0Jhcik7XG4gICAgICBhcHBseUN1c3RvbUNsYXNzKHRpbWVyUHJvZ3Jlc3NCYXIsIGlubmVyUGFyYW1zLCAndGltZXJQcm9ncmVzc0JhcicpO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmIChnbG9iYWxTdGF0ZS50aW1lb3V0ICYmIGdsb2JhbFN0YXRlLnRpbWVvdXQucnVubmluZykge1xuICAgICAgICAgIC8vIHRpbWVyIGNhbiBiZSBhbHJlYWR5IHN0b3BwZWQgb3IgdW5zZXQgYXQgdGhpcyBwb2ludFxuICAgICAgICAgIGFuaW1hdGVUaW1lclByb2dyZXNzQmFyKGlubmVyUGFyYW1zLnRpbWVyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEluaXRpYWxpemUgZm9jdXMgaW4gdGhlIHBvcHVwOlxuICpcbiAqIDEuIElmIGB0b2FzdGAgaXMgYHRydWVgLCBkb24ndCBzdGVhbCBmb2N1cyBmcm9tIHRoZSBkb2N1bWVudC5cbiAqIDIuIEVsc2UgaWYgdGhlcmUgaXMgYW4gW2F1dG9mb2N1c10gZWxlbWVudCwgZm9jdXMgaXQuXG4gKiAzLiBFbHNlIGlmIGBmb2N1c0NvbmZpcm1gIGlzIGB0cnVlYCBhbmQgY29uZmlybSBidXR0b24gaXMgdmlzaWJsZSwgZm9jdXMgaXQuXG4gKiA0LiBFbHNlIGlmIGBmb2N1c0RlbnlgIGlzIGB0cnVlYCBhbmQgZGVueSBidXR0b24gaXMgdmlzaWJsZSwgZm9jdXMgaXQuXG4gKiA1LiBFbHNlIGlmIGBmb2N1c0NhbmNlbGAgaXMgYHRydWVgIGFuZCBjYW5jZWwgYnV0dG9uIGlzIHZpc2libGUsIGZvY3VzIGl0LlxuICogNi4gRWxzZSBmb2N1cyB0aGUgZmlyc3QgZm9jdXNhYmxlIGVsZW1lbnQgaW4gYSBwb3B1cCAoaWYgYW55KS5cbiAqXG4gKiBAcGFyYW0ge0RvbUNhY2hlfSBkb21DYWNoZVxuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gaW5uZXJQYXJhbXNcbiAqL1xuY29uc3QgaW5pdEZvY3VzID0gKGRvbUNhY2hlLCBpbm5lclBhcmFtcykgPT4ge1xuICBpZiAoaW5uZXJQYXJhbXMudG9hc3QpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gVE9ETzogdGhpcyBpcyBkdW1iLCByZW1vdmUgYGFsbG93RW50ZXJLZXlgIHBhcmFtIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb25cbiAgaWYgKCFjYWxsSWZGdW5jdGlvbihpbm5lclBhcmFtcy5hbGxvd0VudGVyS2V5KSkge1xuICAgIHdhcm5BYm91dERlcHJlY2F0aW9uKCdhbGxvd0VudGVyS2V5Jyk7XG4gICAgYmx1ckFjdGl2ZUVsZW1lbnQoKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGZvY3VzQXV0b2ZvY3VzKGRvbUNhY2hlKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZm9jdXNCdXR0b24oZG9tQ2FjaGUsIGlubmVyUGFyYW1zKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBzZXRGb2N1cygtMSwgMSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RG9tQ2FjaGV9IGRvbUNhY2hlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuY29uc3QgZm9jdXNBdXRvZm9jdXMgPSBkb21DYWNoZSA9PiB7XG4gIGNvbnN0IGF1dG9mb2N1c0VsZW1lbnRzID0gQXJyYXkuZnJvbShkb21DYWNoZS5wb3B1cC5xdWVyeVNlbGVjdG9yQWxsKCdbYXV0b2ZvY3VzXScpKTtcbiAgZm9yIChjb25zdCBhdXRvZm9jdXNFbGVtZW50IG9mIGF1dG9mb2N1c0VsZW1lbnRzKSB7XG4gICAgaWYgKGF1dG9mb2N1c0VsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJiBpc1Zpc2libGUkMShhdXRvZm9jdXNFbGVtZW50KSkge1xuICAgICAgYXV0b2ZvY3VzRWxlbWVudC5mb2N1cygpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtEb21DYWNoZX0gZG9tQ2FjaGVcbiAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IGlubmVyUGFyYW1zXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuY29uc3QgZm9jdXNCdXR0b24gPSAoZG9tQ2FjaGUsIGlubmVyUGFyYW1zKSA9PiB7XG4gIGlmIChpbm5lclBhcmFtcy5mb2N1c0RlbnkgJiYgaXNWaXNpYmxlJDEoZG9tQ2FjaGUuZGVueUJ1dHRvbikpIHtcbiAgICBkb21DYWNoZS5kZW55QnV0dG9uLmZvY3VzKCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGlubmVyUGFyYW1zLmZvY3VzQ2FuY2VsICYmIGlzVmlzaWJsZSQxKGRvbUNhY2hlLmNhbmNlbEJ1dHRvbikpIHtcbiAgICBkb21DYWNoZS5jYW5jZWxCdXR0b24uZm9jdXMoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoaW5uZXJQYXJhbXMuZm9jdXNDb25maXJtICYmIGlzVmlzaWJsZSQxKGRvbUNhY2hlLmNvbmZpcm1CdXR0b24pKSB7XG4gICAgZG9tQ2FjaGUuY29uZmlybUJ1dHRvbi5mb2N1cygpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5jb25zdCBibHVyQWN0aXZlRWxlbWVudCA9ICgpID0+IHtcbiAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJiB0eXBlb2YgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5ibHVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5ibHVyKCk7XG4gIH1cbn07XG5cbi8vIEFzc2lnbiBpbnN0YW5jZSBtZXRob2RzIGZyb20gc3JjL2luc3RhbmNlTWV0aG9kcy8qLmpzIHRvIHByb3RvdHlwZVxuU3dlZXRBbGVydC5wcm90b3R5cGUuZGlzYWJsZUJ1dHRvbnMgPSBkaXNhYmxlQnV0dG9ucztcblN3ZWV0QWxlcnQucHJvdG90eXBlLmVuYWJsZUJ1dHRvbnMgPSBlbmFibGVCdXR0b25zO1xuU3dlZXRBbGVydC5wcm90b3R5cGUuZ2V0SW5wdXQgPSBnZXRJbnB1dDtcblN3ZWV0QWxlcnQucHJvdG90eXBlLmRpc2FibGVJbnB1dCA9IGRpc2FibGVJbnB1dDtcblN3ZWV0QWxlcnQucHJvdG90eXBlLmVuYWJsZUlucHV0ID0gZW5hYmxlSW5wdXQ7XG5Td2VldEFsZXJ0LnByb3RvdHlwZS5oaWRlTG9hZGluZyA9IGhpZGVMb2FkaW5nO1xuU3dlZXRBbGVydC5wcm90b3R5cGUuZGlzYWJsZUxvYWRpbmcgPSBoaWRlTG9hZGluZztcblN3ZWV0QWxlcnQucHJvdG90eXBlLnNob3dWYWxpZGF0aW9uTWVzc2FnZSA9IHNob3dWYWxpZGF0aW9uTWVzc2FnZTtcblN3ZWV0QWxlcnQucHJvdG90eXBlLnJlc2V0VmFsaWRhdGlvbk1lc3NhZ2UgPSByZXNldFZhbGlkYXRpb25NZXNzYWdlO1xuU3dlZXRBbGVydC5wcm90b3R5cGUuY2xvc2UgPSBjbG9zZTtcblN3ZWV0QWxlcnQucHJvdG90eXBlLmNsb3NlUG9wdXAgPSBjbG9zZTtcblN3ZWV0QWxlcnQucHJvdG90eXBlLmNsb3NlTW9kYWwgPSBjbG9zZTtcblN3ZWV0QWxlcnQucHJvdG90eXBlLmNsb3NlVG9hc3QgPSBjbG9zZTtcblN3ZWV0QWxlcnQucHJvdG90eXBlLnJlamVjdFByb21pc2UgPSByZWplY3RQcm9taXNlO1xuU3dlZXRBbGVydC5wcm90b3R5cGUudXBkYXRlID0gdXBkYXRlO1xuU3dlZXRBbGVydC5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBfZGVzdHJveTtcblxuLy8gQXNzaWduIHN0YXRpYyBtZXRob2RzIGZyb20gc3JjL3N0YXRpY01ldGhvZHMvKi5qcyB0byBjb25zdHJ1Y3RvclxuT2JqZWN0LmFzc2lnbihTd2VldEFsZXJ0LCBzdGF0aWNNZXRob2RzKTtcblxuLy8gUHJveHkgdG8gaW5zdGFuY2UgbWV0aG9kcyB0byBjb25zdHJ1Y3RvciwgZm9yIG5vdywgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5PYmplY3Qua2V5cyhpbnN0YW5jZU1ldGhvZHMpLmZvckVhY2goa2V5ID0+IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7Li4uKFN3ZWV0QWxlcnRPcHRpb25zIHwgc3RyaW5nIHwgdW5kZWZpbmVkKX0gYXJnc1xuICAgKiBAcmV0dXJucyB7U3dlZXRBbGVydFJlc3VsdCB8IFByb21pc2U8U3dlZXRBbGVydFJlc3VsdD4gfCB1bmRlZmluZWR9XG4gICAqL1xuICBTd2VldEFsZXJ0W2tleV0gPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgIGlmIChjdXJyZW50SW5zdGFuY2UgJiYgY3VycmVudEluc3RhbmNlW2tleV0pIHtcbiAgICAgIHJldHVybiBjdXJyZW50SW5zdGFuY2Vba2V5XSguLi5hcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG59KTtcblN3ZWV0QWxlcnQuRGlzbWlzc1JlYXNvbiA9IERpc21pc3NSZWFzb247XG5Td2VldEFsZXJ0LnZlcnNpb24gPSAnMTEuMjYuMTAnO1xuXG5jb25zdCBTd2FsID0gU3dlZXRBbGVydDtcbi8vIEB0cy1pZ25vcmVcblN3YWwuZGVmYXVsdCA9IFN3YWw7XG5cbmV4cG9ydCB7IFN3YWwgYXMgZGVmYXVsdCB9O1xuXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGRvY3VtZW50JiZmdW5jdGlvbihlLHQpe3ZhciBuPWUuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO2lmKGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdLmFwcGVuZENoaWxkKG4pLG4uc3R5bGVTaGVldCluLnN0eWxlU2hlZXQuZGlzYWJsZWR8fChuLnN0eWxlU2hlZXQuY3NzVGV4dD10KTtlbHNlIHRyeXtuLmlubmVySFRNTD10fWNhdGNoKGUpe24uaW5uZXJUZXh0PXR9fShkb2N1bWVudCxcIjpyb290ey0tc3dhbDItb3V0bGluZTogMCAwIDAgM3B4IHJnYmEoMTAwLCAxNTAsIDIwMCwgMC41KTstLXN3YWwyLWNvbnRhaW5lci1wYWRkaW5nOiAwLjYyNWVtOy0tc3dhbDItYmFja2Ryb3A6IHJnYmEoMCwgMCwgMCwgMC40KTstLXN3YWwyLWJhY2tkcm9wLXRyYW5zaXRpb246IGJhY2tncm91bmQtY29sb3IgMC4xNXM7LS1zd2FsMi13aWR0aDogMzJlbTstLXN3YWwyLXBhZGRpbmc6IDAgMCAxLjI1ZW07LS1zd2FsMi1ib3JkZXI6IG5vbmU7LS1zd2FsMi1ib3JkZXItcmFkaXVzOiAwLjMxMjVyZW07LS1zd2FsMi1iYWNrZ3JvdW5kOiB3aGl0ZTstLXN3YWwyLWNvbG9yOiAjNTQ1NDU0Oy0tc3dhbDItc2hvdy1hbmltYXRpb246IHN3YWwyLXNob3cgMC4zczstLXN3YWwyLWhpZGUtYW5pbWF0aW9uOiBzd2FsMi1oaWRlIDAuMTVzIGZvcndhcmRzOy0tc3dhbDItaWNvbi16b29tOiAxOy0tc3dhbDItaWNvbi1hbmltYXRpb25zOiB0cnVlOy0tc3dhbDItdGl0bGUtcGFkZGluZzogMC44ZW0gMWVtIDA7LS1zd2FsMi1odG1sLWNvbnRhaW5lci1wYWRkaW5nOiAxZW0gMS42ZW0gMC4zZW07LS1zd2FsMi1pbnB1dC1ib3JkZXI6IDFweCBzb2xpZCAjZDlkOWQ5Oy0tc3dhbDItaW5wdXQtYm9yZGVyLXJhZGl1czogMC4xODc1ZW07LS1zd2FsMi1pbnB1dC1ib3gtc2hhZG93OiBpbnNldCAwIDFweCAxcHggcmdiYSgwLCAwLCAwLCAwLjA2KSwgMCAwIDAgM3B4IHRyYW5zcGFyZW50Oy0tc3dhbDItaW5wdXQtYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7LS1zd2FsMi1pbnB1dC10cmFuc2l0aW9uOiBib3JkZXItY29sb3IgMC4ycywgYm94LXNoYWRvdyAwLjJzOy0tc3dhbDItaW5wdXQtaG92ZXItYm94LXNoYWRvdzogaW5zZXQgMCAxcHggMXB4IHJnYmEoMCwgMCwgMCwgMC4wNiksIDAgMCAwIDNweCB0cmFuc3BhcmVudDstLXN3YWwyLWlucHV0LWZvY3VzLWJvcmRlcjogMXB4IHNvbGlkICNiNGRiZWQ7LS1zd2FsMi1pbnB1dC1mb2N1cy1ib3gtc2hhZG93OiBpbnNldCAwIDFweCAxcHggcmdiYSgwLCAwLCAwLCAwLjA2KSwgMCAwIDAgM3B4IHJnYmEoMTAwLCAxNTAsIDIwMCwgMC41KTstLXN3YWwyLXByb2dyZXNzLXN0ZXAtYmFja2dyb3VuZDogI2FkZDhlNjstLXN3YWwyLXZhbGlkYXRpb24tbWVzc2FnZS1iYWNrZ3JvdW5kOiAjZjBmMGYwOy0tc3dhbDItdmFsaWRhdGlvbi1tZXNzYWdlLWNvbG9yOiAjNjY2Oy0tc3dhbDItZm9vdGVyLWJvcmRlci1jb2xvcjogI2VlZTstLXN3YWwyLWZvb3Rlci1iYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDstLXN3YWwyLWZvb3Rlci1jb2xvcjogaW5oZXJpdDstLXN3YWwyLXRpbWVyLXByb2dyZXNzLWJhci1iYWNrZ3JvdW5kOiByZ2JhKDAsIDAsIDAsIDAuMyk7LS1zd2FsMi1jbG9zZS1idXR0b24tcG9zaXRpb246IGluaXRpYWw7LS1zd2FsMi1jbG9zZS1idXR0b24taW5zZXQ6IGF1dG87LS1zd2FsMi1jbG9zZS1idXR0b24tZm9udC1zaXplOiAyLjVlbTstLXN3YWwyLWNsb3NlLWJ1dHRvbi1jb2xvcjogI2NjYzstLXN3YWwyLWNsb3NlLWJ1dHRvbi10cmFuc2l0aW9uOiBjb2xvciAwLjJzLCBib3gtc2hhZG93IDAuMnM7LS1zd2FsMi1jbG9zZS1idXR0b24tb3V0bGluZTogaW5pdGlhbDstLXN3YWwyLWNsb3NlLWJ1dHRvbi1ib3gtc2hhZG93OiBpbnNldCAwIDAgMCAzcHggdHJhbnNwYXJlbnQ7LS1zd2FsMi1jbG9zZS1idXR0b24tZm9jdXMtYm94LXNoYWRvdzogaW5zZXQgdmFyKC0tc3dhbDItb3V0bGluZSk7LS1zd2FsMi1jbG9zZS1idXR0b24taG92ZXItdHJhbnNmb3JtOiBub25lOy0tc3dhbDItYWN0aW9ucy1qdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjstLXN3YWwyLWFjdGlvbnMtd2lkdGg6IGF1dG87LS1zd2FsMi1hY3Rpb25zLW1hcmdpbjogMS4yNWVtIGF1dG8gMDstLXN3YWwyLWFjdGlvbnMtcGFkZGluZzogMDstLXN3YWwyLWFjdGlvbnMtYm9yZGVyLXJhZGl1czogMDstLXN3YWwyLWFjdGlvbnMtYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7LS1zd2FsMi1hY3Rpb24tYnV0dG9uLXRyYW5zaXRpb246IGJhY2tncm91bmQtY29sb3IgMC4ycywgYm94LXNoYWRvdyAwLjJzOy0tc3dhbDItYWN0aW9uLWJ1dHRvbi1ob3ZlcjogYmxhY2sgMTAlOy0tc3dhbDItYWN0aW9uLWJ1dHRvbi1hY3RpdmU6IGJsYWNrIDEwJTstLXN3YWwyLWNvbmZpcm0tYnV0dG9uLWJveC1zaGFkb3c6IG5vbmU7LS1zd2FsMi1jb25maXJtLWJ1dHRvbi1ib3JkZXItcmFkaXVzOiAwLjI1ZW07LS1zd2FsMi1jb25maXJtLWJ1dHRvbi1iYWNrZ3JvdW5kLWNvbG9yOiAjNzA2NmUwOy0tc3dhbDItY29uZmlybS1idXR0b24tY29sb3I6ICNmZmY7LS1zd2FsMi1kZW55LWJ1dHRvbi1ib3gtc2hhZG93OiBub25lOy0tc3dhbDItZGVueS1idXR0b24tYm9yZGVyLXJhZGl1czogMC4yNWVtOy0tc3dhbDItZGVueS1idXR0b24tYmFja2dyb3VuZC1jb2xvcjogI2RjMzc0MTstLXN3YWwyLWRlbnktYnV0dG9uLWNvbG9yOiAjZmZmOy0tc3dhbDItY2FuY2VsLWJ1dHRvbi1ib3gtc2hhZG93OiBub25lOy0tc3dhbDItY2FuY2VsLWJ1dHRvbi1ib3JkZXItcmFkaXVzOiAwLjI1ZW07LS1zd2FsMi1jYW5jZWwtYnV0dG9uLWJhY2tncm91bmQtY29sb3I6ICM2ZTc4ODE7LS1zd2FsMi1jYW5jZWwtYnV0dG9uLWNvbG9yOiAjZmZmOy0tc3dhbDItdG9hc3Qtc2hvdy1hbmltYXRpb246IHN3YWwyLXRvYXN0LXNob3cgMC41czstLXN3YWwyLXRvYXN0LWhpZGUtYW5pbWF0aW9uOiBzd2FsMi10b2FzdC1oaWRlIDAuMXMgZm9yd2FyZHM7LS1zd2FsMi10b2FzdC1ib3JkZXI6IG5vbmU7LS1zd2FsMi10b2FzdC1ib3gtc2hhZG93OiAwIDAgMXB4IGhzbCgwZGVnIDAlIDAlIC8gMC4wNzUpLCAwIDFweCAycHggaHNsKDBkZWcgMCUgMCUgLyAwLjA3NSksIDFweCAycHggNHB4IGhzbCgwZGVnIDAlIDAlIC8gMC4wNzUpLCAxcHggM3B4IDhweCBoc2woMGRlZyAwJSAwJSAvIDAuMDc1KSwgMnB4IDRweCAxNnB4IGhzbCgwZGVnIDAlIDAlIC8gMC4wNzUpfVtkYXRhLXN3YWwyLXRoZW1lPWRhcmtdey0tc3dhbDItZGFyay10aGVtZS1ibGFjazogIzE5MTkxYTstLXN3YWwyLWRhcmstdGhlbWUtd2hpdGU6ICNlMWUxZTE7LS1zd2FsMi1iYWNrZ3JvdW5kOiB2YXIoLS1zd2FsMi1kYXJrLXRoZW1lLWJsYWNrKTstLXN3YWwyLWNvbG9yOiB2YXIoLS1zd2FsMi1kYXJrLXRoZW1lLXdoaXRlKTstLXN3YWwyLWZvb3Rlci1ib3JkZXItY29sb3I6ICM1NTU7LS1zd2FsMi1pbnB1dC1iYWNrZ3JvdW5kOiBjb2xvci1taXgoaW4gc3JnYiwgdmFyKC0tc3dhbDItZGFyay10aGVtZS1ibGFjayksIHZhcigtLXN3YWwyLWRhcmstdGhlbWUtd2hpdGUpIDEwJSk7LS1zd2FsMi12YWxpZGF0aW9uLW1lc3NhZ2UtYmFja2dyb3VuZDogY29sb3ItbWl4KCBpbiBzcmdiLCB2YXIoLS1zd2FsMi1kYXJrLXRoZW1lLWJsYWNrKSwgdmFyKC0tc3dhbDItZGFyay10aGVtZS13aGl0ZSkgMTAlICk7LS1zd2FsMi12YWxpZGF0aW9uLW1lc3NhZ2UtY29sb3I6IHZhcigtLXN3YWwyLWRhcmstdGhlbWUtd2hpdGUpOy0tc3dhbDItdGltZXItcHJvZ3Jlc3MtYmFyLWJhY2tncm91bmQ6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC43KX1AbWVkaWEocHJlZmVycy1jb2xvci1zY2hlbWU6IGRhcmspe1tkYXRhLXN3YWwyLXRoZW1lPWF1dG9dey0tc3dhbDItZGFyay10aGVtZS1ibGFjazogIzE5MTkxYTstLXN3YWwyLWRhcmstdGhlbWUtd2hpdGU6ICNlMWUxZTE7LS1zd2FsMi1iYWNrZ3JvdW5kOiB2YXIoLS1zd2FsMi1kYXJrLXRoZW1lLWJsYWNrKTstLXN3YWwyLWNvbG9yOiB2YXIoLS1zd2FsMi1kYXJrLXRoZW1lLXdoaXRlKTstLXN3YWwyLWZvb3Rlci1ib3JkZXItY29sb3I6ICM1NTU7LS1zd2FsMi1pbnB1dC1iYWNrZ3JvdW5kOiBjb2xvci1taXgoaW4gc3JnYiwgdmFyKC0tc3dhbDItZGFyay10aGVtZS1ibGFjayksIHZhcigtLXN3YWwyLWRhcmstdGhlbWUtd2hpdGUpIDEwJSk7LS1zd2FsMi12YWxpZGF0aW9uLW1lc3NhZ2UtYmFja2dyb3VuZDogY29sb3ItbWl4KCBpbiBzcmdiLCB2YXIoLS1zd2FsMi1kYXJrLXRoZW1lLWJsYWNrKSwgdmFyKC0tc3dhbDItZGFyay10aGVtZS13aGl0ZSkgMTAlICk7LS1zd2FsMi12YWxpZGF0aW9uLW1lc3NhZ2UtY29sb3I6IHZhcigtLXN3YWwyLWRhcmstdGhlbWUtd2hpdGUpOy0tc3dhbDItdGltZXItcHJvZ3Jlc3MtYmFyLWJhY2tncm91bmQ6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC43KX19Ym9keS5zd2FsMi1zaG93bjpub3QoLnN3YWwyLW5vLWJhY2tkcm9wLC5zd2FsMi10b2FzdC1zaG93bil7b3ZlcmZsb3c6aGlkZGVufWJvZHkuc3dhbDItaGVpZ2h0LWF1dG97aGVpZ2h0OmF1dG8gIWltcG9ydGFudH1ib2R5LnN3YWwyLW5vLWJhY2tkcm9wIC5zd2FsMi1jb250YWluZXJ7YmFja2dyb3VuZC1jb2xvcjpyZ2JhKDAsMCwwLDApICFpbXBvcnRhbnQ7cG9pbnRlci1ldmVudHM6bm9uZX1ib2R5LnN3YWwyLW5vLWJhY2tkcm9wIC5zd2FsMi1jb250YWluZXIgLnN3YWwyLXBvcHVwe3BvaW50ZXItZXZlbnRzOmFsbH1ib2R5LnN3YWwyLW5vLWJhY2tkcm9wIC5zd2FsMi1jb250YWluZXIgLnN3YWwyLW1vZGFse2JveC1zaGFkb3c6MCAwIDEwcHggdmFyKC0tc3dhbDItYmFja2Ryb3ApfWJvZHkuc3dhbDItdG9hc3Qtc2hvd24gLnN3YWwyLWNvbnRhaW5lcntib3gtc2l6aW5nOmJvcmRlci1ib3g7d2lkdGg6MzYwcHg7bWF4LXdpZHRoOjEwMCU7YmFja2dyb3VuZC1jb2xvcjpyZ2JhKDAsMCwwLDApO3BvaW50ZXItZXZlbnRzOm5vbmV9Ym9keS5zd2FsMi10b2FzdC1zaG93biAuc3dhbDItY29udGFpbmVyLnN3YWwyLXRvcHtpbnNldDowIGF1dG8gYXV0byA1MCU7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoLTUwJSl9Ym9keS5zd2FsMi10b2FzdC1zaG93biAuc3dhbDItY29udGFpbmVyLnN3YWwyLXRvcC1lbmQsYm9keS5zd2FsMi10b2FzdC1zaG93biAuc3dhbDItY29udGFpbmVyLnN3YWwyLXRvcC1yaWdodHtpbnNldDowIDAgYXV0byBhdXRvfWJvZHkuc3dhbDItdG9hc3Qtc2hvd24gLnN3YWwyLWNvbnRhaW5lci5zd2FsMi10b3Atc3RhcnQsYm9keS5zd2FsMi10b2FzdC1zaG93biAuc3dhbDItY29udGFpbmVyLnN3YWwyLXRvcC1sZWZ0e2luc2V0OjAgYXV0byBhdXRvIDB9Ym9keS5zd2FsMi10b2FzdC1zaG93biAuc3dhbDItY29udGFpbmVyLnN3YWwyLWNlbnRlci1zdGFydCxib2R5LnN3YWwyLXRvYXN0LXNob3duIC5zd2FsMi1jb250YWluZXIuc3dhbDItY2VudGVyLWxlZnR7aW5zZXQ6NTAlIGF1dG8gYXV0byAwO3RyYW5zZm9ybTp0cmFuc2xhdGVZKC01MCUpfWJvZHkuc3dhbDItdG9hc3Qtc2hvd24gLnN3YWwyLWNvbnRhaW5lci5zd2FsMi1jZW50ZXJ7aW5zZXQ6NTAlIGF1dG8gYXV0byA1MCU7dHJhbnNmb3JtOnRyYW5zbGF0ZSgtNTAlLCAtNTAlKX1ib2R5LnN3YWwyLXRvYXN0LXNob3duIC5zd2FsMi1jb250YWluZXIuc3dhbDItY2VudGVyLWVuZCxib2R5LnN3YWwyLXRvYXN0LXNob3duIC5zd2FsMi1jb250YWluZXIuc3dhbDItY2VudGVyLXJpZ2h0e2luc2V0OjUwJSAwIGF1dG8gYXV0bzt0cmFuc2Zvcm06dHJhbnNsYXRlWSgtNTAlKX1ib2R5LnN3YWwyLXRvYXN0LXNob3duIC5zd2FsMi1jb250YWluZXIuc3dhbDItYm90dG9tLXN0YXJ0LGJvZHkuc3dhbDItdG9hc3Qtc2hvd24gLnN3YWwyLWNvbnRhaW5lci5zd2FsMi1ib3R0b20tbGVmdHtpbnNldDphdXRvIGF1dG8gMCAwfWJvZHkuc3dhbDItdG9hc3Qtc2hvd24gLnN3YWwyLWNvbnRhaW5lci5zd2FsMi1ib3R0b217aW5zZXQ6YXV0byBhdXRvIDAgNTAlO3RyYW5zZm9ybTp0cmFuc2xhdGVYKC01MCUpfWJvZHkuc3dhbDItdG9hc3Qtc2hvd24gLnN3YWwyLWNvbnRhaW5lci5zd2FsMi1ib3R0b20tZW5kLGJvZHkuc3dhbDItdG9hc3Qtc2hvd24gLnN3YWwyLWNvbnRhaW5lci5zd2FsMi1ib3R0b20tcmlnaHR7aW5zZXQ6YXV0byAwIDAgYXV0b31AbWVkaWEgcHJpbnR7Ym9keS5zd2FsMi1zaG93bjpub3QoLnN3YWwyLW5vLWJhY2tkcm9wLC5zd2FsMi10b2FzdC1zaG93bil7b3ZlcmZsb3cteTpzY3JvbGwgIWltcG9ydGFudH1ib2R5LnN3YWwyLXNob3duOm5vdCguc3dhbDItbm8tYmFja2Ryb3AsLnN3YWwyLXRvYXN0LXNob3duKT5bYXJpYS1oaWRkZW49dHJ1ZV17ZGlzcGxheTpub25lfWJvZHkuc3dhbDItc2hvd246bm90KC5zd2FsMi1uby1iYWNrZHJvcCwuc3dhbDItdG9hc3Qtc2hvd24pIC5zd2FsMi1jb250YWluZXJ7cG9zaXRpb246c3RhdGljICFpbXBvcnRhbnR9fWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKXtkaXNwbGF5OmdyaWQ7cG9zaXRpb246Zml4ZWQ7ei1pbmRleDoxMDYwO2luc2V0OjA7Ym94LXNpemluZzpib3JkZXItYm94O2dyaWQtdGVtcGxhdGUtYXJlYXM6XFxcInRvcC1zdGFydCAgICAgdG9wICAgICAgICAgICAgdG9wLWVuZFxcXCIgXFxcImNlbnRlci1zdGFydCAgY2VudGVyICAgICAgICAgY2VudGVyLWVuZFxcXCIgXFxcImJvdHRvbS1zdGFydCAgYm90dG9tLWNlbnRlciAgYm90dG9tLWVuZFxcXCI7Z3JpZC10ZW1wbGF0ZS1yb3dzOm1pbm1heChtaW4tY29udGVudCwgYXV0bykgbWlubWF4KG1pbi1jb250ZW50LCBhdXRvKSBtaW5tYXgobWluLWNvbnRlbnQsIGF1dG8pO2hlaWdodDoxMDAlO3BhZGRpbmc6dmFyKC0tc3dhbDItY29udGFpbmVyLXBhZGRpbmcpO292ZXJmbG93LXg6aGlkZGVuO3RyYW5zaXRpb246dmFyKC0tc3dhbDItYmFja2Ryb3AtdHJhbnNpdGlvbik7LXdlYmtpdC1vdmVyZmxvdy1zY3JvbGxpbmc6dG91Y2h9ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpLnN3YWwyLWJhY2tkcm9wLXNob3csZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpLnN3YWwyLW5vYW5pbWF0aW9ue2JhY2tncm91bmQ6dmFyKC0tc3dhbDItYmFja2Ryb3ApfWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKS5zd2FsMi1iYWNrZHJvcC1oaWRle2JhY2tncm91bmQ6cmdiYSgwLDAsMCwwKSAhaW1wb3J0YW50fWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKS5zd2FsMi10b3Atc3RhcnQsZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpLnN3YWwyLWNlbnRlci1zdGFydCxkaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikuc3dhbDItYm90dG9tLXN0YXJ0e2dyaWQtdGVtcGxhdGUtY29sdW1uczptaW5tYXgoMCwgMWZyKSBhdXRvIGF1dG99ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpLnN3YWwyLXRvcCxkaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikuc3dhbDItY2VudGVyLGRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKS5zd2FsMi1ib3R0b217Z3JpZC10ZW1wbGF0ZS1jb2x1bW5zOmF1dG8gbWlubWF4KDAsIDFmcikgYXV0b31kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikuc3dhbDItdG9wLWVuZCxkaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikuc3dhbDItY2VudGVyLWVuZCxkaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikuc3dhbDItYm90dG9tLWVuZHtncmlkLXRlbXBsYXRlLWNvbHVtbnM6YXV0byBhdXRvIG1pbm1heCgwLCAxZnIpfWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKS5zd2FsMi10b3Atc3RhcnQ+LnN3YWwyLXBvcHVwe2FsaWduLXNlbGY6c3RhcnR9ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpLnN3YWwyLXRvcD4uc3dhbDItcG9wdXB7Z3JpZC1jb2x1bW46MjtwbGFjZS1zZWxmOnN0YXJ0IGNlbnRlcn1kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikuc3dhbDItdG9wLWVuZD4uc3dhbDItcG9wdXAsZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpLnN3YWwyLXRvcC1yaWdodD4uc3dhbDItcG9wdXB7Z3JpZC1jb2x1bW46MztwbGFjZS1zZWxmOnN0YXJ0IGVuZH1kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikuc3dhbDItY2VudGVyLXN0YXJ0Pi5zd2FsMi1wb3B1cCxkaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikuc3dhbDItY2VudGVyLWxlZnQ+LnN3YWwyLXBvcHVwe2dyaWQtcm93OjI7YWxpZ24tc2VsZjpjZW50ZXJ9ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpLnN3YWwyLWNlbnRlcj4uc3dhbDItcG9wdXB7Z3JpZC1jb2x1bW46MjtncmlkLXJvdzoyO3BsYWNlLXNlbGY6Y2VudGVyIGNlbnRlcn1kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikuc3dhbDItY2VudGVyLWVuZD4uc3dhbDItcG9wdXAsZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpLnN3YWwyLWNlbnRlci1yaWdodD4uc3dhbDItcG9wdXB7Z3JpZC1jb2x1bW46MztncmlkLXJvdzoyO3BsYWNlLXNlbGY6Y2VudGVyIGVuZH1kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikuc3dhbDItYm90dG9tLXN0YXJ0Pi5zd2FsMi1wb3B1cCxkaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikuc3dhbDItYm90dG9tLWxlZnQ+LnN3YWwyLXBvcHVwe2dyaWQtY29sdW1uOjE7Z3JpZC1yb3c6MzthbGlnbi1zZWxmOmVuZH1kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikuc3dhbDItYm90dG9tPi5zd2FsMi1wb3B1cHtncmlkLWNvbHVtbjoyO2dyaWQtcm93OjM7cGxhY2Utc2VsZjplbmQgY2VudGVyfWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKS5zd2FsMi1ib3R0b20tZW5kPi5zd2FsMi1wb3B1cCxkaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikuc3dhbDItYm90dG9tLXJpZ2h0Pi5zd2FsMi1wb3B1cHtncmlkLWNvbHVtbjozO2dyaWQtcm93OjM7cGxhY2Utc2VsZjplbmQgZW5kfWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKS5zd2FsMi1ncm93LXJvdz4uc3dhbDItcG9wdXAsZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpLnN3YWwyLWdyb3ctZnVsbHNjcmVlbj4uc3dhbDItcG9wdXB7Z3JpZC1jb2x1bW46MS80O3dpZHRoOjEwMCV9ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpLnN3YWwyLWdyb3ctY29sdW1uPi5zd2FsMi1wb3B1cCxkaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikuc3dhbDItZ3Jvdy1mdWxsc2NyZWVuPi5zd2FsMi1wb3B1cHtncmlkLXJvdzoxLzQ7YWxpZ24tc2VsZjpzdHJldGNofWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKS5zd2FsMi1uby10cmFuc2l0aW9ue3RyYW5zaXRpb246bm9uZSAhaW1wb3J0YW50fWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKVtwb3BvdmVyXXt3aWR0aDphdXRvO2JvcmRlcjowfWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSBkaXY6d2hlcmUoLnN3YWwyLXBvcHVwKXtkaXNwbGF5Om5vbmU7cG9zaXRpb246cmVsYXRpdmU7Ym94LXNpemluZzpib3JkZXItYm94O2dyaWQtdGVtcGxhdGUtY29sdW1uczptaW5tYXgoMCwgMTAwJSk7d2lkdGg6dmFyKC0tc3dhbDItd2lkdGgpO21heC13aWR0aDoxMDAlO3BhZGRpbmc6dmFyKC0tc3dhbDItcGFkZGluZyk7Ym9yZGVyOnZhcigtLXN3YWwyLWJvcmRlcik7Ym9yZGVyLXJhZGl1czp2YXIoLS1zd2FsMi1ib3JkZXItcmFkaXVzKTtiYWNrZ3JvdW5kOnZhcigtLXN3YWwyLWJhY2tncm91bmQpO2NvbG9yOnZhcigtLXN3YWwyLWNvbG9yKTtmb250LWZhbWlseTppbmhlcml0O2ZvbnQtc2l6ZToxcmVtO2NvbnRhaW5lci1uYW1lOnN3YWwyLXBvcHVwfWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSBkaXY6d2hlcmUoLnN3YWwyLXBvcHVwKTpmb2N1c3tvdXRsaW5lOm5vbmV9ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIGRpdjp3aGVyZSguc3dhbDItcG9wdXApLnN3YWwyLWxvYWRpbmd7b3ZlcmZsb3cteTpoaWRkZW59ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIGRpdjp3aGVyZSguc3dhbDItcG9wdXApLnN3YWwyLWRyYWdnYWJsZXtjdXJzb3I6Z3JhYn1kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgZGl2OndoZXJlKC5zd2FsMi1wb3B1cCkuc3dhbDItZHJhZ2dhYmxlIGRpdjp3aGVyZSguc3dhbDItaWNvbil7Y3Vyc29yOmdyYWJ9ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIGRpdjp3aGVyZSguc3dhbDItcG9wdXApLnN3YWwyLWRyYWdnaW5ne2N1cnNvcjpncmFiYmluZ31kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgZGl2OndoZXJlKC5zd2FsMi1wb3B1cCkuc3dhbDItZHJhZ2dpbmcgZGl2OndoZXJlKC5zd2FsMi1pY29uKXtjdXJzb3I6Z3JhYmJpbmd9ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIGgyOndoZXJlKC5zd2FsMi10aXRsZSl7cG9zaXRpb246cmVsYXRpdmU7bWF4LXdpZHRoOjEwMCU7bWFyZ2luOjA7cGFkZGluZzp2YXIoLS1zd2FsMi10aXRsZS1wYWRkaW5nKTtjb2xvcjppbmhlcml0O2ZvbnQtc2l6ZToxLjg3NWVtO2ZvbnQtd2VpZ2h0OjYwMDt0ZXh0LWFsaWduOmNlbnRlcjt0ZXh0LXRyYW5zZm9ybTpub25lO292ZXJmbG93LXdyYXA6YnJlYWstd29yZDtjdXJzb3I6aW5pdGlhbH1kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgZGl2OndoZXJlKC5zd2FsMi1hY3Rpb25zKXtkaXNwbGF5OmZsZXg7ei1pbmRleDoxO2JveC1zaXppbmc6Ym9yZGVyLWJveDtmbGV4LXdyYXA6d3JhcDthbGlnbi1pdGVtczpjZW50ZXI7anVzdGlmeS1jb250ZW50OnZhcigtLXN3YWwyLWFjdGlvbnMtanVzdGlmeS1jb250ZW50KTt3aWR0aDp2YXIoLS1zd2FsMi1hY3Rpb25zLXdpZHRoKTttYXJnaW46dmFyKC0tc3dhbDItYWN0aW9ucy1tYXJnaW4pO3BhZGRpbmc6dmFyKC0tc3dhbDItYWN0aW9ucy1wYWRkaW5nKTtib3JkZXItcmFkaXVzOnZhcigtLXN3YWwyLWFjdGlvbnMtYm9yZGVyLXJhZGl1cyk7YmFja2dyb3VuZDp2YXIoLS1zd2FsMi1hY3Rpb25zLWJhY2tncm91bmQpfWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSBkaXY6d2hlcmUoLnN3YWwyLWxvYWRlcil7ZGlzcGxheTpub25lO2FsaWduLWl0ZW1zOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO3dpZHRoOjIuMmVtO2hlaWdodDoyLjJlbTttYXJnaW46MCAxLjg3NWVtO2FuaW1hdGlvbjpzd2FsMi1yb3RhdGUtbG9hZGluZyAxLjVzIGxpbmVhciAwcyBpbmZpbml0ZSBub3JtYWw7Ym9yZGVyLXdpZHRoOi4yNWVtO2JvcmRlci1zdHlsZTpzb2xpZDtib3JkZXItcmFkaXVzOjEwMCU7Ym9yZGVyLWNvbG9yOiMyNzc4YzQgcmdiYSgwLDAsMCwwKSAjMjc3OGM0IHJnYmEoMCwwLDAsMCl9ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIGJ1dHRvbjp3aGVyZSguc3dhbDItc3R5bGVkKXttYXJnaW46LjMxMjVlbTtwYWRkaW5nOi42MjVlbSAxLjFlbTt0cmFuc2l0aW9uOnZhcigtLXN3YWwyLWFjdGlvbi1idXR0b24tdHJhbnNpdGlvbik7Ym9yZGVyOm5vbmU7Ym94LXNoYWRvdzowIDAgMCAzcHggcmdiYSgwLDAsMCwwKTtmb250LXdlaWdodDo1MDB9ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIGJ1dHRvbjp3aGVyZSguc3dhbDItc3R5bGVkKTpub3QoW2Rpc2FibGVkXSl7Y3Vyc29yOnBvaW50ZXJ9ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIGJ1dHRvbjp3aGVyZSguc3dhbDItc3R5bGVkKTp3aGVyZSguc3dhbDItY29uZmlybSl7Ym9yZGVyLXJhZGl1czp2YXIoLS1zd2FsMi1jb25maXJtLWJ1dHRvbi1ib3JkZXItcmFkaXVzKTtiYWNrZ3JvdW5kOmluaXRpYWw7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1zd2FsMi1jb25maXJtLWJ1dHRvbi1iYWNrZ3JvdW5kLWNvbG9yKTtib3gtc2hhZG93OnZhcigtLXN3YWwyLWNvbmZpcm0tYnV0dG9uLWJveC1zaGFkb3cpO2NvbG9yOnZhcigtLXN3YWwyLWNvbmZpcm0tYnV0dG9uLWNvbG9yKTtmb250LXNpemU6MWVtfWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSBidXR0b246d2hlcmUoLnN3YWwyLXN0eWxlZCk6d2hlcmUoLnN3YWwyLWNvbmZpcm0pOmhvdmVye2JhY2tncm91bmQtY29sb3I6Y29sb3ItbWl4KGluIHNyZ2IsIHZhcigtLXN3YWwyLWNvbmZpcm0tYnV0dG9uLWJhY2tncm91bmQtY29sb3IpLCB2YXIoLS1zd2FsMi1hY3Rpb24tYnV0dG9uLWhvdmVyKSl9ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIGJ1dHRvbjp3aGVyZSguc3dhbDItc3R5bGVkKTp3aGVyZSguc3dhbDItY29uZmlybSk6YWN0aXZle2JhY2tncm91bmQtY29sb3I6Y29sb3ItbWl4KGluIHNyZ2IsIHZhcigtLXN3YWwyLWNvbmZpcm0tYnV0dG9uLWJhY2tncm91bmQtY29sb3IpLCB2YXIoLS1zd2FsMi1hY3Rpb24tYnV0dG9uLWFjdGl2ZSkpfWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSBidXR0b246d2hlcmUoLnN3YWwyLXN0eWxlZCk6d2hlcmUoLnN3YWwyLWRlbnkpe2JvcmRlci1yYWRpdXM6dmFyKC0tc3dhbDItZGVueS1idXR0b24tYm9yZGVyLXJhZGl1cyk7YmFja2dyb3VuZDppbml0aWFsO2JhY2tncm91bmQtY29sb3I6dmFyKC0tc3dhbDItZGVueS1idXR0b24tYmFja2dyb3VuZC1jb2xvcik7Ym94LXNoYWRvdzp2YXIoLS1zd2FsMi1kZW55LWJ1dHRvbi1ib3gtc2hhZG93KTtjb2xvcjp2YXIoLS1zd2FsMi1kZW55LWJ1dHRvbi1jb2xvcik7Zm9udC1zaXplOjFlbX1kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgYnV0dG9uOndoZXJlKC5zd2FsMi1zdHlsZWQpOndoZXJlKC5zd2FsMi1kZW55KTpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOmNvbG9yLW1peChpbiBzcmdiLCB2YXIoLS1zd2FsMi1kZW55LWJ1dHRvbi1iYWNrZ3JvdW5kLWNvbG9yKSwgdmFyKC0tc3dhbDItYWN0aW9uLWJ1dHRvbi1ob3ZlcikpfWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSBidXR0b246d2hlcmUoLnN3YWwyLXN0eWxlZCk6d2hlcmUoLnN3YWwyLWRlbnkpOmFjdGl2ZXtiYWNrZ3JvdW5kLWNvbG9yOmNvbG9yLW1peChpbiBzcmdiLCB2YXIoLS1zd2FsMi1kZW55LWJ1dHRvbi1iYWNrZ3JvdW5kLWNvbG9yKSwgdmFyKC0tc3dhbDItYWN0aW9uLWJ1dHRvbi1hY3RpdmUpKX1kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgYnV0dG9uOndoZXJlKC5zd2FsMi1zdHlsZWQpOndoZXJlKC5zd2FsMi1jYW5jZWwpe2JvcmRlci1yYWRpdXM6dmFyKC0tc3dhbDItY2FuY2VsLWJ1dHRvbi1ib3JkZXItcmFkaXVzKTtiYWNrZ3JvdW5kOmluaXRpYWw7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1zd2FsMi1jYW5jZWwtYnV0dG9uLWJhY2tncm91bmQtY29sb3IpO2JveC1zaGFkb3c6dmFyKC0tc3dhbDItY2FuY2VsLWJ1dHRvbi1ib3gtc2hhZG93KTtjb2xvcjp2YXIoLS1zd2FsMi1jYW5jZWwtYnV0dG9uLWNvbG9yKTtmb250LXNpemU6MWVtfWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSBidXR0b246d2hlcmUoLnN3YWwyLXN0eWxlZCk6d2hlcmUoLnN3YWwyLWNhbmNlbCk6aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjpjb2xvci1taXgoaW4gc3JnYiwgdmFyKC0tc3dhbDItY2FuY2VsLWJ1dHRvbi1iYWNrZ3JvdW5kLWNvbG9yKSwgdmFyKC0tc3dhbDItYWN0aW9uLWJ1dHRvbi1ob3ZlcikpfWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSBidXR0b246d2hlcmUoLnN3YWwyLXN0eWxlZCk6d2hlcmUoLnN3YWwyLWNhbmNlbCk6YWN0aXZle2JhY2tncm91bmQtY29sb3I6Y29sb3ItbWl4KGluIHNyZ2IsIHZhcigtLXN3YWwyLWNhbmNlbC1idXR0b24tYmFja2dyb3VuZC1jb2xvciksIHZhcigtLXN3YWwyLWFjdGlvbi1idXR0b24tYWN0aXZlKSl9ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIGJ1dHRvbjp3aGVyZSguc3dhbDItc3R5bGVkKTpmb2N1cy12aXNpYmxle291dGxpbmU6bm9uZTtib3gtc2hhZG93OnZhcigtLXN3YWwyLWFjdGlvbi1idXR0b24tZm9jdXMtYm94LXNoYWRvdyl9ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIGJ1dHRvbjp3aGVyZSguc3dhbDItc3R5bGVkKVtkaXNhYmxlZF06bm90KC5zd2FsMi1sb2FkaW5nKXtvcGFjaXR5Oi40fWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSBidXR0b246d2hlcmUoLnN3YWwyLXN0eWxlZCk6Oi1tb3otZm9jdXMtaW5uZXJ7Ym9yZGVyOjB9ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIGRpdjp3aGVyZSguc3dhbDItZm9vdGVyKXttYXJnaW46MWVtIDAgMDtwYWRkaW5nOjFlbSAxZW0gMDtib3JkZXItdG9wOjFweCBzb2xpZCB2YXIoLS1zd2FsMi1mb290ZXItYm9yZGVyLWNvbG9yKTtiYWNrZ3JvdW5kOnZhcigtLXN3YWwyLWZvb3Rlci1iYWNrZ3JvdW5kKTtjb2xvcjp2YXIoLS1zd2FsMi1mb290ZXItY29sb3IpO2ZvbnQtc2l6ZToxZW07dGV4dC1hbGlnbjpjZW50ZXI7Y3Vyc29yOmluaXRpYWx9ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIC5zd2FsMi10aW1lci1wcm9ncmVzcy1iYXItY29udGFpbmVye3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjA7Ym90dG9tOjA7bGVmdDowO2dyaWQtY29sdW1uOmF1dG8gIWltcG9ydGFudDtvdmVyZmxvdzpoaWRkZW47Ym9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6dmFyKC0tc3dhbDItYm9yZGVyLXJhZGl1cyk7Ym9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czp2YXIoLS1zd2FsMi1ib3JkZXItcmFkaXVzKX1kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgZGl2OndoZXJlKC5zd2FsMi10aW1lci1wcm9ncmVzcy1iYXIpe3dpZHRoOjEwMCU7aGVpZ2h0Oi4yNWVtO2JhY2tncm91bmQ6dmFyKC0tc3dhbDItdGltZXItcHJvZ3Jlc3MtYmFyLWJhY2tncm91bmQpfWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSBpbWc6d2hlcmUoLnN3YWwyLWltYWdlKXttYXgtd2lkdGg6MTAwJTttYXJnaW46MmVtIGF1dG8gMWVtO2N1cnNvcjppbml0aWFsfWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSBidXR0b246d2hlcmUoLnN3YWwyLWNsb3NlKXtwb3NpdGlvbjp2YXIoLS1zd2FsMi1jbG9zZS1idXR0b24tcG9zaXRpb24pO2luc2V0OnZhcigtLXN3YWwyLWNsb3NlLWJ1dHRvbi1pbnNldCk7ei1pbmRleDoyO2FsaWduLWl0ZW1zOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO3dpZHRoOjEuMmVtO2hlaWdodDoxLjJlbTttYXJnaW4tdG9wOjA7bWFyZ2luLXJpZ2h0OjA7bWFyZ2luLWJvdHRvbTotMS4yZW07cGFkZGluZzowO292ZXJmbG93OmhpZGRlbjt0cmFuc2l0aW9uOnZhcigtLXN3YWwyLWNsb3NlLWJ1dHRvbi10cmFuc2l0aW9uKTtib3JkZXI6bm9uZTtib3JkZXItcmFkaXVzOnZhcigtLXN3YWwyLWJvcmRlci1yYWRpdXMpO291dGxpbmU6dmFyKC0tc3dhbDItY2xvc2UtYnV0dG9uLW91dGxpbmUpO2JhY2tncm91bmQ6cmdiYSgwLDAsMCwwKTtjb2xvcjp2YXIoLS1zd2FsMi1jbG9zZS1idXR0b24tY29sb3IpO2ZvbnQtZmFtaWx5Om1vbm9zcGFjZTtmb250LXNpemU6dmFyKC0tc3dhbDItY2xvc2UtYnV0dG9uLWZvbnQtc2l6ZSk7Y3Vyc29yOnBvaW50ZXI7anVzdGlmeS1zZWxmOmVuZH1kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgYnV0dG9uOndoZXJlKC5zd2FsMi1jbG9zZSk6aG92ZXJ7dHJhbnNmb3JtOnZhcigtLXN3YWwyLWNsb3NlLWJ1dHRvbi1ob3Zlci10cmFuc2Zvcm0pO2JhY2tncm91bmQ6cmdiYSgwLDAsMCwwKTtjb2xvcjojZjI3NDc0fWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSBidXR0b246d2hlcmUoLnN3YWwyLWNsb3NlKTpmb2N1cy12aXNpYmxle291dGxpbmU6bm9uZTtib3gtc2hhZG93OnZhcigtLXN3YWwyLWNsb3NlLWJ1dHRvbi1mb2N1cy1ib3gtc2hhZG93KX1kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgYnV0dG9uOndoZXJlKC5zd2FsMi1jbG9zZSk6Oi1tb3otZm9jdXMtaW5uZXJ7Ym9yZGVyOjB9ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIGRpdjp3aGVyZSguc3dhbDItaHRtbC1jb250YWluZXIpe3otaW5kZXg6MTtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO21hcmdpbjowO3BhZGRpbmc6dmFyKC0tc3dhbDItaHRtbC1jb250YWluZXItcGFkZGluZyk7b3ZlcmZsb3c6YXV0bztjb2xvcjppbmhlcml0O2ZvbnQtc2l6ZToxLjEyNWVtO2ZvbnQtd2VpZ2h0Om5vcm1hbDtsaW5lLWhlaWdodDpub3JtYWw7dGV4dC1hbGlnbjpjZW50ZXI7b3ZlcmZsb3ctd3JhcDpicmVhay13b3JkO3dvcmQtYnJlYWs6YnJlYWstd29yZDtjdXJzb3I6aW5pdGlhbH1kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgaW5wdXQ6d2hlcmUoLnN3YWwyLWlucHV0KSxkaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgaW5wdXQ6d2hlcmUoLnN3YWwyLWZpbGUpLGRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSB0ZXh0YXJlYTp3aGVyZSguc3dhbDItdGV4dGFyZWEpLGRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSBzZWxlY3Q6d2hlcmUoLnN3YWwyLXNlbGVjdCksZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIGRpdjp3aGVyZSguc3dhbDItcmFkaW8pLGRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSBsYWJlbDp3aGVyZSguc3dhbDItY2hlY2tib3gpe21hcmdpbjoxZW0gMmVtIDNweH1kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgaW5wdXQ6d2hlcmUoLnN3YWwyLWlucHV0KSxkaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgaW5wdXQ6d2hlcmUoLnN3YWwyLWZpbGUpLGRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSB0ZXh0YXJlYTp3aGVyZSguc3dhbDItdGV4dGFyZWEpe2JveC1zaXppbmc6Ym9yZGVyLWJveDt3aWR0aDphdXRvO3RyYW5zaXRpb246dmFyKC0tc3dhbDItaW5wdXQtdHJhbnNpdGlvbik7Ym9yZGVyOnZhcigtLXN3YWwyLWlucHV0LWJvcmRlcik7Ym9yZGVyLXJhZGl1czp2YXIoLS1zd2FsMi1pbnB1dC1ib3JkZXItcmFkaXVzKTtiYWNrZ3JvdW5kOnZhcigtLXN3YWwyLWlucHV0LWJhY2tncm91bmQpO2JveC1zaGFkb3c6dmFyKC0tc3dhbDItaW5wdXQtYm94LXNoYWRvdyk7Y29sb3I6aW5oZXJpdDtmb250LXNpemU6MS4xMjVlbX1kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgaW5wdXQ6d2hlcmUoLnN3YWwyLWlucHV0KS5zd2FsMi1pbnB1dGVycm9yLGRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSBpbnB1dDp3aGVyZSguc3dhbDItZmlsZSkuc3dhbDItaW5wdXRlcnJvcixkaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgdGV4dGFyZWE6d2hlcmUoLnN3YWwyLXRleHRhcmVhKS5zd2FsMi1pbnB1dGVycm9ye2JvcmRlci1jb2xvcjojZjI3NDc0ICFpbXBvcnRhbnQ7Ym94LXNoYWRvdzowIDAgMnB4ICNmMjc0NzQgIWltcG9ydGFudH1kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgaW5wdXQ6d2hlcmUoLnN3YWwyLWlucHV0KTpob3ZlcixkaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgaW5wdXQ6d2hlcmUoLnN3YWwyLWZpbGUpOmhvdmVyLGRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSB0ZXh0YXJlYTp3aGVyZSguc3dhbDItdGV4dGFyZWEpOmhvdmVye2JveC1zaGFkb3c6dmFyKC0tc3dhbDItaW5wdXQtaG92ZXItYm94LXNoYWRvdyl9ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIGlucHV0OndoZXJlKC5zd2FsMi1pbnB1dCk6Zm9jdXMsZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIGlucHV0OndoZXJlKC5zd2FsMi1maWxlKTpmb2N1cyxkaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgdGV4dGFyZWE6d2hlcmUoLnN3YWwyLXRleHRhcmVhKTpmb2N1c3tib3JkZXI6dmFyKC0tc3dhbDItaW5wdXQtZm9jdXMtYm9yZGVyKTtvdXRsaW5lOm5vbmU7Ym94LXNoYWRvdzp2YXIoLS1zd2FsMi1pbnB1dC1mb2N1cy1ib3gtc2hhZG93KX1kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgaW5wdXQ6d2hlcmUoLnN3YWwyLWlucHV0KTo6cGxhY2Vob2xkZXIsZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIGlucHV0OndoZXJlKC5zd2FsMi1maWxlKTo6cGxhY2Vob2xkZXIsZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIHRleHRhcmVhOndoZXJlKC5zd2FsMi10ZXh0YXJlYSk6OnBsYWNlaG9sZGVye2NvbG9yOiNjY2N9ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIC5zd2FsMi1yYW5nZXttYXJnaW46MWVtIDJlbSAzcHg7YmFja2dyb3VuZDp2YXIoLS1zd2FsMi1iYWNrZ3JvdW5kKX1kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgLnN3YWwyLXJhbmdlIGlucHV0e3dpZHRoOjgwJX1kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgLnN3YWwyLXJhbmdlIG91dHB1dHt3aWR0aDoyMCU7Y29sb3I6aW5oZXJpdDtmb250LXdlaWdodDo2MDA7dGV4dC1hbGlnbjpjZW50ZXJ9ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIC5zd2FsMi1yYW5nZSBpbnB1dCxkaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgLnN3YWwyLXJhbmdlIG91dHB1dHtoZWlnaHQ6Mi42MjVlbTtwYWRkaW5nOjA7Zm9udC1zaXplOjEuMTI1ZW07bGluZS1oZWlnaHQ6Mi42MjVlbX1kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgLnN3YWwyLWlucHV0e2hlaWdodDoyLjYyNWVtO3BhZGRpbmc6MCAuNzVlbX1kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgLnN3YWwyLWZpbGV7d2lkdGg6NzUlO21hcmdpbi1yaWdodDphdXRvO21hcmdpbi1sZWZ0OmF1dG87YmFja2dyb3VuZDp2YXIoLS1zd2FsMi1pbnB1dC1iYWNrZ3JvdW5kKTtmb250LXNpemU6MS4xMjVlbX1kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgLnN3YWwyLXRleHRhcmVhe2hlaWdodDo2Ljc1ZW07cGFkZGluZzouNzVlbX1kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgLnN3YWwyLXNlbGVjdHttaW4td2lkdGg6NTAlO21heC13aWR0aDoxMDAlO3BhZGRpbmc6LjM3NWVtIC42MjVlbTtiYWNrZ3JvdW5kOnZhcigtLXN3YWwyLWlucHV0LWJhY2tncm91bmQpO2NvbG9yOmluaGVyaXQ7Zm9udC1zaXplOjEuMTI1ZW19ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIC5zd2FsMi1yYWRpbyxkaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgLnN3YWwyLWNoZWNrYm94e2FsaWduLWl0ZW1zOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO2JhY2tncm91bmQ6dmFyKC0tc3dhbDItYmFja2dyb3VuZCk7Y29sb3I6aW5oZXJpdH1kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgLnN3YWwyLXJhZGlvIGxhYmVsLGRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSAuc3dhbDItY2hlY2tib3ggbGFiZWx7bWFyZ2luOjAgLjZlbTtmb250LXNpemU6MS4xMjVlbX1kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgLnN3YWwyLXJhZGlvIGlucHV0LGRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSAuc3dhbDItY2hlY2tib3ggaW5wdXR7ZmxleC1zaHJpbms6MDttYXJnaW46MCAuNGVtfWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSBsYWJlbDp3aGVyZSguc3dhbDItaW5wdXQtbGFiZWwpe2Rpc3BsYXk6ZmxleDtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO21hcmdpbjoxZW0gYXV0byAwfWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSBkaXY6d2hlcmUoLnN3YWwyLXZhbGlkYXRpb24tbWVzc2FnZSl7YWxpZ24taXRlbXM6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXI7bWFyZ2luOjFlbSAwIDA7cGFkZGluZzouNjI1ZW07b3ZlcmZsb3c6aGlkZGVuO2JhY2tncm91bmQ6dmFyKC0tc3dhbDItdmFsaWRhdGlvbi1tZXNzYWdlLWJhY2tncm91bmQpO2NvbG9yOnZhcigtLXN3YWwyLXZhbGlkYXRpb24tbWVzc2FnZS1jb2xvcik7Zm9udC1zaXplOjFlbTtmb250LXdlaWdodDozMDB9ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIGRpdjp3aGVyZSguc3dhbDItdmFsaWRhdGlvbi1tZXNzYWdlKTo6YmVmb3Jle2NvbnRlbnQ6XFxcIiFcXFwiO2Rpc3BsYXk6aW5saW5lLWJsb2NrO3dpZHRoOjEuNWVtO21pbi13aWR0aDoxLjVlbTtoZWlnaHQ6MS41ZW07bWFyZ2luOjAgLjYyNWVtO2JvcmRlci1yYWRpdXM6NTAlO2JhY2tncm91bmQtY29sb3I6I2YyNzQ3NDtjb2xvcjojZmZmO2ZvbnQtd2VpZ2h0OjYwMDtsaW5lLWhlaWdodDoxLjVlbTt0ZXh0LWFsaWduOmNlbnRlcn1kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgLnN3YWwyLXByb2dyZXNzLXN0ZXBze2ZsZXgtd3JhcDp3cmFwO2FsaWduLWl0ZW1zOmNlbnRlcjttYXgtd2lkdGg6MTAwJTttYXJnaW46MS4yNWVtIGF1dG87cGFkZGluZzowO2JhY2tncm91bmQ6cmdiYSgwLDAsMCwwKTtmb250LXdlaWdodDo2MDB9ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIC5zd2FsMi1wcm9ncmVzcy1zdGVwcyBsaXtkaXNwbGF5OmlubGluZS1ibG9jaztwb3NpdGlvbjpyZWxhdGl2ZX1kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgLnN3YWwyLXByb2dyZXNzLXN0ZXBzIC5zd2FsMi1wcm9ncmVzcy1zdGVwe3otaW5kZXg6MjA7ZmxleC1zaHJpbms6MDt3aWR0aDoyZW07aGVpZ2h0OjJlbTtib3JkZXItcmFkaXVzOjJlbTtiYWNrZ3JvdW5kOiMyNzc4YzQ7Y29sb3I6I2ZmZjtsaW5lLWhlaWdodDoyZW07dGV4dC1hbGlnbjpjZW50ZXJ9ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIC5zd2FsMi1wcm9ncmVzcy1zdGVwcyAuc3dhbDItcHJvZ3Jlc3Mtc3RlcC5zd2FsMi1hY3RpdmUtcHJvZ3Jlc3Mtc3RlcHtiYWNrZ3JvdW5kOiMyNzc4YzR9ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIC5zd2FsMi1wcm9ncmVzcy1zdGVwcyAuc3dhbDItcHJvZ3Jlc3Mtc3RlcC5zd2FsMi1hY3RpdmUtcHJvZ3Jlc3Mtc3RlcH4uc3dhbDItcHJvZ3Jlc3Mtc3RlcHtiYWNrZ3JvdW5kOnZhcigtLXN3YWwyLXByb2dyZXNzLXN0ZXAtYmFja2dyb3VuZCk7Y29sb3I6I2ZmZn1kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgLnN3YWwyLXByb2dyZXNzLXN0ZXBzIC5zd2FsMi1wcm9ncmVzcy1zdGVwLnN3YWwyLWFjdGl2ZS1wcm9ncmVzcy1zdGVwfi5zd2FsMi1wcm9ncmVzcy1zdGVwLWxpbmV7YmFja2dyb3VuZDp2YXIoLS1zd2FsMi1wcm9ncmVzcy1zdGVwLWJhY2tncm91bmQpfWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSAuc3dhbDItcHJvZ3Jlc3Mtc3RlcHMgLnN3YWwyLXByb2dyZXNzLXN0ZXAtbGluZXt6LWluZGV4OjEwO2ZsZXgtc2hyaW5rOjA7d2lkdGg6Mi41ZW07aGVpZ2h0Oi40ZW07bWFyZ2luOjAgLTFweDtiYWNrZ3JvdW5kOiMyNzc4YzR9ZGl2OndoZXJlKC5zd2FsMi1pY29uKXtwb3NpdGlvbjpyZWxhdGl2ZTtib3gtc2l6aW5nOmNvbnRlbnQtYm94O2p1c3RpZnktY29udGVudDpjZW50ZXI7d2lkdGg6NWVtO2hlaWdodDo1ZW07bWFyZ2luOjIuNWVtIGF1dG8gLjZlbTt6b29tOnZhcigtLXN3YWwyLWljb24tem9vbSk7Ym9yZGVyOi4yNWVtIHNvbGlkIHJnYmEoMCwwLDAsMCk7Ym9yZGVyLXJhZGl1czo1MCU7Ym9yZGVyLWNvbG9yOiMwMDA7Zm9udC1mYW1pbHk6aW5oZXJpdDtsaW5lLWhlaWdodDo1ZW07Y3Vyc29yOmRlZmF1bHQ7dXNlci1zZWxlY3Q6bm9uZX1kaXY6d2hlcmUoLnN3YWwyLWljb24pIC5zd2FsMi1pY29uLWNvbnRlbnR7ZGlzcGxheTpmbGV4O2FsaWduLWl0ZW1zOmNlbnRlcjtmb250LXNpemU6My43NWVtfWRpdjp3aGVyZSguc3dhbDItaWNvbikuc3dhbDItZXJyb3J7Ym9yZGVyLWNvbG9yOiNmMjc0NzQ7Y29sb3I6I2YyNzQ3NH1kaXY6d2hlcmUoLnN3YWwyLWljb24pLnN3YWwyLWVycm9yIC5zd2FsMi14LW1hcmt7cG9zaXRpb246cmVsYXRpdmU7ZmxleC1ncm93OjF9ZGl2OndoZXJlKC5zd2FsMi1pY29uKS5zd2FsMi1lcnJvciBbY2xhc3NePXN3YWwyLXgtbWFyay1saW5lXXtkaXNwbGF5OmJsb2NrO3Bvc2l0aW9uOmFic29sdXRlO3RvcDoyLjMxMjVlbTt3aWR0aDoyLjkzNzVlbTtoZWlnaHQ6LjMxMjVlbTtib3JkZXItcmFkaXVzOi4xMjVlbTtiYWNrZ3JvdW5kLWNvbG9yOiNmMjc0NzR9ZGl2OndoZXJlKC5zd2FsMi1pY29uKS5zd2FsMi1lcnJvciBbY2xhc3NePXN3YWwyLXgtbWFyay1saW5lXVtjbGFzcyQ9bGVmdF17bGVmdDoxLjA2MjVlbTt0cmFuc2Zvcm06cm90YXRlKDQ1ZGVnKX1kaXY6d2hlcmUoLnN3YWwyLWljb24pLnN3YWwyLWVycm9yIFtjbGFzc149c3dhbDIteC1tYXJrLWxpbmVdW2NsYXNzJD1yaWdodF17cmlnaHQ6MWVtO3RyYW5zZm9ybTpyb3RhdGUoLTQ1ZGVnKX1AY29udGFpbmVyIHN3YWwyLXBvcHVwIHN0eWxlKC0tc3dhbDItaWNvbi1hbmltYXRpb25zOnRydWUpe2Rpdjp3aGVyZSguc3dhbDItaWNvbikuc3dhbDItZXJyb3Iuc3dhbDItaWNvbi1zaG93e2FuaW1hdGlvbjpzd2FsMi1hbmltYXRlLWVycm9yLWljb24gLjVzfWRpdjp3aGVyZSguc3dhbDItaWNvbikuc3dhbDItZXJyb3Iuc3dhbDItaWNvbi1zaG93IC5zd2FsMi14LW1hcmt7YW5pbWF0aW9uOnN3YWwyLWFuaW1hdGUtZXJyb3IteC1tYXJrIC41c319ZGl2OndoZXJlKC5zd2FsMi1pY29uKS5zd2FsMi13YXJuaW5ne2JvcmRlci1jb2xvcjojZjhiYjg2O2NvbG9yOiNmOGJiODZ9QGNvbnRhaW5lciBzd2FsMi1wb3B1cCBzdHlsZSgtLXN3YWwyLWljb24tYW5pbWF0aW9uczp0cnVlKXtkaXY6d2hlcmUoLnN3YWwyLWljb24pLnN3YWwyLXdhcm5pbmcuc3dhbDItaWNvbi1zaG93e2FuaW1hdGlvbjpzd2FsMi1hbmltYXRlLWVycm9yLWljb24gLjVzfWRpdjp3aGVyZSguc3dhbDItaWNvbikuc3dhbDItd2FybmluZy5zd2FsMi1pY29uLXNob3cgLnN3YWwyLWljb24tY29udGVudHthbmltYXRpb246c3dhbDItYW5pbWF0ZS1pLW1hcmsgLjVzfX1kaXY6d2hlcmUoLnN3YWwyLWljb24pLnN3YWwyLWluZm97Ym9yZGVyLWNvbG9yOiMzZmMzZWU7Y29sb3I6IzNmYzNlZX1AY29udGFpbmVyIHN3YWwyLXBvcHVwIHN0eWxlKC0tc3dhbDItaWNvbi1hbmltYXRpb25zOnRydWUpe2Rpdjp3aGVyZSguc3dhbDItaWNvbikuc3dhbDItaW5mby5zd2FsMi1pY29uLXNob3d7YW5pbWF0aW9uOnN3YWwyLWFuaW1hdGUtZXJyb3ItaWNvbiAuNXN9ZGl2OndoZXJlKC5zd2FsMi1pY29uKS5zd2FsMi1pbmZvLnN3YWwyLWljb24tc2hvdyAuc3dhbDItaWNvbi1jb250ZW50e2FuaW1hdGlvbjpzd2FsMi1hbmltYXRlLWktbWFyayAuOHN9fWRpdjp3aGVyZSguc3dhbDItaWNvbikuc3dhbDItcXVlc3Rpb257Ym9yZGVyLWNvbG9yOiM4N2FkYmQ7Y29sb3I6Izg3YWRiZH1AY29udGFpbmVyIHN3YWwyLXBvcHVwIHN0eWxlKC0tc3dhbDItaWNvbi1hbmltYXRpb25zOnRydWUpe2Rpdjp3aGVyZSguc3dhbDItaWNvbikuc3dhbDItcXVlc3Rpb24uc3dhbDItaWNvbi1zaG93e2FuaW1hdGlvbjpzd2FsMi1hbmltYXRlLWVycm9yLWljb24gLjVzfWRpdjp3aGVyZSguc3dhbDItaWNvbikuc3dhbDItcXVlc3Rpb24uc3dhbDItaWNvbi1zaG93IC5zd2FsMi1pY29uLWNvbnRlbnR7YW5pbWF0aW9uOnN3YWwyLWFuaW1hdGUtcXVlc3Rpb24tbWFyayAuOHN9fWRpdjp3aGVyZSguc3dhbDItaWNvbikuc3dhbDItc3VjY2Vzc3tib3JkZXItY29sb3I6I2E1ZGM4Njtjb2xvcjojYTVkYzg2fWRpdjp3aGVyZSguc3dhbDItaWNvbikuc3dhbDItc3VjY2VzcyBbY2xhc3NePXN3YWwyLXN1Y2Nlc3MtY2lyY3VsYXItbGluZV17cG9zaXRpb246YWJzb2x1dGU7d2lkdGg6My43NWVtO2hlaWdodDo3LjVlbTtib3JkZXItcmFkaXVzOjUwJX1kaXY6d2hlcmUoLnN3YWwyLWljb24pLnN3YWwyLXN1Y2Nlc3MgW2NsYXNzXj1zd2FsMi1zdWNjZXNzLWNpcmN1bGFyLWxpbmVdW2NsYXNzJD1sZWZ0XXt0b3A6LTAuNDM3NWVtO2xlZnQ6LTIuMDYzNWVtO3RyYW5zZm9ybTpyb3RhdGUoLTQ1ZGVnKTt0cmFuc2Zvcm0tb3JpZ2luOjMuNzVlbSAzLjc1ZW07Ym9yZGVyLXJhZGl1czo3LjVlbSAwIDAgNy41ZW19ZGl2OndoZXJlKC5zd2FsMi1pY29uKS5zd2FsMi1zdWNjZXNzIFtjbGFzc149c3dhbDItc3VjY2Vzcy1jaXJjdWxhci1saW5lXVtjbGFzcyQ9cmlnaHRde3RvcDotMC42ODc1ZW07bGVmdDoxLjg3NWVtO3RyYW5zZm9ybTpyb3RhdGUoLTQ1ZGVnKTt0cmFuc2Zvcm0tb3JpZ2luOjAgMy43NWVtO2JvcmRlci1yYWRpdXM6MCA3LjVlbSA3LjVlbSAwfWRpdjp3aGVyZSguc3dhbDItaWNvbikuc3dhbDItc3VjY2VzcyAuc3dhbDItc3VjY2Vzcy1yaW5ne3Bvc2l0aW9uOmFic29sdXRlO3otaW5kZXg6Mjt0b3A6LTAuMjVlbTtsZWZ0Oi0wLjI1ZW07Ym94LXNpemluZzpjb250ZW50LWJveDt3aWR0aDoxMDAlO2hlaWdodDoxMDAlO2JvcmRlcjouMjVlbSBzb2xpZCByZ2JhKDE2NSwyMjAsMTM0LC4zKTtib3JkZXItcmFkaXVzOjUwJX1kaXY6d2hlcmUoLnN3YWwyLWljb24pLnN3YWwyLXN1Y2Nlc3MgLnN3YWwyLXN1Y2Nlc3MtZml4e3Bvc2l0aW9uOmFic29sdXRlO3otaW5kZXg6MTt0b3A6LjVlbTtsZWZ0OjEuNjI1ZW07d2lkdGg6LjQzNzVlbTtoZWlnaHQ6NS42MjVlbTt0cmFuc2Zvcm06cm90YXRlKC00NWRlZyl9ZGl2OndoZXJlKC5zd2FsMi1pY29uKS5zd2FsMi1zdWNjZXNzIFtjbGFzc149c3dhbDItc3VjY2Vzcy1saW5lXXtkaXNwbGF5OmJsb2NrO3Bvc2l0aW9uOmFic29sdXRlO3otaW5kZXg6MjtoZWlnaHQ6LjMxMjVlbTtib3JkZXItcmFkaXVzOi4xMjVlbTtiYWNrZ3JvdW5kLWNvbG9yOiNhNWRjODZ9ZGl2OndoZXJlKC5zd2FsMi1pY29uKS5zd2FsMi1zdWNjZXNzIFtjbGFzc149c3dhbDItc3VjY2Vzcy1saW5lXVtjbGFzcyQ9dGlwXXt0b3A6Mi44NzVlbTtsZWZ0Oi44MTI1ZW07d2lkdGg6MS41NjI1ZW07dHJhbnNmb3JtOnJvdGF0ZSg0NWRlZyl9ZGl2OndoZXJlKC5zd2FsMi1pY29uKS5zd2FsMi1zdWNjZXNzIFtjbGFzc149c3dhbDItc3VjY2Vzcy1saW5lXVtjbGFzcyQ9bG9uZ117dG9wOjIuMzc1ZW07cmlnaHQ6LjVlbTt3aWR0aDoyLjkzNzVlbTt0cmFuc2Zvcm06cm90YXRlKC00NWRlZyl9QGNvbnRhaW5lciBzd2FsMi1wb3B1cCBzdHlsZSgtLXN3YWwyLWljb24tYW5pbWF0aW9uczp0cnVlKXtkaXY6d2hlcmUoLnN3YWwyLWljb24pLnN3YWwyLXN1Y2Nlc3Muc3dhbDItaWNvbi1zaG93IC5zd2FsMi1zdWNjZXNzLWxpbmUtdGlwe2FuaW1hdGlvbjpzd2FsMi1hbmltYXRlLXN1Y2Nlc3MtbGluZS10aXAgLjc1c31kaXY6d2hlcmUoLnN3YWwyLWljb24pLnN3YWwyLXN1Y2Nlc3Muc3dhbDItaWNvbi1zaG93IC5zd2FsMi1zdWNjZXNzLWxpbmUtbG9uZ3thbmltYXRpb246c3dhbDItYW5pbWF0ZS1zdWNjZXNzLWxpbmUtbG9uZyAuNzVzfWRpdjp3aGVyZSguc3dhbDItaWNvbikuc3dhbDItc3VjY2Vzcy5zd2FsMi1pY29uLXNob3cgLnN3YWwyLXN1Y2Nlc3MtY2lyY3VsYXItbGluZS1yaWdodHthbmltYXRpb246c3dhbDItcm90YXRlLXN1Y2Nlc3MtY2lyY3VsYXItbGluZSA0LjI1cyBlYXNlLWlufX1bY2xhc3NePXN3YWwyXXstd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6cmdiYSgwLDAsMCwwKX0uc3dhbDItc2hvd3thbmltYXRpb246dmFyKC0tc3dhbDItc2hvdy1hbmltYXRpb24pfS5zd2FsMi1oaWRle2FuaW1hdGlvbjp2YXIoLS1zd2FsMi1oaWRlLWFuaW1hdGlvbil9LnN3YWwyLW5vYW5pbWF0aW9ue3RyYW5zaXRpb246bm9uZX0uc3dhbDItc2Nyb2xsYmFyLW1lYXN1cmV7cG9zaXRpb246YWJzb2x1dGU7dG9wOi05OTk5cHg7d2lkdGg6NTBweDtoZWlnaHQ6NTBweDtvdmVyZmxvdzpzY3JvbGx9LnN3YWwyLXJ0bCAuc3dhbDItY2xvc2V7bWFyZ2luLXJpZ2h0OmluaXRpYWw7bWFyZ2luLWxlZnQ6MH0uc3dhbDItcnRsIC5zd2FsMi10aW1lci1wcm9ncmVzcy1iYXJ7cmlnaHQ6MDtsZWZ0OmF1dG99LnN3YWwyLXRvYXN0e2JveC1zaXppbmc6Ym9yZGVyLWJveDtncmlkLWNvbHVtbjoxLzQgIWltcG9ydGFudDtncmlkLXJvdzoxLzQgIWltcG9ydGFudDtncmlkLXRlbXBsYXRlLWNvbHVtbnM6bWluLWNvbnRlbnQgYXV0byBtaW4tY29udGVudDtwYWRkaW5nOjFlbTtvdmVyZmxvdy15OmhpZGRlbjtib3JkZXI6dmFyKC0tc3dhbDItdG9hc3QtYm9yZGVyKTtiYWNrZ3JvdW5kOnZhcigtLXN3YWwyLWJhY2tncm91bmQpO2JveC1zaGFkb3c6dmFyKC0tc3dhbDItdG9hc3QtYm94LXNoYWRvdyk7cG9pbnRlci1ldmVudHM6YWxsfS5zd2FsMi10b2FzdD4qe2dyaWQtY29sdW1uOjJ9LnN3YWwyLXRvYXN0IGgyOndoZXJlKC5zd2FsMi10aXRsZSl7bWFyZ2luOi41ZW0gMWVtO3BhZGRpbmc6MDtmb250LXNpemU6MWVtO3RleHQtYWxpZ246aW5pdGlhbH0uc3dhbDItdG9hc3QgLnN3YWwyLWxvYWRpbmd7anVzdGlmeS1jb250ZW50OmNlbnRlcn0uc3dhbDItdG9hc3QgaW5wdXQ6d2hlcmUoLnN3YWwyLWlucHV0KXtoZWlnaHQ6MmVtO21hcmdpbjouNWVtO2ZvbnQtc2l6ZToxZW19LnN3YWwyLXRvYXN0IC5zd2FsMi12YWxpZGF0aW9uLW1lc3NhZ2V7Zm9udC1zaXplOjFlbX0uc3dhbDItdG9hc3QgZGl2OndoZXJlKC5zd2FsMi1mb290ZXIpe21hcmdpbjouNWVtIDAgMDtwYWRkaW5nOi41ZW0gMCAwO2ZvbnQtc2l6ZTouOGVtfS5zd2FsMi10b2FzdCBidXR0b246d2hlcmUoLnN3YWwyLWNsb3NlKXtncmlkLWNvbHVtbjozLzM7Z3JpZC1yb3c6MS85OTthbGlnbi1zZWxmOmNlbnRlcjt3aWR0aDouOGVtO2hlaWdodDouOGVtO21hcmdpbjowO2ZvbnQtc2l6ZToyZW19LnN3YWwyLXRvYXN0IGRpdjp3aGVyZSguc3dhbDItaHRtbC1jb250YWluZXIpe21hcmdpbjouNWVtIDFlbTtwYWRkaW5nOjA7b3ZlcmZsb3c6aW5pdGlhbDtmb250LXNpemU6MWVtO3RleHQtYWxpZ246aW5pdGlhbH0uc3dhbDItdG9hc3QgZGl2OndoZXJlKC5zd2FsMi1odG1sLWNvbnRhaW5lcik6ZW1wdHl7cGFkZGluZzowfS5zd2FsMi10b2FzdCAuc3dhbDItbG9hZGVye2dyaWQtY29sdW1uOjE7Z3JpZC1yb3c6MS85OTthbGlnbi1zZWxmOmNlbnRlcjt3aWR0aDoyZW07aGVpZ2h0OjJlbTttYXJnaW46LjI1ZW19LnN3YWwyLXRvYXN0IC5zd2FsMi1pY29ue2dyaWQtY29sdW1uOjE7Z3JpZC1yb3c6MS85OTthbGlnbi1zZWxmOmNlbnRlcjt3aWR0aDoyZW07bWluLXdpZHRoOjJlbTtoZWlnaHQ6MmVtO21hcmdpbjowIC41ZW0gMCAwfS5zd2FsMi10b2FzdCAuc3dhbDItaWNvbiAuc3dhbDItaWNvbi1jb250ZW50e2Rpc3BsYXk6ZmxleDthbGlnbi1pdGVtczpjZW50ZXI7Zm9udC1zaXplOjEuOGVtO2ZvbnQtd2VpZ2h0OmJvbGR9LnN3YWwyLXRvYXN0IC5zd2FsMi1pY29uLnN3YWwyLXN1Y2Nlc3MgLnN3YWwyLXN1Y2Nlc3MtcmluZ3t3aWR0aDoyZW07aGVpZ2h0OjJlbX0uc3dhbDItdG9hc3QgLnN3YWwyLWljb24uc3dhbDItZXJyb3IgW2NsYXNzXj1zd2FsMi14LW1hcmstbGluZV17dG9wOi44NzVlbTt3aWR0aDoxLjM3NWVtfS5zd2FsMi10b2FzdCAuc3dhbDItaWNvbi5zd2FsMi1lcnJvciBbY2xhc3NePXN3YWwyLXgtbWFyay1saW5lXVtjbGFzcyQ9bGVmdF17bGVmdDouMzEyNWVtfS5zd2FsMi10b2FzdCAuc3dhbDItaWNvbi5zd2FsMi1lcnJvciBbY2xhc3NePXN3YWwyLXgtbWFyay1saW5lXVtjbGFzcyQ9cmlnaHRde3JpZ2h0Oi4zMTI1ZW19LnN3YWwyLXRvYXN0IGRpdjp3aGVyZSguc3dhbDItYWN0aW9ucyl7anVzdGlmeS1jb250ZW50OmZsZXgtc3RhcnQ7aGVpZ2h0OmF1dG87bWFyZ2luOjA7bWFyZ2luLXRvcDouNWVtO3BhZGRpbmc6MCAuNWVtfS5zd2FsMi10b2FzdCBidXR0b246d2hlcmUoLnN3YWwyLXN0eWxlZCl7bWFyZ2luOi4yNWVtIC41ZW07cGFkZGluZzouNGVtIC42ZW07Zm9udC1zaXplOjFlbX0uc3dhbDItdG9hc3QgLnN3YWwyLXN1Y2Nlc3N7Ym9yZGVyLWNvbG9yOiNhNWRjODZ9LnN3YWwyLXRvYXN0IC5zd2FsMi1zdWNjZXNzIFtjbGFzc149c3dhbDItc3VjY2Vzcy1jaXJjdWxhci1saW5lXXtwb3NpdGlvbjphYnNvbHV0ZTt3aWR0aDoxLjZlbTtoZWlnaHQ6M2VtO2JvcmRlci1yYWRpdXM6NTAlfS5zd2FsMi10b2FzdCAuc3dhbDItc3VjY2VzcyBbY2xhc3NePXN3YWwyLXN1Y2Nlc3MtY2lyY3VsYXItbGluZV1bY2xhc3MkPWxlZnRde3RvcDotMC44ZW07bGVmdDotMC41ZW07dHJhbnNmb3JtOnJvdGF0ZSgtNDVkZWcpO3RyYW5zZm9ybS1vcmlnaW46MmVtIDJlbTtib3JkZXItcmFkaXVzOjRlbSAwIDAgNGVtfS5zd2FsMi10b2FzdCAuc3dhbDItc3VjY2VzcyBbY2xhc3NePXN3YWwyLXN1Y2Nlc3MtY2lyY3VsYXItbGluZV1bY2xhc3MkPXJpZ2h0XXt0b3A6LTAuMjVlbTtsZWZ0Oi45Mzc1ZW07dHJhbnNmb3JtLW9yaWdpbjowIDEuNWVtO2JvcmRlci1yYWRpdXM6MCA0ZW0gNGVtIDB9LnN3YWwyLXRvYXN0IC5zd2FsMi1zdWNjZXNzIC5zd2FsMi1zdWNjZXNzLXJpbmd7d2lkdGg6MmVtO2hlaWdodDoyZW19LnN3YWwyLXRvYXN0IC5zd2FsMi1zdWNjZXNzIC5zd2FsMi1zdWNjZXNzLWZpeHt0b3A6MDtsZWZ0Oi40Mzc1ZW07d2lkdGg6LjQzNzVlbTtoZWlnaHQ6Mi42ODc1ZW19LnN3YWwyLXRvYXN0IC5zd2FsMi1zdWNjZXNzIFtjbGFzc149c3dhbDItc3VjY2Vzcy1saW5lXXtoZWlnaHQ6LjMxMjVlbX0uc3dhbDItdG9hc3QgLnN3YWwyLXN1Y2Nlc3MgW2NsYXNzXj1zd2FsMi1zdWNjZXNzLWxpbmVdW2NsYXNzJD10aXBde3RvcDoxLjEyNWVtO2xlZnQ6LjE4NzVlbTt3aWR0aDouNzVlbX0uc3dhbDItdG9hc3QgLnN3YWwyLXN1Y2Nlc3MgW2NsYXNzXj1zd2FsMi1zdWNjZXNzLWxpbmVdW2NsYXNzJD1sb25nXXt0b3A6LjkzNzVlbTtyaWdodDouMTg3NWVtO3dpZHRoOjEuMzc1ZW19QGNvbnRhaW5lciBzd2FsMi1wb3B1cCBzdHlsZSgtLXN3YWwyLWljb24tYW5pbWF0aW9uczp0cnVlKXsuc3dhbDItdG9hc3QgLnN3YWwyLXN1Y2Nlc3Muc3dhbDItaWNvbi1zaG93IC5zd2FsMi1zdWNjZXNzLWxpbmUtdGlwe2FuaW1hdGlvbjpzd2FsMi10b2FzdC1hbmltYXRlLXN1Y2Nlc3MtbGluZS10aXAgLjc1c30uc3dhbDItdG9hc3QgLnN3YWwyLXN1Y2Nlc3Muc3dhbDItaWNvbi1zaG93IC5zd2FsMi1zdWNjZXNzLWxpbmUtbG9uZ3thbmltYXRpb246c3dhbDItdG9hc3QtYW5pbWF0ZS1zdWNjZXNzLWxpbmUtbG9uZyAuNzVzfX0uc3dhbDItdG9hc3Quc3dhbDItc2hvd3thbmltYXRpb246dmFyKC0tc3dhbDItdG9hc3Qtc2hvdy1hbmltYXRpb24pfS5zd2FsMi10b2FzdC5zd2FsMi1oaWRle2FuaW1hdGlvbjp2YXIoLS1zd2FsMi10b2FzdC1oaWRlLWFuaW1hdGlvbil9QGtleWZyYW1lcyBzd2FsMi1zaG93ezAle3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgwLCAtNTBweCwgMCkgc2NhbGUoMC45KTtvcGFjaXR5OjB9MTAwJXt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoMCwgMCwgMCkgc2NhbGUoMSk7b3BhY2l0eToxfX1Aa2V5ZnJhbWVzIHN3YWwyLWhpZGV7MCV7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDAsIDAsIDApIHNjYWxlKDEpO29wYWNpdHk6MX0xMDAle3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgwLCAtNTBweCwgMCkgc2NhbGUoMC45KTtvcGFjaXR5OjB9fUBrZXlmcmFtZXMgc3dhbDItYW5pbWF0ZS1zdWNjZXNzLWxpbmUtdGlwezAle3RvcDoxLjE4NzVlbTtsZWZ0Oi4wNjI1ZW07d2lkdGg6MH01NCV7dG9wOjEuMDYyNWVtO2xlZnQ6LjEyNWVtO3dpZHRoOjB9NzAle3RvcDoyLjE4NzVlbTtsZWZ0Oi0wLjM3NWVtO3dpZHRoOjMuMTI1ZW19ODQle3RvcDozZW07bGVmdDoxLjMxMjVlbTt3aWR0aDoxLjA2MjVlbX0xMDAle3RvcDoyLjgxMjVlbTtsZWZ0Oi44MTI1ZW07d2lkdGg6MS41NjI1ZW19fUBrZXlmcmFtZXMgc3dhbDItYW5pbWF0ZS1zdWNjZXNzLWxpbmUtbG9uZ3swJXt0b3A6My4zNzVlbTtyaWdodDoyLjg3NWVtO3dpZHRoOjB9NjUle3RvcDozLjM3NWVtO3JpZ2h0OjIuODc1ZW07d2lkdGg6MH04NCV7dG9wOjIuMTg3NWVtO3JpZ2h0OjA7d2lkdGg6My40Mzc1ZW19MTAwJXt0b3A6Mi4zNzVlbTtyaWdodDouNWVtO3dpZHRoOjIuOTM3NWVtfX1Aa2V5ZnJhbWVzIHN3YWwyLXJvdGF0ZS1zdWNjZXNzLWNpcmN1bGFyLWxpbmV7MCV7dHJhbnNmb3JtOnJvdGF0ZSgtNDVkZWcpfTUle3RyYW5zZm9ybTpyb3RhdGUoLTQ1ZGVnKX0xMiV7dHJhbnNmb3JtOnJvdGF0ZSgtNDA1ZGVnKX0xMDAle3RyYW5zZm9ybTpyb3RhdGUoLTQwNWRlZyl9fUBrZXlmcmFtZXMgc3dhbDItYW5pbWF0ZS1lcnJvci14LW1hcmt7MCV7bWFyZ2luLXRvcDoxLjYyNWVtO3RyYW5zZm9ybTpzY2FsZSgwLjQpO29wYWNpdHk6MH01MCV7bWFyZ2luLXRvcDoxLjYyNWVtO3RyYW5zZm9ybTpzY2FsZSgwLjQpO29wYWNpdHk6MH04MCV7bWFyZ2luLXRvcDotMC4zNzVlbTt0cmFuc2Zvcm06c2NhbGUoMS4xNSl9MTAwJXttYXJnaW4tdG9wOjA7dHJhbnNmb3JtOnNjYWxlKDEpO29wYWNpdHk6MX19QGtleWZyYW1lcyBzd2FsMi1hbmltYXRlLWVycm9yLWljb257MCV7dHJhbnNmb3JtOnJvdGF0ZVgoMTAwZGVnKTtvcGFjaXR5OjB9MTAwJXt0cmFuc2Zvcm06cm90YXRlWCgwZGVnKTtvcGFjaXR5OjF9fUBrZXlmcmFtZXMgc3dhbDItcm90YXRlLWxvYWRpbmd7MCV7dHJhbnNmb3JtOnJvdGF0ZSgwZGVnKX0xMDAle3RyYW5zZm9ybTpyb3RhdGUoMzYwZGVnKX19QGtleWZyYW1lcyBzd2FsMi1hbmltYXRlLXF1ZXN0aW9uLW1hcmt7MCV7dHJhbnNmb3JtOnJvdGF0ZVkoLTM2MGRlZyl9MTAwJXt0cmFuc2Zvcm06cm90YXRlWSgwKX19QGtleWZyYW1lcyBzd2FsMi1hbmltYXRlLWktbWFya3swJXt0cmFuc2Zvcm06cm90YXRlWig0NWRlZyk7b3BhY2l0eTowfTI1JXt0cmFuc2Zvcm06cm90YXRlWigtMjVkZWcpO29wYWNpdHk6LjR9NTAle3RyYW5zZm9ybTpyb3RhdGVaKDE1ZGVnKTtvcGFjaXR5Oi44fTc1JXt0cmFuc2Zvcm06cm90YXRlWigtNWRlZyk7b3BhY2l0eToxfTEwMCV7dHJhbnNmb3JtOnJvdGF0ZVgoMCk7b3BhY2l0eToxfX1Aa2V5ZnJhbWVzIHN3YWwyLXRvYXN0LXNob3d7MCV7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoLTAuNjI1ZW0pIHJvdGF0ZVooMmRlZyl9MzMle3RyYW5zZm9ybTp0cmFuc2xhdGVZKDApIHJvdGF0ZVooLTJkZWcpfTY2JXt0cmFuc2Zvcm06dHJhbnNsYXRlWSgwLjMxMjVlbSkgcm90YXRlWigyZGVnKX0xMDAle3RyYW5zZm9ybTp0cmFuc2xhdGVZKDApIHJvdGF0ZVooMGRlZyl9fUBrZXlmcmFtZXMgc3dhbDItdG9hc3QtaGlkZXsxMDAle3RyYW5zZm9ybTpyb3RhdGVaKDFkZWcpO29wYWNpdHk6MH19QGtleWZyYW1lcyBzd2FsMi10b2FzdC1hbmltYXRlLXN1Y2Nlc3MtbGluZS10aXB7MCV7dG9wOi41NjI1ZW07bGVmdDouMDYyNWVtO3dpZHRoOjB9NTQle3RvcDouMTI1ZW07bGVmdDouMTI1ZW07d2lkdGg6MH03MCV7dG9wOi42MjVlbTtsZWZ0Oi0wLjI1ZW07d2lkdGg6MS42MjVlbX04NCV7dG9wOjEuMDYyNWVtO2xlZnQ6Ljc1ZW07d2lkdGg6LjVlbX0xMDAle3RvcDoxLjEyNWVtO2xlZnQ6LjE4NzVlbTt3aWR0aDouNzVlbX19QGtleWZyYW1lcyBzd2FsMi10b2FzdC1hbmltYXRlLXN1Y2Nlc3MtbGluZS1sb25nezAle3RvcDoxLjYyNWVtO3JpZ2h0OjEuMzc1ZW07d2lkdGg6MH02NSV7dG9wOjEuMjVlbTtyaWdodDouOTM3NWVtO3dpZHRoOjB9ODQle3RvcDouOTM3NWVtO3JpZ2h0OjA7d2lkdGg6MS4xMjVlbX0xMDAle3RvcDouOTM3NWVtO3JpZ2h0Oi4xODc1ZW07d2lkdGg6MS4zNzVlbX19XCIpOyJdLCJuYW1lcyI6WyJfYXNzZXJ0Q2xhc3NCcmFuZCIsImUiLCJ0IiwibiIsImhhcyIsImFyZ3VtZW50cyIsImxlbmd0aCIsIlR5cGVFcnJvciIsIl9jaGVja1ByaXZhdGVSZWRlY2xhcmF0aW9uIiwiX2NsYXNzUHJpdmF0ZUZpZWxkR2V0MiIsInMiLCJhIiwiZ2V0IiwiX2NsYXNzUHJpdmF0ZUZpZWxkSW5pdFNwZWMiLCJzZXQiLCJfY2xhc3NQcml2YXRlRmllbGRTZXQyIiwiciIsIlJFU1RPUkVfRk9DVVNfVElNRU9VVCIsImdsb2JhbFN0YXRlIiwiZm9jdXNQcmV2aW91c0FjdGl2ZUVsZW1lbnQiLCJwcmV2aW91c0FjdGl2ZUVsZW1lbnQiLCJIVE1MRWxlbWVudCIsImZvY3VzIiwiZG9jdW1lbnQiLCJib2R5IiwicmVzdG9yZUFjdGl2ZUVsZW1lbnQiLCJyZXR1cm5Gb2N1cyIsIlByb21pc2UiLCJyZXNvbHZlIiwieCIsIndpbmRvdyIsInNjcm9sbFgiLCJ5Iiwic2Nyb2xsWSIsInJlc3RvcmVGb2N1c1RpbWVvdXQiLCJzZXRUaW1lb3V0Iiwic2Nyb2xsVG8iLCJzd2FsUHJlZml4IiwiY2xhc3NOYW1lcyIsInN3YWxDbGFzc2VzIiwicmVkdWNlIiwiYWNjIiwiY2xhc3NOYW1lIiwiaWNvbnMiLCJpY29uVHlwZXMiLCJpY29uIiwiY29uc29sZVByZWZpeCIsImNhcGl0YWxpemVGaXJzdExldHRlciIsInN0ciIsImNoYXJBdCIsInRvVXBwZXJDYXNlIiwic2xpY2UiLCJ3YXJuIiwibWVzc2FnZSIsImNvbnNvbGUiLCJqb2luIiwiZXJyb3IiLCJwcmV2aW91c1dhcm5PbmNlTWVzc2FnZXMiLCJ3YXJuT25jZSIsImluY2x1ZGVzIiwicHVzaCIsIndhcm5BYm91dERlcHJlY2F0aW9uIiwiZGVwcmVjYXRlZFBhcmFtIiwidXNlSW5zdGVhZCIsImNhbGxJZkZ1bmN0aW9uIiwiYXJnIiwiaGFzVG9Qcm9taXNlRm4iLCJ0b1Byb21pc2UiLCJhc1Byb21pc2UiLCJpc1Byb21pc2UiLCJnZXRDb250YWluZXIiLCJxdWVyeVNlbGVjdG9yIiwiY29udGFpbmVyIiwiZWxlbWVudEJ5U2VsZWN0b3IiLCJzZWxlY3RvclN0cmluZyIsImVsZW1lbnRCeUNsYXNzIiwiZ2V0UG9wdXAiLCJwb3B1cCIsImdldEljb24iLCJnZXRJY29uQ29udGVudCIsImdldFRpdGxlIiwidGl0bGUiLCJnZXRIdG1sQ29udGFpbmVyIiwiZ2V0SW1hZ2UiLCJpbWFnZSIsImdldFByb2dyZXNzU3RlcHMiLCJnZXRWYWxpZGF0aW9uTWVzc2FnZSIsImdldENvbmZpcm1CdXR0b24iLCJhY3Rpb25zIiwiY29uZmlybSIsImdldENhbmNlbEJ1dHRvbiIsImNhbmNlbCIsImdldERlbnlCdXR0b24iLCJkZW55IiwiZ2V0SW5wdXRMYWJlbCIsImdldExvYWRlciIsImxvYWRlciIsImdldEFjdGlvbnMiLCJnZXRGb290ZXIiLCJmb290ZXIiLCJnZXRUaW1lclByb2dyZXNzQmFyIiwiZ2V0Q2xvc2VCdXR0b24iLCJjbG9zZSIsImZvY3VzYWJsZSIsImdldEZvY3VzYWJsZUVsZW1lbnRzIiwiZm9jdXNhYmxlRWxlbWVudHNXaXRoVGFiaW5kZXgiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZm9jdXNhYmxlRWxlbWVudHNXaXRoVGFiaW5kZXhTb3J0ZWQiLCJBcnJheSIsImZyb20iLCJzb3J0IiwiYiIsInRhYmluZGV4QSIsInBhcnNlSW50IiwiZ2V0QXR0cmlidXRlIiwidGFiaW5kZXhCIiwib3RoZXJGb2N1c2FibGVFbGVtZW50cyIsIm90aGVyRm9jdXNhYmxlRWxlbWVudHNGaWx0ZXJlZCIsImZpbHRlciIsImVsIiwiU2V0IiwiY29uY2F0IiwiaXNWaXNpYmxlJDEiLCJpc01vZGFsIiwiaGFzQ2xhc3MiLCJzaG93biIsImlzVG9hc3QiLCJ0b2FzdCIsImlzTG9hZGluZyIsImhhc0F0dHJpYnV0ZSIsInNldElubmVySHRtbCIsImVsZW0iLCJodG1sIiwidGV4dENvbnRlbnQiLCJwYXJzZXIiLCJET01QYXJzZXIiLCJwYXJzZWQiLCJwYXJzZUZyb21TdHJpbmciLCJoZWFkIiwiY2hpbGROb2RlcyIsImZvckVhY2giLCJjaGlsZCIsImFwcGVuZENoaWxkIiwiSFRNTFZpZGVvRWxlbWVudCIsIkhUTUxBdWRpb0VsZW1lbnQiLCJjbG9uZU5vZGUiLCJjbGFzc0xpc3QiLCJzcGxpdCIsImkiLCJjb250YWlucyIsInJlbW92ZUN1c3RvbUNsYXNzZXMiLCJwYXJhbXMiLCJPYmplY3QiLCJ2YWx1ZXMiLCJzaG93Q2xhc3MiLCJyZW1vdmUiLCJhcHBseUN1c3RvbUNsYXNzIiwiY3VzdG9tQ2xhc3MiLCJhZGRDbGFzcyIsImdldElucHV0JDEiLCJpbnB1dENsYXNzIiwiY2hlY2tib3giLCJyYWRpbyIsInJhbmdlIiwiaW5wdXQiLCJmb2N1c0lucHV0IiwidHlwZSIsInZhbCIsInZhbHVlIiwidG9nZ2xlQ2xhc3MiLCJ0YXJnZXQiLCJjb25kaXRpb24iLCJCb29sZWFuIiwiaXNBcnJheSIsImFkZCIsInJlbW92ZUNsYXNzIiwiZ2V0RGlyZWN0Q2hpbGRCeUNsYXNzIiwiY2hpbGRyZW4iLCJhcHBseU51bWVyaWNhbFN0eWxlIiwicHJvcGVydHkiLCJzdHlsZSIsInNldFByb3BlcnR5IiwicmVtb3ZlUHJvcGVydHkiLCJzaG93IiwiZGlzcGxheSIsImhpZGUiLCJzaG93V2hlbklubmVySHRtbFByZXNlbnQiLCJNdXRhdGlvbk9ic2VydmVyIiwidG9nZ2xlIiwiaW5uZXJIVE1MIiwib2JzZXJ2ZSIsImNoaWxkTGlzdCIsInN1YnRyZWUiLCJzZXRTdHlsZSIsInBhcmVudCIsInNlbGVjdG9yIiwib2Zmc2V0V2lkdGgiLCJvZmZzZXRIZWlnaHQiLCJnZXRDbGllbnRSZWN0cyIsImFsbEJ1dHRvbnNBcmVIaWRkZW4iLCJpc1Njcm9sbGFibGUiLCJzY3JvbGxIZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJzZWxmT3JQYXJlbnRJc1Njcm9sbGFibGUiLCJlbGVtZW50Iiwic3RvcEVsZW1lbnQiLCJwYXJlbnRFbGVtZW50IiwiaGFzQ3NzQW5pbWF0aW9uIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImFuaW1EdXJhdGlvbiIsInBhcnNlRmxvYXQiLCJnZXRQcm9wZXJ0eVZhbHVlIiwidHJhbnNEdXJhdGlvbiIsImFuaW1hdGVUaW1lclByb2dyZXNzQmFyIiwidGltZXIiLCJyZXNldCIsInRpbWVyUHJvZ3Jlc3NCYXIiLCJ0cmFuc2l0aW9uIiwid2lkdGgiLCJzdG9wVGltZXJQcm9ncmVzc0JhciIsInRpbWVyUHJvZ3Jlc3NCYXJXaWR0aCIsInRpbWVyUHJvZ3Jlc3NCYXJGdWxsV2lkdGgiLCJ0aW1lclByb2dyZXNzQmFyUGVyY2VudCIsImlzTm9kZUVudiIsInN3ZWV0SFRNTCIsImZpbGUiLCJzZWxlY3QiLCJsYWJlbCIsInRleHRhcmVhIiwicmVwbGFjZSIsInJlc2V0T2xkQ29udGFpbmVyIiwib2xkQ29udGFpbmVyIiwiZG9jdW1lbnRFbGVtZW50IiwicmVzZXRWYWxpZGF0aW9uTWVzc2FnZSQxIiwiY3VycmVudEluc3RhbmNlIiwicmVzZXRWYWxpZGF0aW9uTWVzc2FnZSIsImFkZElucHV0Q2hhbmdlTGlzdGVuZXJzIiwicmFuZ2VPdXRwdXQiLCJvbmlucHV0Iiwib25jaGFuZ2UiLCJnZXRUYXJnZXQiLCJzZXR1cEFjY2Vzc2liaWxpdHkiLCJzZXRBdHRyaWJ1dGUiLCJzZXR1cFJUTCIsInRhcmdldEVsZW1lbnQiLCJkaXJlY3Rpb24iLCJydGwiLCJpc1JUTCIsImluaXQiLCJvbGRDb250YWluZXJFeGlzdGVkIiwiY3JlYXRlRWxlbWVudCIsImRhdGFzZXQiLCJ0aGVtZSIsInRvcExheWVyIiwic2hvd1BvcG92ZXIiLCJwYXJzZUh0bWxUb0NvbnRhaW5lciIsInBhcmFtIiwiaGFuZGxlT2JqZWN0IiwianF1ZXJ5IiwiaGFuZGxlSnF1ZXJ5RWxlbSIsInRvU3RyaW5nIiwicmVuZGVyQWN0aW9ucyIsImluc3RhbmNlIiwic2hvd0NvbmZpcm1CdXR0b24iLCJzaG93RGVueUJ1dHRvbiIsInNob3dDYW5jZWxCdXR0b24iLCJyZW5kZXJCdXR0b25zIiwibG9hZGVySHRtbCIsImNvbmZpcm1CdXR0b24iLCJkZW55QnV0dG9uIiwiY2FuY2VsQnV0dG9uIiwicmVuZGVyQnV0dG9uIiwiaGFuZGxlQnV0dG9uc1N0eWxpbmciLCJyZXZlcnNlQnV0dG9ucyIsImluc2VydEJlZm9yZSIsImJ1dHRvbnNTdHlsaW5nIiwic3R5bGVkIiwiY29uZmlybUJ1dHRvbkNvbG9yIiwiZGVueUJ1dHRvbkNvbG9yIiwiY2FuY2VsQnV0dG9uQ29sb3IiLCJhcHBseU91dGxpbmVDb2xvciIsImJ1dHRvbiIsImJ1dHRvblN0eWxlIiwib3V0bGluZUNvbG9yIiwiYmFja2dyb3VuZENvbG9yIiwiYnV0dG9uVHlwZSIsImJ1dHRvbk5hbWUiLCJyZW5kZXJDbG9zZUJ1dHRvbiIsImNsb3NlQnV0dG9uIiwiY2xvc2VCdXR0b25IdG1sIiwic2hvd0Nsb3NlQnV0dG9uIiwiY2xvc2VCdXR0b25BcmlhTGFiZWwiLCJyZW5kZXJDb250YWluZXIiLCJoYW5kbGVCYWNrZHJvcFBhcmFtIiwiYmFja2Ryb3AiLCJoYW5kbGVQb3NpdGlvblBhcmFtIiwicG9zaXRpb24iLCJoYW5kbGVHcm93UGFyYW0iLCJncm93IiwiYmFja2dyb3VuZCIsImNlbnRlciIsInByaXZhdGVQcm9wcyIsImlubmVyUGFyYW1zIiwiV2Vha01hcCIsImRvbUNhY2hlIiwiaW5wdXRDbGFzc2VzIiwicmVuZGVySW5wdXQiLCJyZXJlbmRlciIsImlucHV0Q29udGFpbmVyIiwic2V0QXR0cmlidXRlcyIsImlucHV0QXR0cmlidXRlcyIsInNob3dJbnB1dCIsInNldEN1c3RvbUNsYXNzIiwicmVuZGVySW5wdXRUeXBlIiwia2V5cyIsImdldElucHV0Q29udGFpbmVyIiwiaW5wdXRBdXRvRm9jdXMiLCJyZW1vdmVBdHRyaWJ1dGVzIiwiYXR0cmlidXRlcyIsImF0dHJOYW1lIiwibmFtZSIsInJlbW92ZUF0dHJpYnV0ZSIsImF0dHIiLCJzZXRJbnB1dFBsYWNlaG9sZGVyIiwicGxhY2Vob2xkZXIiLCJpbnB1dFBsYWNlaG9sZGVyIiwic2V0SW5wdXRMYWJlbCIsInByZXBlbmRUbyIsImlucHV0TGFiZWwiLCJsYWJlbENsYXNzIiwiaWQiLCJpbm5lclRleHQiLCJpbnNlcnRBZGphY2VudEVsZW1lbnQiLCJpbnB1dFR5cGUiLCJjaGVja0FuZFNldElucHV0VmFsdWUiLCJpbnB1dFZhbHVlIiwidGV4dCIsImVtYWlsIiwicGFzc3dvcmQiLCJudW1iZXIiLCJ0ZWwiLCJ1cmwiLCJzZWFyY2giLCJkYXRlIiwidGltZSIsIndlZWsiLCJtb250aCIsInJhbmdlSW5wdXQiLCJkaXNhYmxlZCIsInNlbGVjdGVkIiwiY2hlY2tib3hDb250YWluZXIiLCJjaGVja2VkIiwiZ2V0TWFyZ2luIiwibWFyZ2luTGVmdCIsIm1hcmdpblJpZ2h0IiwiaW5pdGlhbFBvcHVwV2lkdGgiLCJ0ZXh0YXJlYVJlc2l6ZUhhbmRsZXIiLCJ0ZXh0YXJlYVdpZHRoIiwiYXR0cmlidXRlRmlsdGVyIiwicmVuZGVyQ29udGVudCIsImh0bWxDb250YWluZXIiLCJyZW5kZXJGb290ZXIiLCJyZW5kZXJJY29uIiwic2V0Q29udGVudCIsImFwcGx5U3R5bGVzIiwiaWNvbkh0bWwiLCJpbmRleE9mIiwiY29sb3JTY2hlbWVRdWVyeUxpc3QiLCJtYXRjaE1lZGlhIiwiYWRkRXZlbnRMaXN0ZW5lciIsImFkanVzdFN1Y2Nlc3NJY29uQmFja2dyb3VuZENvbG9yIiwiaWNvblR5cGUiLCJpY29uQ2xhc3NOYW1lIiwiZW50cmllcyIsInNldENvbG9yIiwicG9wdXBCYWNrZ3JvdW5kQ29sb3IiLCJzdWNjZXNzSWNvblBhcnRzIiwic3VjY2Vzc0ljb25IdG1sIiwiYW5pbWF0aW9uIiwiZXJyb3JJY29uSHRtbCIsIm9sZENvbnRlbnQiLCJuZXdDb250ZW50IiwiaWNvbkNvbnRlbnQiLCJkZWZhdWx0SWNvbkh0bWwiLCJxdWVzdGlvbiIsIndhcm5pbmciLCJpbmZvIiwidHJpbSIsImljb25Db2xvciIsImNvbG9yIiwiYm9yZGVyQ29sb3IiLCJzZWwiLCJjb250ZW50IiwicmVuZGVySW1hZ2UiLCJpbWFnZVVybCIsImltYWdlQWx0IiwiaW1hZ2VXaWR0aCIsImltYWdlSGVpZ2h0IiwiZHJhZ2dpbmciLCJtb3VzZWRvd25YIiwibW91c2Vkb3duWSIsImluaXRpYWxYIiwiaW5pdGlhbFkiLCJhZGREcmFnZ2FibGVMaXN0ZW5lcnMiLCJkb3duIiwibW92ZSIsInVwIiwicmVtb3ZlRHJhZ2dhYmxlTGlzdGVuZXJzIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImV2ZW50IiwiY2xpZW50WFkiLCJnZXRDbGllbnRYWSIsImNsaWVudFgiLCJjbGllbnRZIiwiaW5zZXRJbmxpbmVTdGFydCIsImluc2V0QmxvY2tTdGFydCIsImRlbHRhWCIsInN0YXJ0c1dpdGgiLCJ0b3VjaGVzIiwicmVuZGVyUG9wdXAiLCJwYWRkaW5nIiwiYWRkQ2xhc3NlcyQxIiwiZHJhZ2dhYmxlIiwibW9kYWwiLCJyZW5kZXJQcm9ncmVzc1N0ZXBzIiwicHJvZ3Jlc3NTdGVwc0NvbnRhaW5lciIsInByb2dyZXNzU3RlcHMiLCJjdXJyZW50UHJvZ3Jlc3NTdGVwIiwidW5kZWZpbmVkIiwic3RlcCIsImluZGV4Iiwic3RlcEVsIiwiY3JlYXRlU3RlcEVsZW1lbnQiLCJsaW5lRWwiLCJjcmVhdGVMaW5lRWxlbWVudCIsInByb2dyZXNzU3RlcHNEaXN0YW5jZSIsInJlbmRlclRpdGxlIiwidGl0bGVUZXh0IiwicmVuZGVyIiwiZGlkUmVuZGVyIiwiZXZlbnRFbWl0dGVyIiwiZW1pdCIsImlzVmlzaWJsZSIsImNsaWNrQ29uZmlybSIsIl9kb20kZ2V0Q29uZmlybUJ1dHRvbiIsImNsaWNrIiwiY2xpY2tEZW55IiwiX2RvbSRnZXREZW55QnV0dG9uIiwiY2xpY2tDYW5jZWwiLCJfZG9tJGdldENhbmNlbEJ1dHRvbiIsIkRpc21pc3NSZWFzb24iLCJmcmVlemUiLCJlc2MiLCJyZW1vdmVLZXlkb3duSGFuZGxlciIsImtleWRvd25UYXJnZXQiLCJrZXlkb3duSGFuZGxlckFkZGVkIiwia2V5ZG93bkhhbmRsZXIiLCJjYXB0dXJlIiwia2V5ZG93bkxpc3RlbmVyQ2FwdHVyZSIsImFkZEtleWRvd25IYW5kbGVyIiwiZGlzbWlzc1dpdGgiLCJzZXRGb2N1cyIsImluY3JlbWVudCIsIl9kb20kZ2V0UG9wdXAiLCJmb2N1c2FibGVFbGVtZW50cyIsImFycm93S2V5c05leHRCdXR0b24iLCJhcnJvd0tleXNQcmV2aW91c0J1dHRvbiIsImlzQ29tcG9zaW5nIiwia2V5Q29kZSIsInN0b3BLZXlkb3duUHJvcGFnYXRpb24iLCJzdG9wUHJvcGFnYXRpb24iLCJrZXkiLCJoYW5kbGVFbnRlciIsImhhbmRsZVRhYiIsImhhbmRsZUFycm93cyIsImhhbmRsZUVzYyIsImFsbG93RW50ZXJLZXkiLCJvdXRlckhUTUwiLCJwcmV2ZW50RGVmYXVsdCIsImJ0bkluZGV4Iiwic2hpZnRLZXkiLCJidXR0b25zIiwiYWN0aXZlRWxlbWVudCIsInNpYmxpbmciLCJidXR0b25Ub0ZvY3VzIiwiSFRNTEJ1dHRvbkVsZW1lbnQiLCJhbGxvd0VzY2FwZUtleSIsInByaXZhdGVNZXRob2RzIiwic3dhbFByb21pc2VSZXNvbHZlIiwic3dhbFByb21pc2VSZWplY3QiLCJzZXRBcmlhSGlkZGVuIiwiYm9keUNoaWxkcmVuIiwidW5zZXRBcmlhSGlkZGVuIiwiaXNTYWZhcmlPcklPUyIsIkdlc3R1cmVFdmVudCIsImlPU2ZpeCIsImlvc2ZpeCIsIm9mZnNldCIsInNjcm9sbFRvcCIsInRvcCIsImxvY2tCb2R5U2Nyb2xsIiwicHJldmVudFRvdWNoTW92ZSIsIm9udG91Y2hzdGFydCIsInNob3VsZFByZXZlbnRUb3VjaE1vdmUiLCJvbnRvdWNobW92ZSIsImlzU3R5bHVzIiwiaXNab29tIiwidGFnTmFtZSIsInRvdWNoVHlwZSIsInVuZG9JT1NmaXgiLCJtZWFzdXJlU2Nyb2xsYmFyIiwic2Nyb2xsRGl2Iiwic2Nyb2xsYmFyV2lkdGgiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJjbGllbnRXaWR0aCIsInJlbW92ZUNoaWxkIiwicHJldmlvdXNCb2R5UGFkZGluZyIsInJlcGxhY2VTY3JvbGxiYXJXaXRoUGFkZGluZyIsImluaXRpYWxCb2R5T3ZlcmZsb3ciLCJpbm5lckhlaWdodCIsInBhZGRpbmdSaWdodCIsInVuZG9SZXBsYWNlU2Nyb2xsYmFyV2l0aFBhZGRpbmciLCJyZW1vdmVQb3B1cEFuZFJlc2V0U3RhdGUiLCJkaWRDbG9zZSIsInRyaWdnZXJEaWRDbG9zZUFuZERpc3Bvc2UiLCJ0aGVuIiwicmVtb3ZlQm9keUNsYXNzZXMiLCJyZXNvbHZlVmFsdWUiLCJwcmVwYXJlUmVzb2x2ZVZhbHVlIiwidHJpZ2dlckNsb3NlUG9wdXAiLCJpc0F3YWl0aW5nUHJvbWlzZSIsImlzRGlzbWlzc2VkIiwiaGFuZGxlQXdhaXRpbmdQcm9taXNlIiwiaGlkZUNsYXNzIiwiaGFuZGxlUG9wdXBBbmltYXRpb24iLCJyZWplY3RQcm9taXNlIiwiX2Rlc3Ryb3kiLCJpc0NvbmZpcm1lZCIsImlzRGVuaWVkIiwiYXNzaWduIiwiX2dsb2JhbFN0YXRlJGV2ZW50RW1pIiwiYW5pbWF0aW9uSXNTdXBwb3J0ZWQiLCJ3aWxsQ2xvc2UiLCJhbmltYXRlUG9wdXAiLCJzd2FsQ2xvc2VFdmVudEZpbmlzaGVkQ2FsbGJhY2siLCJiaW5kIiwic3dhbENsb3NlQW5pbWF0aW9uRmluaXNoZWQiLCJfZ2xvYmFsU3RhdGUkc3dhbENsb3MiLCJjYWxsIiwiX2dsb2JhbFN0YXRlJGV2ZW50RW1pMiIsInNob3dMb2FkaW5nIiwiYnV0dG9uVG9SZXBsYWNlIiwiU3dhbCIsInJlcGxhY2VCdXR0b24iLCJsb2FkaW5nIiwiaGFuZGxlSW5wdXRPcHRpb25zQW5kVmFsdWUiLCJoYW5kbGVJbnB1dE9wdGlvbnMiLCJzb21lIiwiaGFuZGxlSW5wdXRWYWx1ZSIsImdldElucHV0VmFsdWUiLCJnZXRJbnB1dCIsImdldENoZWNrYm94VmFsdWUiLCJnZXRSYWRpb1ZhbHVlIiwiZ2V0RmlsZVZhbHVlIiwiaW5wdXRBdXRvVHJpbSIsImZpbGVzIiwicHJvY2Vzc0lucHV0T3B0aW9ucyIsImlucHV0T3B0aW9ucyIsInBvcHVsYXRlU2VsZWN0T3B0aW9ucyIsImZvcm1hdElucHV0T3B0aW9ucyIsInBvcHVsYXRlUmFkaW9PcHRpb25zIiwiaGlkZUxvYWRpbmciLCJjYXRjaCIsImVyciIsInJlbmRlck9wdGlvbiIsIm9wdGlvbkxhYmVsIiwib3B0aW9uVmFsdWUiLCJvcHRpb24iLCJpc1NlbGVjdGVkIiwiaW5wdXRPcHRpb24iLCJvcHRncm91cCIsIm8iLCJyYWRpb1ZhbHVlIiwicmFkaW9MYWJlbCIsInJhZGlvSW5wdXQiLCJyYWRpb0xhYmVsRWxlbWVudCIsInJhZGlvcyIsInJlc3VsdCIsIk1hcCIsInZhbHVlRm9ybWF0dGVkIiwiaGFuZGxlQ29uZmlybUJ1dHRvbkNsaWNrIiwiZGlzYWJsZUJ1dHRvbnMiLCJoYW5kbGVDb25maXJtT3JEZW55V2l0aElucHV0IiwiaGFuZGxlRGVueUJ1dHRvbkNsaWNrIiwicmV0dXJuSW5wdXRWYWx1ZU9uRGVueSIsImhhbmRsZUNhbmNlbEJ1dHRvbkNsaWNrIiwiaW5wdXRWYWxpZGF0b3IiLCJoYW5kbGVJbnB1dFZhbGlkYXRvciIsImNoZWNrVmFsaWRpdHkiLCJlbmFibGVCdXR0b25zIiwic2hvd1ZhbGlkYXRpb25NZXNzYWdlIiwidmFsaWRhdGlvbk1lc3NhZ2UiLCJkaXNhYmxlSW5wdXQiLCJ2YWxpZGF0aW9uUHJvbWlzZSIsImVuYWJsZUlucHV0Iiwic2hvd0xvYWRlck9uRGVueSIsInByZURlbnkiLCJwcmVEZW55UHJvbWlzZSIsInByZURlbnlWYWx1ZSIsInJlamVjdFdpdGgiLCJzdWNjZWVkV2l0aCIsInNob3dMb2FkZXJPbkNvbmZpcm0iLCJwcmVDb25maXJtIiwicHJlQ29uZmlybVByb21pc2UiLCJwcmVDb25maXJtVmFsdWUiLCJzaG93UmVsYXRlZEJ1dHRvbiIsImdldEVsZW1lbnRzQnlDbGFzc05hbWUiLCJzZXRCdXR0b25zRGlzYWJsZWQiLCJzZXRJbnB1dERpc2FibGVkIiwiaW5wdXRlcnJvciIsImRlZmF1bHRQYXJhbXMiLCJ0ZW1wbGF0ZSIsImhlaWdodEF1dG8iLCJhbGxvd091dHNpZGVDbGljayIsImNvbmZpcm1CdXR0b25UZXh0IiwiY29uZmlybUJ1dHRvbkFyaWFMYWJlbCIsImRlbnlCdXR0b25UZXh0IiwiZGVueUJ1dHRvbkFyaWFMYWJlbCIsImNhbmNlbEJ1dHRvblRleHQiLCJjYW5jZWxCdXR0b25BcmlhTGFiZWwiLCJmb2N1c0NvbmZpcm0iLCJmb2N1c0RlbnkiLCJmb2N1c0NhbmNlbCIsIndpbGxPcGVuIiwiZGlkT3BlbiIsImRpZERlc3Ryb3kiLCJzY3JvbGxiYXJQYWRkaW5nIiwidXBkYXRhYmxlUGFyYW1zIiwiZGVwcmVjYXRlZFBhcmFtcyIsInRvYXN0SW5jb21wYXRpYmxlUGFyYW1zIiwiaXNWYWxpZFBhcmFtZXRlciIsInBhcmFtTmFtZSIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiaXNVcGRhdGFibGVQYXJhbWV0ZXIiLCJpc0RlcHJlY2F0ZWRQYXJhbWV0ZXIiLCJjaGVja0lmUGFyYW1Jc1ZhbGlkIiwiY2hlY2tJZlRvYXN0UGFyYW1Jc1ZhbGlkIiwiY2hlY2tJZlBhcmFtSXNEZXByZWNhdGVkIiwiaXNEZXByZWNhdGVkIiwic2hvd1dhcm5pbmdzRm9yUGFyYW1zIiwidXBkYXRlIiwidmFsaWRVcGRhdGFibGVQYXJhbXMiLCJmaWx0ZXJWYWxpZFBhcmFtcyIsInVwZGF0ZWRQYXJhbXMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwid3JpdGFibGUiLCJlbnVtZXJhYmxlIiwiZGlzcG9zZVdlYWtNYXBzIiwiZGlzcG9zZVN3YWwiLCJ1bnNldFdlYWtNYXBzIiwiZGlzYWJsZUxvYWRpbmciLCJjbG9zZVBvcHVwIiwiY2xvc2VNb2RhbCIsImNsb3NlVG9hc3QiLCJvYmoiLCJkZWxldGUiLCJpbnN0YW5jZU1ldGhvZHMiLCJfX3Byb3RvX18iLCJoYW5kbGVQb3B1cENsaWNrIiwiaGFuZGxlVG9hc3RDbGljayIsImhhbmRsZU1vZGFsTW91c2Vkb3duIiwiaGFuZGxlQ29udGFpbmVyTW91c2Vkb3duIiwiaGFuZGxlTW9kYWxDbGljayIsIm9uY2xpY2siLCJpc0FueUJ1dHRvblNob3duIiwiaWdub3JlT3V0c2lkZUNsaWNrIiwib25tb3VzZWRvd24iLCJvbm1vdXNldXAiLCJpc0pxdWVyeUVsZW1lbnQiLCJpc0VsZW1lbnQiLCJFbGVtZW50IiwiYXJnc1RvUGFyYW1zIiwiYXJncyIsImZpcmUiLCJtaXhpbiIsIm1peGluUGFyYW1zIiwiTWl4aW5Td2FsIiwiX21haW4iLCJwcmlvcml0eU1peGluUGFyYW1zIiwiZ2V0VGltZXJMZWZ0IiwidGltZW91dCIsInN0b3BUaW1lciIsInN0b3AiLCJyZXN1bWVUaW1lciIsInJlbWFpbmluZyIsInN0YXJ0IiwidG9nZ2xlVGltZXIiLCJydW5uaW5nIiwiaW5jcmVhc2VUaW1lciIsIm1zIiwiaW5jcmVhc2UiLCJpc1RpbWVyUnVubmluZyIsImlzUnVubmluZyIsImJvZHlDbGlja0xpc3RlbmVyQWRkZWQiLCJjbGlja0hhbmRsZXJzIiwiYmluZENsaWNrSGFuZGxlciIsImJvZHlDbGlja0xpc3RlbmVyIiwicGFyZW50Tm9kZSIsIkV2ZW50RW1pdHRlciIsImNvbnN0cnVjdG9yIiwiZXZlbnRzIiwiX2dldEhhbmRsZXJzQnlFdmVudE5hbWUiLCJldmVudE5hbWUiLCJvbiIsImV2ZW50SGFuZGxlciIsImN1cnJlbnRIYW5kbGVycyIsIm9uY2UiLCJvbmNlRm4iLCJyZW1vdmVMaXN0ZW5lciIsImFwcGx5Iiwic3BsaWNlIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwib2ZmIiwic3RhdGljTWV0aG9kcyIsImVuYWJsZUxvYWRpbmciLCJUaW1lciIsImNhbGxiYWNrIiwiZGVsYXkiLCJzdGFydGVkIiwiRGF0ZSIsImNsZWFyVGltZW91dCIsImdldFRpbWUiLCJzd2FsU3RyaW5nUGFyYW1zIiwiZ2V0VGVtcGxhdGVQYXJhbXMiLCJ0ZW1wbGF0ZUNvbnRlbnQiLCJzaG93V2FybmluZ3NGb3JFbGVtZW50cyIsImdldFN3YWxQYXJhbXMiLCJnZXRTd2FsRnVuY3Rpb25QYXJhbXMiLCJnZXRTd2FsQnV0dG9ucyIsImdldFN3YWxJbWFnZSIsImdldFN3YWxJY29uIiwiZ2V0U3dhbElucHV0IiwiZ2V0U3dhbFN0cmluZ1BhcmFtcyIsInN3YWxQYXJhbXMiLCJzaG93V2FybmluZ3NGb3JBdHRyaWJ1dGVzIiwiSlNPTiIsInBhcnNlIiwic3dhbEZ1bmN0aW9ucyIsIkZ1bmN0aW9uIiwic3dhbEJ1dHRvbnMiLCJvcHRpb25OYW1lIiwicGFyYW1OYW1lcyIsInRhZyIsImFsbG93ZWRFbGVtZW50cyIsInRvTG93ZXJDYXNlIiwiYWxsb3dlZEF0dHJpYnV0ZXMiLCJhdHRyaWJ1dGUiLCJTSE9XX0NMQVNTX1RJTUVPVVQiLCJvcGVuUG9wdXAiLCJib2R5U3R5bGVzIiwib3ZlcmZsb3dZIiwiYWRkQ2xhc3NlcyIsInNldFNjcm9sbGluZ1Zpc2liaWxpdHkiLCJmaXhTY3JvbGxDb250YWluZXIiLCJzd2FsT3BlbkFuaW1hdGlvbkZpbmlzaGVkIiwiZGVmYXVsdElucHV0VmFsaWRhdG9ycyIsInN0cmluZyIsInRlc3QiLCJzZXREZWZhdWx0SW5wdXRWYWxpZGF0b3JzIiwidmFsaWRhdGVDdXN0b21UYXJnZXRFbGVtZW50Iiwic2V0UGFyYW1ldGVycyIsIl9wcm9taXNlIiwiU3dlZXRBbGVydCIsIm91dGVyUGFyYW1zIiwidXNlclBhcmFtcyIsInByZXBhcmVQYXJhbXMiLCJwb3B1bGF0ZURvbUNhY2hlIiwic3dhbFByb21pc2UiLCJvbkZ1bGZpbGxlZCIsImZpbmFsbHkiLCJvbkZpbmFsbHkiLCJyZWplY3QiLCJkaXNtaXNzIiwic2V0dXBUaW1lciIsImluaXRGb2N1cyIsInRlbXBsYXRlUGFyYW1zIiwiYmx1ckFjdGl2ZUVsZW1lbnQiLCJmb2N1c0F1dG9mb2N1cyIsImZvY3VzQnV0dG9uIiwiYXV0b2ZvY3VzRWxlbWVudHMiLCJhdXRvZm9jdXNFbGVtZW50IiwiYmx1ciIsInZlcnNpb24iLCJkZWZhdWx0IiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJzdHlsZVNoZWV0IiwiY3NzVGV4dCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/sweetalert2/dist/sweetalert2.esm.all.js\n");

/***/ })

};
;