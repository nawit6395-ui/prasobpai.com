"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@tiptap";
exports.ids = ["vendor-chunks/@tiptap"];
exports.modules = {

/***/ "(ssr)/./node_modules/@tiptap/core/dist/index.js":
/*!*************************************************!*\
  !*** ./node_modules/@tiptap/core/dist/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CommandManager: () => (/* binding */ CommandManager),\n/* harmony export */   Editor: () => (/* binding */ Editor),\n/* harmony export */   Extendable: () => (/* binding */ Extendable),\n/* harmony export */   Extension: () => (/* binding */ Extension),\n/* harmony export */   Fragment: () => (/* binding */ Fragment6),\n/* harmony export */   InputRule: () => (/* binding */ InputRule),\n/* harmony export */   MappablePosition: () => (/* binding */ MappablePosition),\n/* harmony export */   Mark: () => (/* binding */ Mark),\n/* harmony export */   MarkView: () => (/* binding */ MarkView),\n/* harmony export */   Node: () => (/* binding */ Node3),\n/* harmony export */   NodePos: () => (/* binding */ NodePos),\n/* harmony export */   NodeView: () => (/* binding */ NodeView),\n/* harmony export */   PasteRule: () => (/* binding */ PasteRule),\n/* harmony export */   ResizableNodeView: () => (/* binding */ ResizableNodeView),\n/* harmony export */   ResizableNodeview: () => (/* binding */ ResizableNodeview),\n/* harmony export */   Tracker: () => (/* binding */ Tracker),\n/* harmony export */   callOrReturn: () => (/* binding */ callOrReturn),\n/* harmony export */   canInsertNode: () => (/* binding */ canInsertNode),\n/* harmony export */   combineTransactionSteps: () => (/* binding */ combineTransactionSteps),\n/* harmony export */   commands: () => (/* binding */ commands_exports),\n/* harmony export */   createAtomBlockMarkdownSpec: () => (/* binding */ createAtomBlockMarkdownSpec),\n/* harmony export */   createBlockMarkdownSpec: () => (/* binding */ createBlockMarkdownSpec),\n/* harmony export */   createChainableState: () => (/* binding */ createChainableState),\n/* harmony export */   createDocument: () => (/* binding */ createDocument),\n/* harmony export */   createElement: () => (/* binding */ h),\n/* harmony export */   createInlineMarkdownSpec: () => (/* binding */ createInlineMarkdownSpec),\n/* harmony export */   createMappablePosition: () => (/* binding */ createMappablePosition),\n/* harmony export */   createNodeFromContent: () => (/* binding */ createNodeFromContent),\n/* harmony export */   createStyleTag: () => (/* binding */ createStyleTag),\n/* harmony export */   defaultBlockAt: () => (/* binding */ defaultBlockAt),\n/* harmony export */   deleteProps: () => (/* binding */ deleteProps),\n/* harmony export */   elementFromString: () => (/* binding */ elementFromString),\n/* harmony export */   escapeForRegEx: () => (/* binding */ escapeForRegEx),\n/* harmony export */   extensions: () => (/* binding */ extensions_exports),\n/* harmony export */   findChildren: () => (/* binding */ findChildren),\n/* harmony export */   findChildrenInRange: () => (/* binding */ findChildrenInRange),\n/* harmony export */   findDuplicates: () => (/* binding */ findDuplicates),\n/* harmony export */   findParentNode: () => (/* binding */ findParentNode),\n/* harmony export */   findParentNodeClosestToPos: () => (/* binding */ findParentNodeClosestToPos),\n/* harmony export */   flattenExtensions: () => (/* binding */ flattenExtensions),\n/* harmony export */   fromString: () => (/* binding */ fromString),\n/* harmony export */   generateHTML: () => (/* binding */ generateHTML),\n/* harmony export */   generateJSON: () => (/* binding */ generateJSON),\n/* harmony export */   generateText: () => (/* binding */ generateText),\n/* harmony export */   getAttributes: () => (/* binding */ getAttributes),\n/* harmony export */   getAttributesFromExtensions: () => (/* binding */ getAttributesFromExtensions),\n/* harmony export */   getChangedRanges: () => (/* binding */ getChangedRanges),\n/* harmony export */   getDebugJSON: () => (/* binding */ getDebugJSON),\n/* harmony export */   getExtensionField: () => (/* binding */ getExtensionField),\n/* harmony export */   getHTMLFromFragment: () => (/* binding */ getHTMLFromFragment),\n/* harmony export */   getMarkAttributes: () => (/* binding */ getMarkAttributes),\n/* harmony export */   getMarkRange: () => (/* binding */ getMarkRange),\n/* harmony export */   getMarkType: () => (/* binding */ getMarkType),\n/* harmony export */   getMarksBetween: () => (/* binding */ getMarksBetween),\n/* harmony export */   getNodeAtPosition: () => (/* binding */ getNodeAtPosition),\n/* harmony export */   getNodeAttributes: () => (/* binding */ getNodeAttributes),\n/* harmony export */   getNodeType: () => (/* binding */ getNodeType),\n/* harmony export */   getRenderedAttributes: () => (/* binding */ getRenderedAttributes),\n/* harmony export */   getSchema: () => (/* binding */ getSchema),\n/* harmony export */   getSchemaByResolvedExtensions: () => (/* binding */ getSchemaByResolvedExtensions),\n/* harmony export */   getSchemaTypeByName: () => (/* binding */ getSchemaTypeByName),\n/* harmony export */   getSchemaTypeNameByName: () => (/* binding */ getSchemaTypeNameByName),\n/* harmony export */   getSplittedAttributes: () => (/* binding */ getSplittedAttributes),\n/* harmony export */   getText: () => (/* binding */ getText),\n/* harmony export */   getTextBetween: () => (/* binding */ getTextBetween),\n/* harmony export */   getTextContentFromNodes: () => (/* binding */ getTextContentFromNodes),\n/* harmony export */   getTextSerializersFromSchema: () => (/* binding */ getTextSerializersFromSchema),\n/* harmony export */   getUpdatedPosition: () => (/* binding */ getUpdatedPosition),\n/* harmony export */   h: () => (/* binding */ h),\n/* harmony export */   injectExtensionAttributesToParseRule: () => (/* binding */ injectExtensionAttributesToParseRule),\n/* harmony export */   inputRulesPlugin: () => (/* binding */ inputRulesPlugin),\n/* harmony export */   isActive: () => (/* binding */ isActive),\n/* harmony export */   isAndroid: () => (/* binding */ isAndroid),\n/* harmony export */   isAtEndOfNode: () => (/* binding */ isAtEndOfNode),\n/* harmony export */   isAtStartOfNode: () => (/* binding */ isAtStartOfNode),\n/* harmony export */   isEmptyObject: () => (/* binding */ isEmptyObject),\n/* harmony export */   isExtensionRulesEnabled: () => (/* binding */ isExtensionRulesEnabled),\n/* harmony export */   isFunction: () => (/* binding */ isFunction),\n/* harmony export */   isList: () => (/* binding */ isList),\n/* harmony export */   isMacOS: () => (/* binding */ isMacOS),\n/* harmony export */   isMarkActive: () => (/* binding */ isMarkActive),\n/* harmony export */   isNodeActive: () => (/* binding */ isNodeActive),\n/* harmony export */   isNodeEmpty: () => (/* binding */ isNodeEmpty),\n/* harmony export */   isNodeSelection: () => (/* binding */ isNodeSelection),\n/* harmony export */   isNumber: () => (/* binding */ isNumber),\n/* harmony export */   isPlainObject: () => (/* binding */ isPlainObject),\n/* harmony export */   isRegExp: () => (/* binding */ isRegExp),\n/* harmony export */   isString: () => (/* binding */ isString),\n/* harmony export */   isTextSelection: () => (/* binding */ isTextSelection),\n/* harmony export */   isiOS: () => (/* binding */ isiOS),\n/* harmony export */   markInputRule: () => (/* binding */ markInputRule),\n/* harmony export */   markPasteRule: () => (/* binding */ markPasteRule),\n/* harmony export */   markdown: () => (/* binding */ markdown_exports),\n/* harmony export */   mergeAttributes: () => (/* binding */ mergeAttributes),\n/* harmony export */   mergeDeep: () => (/* binding */ mergeDeep),\n/* harmony export */   minMax: () => (/* binding */ minMax),\n/* harmony export */   nodeInputRule: () => (/* binding */ nodeInputRule),\n/* harmony export */   nodePasteRule: () => (/* binding */ nodePasteRule),\n/* harmony export */   objectIncludes: () => (/* binding */ objectIncludes),\n/* harmony export */   parseAttributes: () => (/* binding */ parseAttributes),\n/* harmony export */   parseIndentedBlocks: () => (/* binding */ parseIndentedBlocks),\n/* harmony export */   pasteRulesPlugin: () => (/* binding */ pasteRulesPlugin),\n/* harmony export */   posToDOMRect: () => (/* binding */ posToDOMRect),\n/* harmony export */   removeDuplicates: () => (/* binding */ removeDuplicates),\n/* harmony export */   renderNestedMarkdownContent: () => (/* binding */ renderNestedMarkdownContent),\n/* harmony export */   resolveExtensions: () => (/* binding */ resolveExtensions),\n/* harmony export */   resolveFocusPosition: () => (/* binding */ resolveFocusPosition),\n/* harmony export */   rewriteUnknownContent: () => (/* binding */ rewriteUnknownContent),\n/* harmony export */   selectionToInsertionEnd: () => (/* binding */ selectionToInsertionEnd),\n/* harmony export */   serializeAttributes: () => (/* binding */ serializeAttributes),\n/* harmony export */   sortExtensions: () => (/* binding */ sortExtensions),\n/* harmony export */   splitExtensions: () => (/* binding */ splitExtensions),\n/* harmony export */   textInputRule: () => (/* binding */ textInputRule),\n/* harmony export */   textPasteRule: () => (/* binding */ textPasteRule),\n/* harmony export */   textblockTypeInputRule: () => (/* binding */ textblockTypeInputRule),\n/* harmony export */   updateMarkViewAttributes: () => (/* binding */ updateMarkViewAttributes),\n/* harmony export */   wrappingInputRule: () => (/* binding */ wrappingInputRule)\n/* harmony export */ });\n/* harmony import */ var _tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/transform */ \"(ssr)/./node_modules/@tiptap/pm/dist/transform/index.js\");\n/* harmony import */ var _tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/pm/commands */ \"(ssr)/./node_modules/@tiptap/pm/dist/commands/index.js\");\n/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tiptap/pm/state */ \"(ssr)/./node_modules/@tiptap/pm/dist/state/index.js\");\n/* harmony import */ var _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tiptap/pm/model */ \"(ssr)/./node_modules/@tiptap/pm/dist/model/index.js\");\n/* harmony import */ var _tiptap_pm_schema_list__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tiptap/pm/schema-list */ \"(ssr)/./node_modules/@tiptap/pm/dist/schema-list/index.js\");\n/* harmony import */ var _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @tiptap/pm/view */ \"(ssr)/./node_modules/@tiptap/pm/dist/view/index.js\");\n/* harmony import */ var _tiptap_pm_keymap__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @tiptap/pm/keymap */ \"(ssr)/./node_modules/@tiptap/pm/dist/keymap/index.js\");\nvar __defProp = Object.defineProperty;\nvar __export = (target, all)=>{\n    for(var name in all)__defProp(target, name, {\n        get: all[name],\n        enumerable: true\n    });\n};\n// src/helpers/createChainableState.ts\nfunction createChainableState(config) {\n    const { state, transaction } = config;\n    let { selection } = transaction;\n    let { doc } = transaction;\n    let { storedMarks } = transaction;\n    return {\n        ...state,\n        apply: state.apply.bind(state),\n        applyTransaction: state.applyTransaction.bind(state),\n        plugins: state.plugins,\n        schema: state.schema,\n        reconfigure: state.reconfigure.bind(state),\n        toJSON: state.toJSON.bind(state),\n        get storedMarks () {\n            return storedMarks;\n        },\n        get selection () {\n            return selection;\n        },\n        get doc () {\n            return doc;\n        },\n        get tr () {\n            selection = transaction.selection;\n            doc = transaction.doc;\n            storedMarks = transaction.storedMarks;\n            return transaction;\n        }\n    };\n}\n// src/CommandManager.ts\nvar CommandManager = class {\n    constructor(props){\n        this.editor = props.editor;\n        this.rawCommands = this.editor.extensionManager.commands;\n        this.customState = props.state;\n    }\n    get hasCustomState() {\n        return !!this.customState;\n    }\n    get state() {\n        return this.customState || this.editor.state;\n    }\n    get commands() {\n        const { rawCommands, editor, state } = this;\n        const { view } = editor;\n        const { tr } = state;\n        const props = this.buildProps(tr);\n        return Object.fromEntries(Object.entries(rawCommands).map(([name, command2])=>{\n            const method = (...args)=>{\n                const callback = command2(...args)(props);\n                if (!tr.getMeta(\"preventDispatch\") && !this.hasCustomState) {\n                    view.dispatch(tr);\n                }\n                return callback;\n            };\n            return [\n                name,\n                method\n            ];\n        }));\n    }\n    get chain() {\n        return ()=>this.createChain();\n    }\n    get can() {\n        return ()=>this.createCan();\n    }\n    createChain(startTr, shouldDispatch = true) {\n        const { rawCommands, editor, state } = this;\n        const { view } = editor;\n        const callbacks = [];\n        const hasStartTransaction = !!startTr;\n        const tr = startTr || state.tr;\n        const run3 = ()=>{\n            if (!hasStartTransaction && shouldDispatch && !tr.getMeta(\"preventDispatch\") && !this.hasCustomState) {\n                view.dispatch(tr);\n            }\n            return callbacks.every((callback)=>callback === true);\n        };\n        const chain = {\n            ...Object.fromEntries(Object.entries(rawCommands).map(([name, command2])=>{\n                const chainedCommand = (...args)=>{\n                    const props = this.buildProps(tr, shouldDispatch);\n                    const callback = command2(...args)(props);\n                    callbacks.push(callback);\n                    return chain;\n                };\n                return [\n                    name,\n                    chainedCommand\n                ];\n            })),\n            run: run3\n        };\n        return chain;\n    }\n    createCan(startTr) {\n        const { rawCommands, state } = this;\n        const dispatch = false;\n        const tr = startTr || state.tr;\n        const props = this.buildProps(tr, dispatch);\n        const formattedCommands = Object.fromEntries(Object.entries(rawCommands).map(([name, command2])=>{\n            return [\n                name,\n                (...args)=>command2(...args)({\n                        ...props,\n                        dispatch: void 0\n                    })\n            ];\n        }));\n        return {\n            ...formattedCommands,\n            chain: ()=>this.createChain(tr, dispatch)\n        };\n    }\n    buildProps(tr, shouldDispatch = true) {\n        const { rawCommands, editor, state } = this;\n        const { view } = editor;\n        const props = {\n            tr,\n            editor,\n            view,\n            state: createChainableState({\n                state,\n                transaction: tr\n            }),\n            dispatch: shouldDispatch ? ()=>void 0 : void 0,\n            chain: ()=>this.createChain(tr, shouldDispatch),\n            can: ()=>this.createCan(tr),\n            get commands () {\n                return Object.fromEntries(Object.entries(rawCommands).map(([name, command2])=>{\n                    return [\n                        name,\n                        (...args)=>command2(...args)(props)\n                    ];\n                }));\n            }\n        };\n        return props;\n    }\n};\n// src/commands/index.ts\nvar commands_exports = {};\n__export(commands_exports, {\n    blur: ()=>blur,\n    clearContent: ()=>clearContent,\n    clearNodes: ()=>clearNodes,\n    command: ()=>command,\n    createParagraphNear: ()=>createParagraphNear,\n    cut: ()=>cut,\n    deleteCurrentNode: ()=>deleteCurrentNode,\n    deleteNode: ()=>deleteNode,\n    deleteRange: ()=>deleteRange,\n    deleteSelection: ()=>deleteSelection,\n    enter: ()=>enter,\n    exitCode: ()=>exitCode,\n    extendMarkRange: ()=>extendMarkRange,\n    first: ()=>first,\n    focus: ()=>focus,\n    forEach: ()=>forEach,\n    insertContent: ()=>insertContent,\n    insertContentAt: ()=>insertContentAt,\n    joinBackward: ()=>joinBackward,\n    joinDown: ()=>joinDown,\n    joinForward: ()=>joinForward,\n    joinItemBackward: ()=>joinItemBackward,\n    joinItemForward: ()=>joinItemForward,\n    joinTextblockBackward: ()=>joinTextblockBackward,\n    joinTextblockForward: ()=>joinTextblockForward,\n    joinUp: ()=>joinUp,\n    keyboardShortcut: ()=>keyboardShortcut,\n    lift: ()=>lift,\n    liftEmptyBlock: ()=>liftEmptyBlock,\n    liftListItem: ()=>liftListItem,\n    newlineInCode: ()=>newlineInCode,\n    resetAttributes: ()=>resetAttributes,\n    scrollIntoView: ()=>scrollIntoView,\n    selectAll: ()=>selectAll,\n    selectNodeBackward: ()=>selectNodeBackward,\n    selectNodeForward: ()=>selectNodeForward,\n    selectParentNode: ()=>selectParentNode,\n    selectTextblockEnd: ()=>selectTextblockEnd,\n    selectTextblockStart: ()=>selectTextblockStart,\n    setContent: ()=>setContent,\n    setMark: ()=>setMark,\n    setMeta: ()=>setMeta,\n    setNode: ()=>setNode,\n    setNodeSelection: ()=>setNodeSelection,\n    setTextDirection: ()=>setTextDirection,\n    setTextSelection: ()=>setTextSelection,\n    sinkListItem: ()=>sinkListItem,\n    splitBlock: ()=>splitBlock,\n    splitListItem: ()=>splitListItem,\n    toggleList: ()=>toggleList,\n    toggleMark: ()=>toggleMark,\n    toggleNode: ()=>toggleNode,\n    toggleWrap: ()=>toggleWrap,\n    undoInputRule: ()=>undoInputRule,\n    unsetAllMarks: ()=>unsetAllMarks,\n    unsetMark: ()=>unsetMark,\n    unsetTextDirection: ()=>unsetTextDirection,\n    updateAttributes: ()=>updateAttributes,\n    wrapIn: ()=>wrapIn,\n    wrapInList: ()=>wrapInList\n});\n// src/commands/blur.ts\nvar blur = ()=>({ editor, view })=>{\n        requestAnimationFrame(()=>{\n            var _a;\n            if (!editor.isDestroyed) {\n                ;\n                view.dom.blur();\n                (_a = window == null ? void 0 : window.getSelection()) == null ? void 0 : _a.removeAllRanges();\n            }\n        });\n        return true;\n    };\n// src/commands/clearContent.ts\nvar clearContent = (emitUpdate = true)=>({ commands })=>{\n        return commands.setContent(\"\", {\n            emitUpdate\n        });\n    };\n// src/commands/clearNodes.ts\n\nvar clearNodes = ()=>({ state, tr, dispatch })=>{\n        const { selection } = tr;\n        const { ranges } = selection;\n        if (!dispatch) {\n            return true;\n        }\n        ranges.forEach(({ $from, $to })=>{\n            state.doc.nodesBetween($from.pos, $to.pos, (node, pos)=>{\n                if (node.type.isText) {\n                    return;\n                }\n                const { doc, mapping } = tr;\n                const $mappedFrom = doc.resolve(mapping.map(pos));\n                const $mappedTo = doc.resolve(mapping.map(pos + node.nodeSize));\n                const nodeRange = $mappedFrom.blockRange($mappedTo);\n                if (!nodeRange) {\n                    return;\n                }\n                const targetLiftDepth = (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_0__.liftTarget)(nodeRange);\n                if (node.type.isTextblock) {\n                    const { defaultType } = $mappedFrom.parent.contentMatchAt($mappedFrom.index());\n                    tr.setNodeMarkup(nodeRange.start, defaultType);\n                }\n                if (targetLiftDepth || targetLiftDepth === 0) {\n                    tr.lift(nodeRange, targetLiftDepth);\n                }\n            });\n        });\n        return true;\n    };\n// src/commands/command.ts\nvar command = (fn)=>(props)=>{\n        return fn(props);\n    };\n// src/commands/createParagraphNear.ts\n\nvar createParagraphNear = ()=>({ state, dispatch })=>{\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_1__.createParagraphNear)(state, dispatch);\n    };\n// src/commands/cut.ts\n\nvar cut = (originRange, targetPos)=>({ editor, tr })=>{\n        const { state } = editor;\n        const contentSlice = state.doc.slice(originRange.from, originRange.to);\n        tr.deleteRange(originRange.from, originRange.to);\n        const newPos = tr.mapping.map(targetPos);\n        tr.insert(newPos, contentSlice.content);\n        tr.setSelection(new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.TextSelection(tr.doc.resolve(Math.max(newPos - 1, 0))));\n        return true;\n    };\n// src/commands/deleteCurrentNode.ts\nvar deleteCurrentNode = ()=>({ tr, dispatch })=>{\n        const { selection } = tr;\n        const currentNode = selection.$anchor.node();\n        if (currentNode.content.size > 0) {\n            return false;\n        }\n        const $pos = tr.selection.$anchor;\n        for(let depth = $pos.depth; depth > 0; depth -= 1){\n            const node = $pos.node(depth);\n            if (node.type === currentNode.type) {\n                if (dispatch) {\n                    const from = $pos.before(depth);\n                    const to = $pos.after(depth);\n                    tr.delete(from, to).scrollIntoView();\n                }\n                return true;\n            }\n        }\n        return false;\n    };\n// src/helpers/getNodeType.ts\nfunction getNodeType(nameOrType, schema) {\n    if (typeof nameOrType === \"string\") {\n        if (!schema.nodes[nameOrType]) {\n            throw Error(`There is no node type named '${nameOrType}'. Maybe you forgot to add the extension?`);\n        }\n        return schema.nodes[nameOrType];\n    }\n    return nameOrType;\n}\n// src/commands/deleteNode.ts\nvar deleteNode = (typeOrName)=>({ tr, state, dispatch })=>{\n        const type = getNodeType(typeOrName, state.schema);\n        const $pos = tr.selection.$anchor;\n        for(let depth = $pos.depth; depth > 0; depth -= 1){\n            const node = $pos.node(depth);\n            if (node.type === type) {\n                if (dispatch) {\n                    const from = $pos.before(depth);\n                    const to = $pos.after(depth);\n                    tr.delete(from, to).scrollIntoView();\n                }\n                return true;\n            }\n        }\n        return false;\n    };\n// src/commands/deleteRange.ts\nvar deleteRange = (range)=>({ tr, dispatch })=>{\n        const { from, to } = range;\n        if (dispatch) {\n            tr.delete(from, to);\n        }\n        return true;\n    };\n// src/commands/deleteSelection.ts\n\nvar deleteSelection = ()=>({ state, dispatch })=>{\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_1__.deleteSelection)(state, dispatch);\n    };\n// src/commands/enter.ts\nvar enter = ()=>({ commands })=>{\n        return commands.keyboardShortcut(\"Enter\");\n    };\n// src/commands/exitCode.ts\n\nvar exitCode = ()=>({ state, dispatch })=>{\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_1__.exitCode)(state, dispatch);\n    };\n// src/commands/extendMarkRange.ts\n\n// src/utilities/isRegExp.ts\nfunction isRegExp(value) {\n    return Object.prototype.toString.call(value) === \"[object RegExp]\";\n}\n// src/utilities/objectIncludes.ts\nfunction objectIncludes(object1, object2, options = {\n    strict: true\n}) {\n    const keys = Object.keys(object2);\n    if (!keys.length) {\n        return true;\n    }\n    return keys.every((key)=>{\n        if (options.strict) {\n            return object2[key] === object1[key];\n        }\n        if (isRegExp(object2[key])) {\n            return object2[key].test(object1[key]);\n        }\n        return object2[key] === object1[key];\n    });\n}\n// src/helpers/getMarkRange.ts\nfunction findMarkInSet(marks, type, attributes = {}) {\n    return marks.find((item)=>{\n        return item.type === type && objectIncludes(// Only check equality for the attributes that are provided\n        Object.fromEntries(Object.keys(attributes).map((k)=>[\n                k,\n                item.attrs[k]\n            ])), attributes);\n    });\n}\nfunction isMarkInSet(marks, type, attributes = {}) {\n    return !!findMarkInSet(marks, type, attributes);\n}\nfunction getMarkRange($pos, type, attributes) {\n    var _a;\n    if (!$pos || !type) {\n        return;\n    }\n    let start = $pos.parent.childAfter($pos.parentOffset);\n    if (!start.node || !start.node.marks.some((mark2)=>mark2.type === type)) {\n        start = $pos.parent.childBefore($pos.parentOffset);\n    }\n    if (!start.node || !start.node.marks.some((mark2)=>mark2.type === type)) {\n        return;\n    }\n    attributes = attributes || ((_a = start.node.marks[0]) == null ? void 0 : _a.attrs);\n    const mark = findMarkInSet([\n        ...start.node.marks\n    ], type, attributes);\n    if (!mark) {\n        return;\n    }\n    let startIndex = start.index;\n    let startPos = $pos.start() + start.offset;\n    let endIndex = startIndex + 1;\n    let endPos = startPos + start.node.nodeSize;\n    while(startIndex > 0 && isMarkInSet([\n        ...$pos.parent.child(startIndex - 1).marks\n    ], type, attributes)){\n        startIndex -= 1;\n        startPos -= $pos.parent.child(startIndex).nodeSize;\n    }\n    while(endIndex < $pos.parent.childCount && isMarkInSet([\n        ...$pos.parent.child(endIndex).marks\n    ], type, attributes)){\n        endPos += $pos.parent.child(endIndex).nodeSize;\n        endIndex += 1;\n    }\n    return {\n        from: startPos,\n        to: endPos\n    };\n}\n// src/helpers/getMarkType.ts\nfunction getMarkType(nameOrType, schema) {\n    if (typeof nameOrType === \"string\") {\n        if (!schema.marks[nameOrType]) {\n            throw Error(`There is no mark type named '${nameOrType}'. Maybe you forgot to add the extension?`);\n        }\n        return schema.marks[nameOrType];\n    }\n    return nameOrType;\n}\n// src/commands/extendMarkRange.ts\nvar extendMarkRange = (typeOrName, attributes = {})=>({ tr, state, dispatch })=>{\n        const type = getMarkType(typeOrName, state.schema);\n        const { doc, selection } = tr;\n        const { $from, from, to } = selection;\n        if (dispatch) {\n            const range = getMarkRange($from, type, attributes);\n            if (range && range.from <= from && range.to >= to) {\n                const newSelection = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.TextSelection.create(doc, range.from, range.to);\n                tr.setSelection(newSelection);\n            }\n        }\n        return true;\n    };\n// src/commands/first.ts\nvar first = (commands)=>(props)=>{\n        const items = typeof commands === \"function\" ? commands(props) : commands;\n        for(let i = 0; i < items.length; i += 1){\n            if (items[i](props)) {\n                return true;\n            }\n        }\n        return false;\n    };\n// src/helpers/isTextSelection.ts\n\nfunction isTextSelection(value) {\n    return value instanceof _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.TextSelection;\n}\n// src/helpers/resolveFocusPosition.ts\n\n// src/utilities/minMax.ts\nfunction minMax(value = 0, min = 0, max = 0) {\n    return Math.min(Math.max(value, min), max);\n}\n// src/helpers/resolveFocusPosition.ts\nfunction resolveFocusPosition(doc, position = null) {\n    if (!position) {\n        return null;\n    }\n    const selectionAtStart = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.Selection.atStart(doc);\n    const selectionAtEnd = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.Selection.atEnd(doc);\n    if (position === \"start\" || position === true) {\n        return selectionAtStart;\n    }\n    if (position === \"end\") {\n        return selectionAtEnd;\n    }\n    const minPos = selectionAtStart.from;\n    const maxPos = selectionAtEnd.to;\n    if (position === \"all\") {\n        return _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.TextSelection.create(doc, minMax(0, minPos, maxPos), minMax(doc.content.size, minPos, maxPos));\n    }\n    return _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.TextSelection.create(doc, minMax(position, minPos, maxPos), minMax(position, minPos, maxPos));\n}\n// src/utilities/isAndroid.ts\nfunction isAndroid() {\n    return navigator.platform === \"Android\" || /android/i.test(navigator.userAgent);\n}\n// src/utilities/isiOS.ts\nfunction isiOS() {\n    return [\n        \"iPad Simulator\",\n        \"iPhone Simulator\",\n        \"iPod Simulator\",\n        \"iPad\",\n        \"iPhone\",\n        \"iPod\"\n    ].includes(navigator.platform) || // iPad on iOS 13 detection\n    navigator.userAgent.includes(\"Mac\") && \"ontouchend\" in document;\n}\n// src/commands/focus.ts\nvar focus = (position = null, options = {})=>({ editor, view, tr, dispatch })=>{\n        options = {\n            scrollIntoView: true,\n            ...options\n        };\n        const delayedFocus = ()=>{\n            if (isiOS() || isAndroid()) {\n                ;\n                view.dom.focus();\n            }\n            requestAnimationFrame(()=>{\n                if (!editor.isDestroyed) {\n                    view.focus();\n                    if (options == null ? void 0 : options.scrollIntoView) {\n                        editor.commands.scrollIntoView();\n                    }\n                }\n            });\n        };\n        if (view.hasFocus() && position === null || position === false) {\n            return true;\n        }\n        if (dispatch && position === null && !isTextSelection(editor.state.selection)) {\n            delayedFocus();\n            return true;\n        }\n        const selection = resolveFocusPosition(tr.doc, position) || editor.state.selection;\n        const isSameSelection = editor.state.selection.eq(selection);\n        if (dispatch) {\n            if (!isSameSelection) {\n                tr.setSelection(selection);\n            }\n            if (isSameSelection && tr.storedMarks) {\n                tr.setStoredMarks(tr.storedMarks);\n            }\n            delayedFocus();\n        }\n        return true;\n    };\n// src/commands/forEach.ts\nvar forEach = (items, fn)=>(props)=>{\n        return items.every((item, index)=>fn(item, {\n                ...props,\n                index\n            }));\n    };\n// src/commands/insertContent.ts\nvar insertContent = (value, options)=>({ tr, commands })=>{\n        return commands.insertContentAt({\n            from: tr.selection.from,\n            to: tr.selection.to\n        }, value, options);\n    };\n// src/commands/insertContentAt.ts\n\n// src/helpers/createNodeFromContent.ts\n\n// src/utilities/elementFromString.ts\nvar removeWhitespaces = (node)=>{\n    const children = node.childNodes;\n    for(let i = children.length - 1; i >= 0; i -= 1){\n        const child = children[i];\n        if (child.nodeType === 3 && child.nodeValue && /^(\\n\\s\\s|\\n)$/.test(child.nodeValue)) {\n            node.removeChild(child);\n        } else if (child.nodeType === 1) {\n            removeWhitespaces(child);\n        }\n    }\n    return node;\n};\nfunction elementFromString(value) {\n    if (true) {\n        throw new Error(\"[tiptap error]: there is no window object available, so this function cannot be used\");\n    }\n    const wrappedValue = `<body>${value}</body>`;\n    const html = new window.DOMParser().parseFromString(wrappedValue, \"text/html\").body;\n    return removeWhitespaces(html);\n}\n// src/helpers/createNodeFromContent.ts\nfunction createNodeFromContent(content, schema, options) {\n    if (content instanceof _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Node || content instanceof _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Fragment) {\n        return content;\n    }\n    options = {\n        slice: true,\n        parseOptions: {},\n        ...options\n    };\n    const isJSONContent = typeof content === \"object\" && content !== null;\n    const isTextContent = typeof content === \"string\";\n    if (isJSONContent) {\n        try {\n            const isArrayContent = Array.isArray(content) && content.length > 0;\n            if (isArrayContent) {\n                return _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Fragment.fromArray(content.map((item)=>schema.nodeFromJSON(item)));\n            }\n            const node = schema.nodeFromJSON(content);\n            if (options.errorOnInvalidContent) {\n                node.check();\n            }\n            return node;\n        } catch (error) {\n            if (options.errorOnInvalidContent) {\n                throw new Error(\"[tiptap error]: Invalid JSON content\", {\n                    cause: error\n                });\n            }\n            console.warn(\"[tiptap warn]: Invalid content.\", \"Passed value:\", content, \"Error:\", error);\n            return createNodeFromContent(\"\", schema, options);\n        }\n    }\n    if (isTextContent) {\n        if (options.errorOnInvalidContent) {\n            let hasInvalidContent = false;\n            let invalidContent = \"\";\n            const contentCheckSchema = new _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Schema({\n                topNode: schema.spec.topNode,\n                marks: schema.spec.marks,\n                // Prosemirror's schemas are executed such that: the last to execute, matches last\n                // This means that we can add a catch-all node at the end of the schema to catch any content that we don't know how to handle\n                nodes: schema.spec.nodes.append({\n                    __tiptap__private__unknown__catch__all__node: {\n                        content: \"inline*\",\n                        group: \"block\",\n                        parseDOM: [\n                            {\n                                tag: \"*\",\n                                getAttrs: (e)=>{\n                                    hasInvalidContent = true;\n                                    invalidContent = typeof e === \"string\" ? e : e.outerHTML;\n                                    return null;\n                                }\n                            }\n                        ]\n                    }\n                })\n            });\n            if (options.slice) {\n                _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.DOMParser.fromSchema(contentCheckSchema).parseSlice(elementFromString(content), options.parseOptions);\n            } else {\n                _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.DOMParser.fromSchema(contentCheckSchema).parse(elementFromString(content), options.parseOptions);\n            }\n            if (options.errorOnInvalidContent && hasInvalidContent) {\n                throw new Error(\"[tiptap error]: Invalid HTML content\", {\n                    cause: new Error(`Invalid element found: ${invalidContent}`)\n                });\n            }\n        }\n        const parser = _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.DOMParser.fromSchema(schema);\n        if (options.slice) {\n            return parser.parseSlice(elementFromString(content), options.parseOptions).content;\n        }\n        return parser.parse(elementFromString(content), options.parseOptions);\n    }\n    return createNodeFromContent(\"\", schema, options);\n}\n// src/helpers/selectionToInsertionEnd.ts\n\n\nfunction selectionToInsertionEnd(tr, startLen, bias) {\n    const last = tr.steps.length - 1;\n    if (last < startLen) {\n        return;\n    }\n    const step = tr.steps[last];\n    if (!(step instanceof _tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_0__.ReplaceStep || step instanceof _tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_0__.ReplaceAroundStep)) {\n        return;\n    }\n    const map = tr.mapping.maps[last];\n    let end = 0;\n    map.forEach((_from, _to, _newFrom, newTo)=>{\n        if (end === 0) {\n            end = newTo;\n        }\n    });\n    tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.Selection.near(tr.doc.resolve(end), bias));\n}\n// src/commands/insertContentAt.ts\nvar isFragment = (nodeOrFragment)=>{\n    return !(\"type\" in nodeOrFragment);\n};\nvar insertContentAt = (position, value, options)=>({ tr, dispatch, editor })=>{\n        var _a;\n        if (dispatch) {\n            options = {\n                parseOptions: editor.options.parseOptions,\n                updateSelection: true,\n                applyInputRules: false,\n                applyPasteRules: false,\n                ...options\n            };\n            let content;\n            const emitContentError = (error)=>{\n                editor.emit(\"contentError\", {\n                    editor,\n                    error,\n                    disableCollaboration: ()=>{\n                        if (\"collaboration\" in editor.storage && typeof editor.storage.collaboration === \"object\" && editor.storage.collaboration) {\n                            ;\n                            editor.storage.collaboration.isDisabled = true;\n                        }\n                    }\n                });\n            };\n            const parseOptions = {\n                preserveWhitespace: \"full\",\n                ...options.parseOptions\n            };\n            if (!options.errorOnInvalidContent && !editor.options.enableContentCheck && editor.options.emitContentError) {\n                try {\n                    createNodeFromContent(value, editor.schema, {\n                        parseOptions,\n                        errorOnInvalidContent: true\n                    });\n                } catch (e) {\n                    emitContentError(e);\n                }\n            }\n            try {\n                content = createNodeFromContent(value, editor.schema, {\n                    parseOptions,\n                    errorOnInvalidContent: (_a = options.errorOnInvalidContent) != null ? _a : editor.options.enableContentCheck\n                });\n            } catch (e) {\n                emitContentError(e);\n                return false;\n            }\n            let { from, to } = typeof position === \"number\" ? {\n                from: position,\n                to: position\n            } : {\n                from: position.from,\n                to: position.to\n            };\n            let isOnlyTextContent = true;\n            let isOnlyBlockContent = true;\n            const nodes = isFragment(content) ? content : [\n                content\n            ];\n            nodes.forEach((node)=>{\n                node.check();\n                isOnlyTextContent = isOnlyTextContent ? node.isText && node.marks.length === 0 : false;\n                isOnlyBlockContent = isOnlyBlockContent ? node.isBlock : false;\n            });\n            if (from === to && isOnlyBlockContent) {\n                const { parent } = tr.doc.resolve(from);\n                const isEmptyTextBlock = parent.isTextblock && !parent.type.spec.code && !parent.childCount;\n                if (isEmptyTextBlock) {\n                    from -= 1;\n                    to += 1;\n                }\n            }\n            let newContent;\n            if (isOnlyTextContent) {\n                if (Array.isArray(value)) {\n                    newContent = value.map((v)=>v.text || \"\").join(\"\");\n                } else if (value instanceof _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Fragment) {\n                    let text = \"\";\n                    value.forEach((node)=>{\n                        if (node.text) {\n                            text += node.text;\n                        }\n                    });\n                    newContent = text;\n                } else if (typeof value === \"object\" && !!value && !!value.text) {\n                    newContent = value.text;\n                } else {\n                    newContent = value;\n                }\n                tr.insertText(newContent, from, to);\n            } else {\n                newContent = content;\n                const $from = tr.doc.resolve(from);\n                const $fromNode = $from.node();\n                const fromSelectionAtStart = $from.parentOffset === 0;\n                const isTextSelection2 = $fromNode.isText || $fromNode.isTextblock;\n                const hasContent = $fromNode.content.size > 0;\n                if (fromSelectionAtStart && isTextSelection2 && hasContent) {\n                    from = Math.max(0, from - 1);\n                }\n                tr.replaceWith(from, to, newContent);\n            }\n            if (options.updateSelection) {\n                selectionToInsertionEnd(tr, tr.steps.length - 1, -1);\n            }\n            if (options.applyInputRules) {\n                tr.setMeta(\"applyInputRules\", {\n                    from,\n                    text: newContent\n                });\n            }\n            if (options.applyPasteRules) {\n                tr.setMeta(\"applyPasteRules\", {\n                    from,\n                    text: newContent\n                });\n            }\n        }\n        return true;\n    };\n// src/commands/join.ts\n\nvar joinUp = ()=>({ state, dispatch })=>{\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_1__.joinUp)(state, dispatch);\n    };\nvar joinDown = ()=>({ state, dispatch })=>{\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_1__.joinDown)(state, dispatch);\n    };\nvar joinBackward = ()=>({ state, dispatch })=>{\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_1__.joinBackward)(state, dispatch);\n    };\nvar joinForward = ()=>({ state, dispatch })=>{\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_1__.joinForward)(state, dispatch);\n    };\n// src/commands/joinItemBackward.ts\n\nvar joinItemBackward = ()=>({ state, dispatch, tr })=>{\n        try {\n            const point = (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_0__.joinPoint)(state.doc, state.selection.$from.pos, -1);\n            if (point === null || point === void 0) {\n                return false;\n            }\n            tr.join(point, 2);\n            if (dispatch) {\n                dispatch(tr);\n            }\n            return true;\n        } catch  {\n            return false;\n        }\n    };\n// src/commands/joinItemForward.ts\n\nvar joinItemForward = ()=>({ state, dispatch, tr })=>{\n        try {\n            const point = (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_0__.joinPoint)(state.doc, state.selection.$from.pos, 1);\n            if (point === null || point === void 0) {\n                return false;\n            }\n            tr.join(point, 2);\n            if (dispatch) {\n                dispatch(tr);\n            }\n            return true;\n        } catch  {\n            return false;\n        }\n    };\n// src/commands/joinTextblockBackward.ts\n\nvar joinTextblockBackward = ()=>({ state, dispatch })=>{\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_1__.joinTextblockBackward)(state, dispatch);\n    };\n// src/commands/joinTextblockForward.ts\n\nvar joinTextblockForward = ()=>({ state, dispatch })=>{\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_1__.joinTextblockForward)(state, dispatch);\n    };\n// src/utilities/isMacOS.ts\nfunction isMacOS() {\n    return typeof navigator !== \"undefined\" ? /Mac/.test(navigator.platform) : false;\n}\n// src/commands/keyboardShortcut.ts\nfunction normalizeKeyName(name) {\n    const parts = name.split(/-(?!$)/);\n    let result = parts[parts.length - 1];\n    if (result === \"Space\") {\n        result = \" \";\n    }\n    let alt;\n    let ctrl;\n    let shift;\n    let meta;\n    for(let i = 0; i < parts.length - 1; i += 1){\n        const mod = parts[i];\n        if (/^(cmd|meta|m)$/i.test(mod)) {\n            meta = true;\n        } else if (/^a(lt)?$/i.test(mod)) {\n            alt = true;\n        } else if (/^(c|ctrl|control)$/i.test(mod)) {\n            ctrl = true;\n        } else if (/^s(hift)?$/i.test(mod)) {\n            shift = true;\n        } else if (/^mod$/i.test(mod)) {\n            if (isiOS() || isMacOS()) {\n                meta = true;\n            } else {\n                ctrl = true;\n            }\n        } else {\n            throw new Error(`Unrecognized modifier name: ${mod}`);\n        }\n    }\n    if (alt) {\n        result = `Alt-${result}`;\n    }\n    if (ctrl) {\n        result = `Ctrl-${result}`;\n    }\n    if (meta) {\n        result = `Meta-${result}`;\n    }\n    if (shift) {\n        result = `Shift-${result}`;\n    }\n    return result;\n}\nvar keyboardShortcut = (name)=>({ editor, view, tr, dispatch })=>{\n        const keys = normalizeKeyName(name).split(/-(?!$)/);\n        const key = keys.find((item)=>![\n                \"Alt\",\n                \"Ctrl\",\n                \"Meta\",\n                \"Shift\"\n            ].includes(item));\n        const event = new KeyboardEvent(\"keydown\", {\n            key: key === \"Space\" ? \" \" : key,\n            altKey: keys.includes(\"Alt\"),\n            ctrlKey: keys.includes(\"Ctrl\"),\n            metaKey: keys.includes(\"Meta\"),\n            shiftKey: keys.includes(\"Shift\"),\n            bubbles: true,\n            cancelable: true\n        });\n        const capturedTransaction = editor.captureTransaction(()=>{\n            view.someProp(\"handleKeyDown\", (f)=>f(view, event));\n        });\n        capturedTransaction == null ? void 0 : capturedTransaction.steps.forEach((step)=>{\n            const newStep = step.map(tr.mapping);\n            if (newStep && dispatch) {\n                tr.maybeStep(newStep);\n            }\n        });\n        return true;\n    };\n// src/commands/lift.ts\n\n// src/helpers/isNodeActive.ts\nfunction isNodeActive(state, typeOrName, attributes = {}) {\n    const { from, to, empty } = state.selection;\n    const type = typeOrName ? getNodeType(typeOrName, state.schema) : null;\n    const nodeRanges = [];\n    state.doc.nodesBetween(from, to, (node, pos)=>{\n        if (node.isText) {\n            return;\n        }\n        const relativeFrom = Math.max(from, pos);\n        const relativeTo = Math.min(to, pos + node.nodeSize);\n        nodeRanges.push({\n            node,\n            from: relativeFrom,\n            to: relativeTo\n        });\n    });\n    const selectionRange = to - from;\n    const matchedNodeRanges = nodeRanges.filter((nodeRange)=>{\n        if (!type) {\n            return true;\n        }\n        return type.name === nodeRange.node.type.name;\n    }).filter((nodeRange)=>objectIncludes(nodeRange.node.attrs, attributes, {\n            strict: false\n        }));\n    if (empty) {\n        return !!matchedNodeRanges.length;\n    }\n    const range = matchedNodeRanges.reduce((sum, nodeRange)=>sum + nodeRange.to - nodeRange.from, 0);\n    return range >= selectionRange;\n}\n// src/commands/lift.ts\nvar lift = (typeOrName, attributes = {})=>({ state, dispatch })=>{\n        const type = getNodeType(typeOrName, state.schema);\n        const isActive2 = isNodeActive(state, type, attributes);\n        if (!isActive2) {\n            return false;\n        }\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_1__.lift)(state, dispatch);\n    };\n// src/commands/liftEmptyBlock.ts\n\nvar liftEmptyBlock = ()=>({ state, dispatch })=>{\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_1__.liftEmptyBlock)(state, dispatch);\n    };\n// src/commands/liftListItem.ts\n\nvar liftListItem = (typeOrName)=>({ state, dispatch })=>{\n        const type = getNodeType(typeOrName, state.schema);\n        return (0,_tiptap_pm_schema_list__WEBPACK_IMPORTED_MODULE_4__.liftListItem)(type)(state, dispatch);\n    };\n// src/commands/newlineInCode.ts\n\nvar newlineInCode = ()=>({ state, dispatch })=>{\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_1__.newlineInCode)(state, dispatch);\n    };\n// src/helpers/getSchemaTypeNameByName.ts\nfunction getSchemaTypeNameByName(name, schema) {\n    if (schema.nodes[name]) {\n        return \"node\";\n    }\n    if (schema.marks[name]) {\n        return \"mark\";\n    }\n    return null;\n}\n// src/utilities/deleteProps.ts\nfunction deleteProps(obj, propOrProps) {\n    const props = typeof propOrProps === \"string\" ? [\n        propOrProps\n    ] : propOrProps;\n    return Object.keys(obj).reduce((newObj, prop)=>{\n        if (!props.includes(prop)) {\n            newObj[prop] = obj[prop];\n        }\n        return newObj;\n    }, {});\n}\n// src/commands/resetAttributes.ts\nvar resetAttributes = (typeOrName, attributes)=>({ tr, state, dispatch })=>{\n        let nodeType = null;\n        let markType = null;\n        const schemaType = getSchemaTypeNameByName(typeof typeOrName === \"string\" ? typeOrName : typeOrName.name, state.schema);\n        if (!schemaType) {\n            return false;\n        }\n        if (schemaType === \"node\") {\n            nodeType = getNodeType(typeOrName, state.schema);\n        }\n        if (schemaType === \"mark\") {\n            markType = getMarkType(typeOrName, state.schema);\n        }\n        let canReset = false;\n        tr.selection.ranges.forEach((range)=>{\n            state.doc.nodesBetween(range.$from.pos, range.$to.pos, (node, pos)=>{\n                if (nodeType && nodeType === node.type) {\n                    canReset = true;\n                    if (dispatch) {\n                        tr.setNodeMarkup(pos, void 0, deleteProps(node.attrs, attributes));\n                    }\n                }\n                if (markType && node.marks.length) {\n                    node.marks.forEach((mark)=>{\n                        if (markType === mark.type) {\n                            canReset = true;\n                            if (dispatch) {\n                                tr.addMark(pos, pos + node.nodeSize, markType.create(deleteProps(mark.attrs, attributes)));\n                            }\n                        }\n                    });\n                }\n            });\n        });\n        return canReset;\n    };\n// src/commands/scrollIntoView.ts\nvar scrollIntoView = ()=>({ tr, dispatch })=>{\n        if (dispatch) {\n            tr.scrollIntoView();\n        }\n        return true;\n    };\n// src/commands/selectAll.ts\n\nvar selectAll = ()=>({ tr, dispatch })=>{\n        if (dispatch) {\n            const selection = new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.AllSelection(tr.doc);\n            tr.setSelection(selection);\n        }\n        return true;\n    };\n// src/commands/selectNodeBackward.ts\n\nvar selectNodeBackward = ()=>({ state, dispatch })=>{\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_1__.selectNodeBackward)(state, dispatch);\n    };\n// src/commands/selectNodeForward.ts\n\nvar selectNodeForward = ()=>({ state, dispatch })=>{\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_1__.selectNodeForward)(state, dispatch);\n    };\n// src/commands/selectParentNode.ts\n\nvar selectParentNode = ()=>({ state, dispatch })=>{\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_1__.selectParentNode)(state, dispatch);\n    };\n// src/commands/selectTextblockEnd.ts\n\nvar selectTextblockEnd = ()=>({ state, dispatch })=>{\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_1__.selectTextblockEnd)(state, dispatch);\n    };\n// src/commands/selectTextblockStart.ts\n\nvar selectTextblockStart = ()=>({ state, dispatch })=>{\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_1__.selectTextblockStart)(state, dispatch);\n    };\n// src/helpers/createDocument.ts\nfunction createDocument(content, schema, parseOptions = {}, options = {}) {\n    return createNodeFromContent(content, schema, {\n        slice: false,\n        parseOptions,\n        errorOnInvalidContent: options.errorOnInvalidContent\n    });\n}\n// src/commands/setContent.ts\nvar setContent = (content, { errorOnInvalidContent, emitUpdate = true, parseOptions = {} } = {})=>({ editor, tr, dispatch, commands })=>{\n        const { doc } = tr;\n        if (parseOptions.preserveWhitespace !== \"full\") {\n            const document2 = createDocument(content, editor.schema, parseOptions, {\n                errorOnInvalidContent: errorOnInvalidContent != null ? errorOnInvalidContent : editor.options.enableContentCheck\n            });\n            if (dispatch) {\n                tr.replaceWith(0, doc.content.size, document2).setMeta(\"preventUpdate\", !emitUpdate);\n            }\n            return true;\n        }\n        if (dispatch) {\n            tr.setMeta(\"preventUpdate\", !emitUpdate);\n        }\n        return commands.insertContentAt({\n            from: 0,\n            to: doc.content.size\n        }, content, {\n            parseOptions,\n            errorOnInvalidContent: errorOnInvalidContent != null ? errorOnInvalidContent : editor.options.enableContentCheck\n        });\n    };\n// src/helpers/getMarkAttributes.ts\nfunction getMarkAttributes(state, typeOrName) {\n    const type = getMarkType(typeOrName, state.schema);\n    const { from, to, empty } = state.selection;\n    const marks = [];\n    if (empty) {\n        if (state.storedMarks) {\n            marks.push(...state.storedMarks);\n        }\n        marks.push(...state.selection.$head.marks());\n    } else {\n        state.doc.nodesBetween(from, to, (node)=>{\n            marks.push(...node.marks);\n        });\n    }\n    const mark = marks.find((markItem)=>markItem.type.name === type.name);\n    if (!mark) {\n        return {};\n    }\n    return {\n        ...mark.attrs\n    };\n}\n// src/helpers/combineTransactionSteps.ts\n\nfunction combineTransactionSteps(oldDoc, transactions) {\n    const transform = new _tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_0__.Transform(oldDoc);\n    transactions.forEach((transaction)=>{\n        transaction.steps.forEach((step)=>{\n            transform.step(step);\n        });\n    });\n    return transform;\n}\n// src/helpers/defaultBlockAt.ts\nfunction defaultBlockAt(match) {\n    for(let i = 0; i < match.edgeCount; i += 1){\n        const { type } = match.edge(i);\n        if (type.isTextblock && !type.hasRequiredAttrs()) {\n            return type;\n        }\n    }\n    return null;\n}\n// src/helpers/findChildren.ts\nfunction findChildren(node, predicate) {\n    const nodesWithPos = [];\n    node.descendants((child, pos)=>{\n        if (predicate(child)) {\n            nodesWithPos.push({\n                node: child,\n                pos\n            });\n        }\n    });\n    return nodesWithPos;\n}\n// src/helpers/findChildrenInRange.ts\nfunction findChildrenInRange(node, range, predicate) {\n    const nodesWithPos = [];\n    node.nodesBetween(range.from, range.to, (child, pos)=>{\n        if (predicate(child)) {\n            nodesWithPos.push({\n                node: child,\n                pos\n            });\n        }\n    });\n    return nodesWithPos;\n}\n// src/helpers/findParentNodeClosestToPos.ts\nfunction findParentNodeClosestToPos($pos, predicate) {\n    for(let i = $pos.depth; i > 0; i -= 1){\n        const node = $pos.node(i);\n        if (predicate(node)) {\n            return {\n                pos: i > 0 ? $pos.before(i) : 0,\n                start: $pos.start(i),\n                depth: i,\n                node\n            };\n        }\n    }\n}\n// src/helpers/findParentNode.ts\nfunction findParentNode(predicate) {\n    return (selection)=>findParentNodeClosestToPos(selection.$from, predicate);\n}\n// src/helpers/getExtensionField.ts\nfunction getExtensionField(extension, field, context) {\n    if (extension.config[field] === void 0 && extension.parent) {\n        return getExtensionField(extension.parent, field, context);\n    }\n    if (typeof extension.config[field] === \"function\") {\n        const value = extension.config[field].bind({\n            ...context,\n            parent: extension.parent ? getExtensionField(extension.parent, field, context) : null\n        });\n        return value;\n    }\n    return extension.config[field];\n}\n// src/helpers/flattenExtensions.ts\nfunction flattenExtensions(extensions) {\n    return extensions.map((extension)=>{\n        const context = {\n            name: extension.name,\n            options: extension.options,\n            storage: extension.storage\n        };\n        const addExtensions = getExtensionField(extension, \"addExtensions\", context);\n        if (addExtensions) {\n            return [\n                extension,\n                ...flattenExtensions(addExtensions())\n            ];\n        }\n        return extension;\n    }).flat(10);\n}\n// src/helpers/generateHTML.ts\n\n// src/helpers/getHTMLFromFragment.ts\n\nfunction getHTMLFromFragment(fragment, schema) {\n    const documentFragment = _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.DOMSerializer.fromSchema(schema).serializeFragment(fragment);\n    const temporaryDocument = document.implementation.createHTMLDocument();\n    const container = temporaryDocument.createElement(\"div\");\n    container.appendChild(documentFragment);\n    return container.innerHTML;\n}\n// src/helpers/getSchemaByResolvedExtensions.ts\n\n// src/utilities/isFunction.ts\nfunction isFunction(value) {\n    return typeof value === \"function\";\n}\n// src/utilities/callOrReturn.ts\nfunction callOrReturn(value, context = void 0, ...props) {\n    if (isFunction(value)) {\n        if (context) {\n            return value.bind(context)(...props);\n        }\n        return value(...props);\n    }\n    return value;\n}\n// src/utilities/isEmptyObject.ts\nfunction isEmptyObject(value = {}) {\n    return Object.keys(value).length === 0 && value.constructor === Object;\n}\n// src/helpers/splitExtensions.ts\nfunction splitExtensions(extensions) {\n    const baseExtensions = extensions.filter((extension)=>extension.type === \"extension\");\n    const nodeExtensions = extensions.filter((extension)=>extension.type === \"node\");\n    const markExtensions = extensions.filter((extension)=>extension.type === \"mark\");\n    return {\n        baseExtensions,\n        nodeExtensions,\n        markExtensions\n    };\n}\n// src/helpers/getAttributesFromExtensions.ts\nfunction getAttributesFromExtensions(extensions) {\n    const extensionAttributes = [];\n    const { nodeExtensions, markExtensions } = splitExtensions(extensions);\n    const nodeAndMarkExtensions = [\n        ...nodeExtensions,\n        ...markExtensions\n    ];\n    const defaultAttribute = {\n        default: null,\n        validate: void 0,\n        rendered: true,\n        renderHTML: null,\n        parseHTML: null,\n        keepOnSplit: true,\n        isRequired: false\n    };\n    extensions.forEach((extension)=>{\n        const context = {\n            name: extension.name,\n            options: extension.options,\n            storage: extension.storage,\n            extensions: nodeAndMarkExtensions\n        };\n        const addGlobalAttributes = getExtensionField(extension, \"addGlobalAttributes\", context);\n        if (!addGlobalAttributes) {\n            return;\n        }\n        const globalAttributes = addGlobalAttributes();\n        globalAttributes.forEach((globalAttribute)=>{\n            globalAttribute.types.forEach((type)=>{\n                Object.entries(globalAttribute.attributes).forEach(([name, attribute])=>{\n                    extensionAttributes.push({\n                        type,\n                        name,\n                        attribute: {\n                            ...defaultAttribute,\n                            ...attribute\n                        }\n                    });\n                });\n            });\n        });\n    });\n    nodeAndMarkExtensions.forEach((extension)=>{\n        const context = {\n            name: extension.name,\n            options: extension.options,\n            storage: extension.storage\n        };\n        const addAttributes = getExtensionField(extension, \"addAttributes\", context);\n        if (!addAttributes) {\n            return;\n        }\n        const attributes = addAttributes();\n        Object.entries(attributes).forEach(([name, attribute])=>{\n            const mergedAttr = {\n                ...defaultAttribute,\n                ...attribute\n            };\n            if (typeof (mergedAttr == null ? void 0 : mergedAttr.default) === \"function\") {\n                mergedAttr.default = mergedAttr.default();\n            }\n            if ((mergedAttr == null ? void 0 : mergedAttr.isRequired) && (mergedAttr == null ? void 0 : mergedAttr.default) === void 0) {\n                delete mergedAttr.default;\n            }\n            extensionAttributes.push({\n                type: extension.name,\n                name,\n                attribute: mergedAttr\n            });\n        });\n    });\n    return extensionAttributes;\n}\n// src/utilities/mergeAttributes.ts\nfunction mergeAttributes(...objects) {\n    return objects.filter((item)=>!!item).reduce((items, item)=>{\n        const mergedAttributes = {\n            ...items\n        };\n        Object.entries(item).forEach(([key, value])=>{\n            const exists = mergedAttributes[key];\n            if (!exists) {\n                mergedAttributes[key] = value;\n                return;\n            }\n            if (key === \"class\") {\n                const valueClasses = value ? String(value).split(\" \") : [];\n                const existingClasses = mergedAttributes[key] ? mergedAttributes[key].split(\" \") : [];\n                const insertClasses = valueClasses.filter((valueClass)=>!existingClasses.includes(valueClass));\n                mergedAttributes[key] = [\n                    ...existingClasses,\n                    ...insertClasses\n                ].join(\" \");\n            } else if (key === \"style\") {\n                const newStyles = value ? value.split(\";\").map((style2)=>style2.trim()).filter(Boolean) : [];\n                const existingStyles = mergedAttributes[key] ? mergedAttributes[key].split(\";\").map((style2)=>style2.trim()).filter(Boolean) : [];\n                const styleMap = /* @__PURE__ */ new Map();\n                existingStyles.forEach((style2)=>{\n                    const [property, val] = style2.split(\":\").map((part)=>part.trim());\n                    styleMap.set(property, val);\n                });\n                newStyles.forEach((style2)=>{\n                    const [property, val] = style2.split(\":\").map((part)=>part.trim());\n                    styleMap.set(property, val);\n                });\n                mergedAttributes[key] = Array.from(styleMap.entries()).map(([property, val])=>`${property}: ${val}`).join(\"; \");\n            } else {\n                mergedAttributes[key] = value;\n            }\n        });\n        return mergedAttributes;\n    }, {});\n}\n// src/helpers/getRenderedAttributes.ts\nfunction getRenderedAttributes(nodeOrMark, extensionAttributes) {\n    return extensionAttributes.filter((attribute)=>attribute.type === nodeOrMark.type.name).filter((item)=>item.attribute.rendered).map((item)=>{\n        if (!item.attribute.renderHTML) {\n            return {\n                [item.name]: nodeOrMark.attrs[item.name]\n            };\n        }\n        return item.attribute.renderHTML(nodeOrMark.attrs) || {};\n    }).reduce((attributes, attribute)=>mergeAttributes(attributes, attribute), {});\n}\n// src/utilities/fromString.ts\nfunction fromString(value) {\n    if (typeof value !== \"string\") {\n        return value;\n    }\n    if (value.match(/^[+-]?(?:\\d*\\.)?\\d+$/)) {\n        return Number(value);\n    }\n    if (value === \"true\") {\n        return true;\n    }\n    if (value === \"false\") {\n        return false;\n    }\n    return value;\n}\n// src/helpers/injectExtensionAttributesToParseRule.ts\nfunction injectExtensionAttributesToParseRule(parseRule, extensionAttributes) {\n    if (\"style\" in parseRule) {\n        return parseRule;\n    }\n    return {\n        ...parseRule,\n        getAttrs: (node)=>{\n            const oldAttributes = parseRule.getAttrs ? parseRule.getAttrs(node) : parseRule.attrs;\n            if (oldAttributes === false) {\n                return false;\n            }\n            const newAttributes = extensionAttributes.reduce((items, item)=>{\n                const value = item.attribute.parseHTML ? item.attribute.parseHTML(node) : fromString(node.getAttribute(item.name));\n                if (value === null || value === void 0) {\n                    return items;\n                }\n                return {\n                    ...items,\n                    [item.name]: value\n                };\n            }, {});\n            return {\n                ...oldAttributes,\n                ...newAttributes\n            };\n        }\n    };\n}\n// src/helpers/getSchemaByResolvedExtensions.ts\nfunction cleanUpSchemaItem(data) {\n    return Object.fromEntries(// @ts-ignore\n    Object.entries(data).filter(([key, value])=>{\n        if (key === \"attrs\" && isEmptyObject(value)) {\n            return false;\n        }\n        return value !== null && value !== void 0;\n    }));\n}\nfunction buildAttributeSpec(extensionAttribute) {\n    var _a, _b;\n    const spec = {};\n    if (!((_a = extensionAttribute == null ? void 0 : extensionAttribute.attribute) == null ? void 0 : _a.isRequired) && \"default\" in ((extensionAttribute == null ? void 0 : extensionAttribute.attribute) || {})) {\n        spec.default = extensionAttribute.attribute.default;\n    }\n    if (((_b = extensionAttribute == null ? void 0 : extensionAttribute.attribute) == null ? void 0 : _b.validate) !== void 0) {\n        spec.validate = extensionAttribute.attribute.validate;\n    }\n    return [\n        extensionAttribute.name,\n        spec\n    ];\n}\nfunction getSchemaByResolvedExtensions(extensions, editor) {\n    var _a;\n    const allAttributes = getAttributesFromExtensions(extensions);\n    const { nodeExtensions, markExtensions } = splitExtensions(extensions);\n    const topNode = (_a = nodeExtensions.find((extension)=>getExtensionField(extension, \"topNode\"))) == null ? void 0 : _a.name;\n    const nodes = Object.fromEntries(nodeExtensions.map((extension)=>{\n        const extensionAttributes = allAttributes.filter((attribute)=>attribute.type === extension.name);\n        const context = {\n            name: extension.name,\n            options: extension.options,\n            storage: extension.storage,\n            editor\n        };\n        const extraNodeFields = extensions.reduce((fields, e)=>{\n            const extendNodeSchema = getExtensionField(e, \"extendNodeSchema\", context);\n            return {\n                ...fields,\n                ...extendNodeSchema ? extendNodeSchema(extension) : {}\n            };\n        }, {});\n        const schema = cleanUpSchemaItem({\n            ...extraNodeFields,\n            content: callOrReturn(getExtensionField(extension, \"content\", context)),\n            marks: callOrReturn(getExtensionField(extension, \"marks\", context)),\n            group: callOrReturn(getExtensionField(extension, \"group\", context)),\n            inline: callOrReturn(getExtensionField(extension, \"inline\", context)),\n            atom: callOrReturn(getExtensionField(extension, \"atom\", context)),\n            selectable: callOrReturn(getExtensionField(extension, \"selectable\", context)),\n            draggable: callOrReturn(getExtensionField(extension, \"draggable\", context)),\n            code: callOrReturn(getExtensionField(extension, \"code\", context)),\n            whitespace: callOrReturn(getExtensionField(extension, \"whitespace\", context)),\n            linebreakReplacement: callOrReturn(getExtensionField(extension, \"linebreakReplacement\", context)),\n            defining: callOrReturn(getExtensionField(extension, \"defining\", context)),\n            isolating: callOrReturn(getExtensionField(extension, \"isolating\", context)),\n            attrs: Object.fromEntries(extensionAttributes.map(buildAttributeSpec))\n        });\n        const parseHTML = callOrReturn(getExtensionField(extension, \"parseHTML\", context));\n        if (parseHTML) {\n            schema.parseDOM = parseHTML.map((parseRule)=>injectExtensionAttributesToParseRule(parseRule, extensionAttributes));\n        }\n        const renderHTML = getExtensionField(extension, \"renderHTML\", context);\n        if (renderHTML) {\n            schema.toDOM = (node)=>renderHTML({\n                    node,\n                    HTMLAttributes: getRenderedAttributes(node, extensionAttributes)\n                });\n        }\n        const renderText = getExtensionField(extension, \"renderText\", context);\n        if (renderText) {\n            schema.toText = renderText;\n        }\n        return [\n            extension.name,\n            schema\n        ];\n    }));\n    const marks = Object.fromEntries(markExtensions.map((extension)=>{\n        const extensionAttributes = allAttributes.filter((attribute)=>attribute.type === extension.name);\n        const context = {\n            name: extension.name,\n            options: extension.options,\n            storage: extension.storage,\n            editor\n        };\n        const extraMarkFields = extensions.reduce((fields, e)=>{\n            const extendMarkSchema = getExtensionField(e, \"extendMarkSchema\", context);\n            return {\n                ...fields,\n                ...extendMarkSchema ? extendMarkSchema(extension) : {}\n            };\n        }, {});\n        const schema = cleanUpSchemaItem({\n            ...extraMarkFields,\n            inclusive: callOrReturn(getExtensionField(extension, \"inclusive\", context)),\n            excludes: callOrReturn(getExtensionField(extension, \"excludes\", context)),\n            group: callOrReturn(getExtensionField(extension, \"group\", context)),\n            spanning: callOrReturn(getExtensionField(extension, \"spanning\", context)),\n            code: callOrReturn(getExtensionField(extension, \"code\", context)),\n            attrs: Object.fromEntries(extensionAttributes.map(buildAttributeSpec))\n        });\n        const parseHTML = callOrReturn(getExtensionField(extension, \"parseHTML\", context));\n        if (parseHTML) {\n            schema.parseDOM = parseHTML.map((parseRule)=>injectExtensionAttributesToParseRule(parseRule, extensionAttributes));\n        }\n        const renderHTML = getExtensionField(extension, \"renderHTML\", context);\n        if (renderHTML) {\n            schema.toDOM = (mark)=>renderHTML({\n                    mark,\n                    HTMLAttributes: getRenderedAttributes(mark, extensionAttributes)\n                });\n        }\n        return [\n            extension.name,\n            schema\n        ];\n    }));\n    return new _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Schema({\n        topNode,\n        nodes,\n        marks\n    });\n}\n// src/utilities/findDuplicates.ts\nfunction findDuplicates(items) {\n    const filtered = items.filter((el, index)=>items.indexOf(el) !== index);\n    return Array.from(new Set(filtered));\n}\n// src/helpers/sortExtensions.ts\nfunction sortExtensions(extensions) {\n    const defaultPriority = 100;\n    return extensions.sort((a, b)=>{\n        const priorityA = getExtensionField(a, \"priority\") || defaultPriority;\n        const priorityB = getExtensionField(b, \"priority\") || defaultPriority;\n        if (priorityA > priorityB) {\n            return -1;\n        }\n        if (priorityA < priorityB) {\n            return 1;\n        }\n        return 0;\n    });\n}\n// src/helpers/resolveExtensions.ts\nfunction resolveExtensions(extensions) {\n    const resolvedExtensions = sortExtensions(flattenExtensions(extensions));\n    const duplicatedNames = findDuplicates(resolvedExtensions.map((extension)=>extension.name));\n    if (duplicatedNames.length) {\n        console.warn(`[tiptap warn]: Duplicate extension names found: [${duplicatedNames.map((item)=>`'${item}'`).join(\", \")}]. This can lead to issues.`);\n    }\n    return resolvedExtensions;\n}\n// src/helpers/getSchema.ts\nfunction getSchema(extensions, editor) {\n    const resolvedExtensions = resolveExtensions(extensions);\n    return getSchemaByResolvedExtensions(resolvedExtensions, editor);\n}\n// src/helpers/generateHTML.ts\nfunction generateHTML(doc, extensions) {\n    const schema = getSchema(extensions);\n    const contentNode = _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Node.fromJSON(schema, doc);\n    return getHTMLFromFragment(contentNode.content, schema);\n}\n// src/helpers/generateJSON.ts\n\nfunction generateJSON(html, extensions) {\n    const schema = getSchema(extensions);\n    const dom = elementFromString(html);\n    return _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.DOMParser.fromSchema(schema).parse(dom).toJSON();\n}\n// src/helpers/generateText.ts\n\n// src/helpers/getTextBetween.ts\nfunction getTextBetween(startNode, range, options) {\n    const { from, to } = range;\n    const { blockSeparator = \"\\n\\n\", textSerializers = {} } = options || {};\n    let text = \"\";\n    startNode.nodesBetween(from, to, (node, pos, parent, index)=>{\n        var _a;\n        if (node.isBlock && pos > from) {\n            text += blockSeparator;\n        }\n        const textSerializer = textSerializers == null ? void 0 : textSerializers[node.type.name];\n        if (textSerializer) {\n            if (parent) {\n                text += textSerializer({\n                    node,\n                    pos,\n                    parent,\n                    index,\n                    range\n                });\n            }\n            return false;\n        }\n        if (node.isText) {\n            text += (_a = node == null ? void 0 : node.text) == null ? void 0 : _a.slice(Math.max(from, pos) - pos, to - pos);\n        }\n    });\n    return text;\n}\n// src/helpers/getText.ts\nfunction getText(node, options) {\n    const range = {\n        from: 0,\n        to: node.content.size\n    };\n    return getTextBetween(node, range, options);\n}\n// src/helpers/getTextSerializersFromSchema.ts\nfunction getTextSerializersFromSchema(schema) {\n    return Object.fromEntries(Object.entries(schema.nodes).filter(([, node])=>node.spec.toText).map(([name, node])=>[\n            name,\n            node.spec.toText\n        ]));\n}\n// src/helpers/generateText.ts\nfunction generateText(doc, extensions, options) {\n    const { blockSeparator = \"\\n\\n\", textSerializers = {} } = options || {};\n    const schema = getSchema(extensions);\n    const contentNode = _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Node.fromJSON(schema, doc);\n    return getText(contentNode, {\n        blockSeparator,\n        textSerializers: {\n            ...getTextSerializersFromSchema(schema),\n            ...textSerializers\n        }\n    });\n}\n// src/helpers/getNodeAttributes.ts\nfunction getNodeAttributes(state, typeOrName) {\n    const type = getNodeType(typeOrName, state.schema);\n    const { from, to } = state.selection;\n    const nodes = [];\n    state.doc.nodesBetween(from, to, (node2)=>{\n        nodes.push(node2);\n    });\n    const node = nodes.reverse().find((nodeItem)=>nodeItem.type.name === type.name);\n    if (!node) {\n        return {};\n    }\n    return {\n        ...node.attrs\n    };\n}\n// src/helpers/getAttributes.ts\nfunction getAttributes(state, typeOrName) {\n    const schemaType = getSchemaTypeNameByName(typeof typeOrName === \"string\" ? typeOrName : typeOrName.name, state.schema);\n    if (schemaType === \"node\") {\n        return getNodeAttributes(state, typeOrName);\n    }\n    if (schemaType === \"mark\") {\n        return getMarkAttributes(state, typeOrName);\n    }\n    return {};\n}\n// src/utilities/removeDuplicates.ts\nfunction removeDuplicates(array, by = JSON.stringify) {\n    const seen = {};\n    return array.filter((item)=>{\n        const key = by(item);\n        return Object.prototype.hasOwnProperty.call(seen, key) ? false : seen[key] = true;\n    });\n}\n// src/helpers/getChangedRanges.ts\nfunction simplifyChangedRanges(changes) {\n    const uniqueChanges = removeDuplicates(changes);\n    return uniqueChanges.length === 1 ? uniqueChanges : uniqueChanges.filter((change, index)=>{\n        const rest = uniqueChanges.filter((_, i)=>i !== index);\n        return !rest.some((otherChange)=>{\n            return change.oldRange.from >= otherChange.oldRange.from && change.oldRange.to <= otherChange.oldRange.to && change.newRange.from >= otherChange.newRange.from && change.newRange.to <= otherChange.newRange.to;\n        });\n    });\n}\nfunction getChangedRanges(transform) {\n    const { mapping, steps } = transform;\n    const changes = [];\n    mapping.maps.forEach((stepMap, index)=>{\n        const ranges = [];\n        if (!stepMap.ranges.length) {\n            const { from, to } = steps[index];\n            if (from === void 0 || to === void 0) {\n                return;\n            }\n            ranges.push({\n                from,\n                to\n            });\n        } else {\n            stepMap.forEach((from, to)=>{\n                ranges.push({\n                    from,\n                    to\n                });\n            });\n        }\n        ranges.forEach(({ from, to })=>{\n            const newStart = mapping.slice(index).map(from, -1);\n            const newEnd = mapping.slice(index).map(to);\n            const oldStart = mapping.invert().map(newStart, -1);\n            const oldEnd = mapping.invert().map(newEnd);\n            changes.push({\n                oldRange: {\n                    from: oldStart,\n                    to: oldEnd\n                },\n                newRange: {\n                    from: newStart,\n                    to: newEnd\n                }\n            });\n        });\n    });\n    return simplifyChangedRanges(changes);\n}\n// src/helpers/getDebugJSON.ts\nfunction getDebugJSON(node, startOffset = 0) {\n    const isTopNode = node.type === node.type.schema.topNodeType;\n    const increment = isTopNode ? 0 : 1;\n    const from = startOffset;\n    const to = from + node.nodeSize;\n    const marks = node.marks.map((mark)=>{\n        const output2 = {\n            type: mark.type.name\n        };\n        if (Object.keys(mark.attrs).length) {\n            output2.attrs = {\n                ...mark.attrs\n            };\n        }\n        return output2;\n    });\n    const attrs = {\n        ...node.attrs\n    };\n    const output = {\n        type: node.type.name,\n        from,\n        to\n    };\n    if (Object.keys(attrs).length) {\n        output.attrs = attrs;\n    }\n    if (marks.length) {\n        output.marks = marks;\n    }\n    if (node.content.childCount) {\n        output.content = [];\n        node.forEach((child, offset)=>{\n            var _a;\n            (_a = output.content) == null ? void 0 : _a.push(getDebugJSON(child, startOffset + offset + increment));\n        });\n    }\n    if (node.text) {\n        output.text = node.text;\n    }\n    return output;\n}\n// src/helpers/getMarksBetween.ts\nfunction getMarksBetween(from, to, doc) {\n    const marks = [];\n    if (from === to) {\n        doc.resolve(from).marks().forEach((mark)=>{\n            const $pos = doc.resolve(from);\n            const range = getMarkRange($pos, mark.type);\n            if (!range) {\n                return;\n            }\n            marks.push({\n                mark,\n                ...range\n            });\n        });\n    } else {\n        doc.nodesBetween(from, to, (node, pos)=>{\n            if (!node || (node == null ? void 0 : node.nodeSize) === void 0) {\n                return;\n            }\n            marks.push(...node.marks.map((mark)=>({\n                    from: pos,\n                    to: pos + node.nodeSize,\n                    mark\n                })));\n        });\n    }\n    return marks;\n}\n// src/helpers/getNodeAtPosition.ts\nvar getNodeAtPosition = (state, typeOrName, pos, maxDepth = 20)=>{\n    const $pos = state.doc.resolve(pos);\n    let currentDepth = maxDepth;\n    let node = null;\n    while(currentDepth > 0 && node === null){\n        const currentNode = $pos.node(currentDepth);\n        if ((currentNode == null ? void 0 : currentNode.type.name) === typeOrName) {\n            node = currentNode;\n        } else {\n            currentDepth -= 1;\n        }\n    }\n    return [\n        node,\n        currentDepth\n    ];\n};\n// src/helpers/getSchemaTypeByName.ts\nfunction getSchemaTypeByName(name, schema) {\n    return schema.nodes[name] || schema.marks[name] || null;\n}\n// src/helpers/getSplittedAttributes.ts\nfunction getSplittedAttributes(extensionAttributes, typeName, attributes) {\n    return Object.fromEntries(Object.entries(attributes).filter(([name])=>{\n        const extensionAttribute = extensionAttributes.find((item)=>{\n            return item.type === typeName && item.name === name;\n        });\n        if (!extensionAttribute) {\n            return false;\n        }\n        return extensionAttribute.attribute.keepOnSplit;\n    }));\n}\n// src/helpers/getTextContentFromNodes.ts\nvar getTextContentFromNodes = ($from, maxMatch = 500)=>{\n    let textBefore = \"\";\n    const sliceEndPos = $from.parentOffset;\n    $from.parent.nodesBetween(Math.max(0, sliceEndPos - maxMatch), sliceEndPos, (node, pos, parent, index)=>{\n        var _a, _b;\n        const chunk = ((_b = (_a = node.type.spec).toText) == null ? void 0 : _b.call(_a, {\n            node,\n            pos,\n            parent,\n            index\n        })) || node.textContent || \"%leaf%\";\n        textBefore += node.isAtom && !node.isText ? chunk : chunk.slice(0, Math.max(0, sliceEndPos - pos));\n    });\n    return textBefore;\n};\n// src/helpers/isMarkActive.ts\nfunction isMarkActive(state, typeOrName, attributes = {}) {\n    const { empty, ranges } = state.selection;\n    const type = typeOrName ? getMarkType(typeOrName, state.schema) : null;\n    if (empty) {\n        return !!(state.storedMarks || state.selection.$from.marks()).filter((mark)=>{\n            if (!type) {\n                return true;\n            }\n            return type.name === mark.type.name;\n        }).find((mark)=>objectIncludes(mark.attrs, attributes, {\n                strict: false\n            }));\n    }\n    let selectionRange = 0;\n    const markRanges = [];\n    ranges.forEach(({ $from, $to })=>{\n        const from = $from.pos;\n        const to = $to.pos;\n        state.doc.nodesBetween(from, to, (node, pos)=>{\n            if (!node.isText && !node.marks.length) {\n                return;\n            }\n            const relativeFrom = Math.max(from, pos);\n            const relativeTo = Math.min(to, pos + node.nodeSize);\n            const range2 = relativeTo - relativeFrom;\n            selectionRange += range2;\n            markRanges.push(...node.marks.map((mark)=>({\n                    mark,\n                    from: relativeFrom,\n                    to: relativeTo\n                })));\n        });\n    });\n    if (selectionRange === 0) {\n        return false;\n    }\n    const matchedRange = markRanges.filter((markRange)=>{\n        if (!type) {\n            return true;\n        }\n        return type.name === markRange.mark.type.name;\n    }).filter((markRange)=>objectIncludes(markRange.mark.attrs, attributes, {\n            strict: false\n        })).reduce((sum, markRange)=>sum + markRange.to - markRange.from, 0);\n    const excludedRange = markRanges.filter((markRange)=>{\n        if (!type) {\n            return true;\n        }\n        return markRange.mark.type !== type && markRange.mark.type.excludes(type);\n    }).reduce((sum, markRange)=>sum + markRange.to - markRange.from, 0);\n    const range = matchedRange > 0 ? matchedRange + excludedRange : matchedRange;\n    return range >= selectionRange;\n}\n// src/helpers/isActive.ts\nfunction isActive(state, name, attributes = {}) {\n    if (!name) {\n        return isNodeActive(state, null, attributes) || isMarkActive(state, null, attributes);\n    }\n    const schemaType = getSchemaTypeNameByName(name, state.schema);\n    if (schemaType === \"node\") {\n        return isNodeActive(state, name, attributes);\n    }\n    if (schemaType === \"mark\") {\n        return isMarkActive(state, name, attributes);\n    }\n    return false;\n}\n// src/helpers/isAtEndOfNode.ts\nvar isAtEndOfNode = (state, nodeType)=>{\n    const { $from, $to, $anchor } = state.selection;\n    if (nodeType) {\n        const parentNode = findParentNode((node)=>node.type.name === nodeType)(state.selection);\n        if (!parentNode) {\n            return false;\n        }\n        const $parentPos = state.doc.resolve(parentNode.pos + 1);\n        if ($anchor.pos + 1 === $parentPos.end()) {\n            return true;\n        }\n        return false;\n    }\n    if ($to.parentOffset < $to.parent.nodeSize - 2 || $from.pos !== $to.pos) {\n        return false;\n    }\n    return true;\n};\n// src/helpers/isAtStartOfNode.ts\nvar isAtStartOfNode = (state)=>{\n    const { $from, $to } = state.selection;\n    if ($from.parentOffset > 0 || $from.pos !== $to.pos) {\n        return false;\n    }\n    return true;\n};\n// src/helpers/isExtensionRulesEnabled.ts\nfunction isExtensionRulesEnabled(extension, enabled) {\n    if (Array.isArray(enabled)) {\n        return enabled.some((enabledExtension)=>{\n            const name = typeof enabledExtension === \"string\" ? enabledExtension : enabledExtension.name;\n            return name === extension.name;\n        });\n    }\n    return enabled;\n}\n// src/helpers/isList.ts\nfunction isList(name, extensions) {\n    const { nodeExtensions } = splitExtensions(extensions);\n    const extension = nodeExtensions.find((item)=>item.name === name);\n    if (!extension) {\n        return false;\n    }\n    const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: extension.storage\n    };\n    const group = callOrReturn(getExtensionField(extension, \"group\", context));\n    if (typeof group !== \"string\") {\n        return false;\n    }\n    return group.split(\" \").includes(\"list\");\n}\n// src/helpers/isNodeEmpty.ts\nfunction isNodeEmpty(node, { checkChildren = true, ignoreWhitespace = false } = {}) {\n    var _a;\n    if (ignoreWhitespace) {\n        if (node.type.name === \"hardBreak\") {\n            return true;\n        }\n        if (node.isText) {\n            return /^\\s*$/m.test((_a = node.text) != null ? _a : \"\");\n        }\n    }\n    if (node.isText) {\n        return !node.text;\n    }\n    if (node.isAtom || node.isLeaf) {\n        return false;\n    }\n    if (node.content.childCount === 0) {\n        return true;\n    }\n    if (checkChildren) {\n        let isContentEmpty = true;\n        node.content.forEach((childNode)=>{\n            if (isContentEmpty === false) {\n                return;\n            }\n            if (!isNodeEmpty(childNode, {\n                ignoreWhitespace,\n                checkChildren\n            })) {\n                isContentEmpty = false;\n            }\n        });\n        return isContentEmpty;\n    }\n    return false;\n}\n// src/helpers/isNodeSelection.ts\n\nfunction isNodeSelection(value) {\n    return value instanceof _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.NodeSelection;\n}\n// src/helpers/MappablePosition.ts\nvar MappablePosition = class _MappablePosition {\n    constructor(position){\n        this.position = position;\n    }\n    /**\n   * Creates a MappablePosition from a JSON object.\n   */ static fromJSON(json) {\n        return new _MappablePosition(json.position);\n    }\n    /**\n   * Converts the MappablePosition to a JSON object.\n   */ toJSON() {\n        return {\n            position: this.position\n        };\n    }\n};\nfunction getUpdatedPosition(position, transaction) {\n    const mapResult = transaction.mapping.mapResult(position.position);\n    return {\n        position: new MappablePosition(mapResult.pos),\n        mapResult\n    };\n}\nfunction createMappablePosition(position) {\n    return new MappablePosition(position);\n}\n// src/helpers/posToDOMRect.ts\nfunction posToDOMRect(view, from, to) {\n    const minPos = 0;\n    const maxPos = view.state.doc.content.size;\n    const resolvedFrom = minMax(from, minPos, maxPos);\n    const resolvedEnd = minMax(to, minPos, maxPos);\n    const start = view.coordsAtPos(resolvedFrom);\n    const end = view.coordsAtPos(resolvedEnd, -1);\n    const top = Math.min(start.top, end.top);\n    const bottom = Math.max(start.bottom, end.bottom);\n    const left = Math.min(start.left, end.left);\n    const right = Math.max(start.right, end.right);\n    const width = right - left;\n    const height = bottom - top;\n    const x = left;\n    const y = top;\n    const data = {\n        top,\n        bottom,\n        left,\n        right,\n        width,\n        height,\n        x,\n        y\n    };\n    return {\n        ...data,\n        toJSON: ()=>data\n    };\n}\n// src/helpers/rewriteUnknownContent.ts\nfunction rewriteUnknownContentInner({ json, validMarks, validNodes, options, rewrittenContent = [] }) {\n    if (json.marks && Array.isArray(json.marks)) {\n        json.marks = json.marks.filter((mark)=>{\n            const name = typeof mark === \"string\" ? mark : mark.type;\n            if (validMarks.has(name)) {\n                return true;\n            }\n            rewrittenContent.push({\n                original: JSON.parse(JSON.stringify(mark)),\n                unsupported: name\n            });\n            return false;\n        });\n    }\n    if (json.content && Array.isArray(json.content)) {\n        json.content = json.content.map((value)=>rewriteUnknownContentInner({\n                json: value,\n                validMarks,\n                validNodes,\n                options,\n                rewrittenContent\n            }).json).filter((a)=>a !== null && a !== void 0);\n    }\n    if (json.type && !validNodes.has(json.type)) {\n        rewrittenContent.push({\n            original: JSON.parse(JSON.stringify(json)),\n            unsupported: json.type\n        });\n        if (json.content && Array.isArray(json.content) && (options == null ? void 0 : options.fallbackToParagraph) !== false) {\n            json.type = \"paragraph\";\n            return {\n                json,\n                rewrittenContent\n            };\n        }\n        return {\n            json: null,\n            rewrittenContent\n        };\n    }\n    return {\n        json,\n        rewrittenContent\n    };\n}\nfunction rewriteUnknownContent(json, schema, options) {\n    return rewriteUnknownContentInner({\n        json,\n        validNodes: new Set(Object.keys(schema.nodes)),\n        validMarks: new Set(Object.keys(schema.marks)),\n        options\n    });\n}\n// src/commands/setMark.ts\nfunction canSetMark(state, tr, newMarkType) {\n    var _a;\n    const { selection } = tr;\n    let cursor = null;\n    if (isTextSelection(selection)) {\n        cursor = selection.$cursor;\n    }\n    if (cursor) {\n        const currentMarks = (_a = state.storedMarks) != null ? _a : cursor.marks();\n        const parentAllowsMarkType = cursor.parent.type.allowsMarkType(newMarkType);\n        return parentAllowsMarkType && (!!newMarkType.isInSet(currentMarks) || !currentMarks.some((mark)=>mark.type.excludes(newMarkType)));\n    }\n    const { ranges } = selection;\n    return ranges.some(({ $from, $to })=>{\n        let someNodeSupportsMark = $from.depth === 0 ? state.doc.inlineContent && state.doc.type.allowsMarkType(newMarkType) : false;\n        state.doc.nodesBetween($from.pos, $to.pos, (node, _pos, parent)=>{\n            if (someNodeSupportsMark) {\n                return false;\n            }\n            if (node.isInline) {\n                const parentAllowsMarkType = !parent || parent.type.allowsMarkType(newMarkType);\n                const currentMarksAllowMarkType = !!newMarkType.isInSet(node.marks) || !node.marks.some((otherMark)=>otherMark.type.excludes(newMarkType));\n                someNodeSupportsMark = parentAllowsMarkType && currentMarksAllowMarkType;\n            }\n            return !someNodeSupportsMark;\n        });\n        return someNodeSupportsMark;\n    });\n}\nvar setMark = (typeOrName, attributes = {})=>({ tr, state, dispatch })=>{\n        const { selection } = tr;\n        const { empty, ranges } = selection;\n        const type = getMarkType(typeOrName, state.schema);\n        if (dispatch) {\n            if (empty) {\n                const oldAttributes = getMarkAttributes(state, type);\n                tr.addStoredMark(type.create({\n                    ...oldAttributes,\n                    ...attributes\n                }));\n            } else {\n                ranges.forEach((range)=>{\n                    const from = range.$from.pos;\n                    const to = range.$to.pos;\n                    state.doc.nodesBetween(from, to, (node, pos)=>{\n                        const trimmedFrom = Math.max(pos, from);\n                        const trimmedTo = Math.min(pos + node.nodeSize, to);\n                        const someHasMark = node.marks.find((mark)=>mark.type === type);\n                        if (someHasMark) {\n                            node.marks.forEach((mark)=>{\n                                if (type === mark.type) {\n                                    tr.addMark(trimmedFrom, trimmedTo, type.create({\n                                        ...mark.attrs,\n                                        ...attributes\n                                    }));\n                                }\n                            });\n                        } else {\n                            tr.addMark(trimmedFrom, trimmedTo, type.create(attributes));\n                        }\n                    });\n                });\n            }\n        }\n        return canSetMark(state, tr, type);\n    };\n// src/commands/setMeta.ts\nvar setMeta = (key, value)=>({ tr })=>{\n        tr.setMeta(key, value);\n        return true;\n    };\n// src/commands/setNode.ts\n\nvar setNode = (typeOrName, attributes = {})=>({ state, dispatch, chain })=>{\n        const type = getNodeType(typeOrName, state.schema);\n        let attributesToCopy;\n        if (state.selection.$anchor.sameParent(state.selection.$head)) {\n            attributesToCopy = state.selection.$anchor.parent.attrs;\n        }\n        if (!type.isTextblock) {\n            console.warn('[tiptap warn]: Currently \"setNode()\" only supports text block nodes.');\n            return false;\n        }\n        return chain().command(({ commands })=>{\n            const canSetBlock = (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_1__.setBlockType)(type, {\n                ...attributesToCopy,\n                ...attributes\n            })(state);\n            if (canSetBlock) {\n                return true;\n            }\n            return commands.clearNodes();\n        }).command(({ state: updatedState })=>{\n            return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_1__.setBlockType)(type, {\n                ...attributesToCopy,\n                ...attributes\n            })(updatedState, dispatch);\n        }).run();\n    };\n// src/commands/setNodeSelection.ts\n\nvar setNodeSelection = (position)=>({ tr, dispatch })=>{\n        if (dispatch) {\n            const { doc } = tr;\n            const from = minMax(position, 0, doc.content.size);\n            const selection = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.NodeSelection.create(doc, from);\n            tr.setSelection(selection);\n        }\n        return true;\n    };\n// src/commands/setTextDirection.ts\nvar setTextDirection = (direction, position)=>({ tr, state, dispatch })=>{\n        const { selection } = state;\n        let from;\n        let to;\n        if (typeof position === \"number\") {\n            from = position;\n            to = position;\n        } else if (position && \"from\" in position && \"to\" in position) {\n            from = position.from;\n            to = position.to;\n        } else {\n            from = selection.from;\n            to = selection.to;\n        }\n        if (dispatch) {\n            tr.doc.nodesBetween(from, to, (node, pos)=>{\n                if (node.isText) {\n                    return;\n                }\n                tr.setNodeMarkup(pos, void 0, {\n                    ...node.attrs,\n                    dir: direction\n                });\n            });\n        }\n        return true;\n    };\n// src/commands/setTextSelection.ts\n\nvar setTextSelection = (position)=>({ tr, dispatch })=>{\n        if (dispatch) {\n            const { doc } = tr;\n            const { from, to } = typeof position === \"number\" ? {\n                from: position,\n                to: position\n            } : position;\n            const minPos = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.TextSelection.atStart(doc).from;\n            const maxPos = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.TextSelection.atEnd(doc).to;\n            const resolvedFrom = minMax(from, minPos, maxPos);\n            const resolvedEnd = minMax(to, minPos, maxPos);\n            const selection = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.TextSelection.create(doc, resolvedFrom, resolvedEnd);\n            tr.setSelection(selection);\n        }\n        return true;\n    };\n// src/commands/sinkListItem.ts\n\nvar sinkListItem = (typeOrName)=>({ state, dispatch })=>{\n        const type = getNodeType(typeOrName, state.schema);\n        return (0,_tiptap_pm_schema_list__WEBPACK_IMPORTED_MODULE_4__.sinkListItem)(type)(state, dispatch);\n    };\n// src/commands/splitBlock.ts\n\n\nfunction ensureMarks(state, splittableMarks) {\n    const marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();\n    if (marks) {\n        const filteredMarks = marks.filter((mark)=>splittableMarks == null ? void 0 : splittableMarks.includes(mark.type.name));\n        state.tr.ensureMarks(filteredMarks);\n    }\n}\nvar splitBlock = ({ keepMarks = true } = {})=>({ tr, state, dispatch, editor })=>{\n        const { selection, doc } = tr;\n        const { $from, $to } = selection;\n        const extensionAttributes = editor.extensionManager.attributes;\n        const newAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);\n        if (selection instanceof _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.NodeSelection && selection.node.isBlock) {\n            if (!$from.parentOffset || !(0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit)(doc, $from.pos)) {\n                return false;\n            }\n            if (dispatch) {\n                if (keepMarks) {\n                    ensureMarks(state, editor.extensionManager.splittableMarks);\n                }\n                tr.split($from.pos).scrollIntoView();\n            }\n            return true;\n        }\n        if (!$from.parent.isBlock) {\n            return false;\n        }\n        const atEnd = $to.parentOffset === $to.parent.content.size;\n        const deflt = $from.depth === 0 ? void 0 : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));\n        let types = atEnd && deflt ? [\n            {\n                type: deflt,\n                attrs: newAttributes\n            }\n        ] : void 0;\n        let can = (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit)(tr.doc, tr.mapping.map($from.pos), 1, types);\n        if (!types && !can && (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit)(tr.doc, tr.mapping.map($from.pos), 1, deflt ? [\n            {\n                type: deflt\n            }\n        ] : void 0)) {\n            can = true;\n            types = deflt ? [\n                {\n                    type: deflt,\n                    attrs: newAttributes\n                }\n            ] : void 0;\n        }\n        if (dispatch) {\n            if (can) {\n                if (selection instanceof _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.TextSelection) {\n                    tr.deleteSelection();\n                }\n                tr.split(tr.mapping.map($from.pos), 1, types);\n                if (deflt && !atEnd && !$from.parentOffset && $from.parent.type !== deflt) {\n                    const first2 = tr.mapping.map($from.before());\n                    const $first = tr.doc.resolve(first2);\n                    if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {\n                        tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);\n                    }\n                }\n            }\n            if (keepMarks) {\n                ensureMarks(state, editor.extensionManager.splittableMarks);\n            }\n            tr.scrollIntoView();\n        }\n        return can;\n    };\n// src/commands/splitListItem.ts\n\n\n\nvar splitListItem = (typeOrName, overrideAttrs = {})=>({ tr, state, dispatch, editor })=>{\n        var _a;\n        const type = getNodeType(typeOrName, state.schema);\n        const { $from, $to } = state.selection;\n        const node = state.selection.node;\n        if (node && node.isBlock || $from.depth < 2 || !$from.sameParent($to)) {\n            return false;\n        }\n        const grandParent = $from.node(-1);\n        if (grandParent.type !== type) {\n            return false;\n        }\n        const extensionAttributes = editor.extensionManager.attributes;\n        if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {\n            if ($from.depth === 2 || $from.node(-3).type !== type || $from.index(-2) !== $from.node(-2).childCount - 1) {\n                return false;\n            }\n            if (dispatch) {\n                let wrap = _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Fragment.empty;\n                const depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;\n                for(let d = $from.depth - depthBefore; d >= $from.depth - 3; d -= 1){\n                    wrap = _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Fragment.from($from.node(d).copy(wrap));\n                }\n                const depthAfter = // eslint-disable-next-line no-nested-ternary\n                $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;\n                const newNextTypeAttributes2 = {\n                    ...getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs),\n                    ...overrideAttrs\n                };\n                const nextType2 = ((_a = type.contentMatch.defaultType) == null ? void 0 : _a.createAndFill(newNextTypeAttributes2)) || void 0;\n                wrap = wrap.append(_tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Fragment.from(type.createAndFill(null, nextType2) || void 0));\n                const start = $from.before($from.depth - (depthBefore - 1));\n                tr.replace(start, $from.after(-depthAfter), new _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Slice(wrap, 4 - depthBefore, 0));\n                let sel = -1;\n                tr.doc.nodesBetween(start, tr.doc.content.size, (n, pos)=>{\n                    if (sel > -1) {\n                        return false;\n                    }\n                    if (n.isTextblock && n.content.size === 0) {\n                        sel = pos + 1;\n                    }\n                });\n                if (sel > -1) {\n                    tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.TextSelection.near(tr.doc.resolve(sel)));\n                }\n                tr.scrollIntoView();\n            }\n            return true;\n        }\n        const nextType = $to.pos === $from.end() ? grandParent.contentMatchAt(0).defaultType : null;\n        const newTypeAttributes = {\n            ...getSplittedAttributes(extensionAttributes, grandParent.type.name, grandParent.attrs),\n            ...overrideAttrs\n        };\n        const newNextTypeAttributes = {\n            ...getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs),\n            ...overrideAttrs\n        };\n        tr.delete($from.pos, $to.pos);\n        const types = nextType ? [\n            {\n                type,\n                attrs: newTypeAttributes\n            },\n            {\n                type: nextType,\n                attrs: newNextTypeAttributes\n            }\n        ] : [\n            {\n                type,\n                attrs: newTypeAttributes\n            }\n        ];\n        if (!(0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit)(tr.doc, $from.pos, 2)) {\n            return false;\n        }\n        if (dispatch) {\n            const { selection, storedMarks } = state;\n            const { splittableMarks } = editor.extensionManager;\n            const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();\n            tr.split($from.pos, 2, types).scrollIntoView();\n            if (!marks || !dispatch) {\n                return true;\n            }\n            const filteredMarks = marks.filter((mark)=>splittableMarks.includes(mark.type.name));\n            tr.ensureMarks(filteredMarks);\n        }\n        return true;\n    };\n// src/commands/toggleList.ts\n\nvar joinListBackwards = (tr, listType)=>{\n    const list = findParentNode((node)=>node.type === listType)(tr.selection);\n    if (!list) {\n        return true;\n    }\n    const before = tr.doc.resolve(Math.max(0, list.pos - 1)).before(list.depth);\n    if (before === void 0) {\n        return true;\n    }\n    const nodeBefore = tr.doc.nodeAt(before);\n    const canJoinBackwards = list.node.type === (nodeBefore == null ? void 0 : nodeBefore.type) && (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(tr.doc, list.pos);\n    if (!canJoinBackwards) {\n        return true;\n    }\n    tr.join(list.pos);\n    return true;\n};\nvar joinListForwards = (tr, listType)=>{\n    const list = findParentNode((node)=>node.type === listType)(tr.selection);\n    if (!list) {\n        return true;\n    }\n    const after = tr.doc.resolve(list.start).after(list.depth);\n    if (after === void 0) {\n        return true;\n    }\n    const nodeAfter = tr.doc.nodeAt(after);\n    const canJoinForwards = list.node.type === (nodeAfter == null ? void 0 : nodeAfter.type) && (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(tr.doc, after);\n    if (!canJoinForwards) {\n        return true;\n    }\n    tr.join(after);\n    return true;\n};\nvar toggleList = (listTypeOrName, itemTypeOrName, keepMarks, attributes = {})=>({ editor, tr, state, dispatch, chain, commands, can })=>{\n        const { extensions, splittableMarks } = editor.extensionManager;\n        const listType = getNodeType(listTypeOrName, state.schema);\n        const itemType = getNodeType(itemTypeOrName, state.schema);\n        const { selection, storedMarks } = state;\n        const { $from, $to } = selection;\n        const range = $from.blockRange($to);\n        const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();\n        if (!range) {\n            return false;\n        }\n        const parentList = findParentNode((node)=>isList(node.type.name, extensions))(selection);\n        if (range.depth >= 1 && parentList && range.depth - parentList.depth <= 1) {\n            if (parentList.node.type === listType) {\n                return commands.liftListItem(itemType);\n            }\n            if (isList(parentList.node.type.name, extensions) && listType.validContent(parentList.node.content) && dispatch) {\n                return chain().command(()=>{\n                    tr.setNodeMarkup(parentList.pos, listType);\n                    return true;\n                }).command(()=>joinListBackwards(tr, listType)).command(()=>joinListForwards(tr, listType)).run();\n            }\n        }\n        if (!keepMarks || !marks || !dispatch) {\n            return chain().command(()=>{\n                const canWrapInList = can().wrapInList(listType, attributes);\n                if (canWrapInList) {\n                    return true;\n                }\n                return commands.clearNodes();\n            }).wrapInList(listType, attributes).command(()=>joinListBackwards(tr, listType)).command(()=>joinListForwards(tr, listType)).run();\n        }\n        return chain().command(()=>{\n            const canWrapInList = can().wrapInList(listType, attributes);\n            const filteredMarks = marks.filter((mark)=>splittableMarks.includes(mark.type.name));\n            tr.ensureMarks(filteredMarks);\n            if (canWrapInList) {\n                return true;\n            }\n            return commands.clearNodes();\n        }).wrapInList(listType, attributes).command(()=>joinListBackwards(tr, listType)).command(()=>joinListForwards(tr, listType)).run();\n    };\n// src/commands/toggleMark.ts\nvar toggleMark = (typeOrName, attributes = {}, options = {})=>({ state, commands })=>{\n        const { extendEmptyMarkRange = false } = options;\n        const type = getMarkType(typeOrName, state.schema);\n        const isActive2 = isMarkActive(state, type, attributes);\n        if (isActive2) {\n            return commands.unsetMark(type, {\n                extendEmptyMarkRange\n            });\n        }\n        return commands.setMark(type, attributes);\n    };\n// src/commands/toggleNode.ts\nvar toggleNode = (typeOrName, toggleTypeOrName, attributes = {})=>({ state, commands })=>{\n        const type = getNodeType(typeOrName, state.schema);\n        const toggleType = getNodeType(toggleTypeOrName, state.schema);\n        const isActive2 = isNodeActive(state, type, attributes);\n        let attributesToCopy;\n        if (state.selection.$anchor.sameParent(state.selection.$head)) {\n            attributesToCopy = state.selection.$anchor.parent.attrs;\n        }\n        if (isActive2) {\n            return commands.setNode(toggleType, attributesToCopy);\n        }\n        return commands.setNode(type, {\n            ...attributesToCopy,\n            ...attributes\n        });\n    };\n// src/commands/toggleWrap.ts\nvar toggleWrap = (typeOrName, attributes = {})=>({ state, commands })=>{\n        const type = getNodeType(typeOrName, state.schema);\n        const isActive2 = isNodeActive(state, type, attributes);\n        if (isActive2) {\n            return commands.lift(type);\n        }\n        return commands.wrapIn(type, attributes);\n    };\n// src/commands/undoInputRule.ts\nvar undoInputRule = ()=>({ state, dispatch })=>{\n        const plugins = state.plugins;\n        for(let i = 0; i < plugins.length; i += 1){\n            const plugin = plugins[i];\n            let undoable;\n            if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {\n                if (dispatch) {\n                    const tr = state.tr;\n                    const toUndo = undoable.transform;\n                    for(let j = toUndo.steps.length - 1; j >= 0; j -= 1){\n                        tr.step(toUndo.steps[j].invert(toUndo.docs[j]));\n                    }\n                    if (undoable.text) {\n                        const marks = tr.doc.resolve(undoable.from).marks();\n                        tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));\n                    } else {\n                        tr.delete(undoable.from, undoable.to);\n                    }\n                }\n                return true;\n            }\n        }\n        return false;\n    };\n// src/commands/unsetAllMarks.ts\nvar unsetAllMarks = ()=>({ tr, dispatch })=>{\n        const { selection } = tr;\n        const { empty, ranges } = selection;\n        if (empty) {\n            return true;\n        }\n        if (dispatch) {\n            ranges.forEach((range)=>{\n                tr.removeMark(range.$from.pos, range.$to.pos);\n            });\n        }\n        return true;\n    };\n// src/commands/unsetMark.ts\nvar unsetMark = (typeOrName, options = {})=>({ tr, state, dispatch })=>{\n        var _a;\n        const { extendEmptyMarkRange = false } = options;\n        const { selection } = tr;\n        const type = getMarkType(typeOrName, state.schema);\n        const { $from, empty, ranges } = selection;\n        if (!dispatch) {\n            return true;\n        }\n        if (empty && extendEmptyMarkRange) {\n            let { from, to } = selection;\n            const attrs = (_a = $from.marks().find((mark)=>mark.type === type)) == null ? void 0 : _a.attrs;\n            const range = getMarkRange($from, type, attrs);\n            if (range) {\n                from = range.from;\n                to = range.to;\n            }\n            tr.removeMark(from, to, type);\n        } else {\n            ranges.forEach((range)=>{\n                tr.removeMark(range.$from.pos, range.$to.pos, type);\n            });\n        }\n        tr.removeStoredMark(type);\n        return true;\n    };\n// src/commands/unsetTextDirection.ts\nvar unsetTextDirection = (position)=>({ tr, state, dispatch })=>{\n        const { selection } = state;\n        let from;\n        let to;\n        if (typeof position === \"number\") {\n            from = position;\n            to = position;\n        } else if (position && \"from\" in position && \"to\" in position) {\n            from = position.from;\n            to = position.to;\n        } else {\n            from = selection.from;\n            to = selection.to;\n        }\n        if (dispatch) {\n            tr.doc.nodesBetween(from, to, (node, pos)=>{\n                if (node.isText) {\n                    return;\n                }\n                const newAttrs = {\n                    ...node.attrs\n                };\n                delete newAttrs.dir;\n                tr.setNodeMarkup(pos, void 0, newAttrs);\n            });\n        }\n        return true;\n    };\n// src/commands/updateAttributes.ts\nvar updateAttributes = (typeOrName, attributes = {})=>({ tr, state, dispatch })=>{\n        let nodeType = null;\n        let markType = null;\n        const schemaType = getSchemaTypeNameByName(typeof typeOrName === \"string\" ? typeOrName : typeOrName.name, state.schema);\n        if (!schemaType) {\n            return false;\n        }\n        if (schemaType === \"node\") {\n            nodeType = getNodeType(typeOrName, state.schema);\n        }\n        if (schemaType === \"mark\") {\n            markType = getMarkType(typeOrName, state.schema);\n        }\n        let canUpdate = false;\n        tr.selection.ranges.forEach((range)=>{\n            const from = range.$from.pos;\n            const to = range.$to.pos;\n            let lastPos;\n            let lastNode;\n            let trimmedFrom;\n            let trimmedTo;\n            if (tr.selection.empty) {\n                state.doc.nodesBetween(from, to, (node, pos)=>{\n                    if (nodeType && nodeType === node.type) {\n                        canUpdate = true;\n                        trimmedFrom = Math.max(pos, from);\n                        trimmedTo = Math.min(pos + node.nodeSize, to);\n                        lastPos = pos;\n                        lastNode = node;\n                    }\n                });\n            } else {\n                state.doc.nodesBetween(from, to, (node, pos)=>{\n                    if (pos < from && nodeType && nodeType === node.type) {\n                        canUpdate = true;\n                        trimmedFrom = Math.max(pos, from);\n                        trimmedTo = Math.min(pos + node.nodeSize, to);\n                        lastPos = pos;\n                        lastNode = node;\n                    }\n                    if (pos >= from && pos <= to) {\n                        if (nodeType && nodeType === node.type) {\n                            canUpdate = true;\n                            if (dispatch) {\n                                tr.setNodeMarkup(pos, void 0, {\n                                    ...node.attrs,\n                                    ...attributes\n                                });\n                            }\n                        }\n                        if (markType && node.marks.length) {\n                            node.marks.forEach((mark)=>{\n                                if (markType === mark.type) {\n                                    canUpdate = true;\n                                    if (dispatch) {\n                                        const trimmedFrom2 = Math.max(pos, from);\n                                        const trimmedTo2 = Math.min(pos + node.nodeSize, to);\n                                        tr.addMark(trimmedFrom2, trimmedTo2, markType.create({\n                                            ...mark.attrs,\n                                            ...attributes\n                                        }));\n                                    }\n                                }\n                            });\n                        }\n                    }\n                });\n            }\n            if (lastNode) {\n                if (lastPos !== void 0 && dispatch) {\n                    tr.setNodeMarkup(lastPos, void 0, {\n                        ...lastNode.attrs,\n                        ...attributes\n                    });\n                }\n                if (markType && lastNode.marks.length) {\n                    lastNode.marks.forEach((mark)=>{\n                        if (markType === mark.type && dispatch) {\n                            tr.addMark(trimmedFrom, trimmedTo, markType.create({\n                                ...mark.attrs,\n                                ...attributes\n                            }));\n                        }\n                    });\n                }\n            }\n        });\n        return canUpdate;\n    };\n// src/commands/wrapIn.ts\n\nvar wrapIn = (typeOrName, attributes = {})=>({ state, dispatch })=>{\n        const type = getNodeType(typeOrName, state.schema);\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_1__.wrapIn)(type, attributes)(state, dispatch);\n    };\n// src/commands/wrapInList.ts\n\nvar wrapInList = (typeOrName, attributes = {})=>({ state, dispatch })=>{\n        const type = getNodeType(typeOrName, state.schema);\n        return (0,_tiptap_pm_schema_list__WEBPACK_IMPORTED_MODULE_4__.wrapInList)(type, attributes)(state, dispatch);\n    };\n// src/Editor.ts\n\n\n// src/EventEmitter.ts\nvar EventEmitter = class {\n    constructor(){\n        this.callbacks = {};\n    }\n    on(event, fn) {\n        if (!this.callbacks[event]) {\n            this.callbacks[event] = [];\n        }\n        this.callbacks[event].push(fn);\n        return this;\n    }\n    emit(event, ...args) {\n        const callbacks = this.callbacks[event];\n        if (callbacks) {\n            callbacks.forEach((callback)=>callback.apply(this, args));\n        }\n        return this;\n    }\n    off(event, fn) {\n        const callbacks = this.callbacks[event];\n        if (callbacks) {\n            if (fn) {\n                this.callbacks[event] = callbacks.filter((callback)=>callback !== fn);\n            } else {\n                delete this.callbacks[event];\n            }\n        }\n        return this;\n    }\n    once(event, fn) {\n        const onceFn = (...args)=>{\n            this.off(event, onceFn);\n            fn.apply(this, args);\n        };\n        return this.on(event, onceFn);\n    }\n    removeAllListeners() {\n        this.callbacks = {};\n    }\n};\n// src/ExtensionManager.ts\n\n// src/InputRule.ts\n\n\nvar InputRule = class {\n    constructor(config){\n        var _a;\n        this.find = config.find;\n        this.handler = config.handler;\n        this.undoable = (_a = config.undoable) != null ? _a : true;\n    }\n};\nvar inputRuleMatcherHandler = (text, find)=>{\n    if (isRegExp(find)) {\n        return find.exec(text);\n    }\n    const inputRuleMatch = find(text);\n    if (!inputRuleMatch) {\n        return null;\n    }\n    const result = [\n        inputRuleMatch.text\n    ];\n    result.index = inputRuleMatch.index;\n    result.input = text;\n    result.data = inputRuleMatch.data;\n    if (inputRuleMatch.replaceWith) {\n        if (!inputRuleMatch.text.includes(inputRuleMatch.replaceWith)) {\n            console.warn('[tiptap warn]: \"inputRuleMatch.replaceWith\" must be part of \"inputRuleMatch.text\".');\n        }\n        result.push(inputRuleMatch.replaceWith);\n    }\n    return result;\n};\nfunction run(config) {\n    var _a;\n    const { editor, from, to, text, rules, plugin } = config;\n    const { view } = editor;\n    if (view.composing) {\n        return false;\n    }\n    const $from = view.state.doc.resolve(from);\n    if (// check for code node\n    $from.parent.type.spec.code || // check for code mark\n    !!((_a = $from.nodeBefore || $from.nodeAfter) == null ? void 0 : _a.marks.find((mark)=>mark.type.spec.code))) {\n        return false;\n    }\n    let matched = false;\n    const textBefore = getTextContentFromNodes($from) + text;\n    rules.forEach((rule)=>{\n        if (matched) {\n            return;\n        }\n        const match = inputRuleMatcherHandler(textBefore, rule.find);\n        if (!match) {\n            return;\n        }\n        const tr = view.state.tr;\n        const state = createChainableState({\n            state: view.state,\n            transaction: tr\n        });\n        const range = {\n            from: from - (match[0].length - text.length),\n            to\n        };\n        const { commands, chain, can } = new CommandManager({\n            editor,\n            state\n        });\n        const handler = rule.handler({\n            state,\n            range,\n            match,\n            commands,\n            chain,\n            can\n        });\n        if (handler === null || !tr.steps.length) {\n            return;\n        }\n        if (rule.undoable) {\n            tr.setMeta(plugin, {\n                transform: tr,\n                from,\n                to,\n                text\n            });\n        }\n        view.dispatch(tr);\n        matched = true;\n    });\n    return matched;\n}\nfunction inputRulesPlugin(props) {\n    const { editor, rules } = props;\n    const plugin = new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.Plugin({\n        state: {\n            init () {\n                return null;\n            },\n            apply (tr, prev, state) {\n                const stored = tr.getMeta(plugin);\n                if (stored) {\n                    return stored;\n                }\n                const simulatedInputMeta = tr.getMeta(\"applyInputRules\");\n                const isSimulatedInput = !!simulatedInputMeta;\n                if (isSimulatedInput) {\n                    setTimeout(()=>{\n                        let { text } = simulatedInputMeta;\n                        if (typeof text === \"string\") {\n                            text = text;\n                        } else {\n                            text = getHTMLFromFragment(_tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Fragment.from(text), state.schema);\n                        }\n                        const { from } = simulatedInputMeta;\n                        const to = from + text.length;\n                        run({\n                            editor,\n                            from,\n                            to,\n                            text,\n                            rules,\n                            plugin\n                        });\n                    });\n                }\n                return tr.selectionSet || tr.docChanged ? null : prev;\n            }\n        },\n        props: {\n            handleTextInput (view, from, to, text) {\n                return run({\n                    editor,\n                    from,\n                    to,\n                    text,\n                    rules,\n                    plugin\n                });\n            },\n            handleDOMEvents: {\n                compositionend: (view)=>{\n                    setTimeout(()=>{\n                        const { $cursor } = view.state.selection;\n                        if ($cursor) {\n                            run({\n                                editor,\n                                from: $cursor.pos,\n                                to: $cursor.pos,\n                                text: \"\",\n                                rules,\n                                plugin\n                            });\n                        }\n                    });\n                    return false;\n                }\n            },\n            // add support for input rules to trigger on enter\n            // this is useful for example for code blocks\n            handleKeyDown (view, event) {\n                if (event.key !== \"Enter\") {\n                    return false;\n                }\n                const { $cursor } = view.state.selection;\n                if ($cursor) {\n                    return run({\n                        editor,\n                        from: $cursor.pos,\n                        to: $cursor.pos,\n                        text: \"\\n\",\n                        rules,\n                        plugin\n                    });\n                }\n                return false;\n            }\n        },\n        // @ts-ignore\n        isInputRules: true\n    });\n    return plugin;\n}\n// src/utilities/isPlainObject.ts\nfunction getType(value) {\n    return Object.prototype.toString.call(value).slice(8, -1);\n}\nfunction isPlainObject(value) {\n    if (getType(value) !== \"Object\") {\n        return false;\n    }\n    return value.constructor === Object && Object.getPrototypeOf(value) === Object.prototype;\n}\n// src/utilities/mergeDeep.ts\nfunction mergeDeep(target, source) {\n    const output = {\n        ...target\n    };\n    if (isPlainObject(target) && isPlainObject(source)) {\n        Object.keys(source).forEach((key)=>{\n            if (isPlainObject(source[key]) && isPlainObject(target[key])) {\n                output[key] = mergeDeep(target[key], source[key]);\n            } else {\n                output[key] = source[key];\n            }\n        });\n    }\n    return output;\n}\n// src/Extendable.ts\nvar Extendable = class {\n    constructor(config = {}){\n        this.type = \"extendable\";\n        this.parent = null;\n        this.child = null;\n        this.name = \"\";\n        this.config = {\n            name: this.name\n        };\n        this.config = {\n            ...this.config,\n            ...config\n        };\n        this.name = this.config.name;\n    }\n    get options() {\n        return {\n            ...callOrReturn(getExtensionField(this, \"addOptions\", {\n                name: this.name\n            })) || {}\n        };\n    }\n    get storage() {\n        return {\n            ...callOrReturn(getExtensionField(this, \"addStorage\", {\n                name: this.name,\n                options: this.options\n            })) || {}\n        };\n    }\n    configure(options = {}) {\n        const extension = this.extend({\n            ...this.config,\n            addOptions: ()=>{\n                return mergeDeep(this.options, options);\n            }\n        });\n        extension.name = this.name;\n        extension.parent = this.parent;\n        return extension;\n    }\n    extend(extendedConfig = {}) {\n        const extension = new this.constructor({\n            ...this.config,\n            ...extendedConfig\n        });\n        extension.parent = this;\n        this.child = extension;\n        extension.name = \"name\" in extendedConfig ? extendedConfig.name : extension.parent.name;\n        return extension;\n    }\n};\n// src/Mark.ts\nvar Mark = class _Mark extends Extendable {\n    constructor(){\n        super(...arguments);\n        this.type = \"mark\";\n    }\n    /**\n   * Create a new Mark instance\n   * @param config - Mark configuration object or a function that returns a configuration object\n   */ static create(config = {}) {\n        const resolvedConfig = typeof config === \"function\" ? config() : config;\n        return new _Mark(resolvedConfig);\n    }\n    static handleExit({ editor, mark }) {\n        const { tr } = editor.state;\n        const currentPos = editor.state.selection.$from;\n        const isAtEnd = currentPos.pos === currentPos.end();\n        if (isAtEnd) {\n            const currentMarks = currentPos.marks();\n            const isInMark = !!currentMarks.find((m)=>(m == null ? void 0 : m.type.name) === mark.name);\n            if (!isInMark) {\n                return false;\n            }\n            const removeMark = currentMarks.find((m)=>(m == null ? void 0 : m.type.name) === mark.name);\n            if (removeMark) {\n                tr.removeStoredMark(removeMark);\n            }\n            tr.insertText(\" \", currentPos.pos);\n            editor.view.dispatch(tr);\n            return true;\n        }\n        return false;\n    }\n    configure(options) {\n        return super.configure(options);\n    }\n    extend(extendedConfig) {\n        const resolvedConfig = typeof extendedConfig === \"function\" ? extendedConfig() : extendedConfig;\n        return super.extend(resolvedConfig);\n    }\n};\n// src/PasteRule.ts\n\n\n// src/utilities/isNumber.ts\nfunction isNumber(value) {\n    return typeof value === \"number\";\n}\n// src/PasteRule.ts\nvar PasteRule = class {\n    constructor(config){\n        this.find = config.find;\n        this.handler = config.handler;\n    }\n};\nvar pasteRuleMatcherHandler = (text, find, event)=>{\n    if (isRegExp(find)) {\n        return [\n            ...text.matchAll(find)\n        ];\n    }\n    const matches = find(text, event);\n    if (!matches) {\n        return [];\n    }\n    return matches.map((pasteRuleMatch)=>{\n        const result = [\n            pasteRuleMatch.text\n        ];\n        result.index = pasteRuleMatch.index;\n        result.input = text;\n        result.data = pasteRuleMatch.data;\n        if (pasteRuleMatch.replaceWith) {\n            if (!pasteRuleMatch.text.includes(pasteRuleMatch.replaceWith)) {\n                console.warn('[tiptap warn]: \"pasteRuleMatch.replaceWith\" must be part of \"pasteRuleMatch.text\".');\n            }\n            result.push(pasteRuleMatch.replaceWith);\n        }\n        return result;\n    });\n};\nfunction run2(config) {\n    const { editor, state, from, to, rule, pasteEvent, dropEvent } = config;\n    const { commands, chain, can } = new CommandManager({\n        editor,\n        state\n    });\n    const handlers = [];\n    state.doc.nodesBetween(from, to, (node, pos)=>{\n        var _a, _b, _c, _d, _e;\n        if (((_b = (_a = node.type) == null ? void 0 : _a.spec) == null ? void 0 : _b.code) || !(node.isText || node.isTextblock || node.isInline)) {\n            return;\n        }\n        const contentSize = (_e = (_d = (_c = node.content) == null ? void 0 : _c.size) != null ? _d : node.nodeSize) != null ? _e : 0;\n        const resolvedFrom = Math.max(from, pos);\n        const resolvedTo = Math.min(to, pos + contentSize);\n        if (resolvedFrom >= resolvedTo) {\n            return;\n        }\n        const textToMatch = node.isText ? node.text || \"\" : node.textBetween(resolvedFrom - pos, resolvedTo - pos, void 0, \"\");\n        const matches = pasteRuleMatcherHandler(textToMatch, rule.find, pasteEvent);\n        matches.forEach((match)=>{\n            if (match.index === void 0) {\n                return;\n            }\n            const start = resolvedFrom + match.index + 1;\n            const end = start + match[0].length;\n            const range = {\n                from: state.tr.mapping.map(start),\n                to: state.tr.mapping.map(end)\n            };\n            const handler = rule.handler({\n                state,\n                range,\n                match,\n                commands,\n                chain,\n                can,\n                pasteEvent,\n                dropEvent\n            });\n            handlers.push(handler);\n        });\n    });\n    const success = handlers.every((handler)=>handler !== null);\n    return success;\n}\nvar tiptapDragFromOtherEditor = null;\nvar createClipboardPasteEvent = (text)=>{\n    var _a;\n    const event = new ClipboardEvent(\"paste\", {\n        clipboardData: new DataTransfer()\n    });\n    (_a = event.clipboardData) == null ? void 0 : _a.setData(\"text/html\", text);\n    return event;\n};\nfunction pasteRulesPlugin(props) {\n    const { editor, rules } = props;\n    let dragSourceElement = null;\n    let isPastedFromProseMirror = false;\n    let isDroppedFromProseMirror = false;\n    let pasteEvent = typeof ClipboardEvent !== \"undefined\" ? new ClipboardEvent(\"paste\") : null;\n    let dropEvent;\n    try {\n        dropEvent = typeof DragEvent !== \"undefined\" ? new DragEvent(\"drop\") : null;\n    } catch  {\n        dropEvent = null;\n    }\n    const processEvent = ({ state, from, to, rule, pasteEvt })=>{\n        const tr = state.tr;\n        const chainableState = createChainableState({\n            state,\n            transaction: tr\n        });\n        const handler = run2({\n            editor,\n            state: chainableState,\n            from: Math.max(from - 1, 0),\n            to: to.b - 1,\n            rule,\n            pasteEvent: pasteEvt,\n            dropEvent\n        });\n        if (!handler || !tr.steps.length) {\n            return;\n        }\n        try {\n            dropEvent = typeof DragEvent !== \"undefined\" ? new DragEvent(\"drop\") : null;\n        } catch  {\n            dropEvent = null;\n        }\n        pasteEvent = typeof ClipboardEvent !== \"undefined\" ? new ClipboardEvent(\"paste\") : null;\n        return tr;\n    };\n    const plugins = rules.map((rule)=>{\n        return new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.Plugin({\n            // we register a global drag handler to track the current drag source element\n            view (view) {\n                const handleDragstart = (event)=>{\n                    var _a;\n                    dragSourceElement = ((_a = view.dom.parentElement) == null ? void 0 : _a.contains(event.target)) ? view.dom.parentElement : null;\n                    if (dragSourceElement) {\n                        tiptapDragFromOtherEditor = editor;\n                    }\n                };\n                const handleDragend = ()=>{\n                    if (tiptapDragFromOtherEditor) {\n                        tiptapDragFromOtherEditor = null;\n                    }\n                };\n                window.addEventListener(\"dragstart\", handleDragstart);\n                window.addEventListener(\"dragend\", handleDragend);\n                return {\n                    destroy () {\n                        window.removeEventListener(\"dragstart\", handleDragstart);\n                        window.removeEventListener(\"dragend\", handleDragend);\n                    }\n                };\n            },\n            props: {\n                handleDOMEvents: {\n                    drop: (view, event)=>{\n                        isDroppedFromProseMirror = dragSourceElement === view.dom.parentElement;\n                        dropEvent = event;\n                        if (!isDroppedFromProseMirror) {\n                            const dragFromOtherEditor = tiptapDragFromOtherEditor;\n                            if (dragFromOtherEditor == null ? void 0 : dragFromOtherEditor.isEditable) {\n                                setTimeout(()=>{\n                                    const selection = dragFromOtherEditor.state.selection;\n                                    if (selection) {\n                                        dragFromOtherEditor.commands.deleteRange({\n                                            from: selection.from,\n                                            to: selection.to\n                                        });\n                                    }\n                                }, 10);\n                            }\n                        }\n                        return false;\n                    },\n                    paste: (_view, event)=>{\n                        var _a;\n                        const html = (_a = event.clipboardData) == null ? void 0 : _a.getData(\"text/html\");\n                        pasteEvent = event;\n                        isPastedFromProseMirror = !!(html == null ? void 0 : html.includes(\"data-pm-slice\"));\n                        return false;\n                    }\n                }\n            },\n            appendTransaction: (transactions, oldState, state)=>{\n                const transaction = transactions[0];\n                const isPaste = transaction.getMeta(\"uiEvent\") === \"paste\" && !isPastedFromProseMirror;\n                const isDrop = transaction.getMeta(\"uiEvent\") === \"drop\" && !isDroppedFromProseMirror;\n                const simulatedPasteMeta = transaction.getMeta(\"applyPasteRules\");\n                const isSimulatedPaste = !!simulatedPasteMeta;\n                if (!isPaste && !isDrop && !isSimulatedPaste) {\n                    return;\n                }\n                if (isSimulatedPaste) {\n                    let { text } = simulatedPasteMeta;\n                    if (typeof text === \"string\") {\n                        text = text;\n                    } else {\n                        text = getHTMLFromFragment(_tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Fragment.from(text), state.schema);\n                    }\n                    const { from: from2 } = simulatedPasteMeta;\n                    const to2 = from2 + text.length;\n                    const pasteEvt = createClipboardPasteEvent(text);\n                    return processEvent({\n                        rule,\n                        state,\n                        from: from2,\n                        to: {\n                            b: to2\n                        },\n                        pasteEvt\n                    });\n                }\n                const from = oldState.doc.content.findDiffStart(state.doc.content);\n                const to = oldState.doc.content.findDiffEnd(state.doc.content);\n                if (!isNumber(from) || !to || from === to.b) {\n                    return;\n                }\n                return processEvent({\n                    rule,\n                    state,\n                    from,\n                    to,\n                    pasteEvt: pasteEvent\n                });\n            }\n        });\n    });\n    return plugins;\n}\n// src/ExtensionManager.ts\nvar ExtensionManager = class {\n    constructor(extensions, editor){\n        this.splittableMarks = [];\n        this.editor = editor;\n        this.baseExtensions = extensions;\n        this.extensions = resolveExtensions(extensions);\n        this.schema = getSchemaByResolvedExtensions(this.extensions, editor);\n        this.setupExtensions();\n    }\n    /**\n   * Get all commands from the extensions.\n   * @returns An object with all commands where the key is the command name and the value is the command function\n   */ get commands() {\n        return this.extensions.reduce((commands, extension)=>{\n            const context = {\n                name: extension.name,\n                options: extension.options,\n                storage: this.editor.extensionStorage[extension.name],\n                editor: this.editor,\n                type: getSchemaTypeByName(extension.name, this.schema)\n            };\n            const addCommands = getExtensionField(extension, \"addCommands\", context);\n            if (!addCommands) {\n                return commands;\n            }\n            return {\n                ...commands,\n                ...addCommands()\n            };\n        }, {});\n    }\n    /**\n   * Get all registered Prosemirror plugins from the extensions.\n   * @returns An array of Prosemirror plugins\n   */ get plugins() {\n        const { editor } = this;\n        const extensions = sortExtensions([\n            ...this.extensions\n        ].reverse());\n        const allPlugins = extensions.flatMap((extension)=>{\n            const context = {\n                name: extension.name,\n                options: extension.options,\n                storage: this.editor.extensionStorage[extension.name],\n                editor,\n                type: getSchemaTypeByName(extension.name, this.schema)\n            };\n            const plugins = [];\n            const addKeyboardShortcuts = getExtensionField(extension, \"addKeyboardShortcuts\", context);\n            let defaultBindings = {};\n            if (extension.type === \"mark\" && getExtensionField(extension, \"exitable\", context)) {\n                defaultBindings.ArrowRight = ()=>Mark.handleExit({\n                        editor,\n                        mark: extension\n                    });\n            }\n            if (addKeyboardShortcuts) {\n                const bindings = Object.fromEntries(Object.entries(addKeyboardShortcuts()).map(([shortcut, method])=>{\n                    return [\n                        shortcut,\n                        ()=>method({\n                                editor\n                            })\n                    ];\n                }));\n                defaultBindings = {\n                    ...defaultBindings,\n                    ...bindings\n                };\n            }\n            const keyMapPlugin = (0,_tiptap_pm_keymap__WEBPACK_IMPORTED_MODULE_6__.keymap)(defaultBindings);\n            plugins.push(keyMapPlugin);\n            const addInputRules = getExtensionField(extension, \"addInputRules\", context);\n            if (isExtensionRulesEnabled(extension, editor.options.enableInputRules) && addInputRules) {\n                const rules = addInputRules();\n                if (rules && rules.length) {\n                    const inputResult = inputRulesPlugin({\n                        editor,\n                        rules\n                    });\n                    const inputPlugins = Array.isArray(inputResult) ? inputResult : [\n                        inputResult\n                    ];\n                    plugins.push(...inputPlugins);\n                }\n            }\n            const addPasteRules = getExtensionField(extension, \"addPasteRules\", context);\n            if (isExtensionRulesEnabled(extension, editor.options.enablePasteRules) && addPasteRules) {\n                const rules = addPasteRules();\n                if (rules && rules.length) {\n                    const pasteRules = pasteRulesPlugin({\n                        editor,\n                        rules\n                    });\n                    plugins.push(...pasteRules);\n                }\n            }\n            const addProseMirrorPlugins = getExtensionField(extension, \"addProseMirrorPlugins\", context);\n            if (addProseMirrorPlugins) {\n                const proseMirrorPlugins = addProseMirrorPlugins();\n                plugins.push(...proseMirrorPlugins);\n            }\n            return plugins;\n        });\n        return allPlugins;\n    }\n    /**\n   * Get all attributes from the extensions.\n   * @returns An array of attributes\n   */ get attributes() {\n        return getAttributesFromExtensions(this.extensions);\n    }\n    /**\n   * Get all node views from the extensions.\n   * @returns An object with all node views where the key is the node name and the value is the node view function\n   */ get nodeViews() {\n        const { editor } = this;\n        const { nodeExtensions } = splitExtensions(this.extensions);\n        return Object.fromEntries(nodeExtensions.filter((extension)=>!!getExtensionField(extension, \"addNodeView\")).map((extension)=>{\n            const extensionAttributes = this.attributes.filter((attribute)=>attribute.type === extension.name);\n            const context = {\n                name: extension.name,\n                options: extension.options,\n                storage: this.editor.extensionStorage[extension.name],\n                editor,\n                type: getNodeType(extension.name, this.schema)\n            };\n            const addNodeView = getExtensionField(extension, \"addNodeView\", context);\n            if (!addNodeView) {\n                return [];\n            }\n            const nodeViewResult = addNodeView();\n            if (!nodeViewResult) {\n                return [];\n            }\n            const nodeview = (node, view, getPos, decorations, innerDecorations)=>{\n                const HTMLAttributes = getRenderedAttributes(node, extensionAttributes);\n                return nodeViewResult({\n                    // pass-through\n                    node,\n                    view,\n                    getPos,\n                    decorations,\n                    innerDecorations,\n                    // tiptap-specific\n                    editor,\n                    extension,\n                    HTMLAttributes\n                });\n            };\n            return [\n                extension.name,\n                nodeview\n            ];\n        }));\n    }\n    get markViews() {\n        const { editor } = this;\n        const { markExtensions } = splitExtensions(this.extensions);\n        return Object.fromEntries(markExtensions.filter((extension)=>!!getExtensionField(extension, \"addMarkView\")).map((extension)=>{\n            const extensionAttributes = this.attributes.filter((attribute)=>attribute.type === extension.name);\n            const context = {\n                name: extension.name,\n                options: extension.options,\n                storage: this.editor.extensionStorage[extension.name],\n                editor,\n                type: getMarkType(extension.name, this.schema)\n            };\n            const addMarkView = getExtensionField(extension, \"addMarkView\", context);\n            if (!addMarkView) {\n                return [];\n            }\n            const markView = (mark, view, inline)=>{\n                const HTMLAttributes = getRenderedAttributes(mark, extensionAttributes);\n                return addMarkView()({\n                    // pass-through\n                    mark,\n                    view,\n                    inline,\n                    // tiptap-specific\n                    editor,\n                    extension,\n                    HTMLAttributes,\n                    updateAttributes: (attrs)=>{\n                        updateMarkViewAttributes(mark, editor, attrs);\n                    }\n                });\n            };\n            return [\n                extension.name,\n                markView\n            ];\n        }));\n    }\n    /**\n   * Go through all extensions, create extension storages & setup marks\n   * & bind editor event listener.\n   */ setupExtensions() {\n        const extensions = this.extensions;\n        this.editor.extensionStorage = Object.fromEntries(extensions.map((extension)=>[\n                extension.name,\n                extension.storage\n            ]));\n        extensions.forEach((extension)=>{\n            var _a;\n            const context = {\n                name: extension.name,\n                options: extension.options,\n                storage: this.editor.extensionStorage[extension.name],\n                editor: this.editor,\n                type: getSchemaTypeByName(extension.name, this.schema)\n            };\n            if (extension.type === \"mark\") {\n                const keepOnSplit = (_a = callOrReturn(getExtensionField(extension, \"keepOnSplit\", context))) != null ? _a : true;\n                if (keepOnSplit) {\n                    this.splittableMarks.push(extension.name);\n                }\n            }\n            const onBeforeCreate = getExtensionField(extension, \"onBeforeCreate\", context);\n            const onCreate = getExtensionField(extension, \"onCreate\", context);\n            const onUpdate = getExtensionField(extension, \"onUpdate\", context);\n            const onSelectionUpdate = getExtensionField(extension, \"onSelectionUpdate\", context);\n            const onTransaction = getExtensionField(extension, \"onTransaction\", context);\n            const onFocus = getExtensionField(extension, \"onFocus\", context);\n            const onBlur = getExtensionField(extension, \"onBlur\", context);\n            const onDestroy = getExtensionField(extension, \"onDestroy\", context);\n            if (onBeforeCreate) {\n                this.editor.on(\"beforeCreate\", onBeforeCreate);\n            }\n            if (onCreate) {\n                this.editor.on(\"create\", onCreate);\n            }\n            if (onUpdate) {\n                this.editor.on(\"update\", onUpdate);\n            }\n            if (onSelectionUpdate) {\n                this.editor.on(\"selectionUpdate\", onSelectionUpdate);\n            }\n            if (onTransaction) {\n                this.editor.on(\"transaction\", onTransaction);\n            }\n            if (onFocus) {\n                this.editor.on(\"focus\", onFocus);\n            }\n            if (onBlur) {\n                this.editor.on(\"blur\", onBlur);\n            }\n            if (onDestroy) {\n                this.editor.on(\"destroy\", onDestroy);\n            }\n        });\n    }\n};\nExtensionManager.resolve = resolveExtensions;\nExtensionManager.sort = sortExtensions;\nExtensionManager.flatten = flattenExtensions;\n// src/extensions/index.ts\nvar extensions_exports = {};\n__export(extensions_exports, {\n    ClipboardTextSerializer: ()=>ClipboardTextSerializer,\n    Commands: ()=>Commands,\n    Delete: ()=>Delete,\n    Drop: ()=>Drop,\n    Editable: ()=>Editable,\n    FocusEvents: ()=>FocusEvents,\n    Keymap: ()=>Keymap,\n    Paste: ()=>Paste,\n    Tabindex: ()=>Tabindex,\n    TextDirection: ()=>TextDirection,\n    focusEventsPluginKey: ()=>focusEventsPluginKey\n});\n// src/extensions/clipboardTextSerializer.ts\n\n// src/Extension.ts\nvar Extension = class _Extension extends Extendable {\n    constructor(){\n        super(...arguments);\n        this.type = \"extension\";\n    }\n    /**\n   * Create a new Extension instance\n   * @param config - Extension configuration object or a function that returns a configuration object\n   */ static create(config = {}) {\n        const resolvedConfig = typeof config === \"function\" ? config() : config;\n        return new _Extension(resolvedConfig);\n    }\n    configure(options) {\n        return super.configure(options);\n    }\n    extend(extendedConfig) {\n        const resolvedConfig = typeof extendedConfig === \"function\" ? extendedConfig() : extendedConfig;\n        return super.extend(resolvedConfig);\n    }\n};\n// src/extensions/clipboardTextSerializer.ts\nvar ClipboardTextSerializer = Extension.create({\n    name: \"clipboardTextSerializer\",\n    addOptions () {\n        return {\n            blockSeparator: void 0\n        };\n    },\n    addProseMirrorPlugins () {\n        return [\n            new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.Plugin({\n                key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.PluginKey(\"clipboardTextSerializer\"),\n                props: {\n                    clipboardTextSerializer: ()=>{\n                        const { editor } = this;\n                        const { state, schema } = editor;\n                        const { doc, selection } = state;\n                        const { ranges } = selection;\n                        const from = Math.min(...ranges.map((range2)=>range2.$from.pos));\n                        const to = Math.max(...ranges.map((range2)=>range2.$to.pos));\n                        const textSerializers = getTextSerializersFromSchema(schema);\n                        const range = {\n                            from,\n                            to\n                        };\n                        return getTextBetween(doc, range, {\n                            ...this.options.blockSeparator !== void 0 ? {\n                                blockSeparator: this.options.blockSeparator\n                            } : {},\n                            textSerializers\n                        });\n                    }\n                }\n            })\n        ];\n    }\n});\n// src/extensions/commands.ts\nvar Commands = Extension.create({\n    name: \"commands\",\n    addCommands () {\n        return {\n            ...commands_exports\n        };\n    }\n});\n// src/extensions/delete.ts\n\nvar Delete = Extension.create({\n    name: \"delete\",\n    onUpdate ({ transaction, appendedTransactions }) {\n        var _a, _b, _c;\n        const callback = ()=>{\n            var _a2, _b2, _c2, _d;\n            if ((_d = (_c2 = (_b2 = (_a2 = this.editor.options.coreExtensionOptions) == null ? void 0 : _a2.delete) == null ? void 0 : _b2.filterTransaction) == null ? void 0 : _c2.call(_b2, transaction)) != null ? _d : transaction.getMeta(\"y-sync$\")) {\n                return;\n            }\n            const nextTransaction = combineTransactionSteps(transaction.before, [\n                transaction,\n                ...appendedTransactions\n            ]);\n            const changes = getChangedRanges(nextTransaction);\n            changes.forEach((change)=>{\n                if (nextTransaction.mapping.mapResult(change.oldRange.from).deletedAfter && nextTransaction.mapping.mapResult(change.oldRange.to).deletedBefore) {\n                    nextTransaction.before.nodesBetween(change.oldRange.from, change.oldRange.to, (node, from)=>{\n                        const to = from + node.nodeSize - 2;\n                        const isFullyWithinRange = change.oldRange.from <= from && to <= change.oldRange.to;\n                        this.editor.emit(\"delete\", {\n                            type: \"node\",\n                            node,\n                            from,\n                            to,\n                            newFrom: nextTransaction.mapping.map(from),\n                            newTo: nextTransaction.mapping.map(to),\n                            deletedRange: change.oldRange,\n                            newRange: change.newRange,\n                            partial: !isFullyWithinRange,\n                            editor: this.editor,\n                            transaction,\n                            combinedTransform: nextTransaction\n                        });\n                    });\n                }\n            });\n            const mapping = nextTransaction.mapping;\n            nextTransaction.steps.forEach((step, index)=>{\n                var _a3, _b3;\n                if (step instanceof _tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_0__.RemoveMarkStep) {\n                    const newStart = mapping.slice(index).map(step.from, -1);\n                    const newEnd = mapping.slice(index).map(step.to);\n                    const oldStart = mapping.invert().map(newStart, -1);\n                    const oldEnd = mapping.invert().map(newEnd);\n                    const foundBeforeMark = (_a3 = nextTransaction.doc.nodeAt(newStart - 1)) == null ? void 0 : _a3.marks.some((mark)=>mark.eq(step.mark));\n                    const foundAfterMark = (_b3 = nextTransaction.doc.nodeAt(newEnd)) == null ? void 0 : _b3.marks.some((mark)=>mark.eq(step.mark));\n                    this.editor.emit(\"delete\", {\n                        type: \"mark\",\n                        mark: step.mark,\n                        from: step.from,\n                        to: step.to,\n                        deletedRange: {\n                            from: oldStart,\n                            to: oldEnd\n                        },\n                        newRange: {\n                            from: newStart,\n                            to: newEnd\n                        },\n                        partial: Boolean(foundAfterMark || foundBeforeMark),\n                        editor: this.editor,\n                        transaction,\n                        combinedTransform: nextTransaction\n                    });\n                }\n            });\n        };\n        if ((_c = (_b = (_a = this.editor.options.coreExtensionOptions) == null ? void 0 : _a.delete) == null ? void 0 : _b.async) != null ? _c : true) {\n            setTimeout(callback, 0);\n        } else {\n            callback();\n        }\n    }\n});\n// src/extensions/drop.ts\n\nvar Drop = Extension.create({\n    name: \"drop\",\n    addProseMirrorPlugins () {\n        return [\n            new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.Plugin({\n                key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.PluginKey(\"tiptapDrop\"),\n                props: {\n                    handleDrop: (_, e, slice, moved)=>{\n                        this.editor.emit(\"drop\", {\n                            editor: this.editor,\n                            event: e,\n                            slice,\n                            moved\n                        });\n                    }\n                }\n            })\n        ];\n    }\n});\n// src/extensions/editable.ts\n\nvar Editable = Extension.create({\n    name: \"editable\",\n    addProseMirrorPlugins () {\n        return [\n            new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.Plugin({\n                key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.PluginKey(\"editable\"),\n                props: {\n                    editable: ()=>this.editor.options.editable\n                }\n            })\n        ];\n    }\n});\n// src/extensions/focusEvents.ts\n\nvar focusEventsPluginKey = new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.PluginKey(\"focusEvents\");\nvar FocusEvents = Extension.create({\n    name: \"focusEvents\",\n    addProseMirrorPlugins () {\n        const { editor } = this;\n        return [\n            new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.Plugin({\n                key: focusEventsPluginKey,\n                props: {\n                    handleDOMEvents: {\n                        focus: (view, event)=>{\n                            editor.isFocused = true;\n                            const transaction = editor.state.tr.setMeta(\"focus\", {\n                                event\n                            }).setMeta(\"addToHistory\", false);\n                            view.dispatch(transaction);\n                            return false;\n                        },\n                        blur: (view, event)=>{\n                            editor.isFocused = false;\n                            const transaction = editor.state.tr.setMeta(\"blur\", {\n                                event\n                            }).setMeta(\"addToHistory\", false);\n                            view.dispatch(transaction);\n                            return false;\n                        }\n                    }\n                }\n            })\n        ];\n    }\n});\n// src/extensions/keymap.ts\n\nvar Keymap = Extension.create({\n    name: \"keymap\",\n    addKeyboardShortcuts () {\n        const handleBackspace = ()=>this.editor.commands.first(({ commands })=>[\n                    ()=>commands.undoInputRule(),\n                    // maybe convert first text block node to default node\n                    ()=>commands.command(({ tr })=>{\n                            const { selection, doc } = tr;\n                            const { empty, $anchor } = selection;\n                            const { pos, parent } = $anchor;\n                            const $parentPos = $anchor.parent.isTextblock && pos > 0 ? tr.doc.resolve(pos - 1) : $anchor;\n                            const parentIsIsolating = $parentPos.parent.type.spec.isolating;\n                            const parentPos = $anchor.pos - $anchor.parentOffset;\n                            const isAtStart = parentIsIsolating && $parentPos.parent.childCount === 1 ? parentPos === $anchor.pos : _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.Selection.atStart(doc).from === pos;\n                            if (!empty || !parent.type.isTextblock || parent.textContent.length || !isAtStart || isAtStart && $anchor.parent.type.name === \"paragraph\") {\n                                return false;\n                            }\n                            return commands.clearNodes();\n                        }),\n                    ()=>commands.deleteSelection(),\n                    ()=>commands.joinBackward(),\n                    ()=>commands.selectNodeBackward()\n                ]);\n        const handleDelete = ()=>this.editor.commands.first(({ commands })=>[\n                    ()=>commands.deleteSelection(),\n                    ()=>commands.deleteCurrentNode(),\n                    ()=>commands.joinForward(),\n                    ()=>commands.selectNodeForward()\n                ]);\n        const handleEnter = ()=>this.editor.commands.first(({ commands })=>[\n                    ()=>commands.newlineInCode(),\n                    ()=>commands.createParagraphNear(),\n                    ()=>commands.liftEmptyBlock(),\n                    ()=>commands.splitBlock()\n                ]);\n        const baseKeymap = {\n            Enter: handleEnter,\n            \"Mod-Enter\": ()=>this.editor.commands.exitCode(),\n            Backspace: handleBackspace,\n            \"Mod-Backspace\": handleBackspace,\n            \"Shift-Backspace\": handleBackspace,\n            Delete: handleDelete,\n            \"Mod-Delete\": handleDelete,\n            \"Mod-a\": ()=>this.editor.commands.selectAll()\n        };\n        const pcKeymap = {\n            ...baseKeymap\n        };\n        const macKeymap = {\n            ...baseKeymap,\n            \"Ctrl-h\": handleBackspace,\n            \"Alt-Backspace\": handleBackspace,\n            \"Ctrl-d\": handleDelete,\n            \"Ctrl-Alt-Backspace\": handleDelete,\n            \"Alt-Delete\": handleDelete,\n            \"Alt-d\": handleDelete,\n            \"Ctrl-a\": ()=>this.editor.commands.selectTextblockStart(),\n            \"Ctrl-e\": ()=>this.editor.commands.selectTextblockEnd()\n        };\n        if (isiOS() || isMacOS()) {\n            return macKeymap;\n        }\n        return pcKeymap;\n    },\n    addProseMirrorPlugins () {\n        return [\n            // With this plugin we check if the whole document was selected and deleted.\n            // In this case we will additionally call `clearNodes()` to convert e.g. a heading\n            // to a paragraph if necessary.\n            // This is an alternative to ProseMirror's `AllSelection`, which doesnt work well\n            // with many other commands.\n            new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.Plugin({\n                key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.PluginKey(\"clearDocument\"),\n                appendTransaction: (transactions, oldState, newState)=>{\n                    if (transactions.some((tr2)=>tr2.getMeta(\"composition\"))) {\n                        return;\n                    }\n                    const docChanges = transactions.some((transaction)=>transaction.docChanged) && !oldState.doc.eq(newState.doc);\n                    const ignoreTr = transactions.some((transaction)=>transaction.getMeta(\"preventClearDocument\"));\n                    if (!docChanges || ignoreTr) {\n                        return;\n                    }\n                    const { empty, from, to } = oldState.selection;\n                    const allFrom = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.Selection.atStart(oldState.doc).from;\n                    const allEnd = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.Selection.atEnd(oldState.doc).to;\n                    const allWasSelected = from === allFrom && to === allEnd;\n                    if (empty || !allWasSelected) {\n                        return;\n                    }\n                    const isEmpty = isNodeEmpty(newState.doc);\n                    if (!isEmpty) {\n                        return;\n                    }\n                    const tr = newState.tr;\n                    const state = createChainableState({\n                        state: newState,\n                        transaction: tr\n                    });\n                    const { commands } = new CommandManager({\n                        editor: this.editor,\n                        state\n                    });\n                    commands.clearNodes();\n                    if (!tr.steps.length) {\n                        return;\n                    }\n                    return tr;\n                }\n            })\n        ];\n    }\n});\n// src/extensions/paste.ts\n\nvar Paste = Extension.create({\n    name: \"paste\",\n    addProseMirrorPlugins () {\n        return [\n            new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.Plugin({\n                key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.PluginKey(\"tiptapPaste\"),\n                props: {\n                    handlePaste: (_view, e, slice)=>{\n                        this.editor.emit(\"paste\", {\n                            editor: this.editor,\n                            event: e,\n                            slice\n                        });\n                    }\n                }\n            })\n        ];\n    }\n});\n// src/extensions/tabindex.ts\n\nvar Tabindex = Extension.create({\n    name: \"tabindex\",\n    addProseMirrorPlugins () {\n        return [\n            new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.Plugin({\n                key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.PluginKey(\"tabindex\"),\n                props: {\n                    attributes: ()=>this.editor.isEditable ? {\n                            tabindex: \"0\"\n                        } : {}\n                }\n            })\n        ];\n    }\n});\n// src/extensions/textDirection.ts\n\nvar TextDirection = Extension.create({\n    name: \"textDirection\",\n    addOptions () {\n        return {\n            direction: void 0\n        };\n    },\n    addGlobalAttributes () {\n        if (!this.options.direction) {\n            return [];\n        }\n        const { nodeExtensions } = splitExtensions(this.extensions);\n        return [\n            {\n                types: nodeExtensions.filter((extension)=>extension.name !== \"text\").map((extension)=>extension.name),\n                attributes: {\n                    dir: {\n                        default: this.options.direction,\n                        parseHTML: (element)=>{\n                            const dir = element.getAttribute(\"dir\");\n                            if (dir && (dir === \"ltr\" || dir === \"rtl\" || dir === \"auto\")) {\n                                return dir;\n                            }\n                            return this.options.direction;\n                        },\n                        renderHTML: (attributes)=>{\n                            if (!attributes.dir) {\n                                return {};\n                            }\n                            return {\n                                dir: attributes.dir\n                            };\n                        }\n                    }\n                }\n            }\n        ];\n    },\n    addProseMirrorPlugins () {\n        return [\n            new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.Plugin({\n                key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.PluginKey(\"textDirection\"),\n                props: {\n                    attributes: ()=>{\n                        const direction = this.options.direction;\n                        if (!direction) {\n                            return {};\n                        }\n                        return {\n                            dir: direction\n                        };\n                    }\n                }\n            })\n        ];\n    }\n});\n// src/NodePos.ts\nvar NodePos = class _NodePos {\n    constructor(pos, editor, isBlock = false, node = null){\n        this.currentNode = null;\n        this.actualDepth = null;\n        this.isBlock = isBlock;\n        this.resolvedPos = pos;\n        this.editor = editor;\n        this.currentNode = node;\n    }\n    get name() {\n        return this.node.type.name;\n    }\n    get node() {\n        return this.currentNode || this.resolvedPos.node();\n    }\n    get element() {\n        return this.editor.view.domAtPos(this.pos).node;\n    }\n    get depth() {\n        var _a;\n        return (_a = this.actualDepth) != null ? _a : this.resolvedPos.depth;\n    }\n    get pos() {\n        return this.resolvedPos.pos;\n    }\n    get content() {\n        return this.node.content;\n    }\n    set content(content) {\n        let from = this.from;\n        let to = this.to;\n        if (this.isBlock) {\n            if (this.content.size === 0) {\n                console.error(`You can\\u2019t set content on a block node. Tried to set content on ${this.name} at ${this.pos}`);\n                return;\n            }\n            from = this.from + 1;\n            to = this.to - 1;\n        }\n        this.editor.commands.insertContentAt({\n            from,\n            to\n        }, content);\n    }\n    get attributes() {\n        return this.node.attrs;\n    }\n    get textContent() {\n        return this.node.textContent;\n    }\n    get size() {\n        return this.node.nodeSize;\n    }\n    get from() {\n        if (this.isBlock) {\n            return this.pos;\n        }\n        return this.resolvedPos.start(this.resolvedPos.depth);\n    }\n    get range() {\n        return {\n            from: this.from,\n            to: this.to\n        };\n    }\n    get to() {\n        if (this.isBlock) {\n            return this.pos + this.size;\n        }\n        return this.resolvedPos.end(this.resolvedPos.depth) + (this.node.isText ? 0 : 1);\n    }\n    get parent() {\n        if (this.depth === 0) {\n            return null;\n        }\n        const parentPos = this.resolvedPos.start(this.resolvedPos.depth - 1);\n        const $pos = this.resolvedPos.doc.resolve(parentPos);\n        return new _NodePos($pos, this.editor);\n    }\n    get before() {\n        let $pos = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2));\n        if ($pos.depth !== this.depth) {\n            $pos = this.resolvedPos.doc.resolve(this.from - 3);\n        }\n        return new _NodePos($pos, this.editor);\n    }\n    get after() {\n        let $pos = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1));\n        if ($pos.depth !== this.depth) {\n            $pos = this.resolvedPos.doc.resolve(this.to + 3);\n        }\n        return new _NodePos($pos, this.editor);\n    }\n    get children() {\n        const children = [];\n        this.node.content.forEach((node, offset)=>{\n            const isBlock = node.isBlock && !node.isTextblock;\n            const isNonTextAtom = node.isAtom && !node.isText;\n            const targetPos = this.pos + offset + (isNonTextAtom ? 0 : 1);\n            if (targetPos < 0 || targetPos > this.resolvedPos.doc.nodeSize - 2) {\n                return;\n            }\n            const $pos = this.resolvedPos.doc.resolve(targetPos);\n            if (!isBlock && $pos.depth <= this.depth) {\n                return;\n            }\n            const childNodePos = new _NodePos($pos, this.editor, isBlock, isBlock ? node : null);\n            if (isBlock) {\n                childNodePos.actualDepth = this.depth + 1;\n            }\n            children.push(new _NodePos($pos, this.editor, isBlock, isBlock ? node : null));\n        });\n        return children;\n    }\n    get firstChild() {\n        return this.children[0] || null;\n    }\n    get lastChild() {\n        const children = this.children;\n        return children[children.length - 1] || null;\n    }\n    closest(selector, attributes = {}) {\n        let node = null;\n        let currentNode = this.parent;\n        while(currentNode && !node){\n            if (currentNode.node.type.name === selector) {\n                if (Object.keys(attributes).length > 0) {\n                    const nodeAttributes = currentNode.node.attrs;\n                    const attrKeys = Object.keys(attributes);\n                    for(let index = 0; index < attrKeys.length; index += 1){\n                        const key = attrKeys[index];\n                        if (nodeAttributes[key] !== attributes[key]) {\n                            break;\n                        }\n                    }\n                } else {\n                    node = currentNode;\n                }\n            }\n            currentNode = currentNode.parent;\n        }\n        return node;\n    }\n    querySelector(selector, attributes = {}) {\n        return this.querySelectorAll(selector, attributes, true)[0] || null;\n    }\n    querySelectorAll(selector, attributes = {}, firstItemOnly = false) {\n        let nodes = [];\n        if (!this.children || this.children.length === 0) {\n            return nodes;\n        }\n        const attrKeys = Object.keys(attributes);\n        this.children.forEach((childPos)=>{\n            if (firstItemOnly && nodes.length > 0) {\n                return;\n            }\n            if (childPos.node.type.name === selector) {\n                const doesAllAttributesMatch = attrKeys.every((key)=>attributes[key] === childPos.node.attrs[key]);\n                if (doesAllAttributesMatch) {\n                    nodes.push(childPos);\n                }\n            }\n            if (firstItemOnly && nodes.length > 0) {\n                return;\n            }\n            nodes = nodes.concat(childPos.querySelectorAll(selector, attributes, firstItemOnly));\n        });\n        return nodes;\n    }\n    setAttribute(attributes) {\n        const { tr } = this.editor.state;\n        tr.setNodeMarkup(this.from, void 0, {\n            ...this.node.attrs,\n            ...attributes\n        });\n        this.editor.view.dispatch(tr);\n    }\n};\n// src/style.ts\nvar style = `.ProseMirror {\n  position: relative;\n}\n\n.ProseMirror {\n  word-wrap: break-word;\n  white-space: pre-wrap;\n  white-space: break-spaces;\n  -webkit-font-variant-ligatures: none;\n  font-variant-ligatures: none;\n  font-feature-settings: \"liga\" 0; /* the above doesn't seem to work in Edge */\n}\n\n.ProseMirror [contenteditable=\"false\"] {\n  white-space: normal;\n}\n\n.ProseMirror [contenteditable=\"false\"] [contenteditable=\"true\"] {\n  white-space: pre-wrap;\n}\n\n.ProseMirror pre {\n  white-space: pre-wrap;\n}\n\nimg.ProseMirror-separator {\n  display: inline !important;\n  border: none !important;\n  margin: 0 !important;\n  width: 0 !important;\n  height: 0 !important;\n}\n\n.ProseMirror-gapcursor {\n  display: none;\n  pointer-events: none;\n  position: absolute;\n  margin: 0;\n}\n\n.ProseMirror-gapcursor:after {\n  content: \"\";\n  display: block;\n  position: absolute;\n  top: -2px;\n  width: 20px;\n  border-top: 1px solid black;\n  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;\n}\n\n@keyframes ProseMirror-cursor-blink {\n  to {\n    visibility: hidden;\n  }\n}\n\n.ProseMirror-hideselection *::selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection *::-moz-selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection * {\n  caret-color: transparent;\n}\n\n.ProseMirror-focused .ProseMirror-gapcursor {\n  display: block;\n}`;\n// src/utilities/createStyleTag.ts\nfunction createStyleTag(style2, nonce, suffix) {\n    const tiptapStyleTag = document.querySelector(`style[data-tiptap-style${suffix ? `-${suffix}` : \"\"}]`);\n    if (tiptapStyleTag !== null) {\n        return tiptapStyleTag;\n    }\n    const styleNode = document.createElement(\"style\");\n    if (nonce) {\n        styleNode.setAttribute(\"nonce\", nonce);\n    }\n    styleNode.setAttribute(`data-tiptap-style${suffix ? `-${suffix}` : \"\"}`, \"\");\n    styleNode.innerHTML = style2;\n    document.getElementsByTagName(\"head\")[0].appendChild(styleNode);\n    return styleNode;\n}\n// src/Editor.ts\nvar Editor = class extends EventEmitter {\n    constructor(options = {}){\n        super();\n        this.css = null;\n        this.className = \"tiptap\";\n        this.editorView = null;\n        this.isFocused = false;\n        /**\n     * The editor is considered initialized after the `create` event has been emitted.\n     */ this.isInitialized = false;\n        this.extensionStorage = {};\n        /**\n     * A unique ID for this editor instance.\n     */ this.instanceId = Math.random().toString(36).slice(2, 9);\n        this.options = {\n            element: typeof document !== \"undefined\" ? document.createElement(\"div\") : null,\n            content: \"\",\n            injectCSS: true,\n            injectNonce: void 0,\n            extensions: [],\n            autofocus: false,\n            editable: true,\n            textDirection: void 0,\n            editorProps: {},\n            parseOptions: {},\n            coreExtensionOptions: {},\n            enableInputRules: true,\n            enablePasteRules: true,\n            enableCoreExtensions: true,\n            enableContentCheck: false,\n            emitContentError: false,\n            onBeforeCreate: ()=>null,\n            onCreate: ()=>null,\n            onMount: ()=>null,\n            onUnmount: ()=>null,\n            onUpdate: ()=>null,\n            onSelectionUpdate: ()=>null,\n            onTransaction: ()=>null,\n            onFocus: ()=>null,\n            onBlur: ()=>null,\n            onDestroy: ()=>null,\n            onContentError: ({ error })=>{\n                throw error;\n            },\n            onPaste: ()=>null,\n            onDrop: ()=>null,\n            onDelete: ()=>null\n        };\n        this.isCapturingTransaction = false;\n        this.capturedTransaction = null;\n        /**\n     * Returns a set of utilities for working with positions and ranges.\n     */ this.utils = {\n            getUpdatedPosition,\n            createMappablePosition\n        };\n        this.setOptions(options);\n        this.createExtensionManager();\n        this.createCommandManager();\n        this.createSchema();\n        this.on(\"beforeCreate\", this.options.onBeforeCreate);\n        this.emit(\"beforeCreate\", {\n            editor: this\n        });\n        this.on(\"mount\", this.options.onMount);\n        this.on(\"unmount\", this.options.onUnmount);\n        this.on(\"contentError\", this.options.onContentError);\n        this.on(\"create\", this.options.onCreate);\n        this.on(\"update\", this.options.onUpdate);\n        this.on(\"selectionUpdate\", this.options.onSelectionUpdate);\n        this.on(\"transaction\", this.options.onTransaction);\n        this.on(\"focus\", this.options.onFocus);\n        this.on(\"blur\", this.options.onBlur);\n        this.on(\"destroy\", this.options.onDestroy);\n        this.on(\"drop\", ({ event, slice, moved })=>this.options.onDrop(event, slice, moved));\n        this.on(\"paste\", ({ event, slice })=>this.options.onPaste(event, slice));\n        this.on(\"delete\", this.options.onDelete);\n        const initialDoc = this.createDoc();\n        const selection = resolveFocusPosition(initialDoc, this.options.autofocus);\n        this.editorState = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.EditorState.create({\n            doc: initialDoc,\n            schema: this.schema,\n            selection: selection || void 0\n        });\n        if (this.options.element) {\n            this.mount(this.options.element);\n        }\n    }\n    /**\n   * Attach the editor to the DOM, creating a new editor view.\n   */ mount(el) {\n        if (typeof document === \"undefined\") {\n            throw new Error(`[tiptap error]: The editor cannot be mounted because there is no 'document' defined in this environment.`);\n        }\n        this.createView(el);\n        this.emit(\"mount\", {\n            editor: this\n        });\n        if (this.css && !document.head.contains(this.css)) {\n            document.head.appendChild(this.css);\n        }\n        window.setTimeout(()=>{\n            if (this.isDestroyed) {\n                return;\n            }\n            if (this.options.autofocus !== false && this.options.autofocus !== null) {\n                this.commands.focus(this.options.autofocus);\n            }\n            this.emit(\"create\", {\n                editor: this\n            });\n            this.isInitialized = true;\n        }, 0);\n    }\n    /**\n   * Remove the editor from the DOM, but still allow remounting at a different point in time\n   */ unmount() {\n        if (this.editorView) {\n            const dom = this.editorView.dom;\n            if (dom == null ? void 0 : dom.editor) {\n                delete dom.editor;\n            }\n            this.editorView.destroy();\n        }\n        this.editorView = null;\n        this.isInitialized = false;\n        if (this.css && !document.querySelectorAll(`.${this.className}`).length) {\n            try {\n                if (typeof this.css.remove === \"function\") {\n                    this.css.remove();\n                } else if (this.css.parentNode) {\n                    this.css.parentNode.removeChild(this.css);\n                }\n            } catch (error) {\n                console.warn(\"Failed to remove CSS element:\", error);\n            }\n        }\n        this.css = null;\n        this.emit(\"unmount\", {\n            editor: this\n        });\n    }\n    /**\n   * Returns the editor storage.\n   */ get storage() {\n        return this.extensionStorage;\n    }\n    /**\n   * An object of all registered commands.\n   */ get commands() {\n        return this.commandManager.commands;\n    }\n    /**\n   * Create a command chain to call multiple commands at once.\n   */ chain() {\n        return this.commandManager.chain();\n    }\n    /**\n   * Check if a command or a command chain can be executed. Without executing it.\n   */ can() {\n        return this.commandManager.can();\n    }\n    /**\n   * Inject CSS styles.\n   */ injectCSS() {\n        if (this.options.injectCSS && typeof document !== \"undefined\") {\n            this.css = createStyleTag(style, this.options.injectNonce);\n        }\n    }\n    /**\n   * Update editor options.\n   *\n   * @param options A list of options\n   */ setOptions(options = {}) {\n        this.options = {\n            ...this.options,\n            ...options\n        };\n        if (!this.editorView || !this.state || this.isDestroyed) {\n            return;\n        }\n        if (this.options.editorProps) {\n            this.view.setProps(this.options.editorProps);\n        }\n        this.view.updateState(this.state);\n    }\n    /**\n   * Update editable state of the editor.\n   */ setEditable(editable, emitUpdate = true) {\n        this.setOptions({\n            editable\n        });\n        if (emitUpdate) {\n            this.emit(\"update\", {\n                editor: this,\n                transaction: this.state.tr,\n                appendedTransactions: []\n            });\n        }\n    }\n    /**\n   * Returns whether the editor is editable.\n   */ get isEditable() {\n        return this.options.editable && this.view && this.view.editable;\n    }\n    /**\n   * Returns the editor state.\n   */ get view() {\n        if (this.editorView) {\n            return this.editorView;\n        }\n        return new Proxy({\n            state: this.editorState,\n            updateState: (state)=>{\n                this.editorState = state;\n            },\n            dispatch: (tr)=>{\n                this.dispatchTransaction(tr);\n            },\n            // Stub some commonly accessed properties to prevent errors\n            composing: false,\n            dragging: null,\n            editable: true,\n            isDestroyed: false\n        }, {\n            get: (obj, key)=>{\n                if (this.editorView) {\n                    return this.editorView[key];\n                }\n                if (key === \"state\") {\n                    return this.editorState;\n                }\n                if (key in obj) {\n                    return Reflect.get(obj, key);\n                }\n                throw new Error(`[tiptap error]: The editor view is not available. Cannot access view['${key}']. The editor may not be mounted yet.`);\n            }\n        });\n    }\n    /**\n   * Returns the editor state.\n   */ get state() {\n        if (this.editorView) {\n            this.editorState = this.view.state;\n        }\n        return this.editorState;\n    }\n    /**\n   * Register a ProseMirror plugin.\n   *\n   * @param plugin A ProseMirror plugin\n   * @param handlePlugins Control how to merge the plugin into the existing plugins.\n   * @returns The new editor state\n   */ registerPlugin(plugin, handlePlugins) {\n        const plugins = isFunction(handlePlugins) ? handlePlugins(plugin, [\n            ...this.state.plugins\n        ]) : [\n            ...this.state.plugins,\n            plugin\n        ];\n        const state = this.state.reconfigure({\n            plugins\n        });\n        this.view.updateState(state);\n        return state;\n    }\n    /**\n   * Unregister a ProseMirror plugin.\n   *\n   * @param nameOrPluginKeyToRemove The plugins name\n   * @returns The new editor state or undefined if the editor is destroyed\n   */ unregisterPlugin(nameOrPluginKeyToRemove) {\n        if (this.isDestroyed) {\n            return void 0;\n        }\n        const prevPlugins = this.state.plugins;\n        let plugins = prevPlugins;\n        [].concat(nameOrPluginKeyToRemove).forEach((nameOrPluginKey)=>{\n            const name = typeof nameOrPluginKey === \"string\" ? `${nameOrPluginKey}$` : nameOrPluginKey.key;\n            plugins = plugins.filter((plugin)=>!plugin.key.startsWith(name));\n        });\n        if (prevPlugins.length === plugins.length) {\n            return void 0;\n        }\n        const state = this.state.reconfigure({\n            plugins\n        });\n        this.view.updateState(state);\n        return state;\n    }\n    /**\n   * Creates an extension manager.\n   */ createExtensionManager() {\n        var _a, _b;\n        const coreExtensions = this.options.enableCoreExtensions ? [\n            Editable,\n            ClipboardTextSerializer.configure({\n                blockSeparator: (_b = (_a = this.options.coreExtensionOptions) == null ? void 0 : _a.clipboardTextSerializer) == null ? void 0 : _b.blockSeparator\n            }),\n            Commands,\n            FocusEvents,\n            Keymap,\n            Tabindex,\n            Drop,\n            Paste,\n            Delete,\n            TextDirection.configure({\n                direction: this.options.textDirection\n            })\n        ].filter((ext)=>{\n            if (typeof this.options.enableCoreExtensions === \"object\") {\n                return this.options.enableCoreExtensions[ext.name] !== false;\n            }\n            return true;\n        }) : [];\n        const allExtensions = [\n            ...coreExtensions,\n            ...this.options.extensions\n        ].filter((extension)=>{\n            return [\n                \"extension\",\n                \"node\",\n                \"mark\"\n            ].includes(extension == null ? void 0 : extension.type);\n        });\n        this.extensionManager = new ExtensionManager(allExtensions, this);\n    }\n    /**\n   * Creates an command manager.\n   */ createCommandManager() {\n        this.commandManager = new CommandManager({\n            editor: this\n        });\n    }\n    /**\n   * Creates a ProseMirror schema.\n   */ createSchema() {\n        this.schema = this.extensionManager.schema;\n    }\n    /**\n   * Creates the initial document.\n   */ createDoc() {\n        let doc;\n        try {\n            doc = createDocument(this.options.content, this.schema, this.options.parseOptions, {\n                errorOnInvalidContent: this.options.enableContentCheck\n            });\n        } catch (e) {\n            if (!(e instanceof Error) || ![\n                \"[tiptap error]: Invalid JSON content\",\n                \"[tiptap error]: Invalid HTML content\"\n            ].includes(e.message)) {\n                throw e;\n            }\n            this.emit(\"contentError\", {\n                editor: this,\n                error: e,\n                disableCollaboration: ()=>{\n                    if (\"collaboration\" in this.storage && typeof this.storage.collaboration === \"object\" && this.storage.collaboration) {\n                        ;\n                        this.storage.collaboration.isDisabled = true;\n                    }\n                    this.options.extensions = this.options.extensions.filter((extension)=>extension.name !== \"collaboration\");\n                    this.createExtensionManager();\n                }\n            });\n            doc = createDocument(this.options.content, this.schema, this.options.parseOptions, {\n                errorOnInvalidContent: false\n            });\n        }\n        return doc;\n    }\n    /**\n   * Creates a ProseMirror view.\n   */ createView(element) {\n        var _a;\n        this.editorView = new _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_5__.EditorView(element, {\n            ...this.options.editorProps,\n            attributes: {\n                // add `role=\"textbox\"` to the editor element\n                role: \"textbox\",\n                ...(_a = this.options.editorProps) == null ? void 0 : _a.attributes\n            },\n            dispatchTransaction: this.dispatchTransaction.bind(this),\n            state: this.editorState,\n            markViews: this.extensionManager.markViews,\n            nodeViews: this.extensionManager.nodeViews\n        });\n        const newState = this.state.reconfigure({\n            plugins: this.extensionManager.plugins\n        });\n        this.view.updateState(newState);\n        this.prependClass();\n        this.injectCSS();\n        const dom = this.view.dom;\n        dom.editor = this;\n    }\n    /**\n   * Creates all node and mark views.\n   */ createNodeViews() {\n        if (this.view.isDestroyed) {\n            return;\n        }\n        this.view.setProps({\n            markViews: this.extensionManager.markViews,\n            nodeViews: this.extensionManager.nodeViews\n        });\n    }\n    /**\n   * Prepend class name to element.\n   */ prependClass() {\n        this.view.dom.className = `${this.className} ${this.view.dom.className}`;\n    }\n    captureTransaction(fn) {\n        this.isCapturingTransaction = true;\n        fn();\n        this.isCapturingTransaction = false;\n        const tr = this.capturedTransaction;\n        this.capturedTransaction = null;\n        return tr;\n    }\n    /**\n   * The callback over which to send transactions (state updates) produced by the view.\n   *\n   * @param transaction An editor state transaction\n   */ dispatchTransaction(transaction) {\n        if (this.view.isDestroyed) {\n            return;\n        }\n        if (this.isCapturingTransaction) {\n            if (!this.capturedTransaction) {\n                this.capturedTransaction = transaction;\n                return;\n            }\n            transaction.steps.forEach((step)=>{\n                var _a;\n                return (_a = this.capturedTransaction) == null ? void 0 : _a.step(step);\n            });\n            return;\n        }\n        const { state, transactions } = this.state.applyTransaction(transaction);\n        const selectionHasChanged = !this.state.selection.eq(state.selection);\n        const rootTrWasApplied = transactions.includes(transaction);\n        const prevState = this.state;\n        this.emit(\"beforeTransaction\", {\n            editor: this,\n            transaction,\n            nextState: state\n        });\n        if (!rootTrWasApplied) {\n            return;\n        }\n        this.view.updateState(state);\n        this.emit(\"transaction\", {\n            editor: this,\n            transaction,\n            appendedTransactions: transactions.slice(1)\n        });\n        if (selectionHasChanged) {\n            this.emit(\"selectionUpdate\", {\n                editor: this,\n                transaction\n            });\n        }\n        const mostRecentFocusTr = transactions.findLast((tr)=>tr.getMeta(\"focus\") || tr.getMeta(\"blur\"));\n        const focus2 = mostRecentFocusTr == null ? void 0 : mostRecentFocusTr.getMeta(\"focus\");\n        const blur2 = mostRecentFocusTr == null ? void 0 : mostRecentFocusTr.getMeta(\"blur\");\n        if (focus2) {\n            this.emit(\"focus\", {\n                editor: this,\n                event: focus2.event,\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                transaction: mostRecentFocusTr\n            });\n        }\n        if (blur2) {\n            this.emit(\"blur\", {\n                editor: this,\n                event: blur2.event,\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                transaction: mostRecentFocusTr\n            });\n        }\n        if (transaction.getMeta(\"preventUpdate\") || !transactions.some((tr)=>tr.docChanged) || prevState.doc.eq(state.doc)) {\n            return;\n        }\n        this.emit(\"update\", {\n            editor: this,\n            transaction,\n            appendedTransactions: transactions.slice(1)\n        });\n    }\n    /**\n   * Get attributes of the currently selected node or mark.\n   */ getAttributes(nameOrType) {\n        return getAttributes(this.state, nameOrType);\n    }\n    isActive(nameOrAttributes, attributesOrUndefined) {\n        const name = typeof nameOrAttributes === \"string\" ? nameOrAttributes : null;\n        const attributes = typeof nameOrAttributes === \"string\" ? attributesOrUndefined : nameOrAttributes;\n        return isActive(this.state, name, attributes);\n    }\n    /**\n   * Get the document as JSON.\n   */ getJSON() {\n        return this.state.doc.toJSON();\n    }\n    /**\n   * Get the document as HTML.\n   */ getHTML() {\n        return getHTMLFromFragment(this.state.doc.content, this.schema);\n    }\n    /**\n   * Get the document as text.\n   */ getText(options) {\n        const { blockSeparator = \"\\n\\n\", textSerializers = {} } = options || {};\n        return getText(this.state.doc, {\n            blockSeparator,\n            textSerializers: {\n                ...getTextSerializersFromSchema(this.schema),\n                ...textSerializers\n            }\n        });\n    }\n    /**\n   * Check if there is no content.\n   */ get isEmpty() {\n        return isNodeEmpty(this.state.doc);\n    }\n    /**\n   * Destroy the editor.\n   */ destroy() {\n        this.emit(\"destroy\");\n        this.unmount();\n        this.removeAllListeners();\n    }\n    /**\n   * Check if the editor is already destroyed.\n   */ get isDestroyed() {\n        var _a, _b;\n        return (_b = (_a = this.editorView) == null ? void 0 : _a.isDestroyed) != null ? _b : true;\n    }\n    $node(selector, attributes) {\n        var _a;\n        return ((_a = this.$doc) == null ? void 0 : _a.querySelector(selector, attributes)) || null;\n    }\n    $nodes(selector, attributes) {\n        var _a;\n        return ((_a = this.$doc) == null ? void 0 : _a.querySelectorAll(selector, attributes)) || null;\n    }\n    $pos(pos) {\n        const $pos = this.state.doc.resolve(pos);\n        return new NodePos($pos, this);\n    }\n    get $doc() {\n        return this.$pos(0);\n    }\n};\n// src/inputRules/markInputRule.ts\nfunction markInputRule(config) {\n    return new InputRule({\n        find: config.find,\n        handler: ({ state, range, match })=>{\n            const attributes = callOrReturn(config.getAttributes, void 0, match);\n            if (attributes === false || attributes === null) {\n                return null;\n            }\n            const { tr } = state;\n            const captureGroup = match[match.length - 1];\n            const fullMatch = match[0];\n            if (captureGroup) {\n                const startSpaces = fullMatch.search(/\\S/);\n                const textStart = range.from + fullMatch.indexOf(captureGroup);\n                const textEnd = textStart + captureGroup.length;\n                const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter((item)=>{\n                    const excluded = item.mark.type.excluded;\n                    return excluded.find((type)=>type === config.type && type !== item.mark.type);\n                }).filter((item)=>item.to > textStart);\n                if (excludedMarks.length) {\n                    return null;\n                }\n                if (textEnd < range.to) {\n                    tr.delete(textEnd, range.to);\n                }\n                if (textStart > range.from) {\n                    tr.delete(range.from + startSpaces, textStart);\n                }\n                const markEnd = range.from + startSpaces + captureGroup.length;\n                tr.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));\n                tr.removeStoredMark(config.type);\n            }\n        },\n        undoable: config.undoable\n    });\n}\n// src/inputRules/nodeInputRule.ts\nfunction nodeInputRule(config) {\n    return new InputRule({\n        find: config.find,\n        handler: ({ state, range, match })=>{\n            const attributes = callOrReturn(config.getAttributes, void 0, match) || {};\n            const { tr } = state;\n            const start = range.from;\n            let end = range.to;\n            const newNode = config.type.create(attributes);\n            if (match[1]) {\n                const offset = match[0].lastIndexOf(match[1]);\n                let matchStart = start + offset;\n                if (matchStart > end) {\n                    matchStart = end;\n                } else {\n                    end = matchStart + match[1].length;\n                }\n                const lastChar = match[0][match[0].length - 1];\n                tr.insertText(lastChar, start + match[0].length - 1);\n                tr.replaceWith(matchStart, end, newNode);\n            } else if (match[0]) {\n                const insertionStart = config.type.isInline ? start : start - 1;\n                tr.insert(insertionStart, config.type.create(attributes)).delete(tr.mapping.map(start), tr.mapping.map(end));\n            }\n            tr.scrollIntoView();\n        },\n        undoable: config.undoable\n    });\n}\n// src/inputRules/textblockTypeInputRule.ts\nfunction textblockTypeInputRule(config) {\n    return new InputRule({\n        find: config.find,\n        handler: ({ state, range, match })=>{\n            const $start = state.doc.resolve(range.from);\n            const attributes = callOrReturn(config.getAttributes, void 0, match) || {};\n            if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), config.type)) {\n                return null;\n            }\n            state.tr.delete(range.from, range.to).setBlockType(range.from, range.from, config.type, attributes);\n        },\n        undoable: config.undoable\n    });\n}\n// src/inputRules/textInputRule.ts\nfunction textInputRule(config) {\n    return new InputRule({\n        find: config.find,\n        handler: ({ state, range, match })=>{\n            let insert = config.replace;\n            let start = range.from;\n            const end = range.to;\n            if (match[1]) {\n                const offset = match[0].lastIndexOf(match[1]);\n                insert += match[0].slice(offset + match[1].length);\n                start += offset;\n                const cutOff = start - end;\n                if (cutOff > 0) {\n                    insert = match[0].slice(offset - cutOff, offset) + insert;\n                    start = end;\n                }\n            }\n            state.tr.insertText(insert, start, end);\n        },\n        undoable: config.undoable\n    });\n}\n// src/inputRules/wrappingInputRule.ts\n\nfunction wrappingInputRule(config) {\n    return new InputRule({\n        find: config.find,\n        handler: ({ state, range, match, chain })=>{\n            const attributes = callOrReturn(config.getAttributes, void 0, match) || {};\n            const tr = state.tr.delete(range.from, range.to);\n            const $start = tr.doc.resolve(range.from);\n            const blockRange = $start.blockRange();\n            const wrapping = blockRange && (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_0__.findWrapping)(blockRange, config.type, attributes);\n            if (!wrapping) {\n                return null;\n            }\n            tr.wrap(blockRange, wrapping);\n            if (config.keepMarks && config.editor) {\n                const { selection, storedMarks } = state;\n                const { splittableMarks } = config.editor.extensionManager;\n                const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();\n                if (marks) {\n                    const filteredMarks = marks.filter((mark)=>splittableMarks.includes(mark.type.name));\n                    tr.ensureMarks(filteredMarks);\n                }\n            }\n            if (config.keepAttributes) {\n                const nodeType = config.type.name === \"bulletList\" || config.type.name === \"orderedList\" ? \"listItem\" : \"taskList\";\n                chain().updateAttributes(nodeType, attributes).run();\n            }\n            const before = tr.doc.resolve(range.from - 1).nodeBefore;\n            if (before && before.type === config.type && (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(tr.doc, range.from - 1) && (!config.joinPredicate || config.joinPredicate(match, before))) {\n                tr.join(range.from - 1);\n            }\n        },\n        undoable: config.undoable\n    });\n}\n// src/jsx-runtime.ts\nfunction Fragment6(props) {\n    return props.children;\n}\nvar h = (tag, attributes)=>{\n    if (tag === \"slot\") {\n        return 0;\n    }\n    if (tag instanceof Function) {\n        return tag(attributes);\n    }\n    const { children, ...rest } = attributes != null ? attributes : {};\n    if (tag === \"svg\") {\n        throw new Error(\"SVG elements are not supported in the JSX syntax, use the array syntax instead\");\n    }\n    return [\n        tag,\n        rest,\n        children\n    ];\n};\n// src/lib/ResizableNodeView.ts\nvar isTouchEvent = (e)=>{\n    return \"touches\" in e;\n};\nvar ResizableNodeView = class {\n    /**\n   * Creates a new ResizableNodeView instance.\n   *\n   * The constructor sets up the resize handles, applies initial sizing from\n   * node attributes, and configures all resize behavior options.\n   *\n   * @param options - Configuration options for the resizable node view\n   */ constructor(options){\n        /** Active resize handle directions */ this.directions = [\n            \"bottom-left\",\n            \"bottom-right\",\n            \"top-left\",\n            \"top-right\"\n        ];\n        /** Minimum allowed dimensions */ this.minSize = {\n            height: 8,\n            width: 8\n        };\n        /** Whether to always preserve aspect ratio */ this.preserveAspectRatio = false;\n        /** CSS class names for elements */ this.classNames = {\n            container: \"\",\n            wrapper: \"\",\n            handle: \"\",\n            resizing: \"\"\n        };\n        /** Initial width of the element (for aspect ratio calculation) */ this.initialWidth = 0;\n        /** Initial height of the element (for aspect ratio calculation) */ this.initialHeight = 0;\n        /** Calculated aspect ratio (width / height) */ this.aspectRatio = 1;\n        /** Whether a resize operation is currently active */ this.isResizing = false;\n        /** The handle currently being dragged */ this.activeHandle = null;\n        /** Starting mouse X position when resize began */ this.startX = 0;\n        /** Starting mouse Y position when resize began */ this.startY = 0;\n        /** Element width when resize began */ this.startWidth = 0;\n        /** Element height when resize began */ this.startHeight = 0;\n        /** Whether Shift key is currently pressed (for temporary aspect ratio lock) */ this.isShiftKeyPressed = false;\n        /** Last known editable state of the editor */ this.lastEditableState = void 0;\n        /** Map of handle elements by direction */ this.handleMap = /* @__PURE__ */ new Map();\n        /**\n     * Handles mouse movement during an active resize.\n     *\n     * Calculates the delta from the starting position, computes new dimensions\n     * based on the active handle direction, applies constraints and aspect ratio,\n     * then updates the element's style and calls the onResize callback.\n     *\n     * @param event - The mouse move event\n     */ this.handleMouseMove = (event)=>{\n            if (!this.isResizing || !this.activeHandle) {\n                return;\n            }\n            const deltaX = event.clientX - this.startX;\n            const deltaY = event.clientY - this.startY;\n            this.handleResize(deltaX, deltaY);\n        };\n        this.handleTouchMove = (event)=>{\n            if (!this.isResizing || !this.activeHandle) {\n                return;\n            }\n            const touch = event.touches[0];\n            if (!touch) {\n                return;\n            }\n            const deltaX = touch.clientX - this.startX;\n            const deltaY = touch.clientY - this.startY;\n            this.handleResize(deltaX, deltaY);\n        };\n        /**\n     * Completes the resize operation when the mouse button is released.\n     *\n     * Captures final dimensions, calls the onCommit callback to persist changes,\n     * removes the resizing state and class, and cleans up document-level listeners.\n     */ this.handleMouseUp = ()=>{\n            if (!this.isResizing) {\n                return;\n            }\n            const finalWidth = this.element.offsetWidth;\n            const finalHeight = this.element.offsetHeight;\n            this.onCommit(finalWidth, finalHeight);\n            this.isResizing = false;\n            this.activeHandle = null;\n            this.container.dataset.resizeState = \"false\";\n            if (this.classNames.resizing) {\n                this.container.classList.remove(this.classNames.resizing);\n            }\n            document.removeEventListener(\"mousemove\", this.handleMouseMove);\n            document.removeEventListener(\"mouseup\", this.handleMouseUp);\n            document.removeEventListener(\"keydown\", this.handleKeyDown);\n            document.removeEventListener(\"keyup\", this.handleKeyUp);\n        };\n        /**\n     * Tracks Shift key state to enable temporary aspect ratio locking.\n     *\n     * When Shift is pressed during resize, aspect ratio is preserved even if\n     * preserveAspectRatio is false.\n     *\n     * @param event - The keyboard event\n     */ this.handleKeyDown = (event)=>{\n            if (event.key === \"Shift\") {\n                this.isShiftKeyPressed = true;\n            }\n        };\n        /**\n     * Tracks Shift key release to disable temporary aspect ratio locking.\n     *\n     * @param event - The keyboard event\n     */ this.handleKeyUp = (event)=>{\n            if (event.key === \"Shift\") {\n                this.isShiftKeyPressed = false;\n            }\n        };\n        var _a, _b, _c, _d, _e, _f;\n        this.node = options.node;\n        this.editor = options.editor;\n        this.element = options.element;\n        this.contentElement = options.contentElement;\n        this.getPos = options.getPos;\n        this.onResize = options.onResize;\n        this.onCommit = options.onCommit;\n        this.onUpdate = options.onUpdate;\n        if ((_a = options.options) == null ? void 0 : _a.min) {\n            this.minSize = {\n                ...this.minSize,\n                ...options.options.min\n            };\n        }\n        if ((_b = options.options) == null ? void 0 : _b.max) {\n            this.maxSize = options.options.max;\n        }\n        if ((_c = options == null ? void 0 : options.options) == null ? void 0 : _c.directions) {\n            this.directions = options.options.directions;\n        }\n        if ((_d = options.options) == null ? void 0 : _d.preserveAspectRatio) {\n            this.preserveAspectRatio = options.options.preserveAspectRatio;\n        }\n        if ((_e = options.options) == null ? void 0 : _e.className) {\n            this.classNames = {\n                container: options.options.className.container || \"\",\n                wrapper: options.options.className.wrapper || \"\",\n                handle: options.options.className.handle || \"\",\n                resizing: options.options.className.resizing || \"\"\n            };\n        }\n        if ((_f = options.options) == null ? void 0 : _f.createCustomHandle) {\n            this.createCustomHandle = options.options.createCustomHandle;\n        }\n        this.wrapper = this.createWrapper();\n        this.container = this.createContainer();\n        this.applyInitialSize();\n        this.attachHandles();\n        this.editor.on(\"update\", this.handleEditorUpdate.bind(this));\n    }\n    /**\n   * Returns the top-level DOM node that should be placed in the editor.\n   *\n   * This is required by the ProseMirror NodeView interface. The container\n   * includes the wrapper, handles, and the actual content element.\n   *\n   * @returns The container element to be inserted into the editor\n   */ get dom() {\n        return this.container;\n    }\n    get contentDOM() {\n        return this.contentElement;\n    }\n    handleEditorUpdate() {\n        const isEditable = this.editor.isEditable;\n        if (isEditable === this.lastEditableState) {\n            return;\n        }\n        this.lastEditableState = isEditable;\n        if (!isEditable) {\n            this.removeHandles();\n        } else if (isEditable && this.handleMap.size === 0) {\n            this.attachHandles();\n        }\n    }\n    /**\n   * Called when the node's content or attributes change.\n   *\n   * Updates the internal node reference. If a custom `onUpdate` callback\n   * was provided, it will be called to handle additional update logic.\n   *\n   * @param node - The new/updated node\n   * @param decorations - Node decorations\n   * @param innerDecorations - Inner decorations\n   * @returns `false` if the node type has changed (requires full rebuild), otherwise the result of `onUpdate` or `true`\n   */ update(node, decorations, innerDecorations) {\n        if (node.type !== this.node.type) {\n            return false;\n        }\n        this.node = node;\n        if (this.onUpdate) {\n            return this.onUpdate(node, decorations, innerDecorations);\n        }\n        return true;\n    }\n    /**\n   * Cleanup method called when the node view is being removed.\n   *\n   * Removes all event listeners to prevent memory leaks. This is required\n   * by the ProseMirror NodeView interface. If a resize is active when\n   * destroy is called, it will be properly cancelled.\n   */ destroy() {\n        if (this.isResizing) {\n            this.container.dataset.resizeState = \"false\";\n            if (this.classNames.resizing) {\n                this.container.classList.remove(this.classNames.resizing);\n            }\n            document.removeEventListener(\"mousemove\", this.handleMouseMove);\n            document.removeEventListener(\"mouseup\", this.handleMouseUp);\n            document.removeEventListener(\"keydown\", this.handleKeyDown);\n            document.removeEventListener(\"keyup\", this.handleKeyUp);\n            this.isResizing = false;\n            this.activeHandle = null;\n        }\n        this.editor.off(\"update\", this.handleEditorUpdate.bind(this));\n        this.container.remove();\n    }\n    /**\n   * Creates the outer container element.\n   *\n   * The container is the top-level element returned by the NodeView and\n   * wraps the entire resizable node. It's set up with flexbox to handle\n   * alignment and includes data attributes for styling and identification.\n   *\n   * @returns The container element\n   */ createContainer() {\n        const element = document.createElement(\"div\");\n        element.dataset.resizeContainer = \"\";\n        element.dataset.node = this.node.type.name;\n        element.style.display = \"flex\";\n        if (this.classNames.container) {\n            element.className = this.classNames.container;\n        }\n        element.appendChild(this.wrapper);\n        return element;\n    }\n    /**\n   * Creates the wrapper element that contains the content and handles.\n   *\n   * The wrapper uses relative positioning so that resize handles can be\n   * positioned absolutely within it. This is the direct parent of the\n   * content element being made resizable.\n   *\n   * @returns The wrapper element\n   */ createWrapper() {\n        const element = document.createElement(\"div\");\n        element.style.position = \"relative\";\n        element.style.display = \"block\";\n        element.dataset.resizeWrapper = \"\";\n        if (this.classNames.wrapper) {\n            element.className = this.classNames.wrapper;\n        }\n        element.appendChild(this.element);\n        return element;\n    }\n    /**\n   * Creates a resize handle element for a specific direction.\n   *\n   * Each handle is absolutely positioned and includes a data attribute\n   * identifying its direction for styling purposes.\n   *\n   * @param direction - The resize direction for this handle\n   * @returns The handle element\n   */ createHandle(direction) {\n        const handle = document.createElement(\"div\");\n        handle.dataset.resizeHandle = direction;\n        handle.style.position = \"absolute\";\n        if (this.classNames.handle) {\n            handle.className = this.classNames.handle;\n        }\n        return handle;\n    }\n    /**\n   * Positions a handle element according to its direction.\n   *\n   * Corner handles (e.g., 'top-left') are positioned at the intersection\n   * of two edges. Edge handles (e.g., 'top') span the full width or height.\n   *\n   * @param handle - The handle element to position\n   * @param direction - The direction determining the position\n   */ positionHandle(handle, direction) {\n        const isTop = direction.includes(\"top\");\n        const isBottom = direction.includes(\"bottom\");\n        const isLeft = direction.includes(\"left\");\n        const isRight = direction.includes(\"right\");\n        if (isTop) {\n            handle.style.top = \"0\";\n        }\n        if (isBottom) {\n            handle.style.bottom = \"0\";\n        }\n        if (isLeft) {\n            handle.style.left = \"0\";\n        }\n        if (isRight) {\n            handle.style.right = \"0\";\n        }\n        if (direction === \"top\" || direction === \"bottom\") {\n            handle.style.left = \"0\";\n            handle.style.right = \"0\";\n        }\n        if (direction === \"left\" || direction === \"right\") {\n            handle.style.top = \"0\";\n            handle.style.bottom = \"0\";\n        }\n    }\n    /**\n   * Creates and attaches all resize handles to the wrapper.\n   *\n   * Iterates through the configured directions, creates a handle for each,\n   * positions it, attaches the mousedown listener, and appends it to the DOM.\n   */ attachHandles() {\n        this.directions.forEach((direction)=>{\n            let handle;\n            if (this.createCustomHandle) {\n                handle = this.createCustomHandle(direction);\n            } else {\n                handle = this.createHandle(direction);\n            }\n            if (!(handle instanceof HTMLElement)) {\n                console.warn(`[ResizableNodeView] createCustomHandle(\"${direction}\") did not return an HTMLElement. Falling back to default handle.`);\n                handle = this.createHandle(direction);\n            }\n            if (!this.createCustomHandle) {\n                this.positionHandle(handle, direction);\n            }\n            handle.addEventListener(\"mousedown\", (event)=>this.handleResizeStart(event, direction));\n            handle.addEventListener(\"touchstart\", (event)=>this.handleResizeStart(event, direction));\n            this.handleMap.set(direction, handle);\n            this.wrapper.appendChild(handle);\n        });\n    }\n    /**\n   * Removes all resize handles from the wrapper.\n   *\n   * Cleans up the handle map and removes each handle element from the DOM.\n   */ removeHandles() {\n        this.handleMap.forEach((el)=>el.remove());\n        this.handleMap.clear();\n    }\n    /**\n   * Applies initial sizing from node attributes to the element.\n   *\n   * If width/height attributes exist on the node, they're applied to the element.\n   * Otherwise, the element's natural/current dimensions are measured. The aspect\n   * ratio is calculated for later use in aspect-ratio-preserving resizes.\n   */ applyInitialSize() {\n        const width = this.node.attrs.width;\n        const height = this.node.attrs.height;\n        if (width) {\n            this.element.style.width = `${width}px`;\n            this.initialWidth = width;\n        } else {\n            this.initialWidth = this.element.offsetWidth;\n        }\n        if (height) {\n            this.element.style.height = `${height}px`;\n            this.initialHeight = height;\n        } else {\n            this.initialHeight = this.element.offsetHeight;\n        }\n        if (this.initialWidth > 0 && this.initialHeight > 0) {\n            this.aspectRatio = this.initialWidth / this.initialHeight;\n        }\n    }\n    /**\n   * Initiates a resize operation when a handle is clicked.\n   *\n   * Captures the starting mouse position and element dimensions, sets up\n   * the resize state, adds the resizing class and state attribute, and\n   * attaches document-level listeners for mouse movement and keyboard input.\n   *\n   * @param event - The mouse down event\n   * @param direction - The direction of the handle being dragged\n   */ handleResizeStart(event, direction) {\n        event.preventDefault();\n        event.stopPropagation();\n        this.isResizing = true;\n        this.activeHandle = direction;\n        if (isTouchEvent(event)) {\n            this.startX = event.touches[0].clientX;\n            this.startY = event.touches[0].clientY;\n        } else {\n            this.startX = event.clientX;\n            this.startY = event.clientY;\n        }\n        this.startWidth = this.element.offsetWidth;\n        this.startHeight = this.element.offsetHeight;\n        if (this.startWidth > 0 && this.startHeight > 0) {\n            this.aspectRatio = this.startWidth / this.startHeight;\n        }\n        const pos = this.getPos();\n        if (pos !== void 0) {}\n        this.container.dataset.resizeState = \"true\";\n        if (this.classNames.resizing) {\n            this.container.classList.add(this.classNames.resizing);\n        }\n        document.addEventListener(\"mousemove\", this.handleMouseMove);\n        document.addEventListener(\"touchmove\", this.handleTouchMove);\n        document.addEventListener(\"mouseup\", this.handleMouseUp);\n        document.addEventListener(\"keydown\", this.handleKeyDown);\n        document.addEventListener(\"keyup\", this.handleKeyUp);\n    }\n    handleResize(deltaX, deltaY) {\n        if (!this.activeHandle) {\n            return;\n        }\n        const shouldPreserveAspectRatio = this.preserveAspectRatio || this.isShiftKeyPressed;\n        const { width, height } = this.calculateNewDimensions(this.activeHandle, deltaX, deltaY);\n        const constrained = this.applyConstraints(width, height, shouldPreserveAspectRatio);\n        this.element.style.width = `${constrained.width}px`;\n        this.element.style.height = `${constrained.height}px`;\n        if (this.onResize) {\n            this.onResize(constrained.width, constrained.height);\n        }\n    }\n    /**\n   * Calculates new dimensions based on mouse delta and resize direction.\n   *\n   * Takes the starting dimensions and applies the mouse movement delta\n   * according to the handle direction. For corner handles, both dimensions\n   * are affected. For edge handles, only one dimension changes. If aspect\n   * ratio should be preserved, delegates to applyAspectRatio.\n   *\n   * @param direction - The active resize handle direction\n   * @param deltaX - Horizontal mouse movement since resize start\n   * @param deltaY - Vertical mouse movement since resize start\n   * @returns The calculated width and height\n   */ calculateNewDimensions(direction, deltaX, deltaY) {\n        let newWidth = this.startWidth;\n        let newHeight = this.startHeight;\n        const isRight = direction.includes(\"right\");\n        const isLeft = direction.includes(\"left\");\n        const isBottom = direction.includes(\"bottom\");\n        const isTop = direction.includes(\"top\");\n        if (isRight) {\n            newWidth = this.startWidth + deltaX;\n        } else if (isLeft) {\n            newWidth = this.startWidth - deltaX;\n        }\n        if (isBottom) {\n            newHeight = this.startHeight + deltaY;\n        } else if (isTop) {\n            newHeight = this.startHeight - deltaY;\n        }\n        if (direction === \"right\" || direction === \"left\") {\n            newWidth = this.startWidth + (isRight ? deltaX : -deltaX);\n        }\n        if (direction === \"top\" || direction === \"bottom\") {\n            newHeight = this.startHeight + (isBottom ? deltaY : -deltaY);\n        }\n        const shouldPreserveAspectRatio = this.preserveAspectRatio || this.isShiftKeyPressed;\n        if (shouldPreserveAspectRatio) {\n            return this.applyAspectRatio(newWidth, newHeight, direction);\n        }\n        return {\n            width: newWidth,\n            height: newHeight\n        };\n    }\n    /**\n   * Applies min/max constraints to dimensions.\n   *\n   * When aspect ratio is NOT preserved, constraints are applied independently\n   * to width and height. When aspect ratio IS preserved, constraints are\n   * applied while maintaining the aspect ratioif one dimension hits a limit,\n   * the other is recalculated proportionally.\n   *\n   * This ensures that aspect ratio is never broken when constrained.\n   *\n   * @param width - The unconstrained width\n   * @param height - The unconstrained height\n   * @param preserveAspectRatio - Whether to maintain aspect ratio while constraining\n   * @returns The constrained dimensions\n   */ applyConstraints(width, height, preserveAspectRatio) {\n        var _a, _b, _c, _d;\n        if (!preserveAspectRatio) {\n            let constrainedWidth2 = Math.max(this.minSize.width, width);\n            let constrainedHeight2 = Math.max(this.minSize.height, height);\n            if ((_a = this.maxSize) == null ? void 0 : _a.width) {\n                constrainedWidth2 = Math.min(this.maxSize.width, constrainedWidth2);\n            }\n            if ((_b = this.maxSize) == null ? void 0 : _b.height) {\n                constrainedHeight2 = Math.min(this.maxSize.height, constrainedHeight2);\n            }\n            return {\n                width: constrainedWidth2,\n                height: constrainedHeight2\n            };\n        }\n        let constrainedWidth = width;\n        let constrainedHeight = height;\n        if (constrainedWidth < this.minSize.width) {\n            constrainedWidth = this.minSize.width;\n            constrainedHeight = constrainedWidth / this.aspectRatio;\n        }\n        if (constrainedHeight < this.minSize.height) {\n            constrainedHeight = this.minSize.height;\n            constrainedWidth = constrainedHeight * this.aspectRatio;\n        }\n        if (((_c = this.maxSize) == null ? void 0 : _c.width) && constrainedWidth > this.maxSize.width) {\n            constrainedWidth = this.maxSize.width;\n            constrainedHeight = constrainedWidth / this.aspectRatio;\n        }\n        if (((_d = this.maxSize) == null ? void 0 : _d.height) && constrainedHeight > this.maxSize.height) {\n            constrainedHeight = this.maxSize.height;\n            constrainedWidth = constrainedHeight * this.aspectRatio;\n        }\n        return {\n            width: constrainedWidth,\n            height: constrainedHeight\n        };\n    }\n    /**\n   * Adjusts dimensions to maintain the original aspect ratio.\n   *\n   * For horizontal handles (left/right), uses width as the primary dimension\n   * and calculates height from it. For vertical handles (top/bottom), uses\n   * height as primary and calculates width. For corner handles, uses width\n   * as the primary dimension.\n   *\n   * @param width - The new width\n   * @param height - The new height\n   * @param direction - The active resize direction\n   * @returns Dimensions adjusted to preserve aspect ratio\n   */ applyAspectRatio(width, height, direction) {\n        const isHorizontal = direction === \"left\" || direction === \"right\";\n        const isVertical = direction === \"top\" || direction === \"bottom\";\n        if (isHorizontal) {\n            return {\n                width,\n                height: width / this.aspectRatio\n            };\n        }\n        if (isVertical) {\n            return {\n                width: height * this.aspectRatio,\n                height\n            };\n        }\n        return {\n            width,\n            height: width / this.aspectRatio\n        };\n    }\n};\nvar ResizableNodeview = ResizableNodeView;\n// src/utilities/canInsertNode.ts\n\nfunction canInsertNode(state, nodeType) {\n    const { selection } = state;\n    const { $from } = selection;\n    if (selection instanceof _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.NodeSelection) {\n        const index = $from.index();\n        const parent = $from.parent;\n        return parent.canReplaceWith(index, index + 1, nodeType);\n    }\n    let depth = $from.depth;\n    while(depth >= 0){\n        const index = $from.index(depth);\n        const parent = $from.node(depth);\n        const match = parent.contentMatchAt(index);\n        if (match.matchType(nodeType)) {\n            return true;\n        }\n        depth -= 1;\n    }\n    return false;\n}\n// src/utilities/escapeForRegEx.ts\nfunction escapeForRegEx(string) {\n    return string.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n}\n// src/utilities/isString.ts\nfunction isString(value) {\n    return typeof value === \"string\";\n}\n// src/utilities/markdown/index.ts\nvar markdown_exports = {};\n__export(markdown_exports, {\n    createAtomBlockMarkdownSpec: ()=>createAtomBlockMarkdownSpec,\n    createBlockMarkdownSpec: ()=>createBlockMarkdownSpec,\n    createInlineMarkdownSpec: ()=>createInlineMarkdownSpec,\n    parseAttributes: ()=>parseAttributes,\n    parseIndentedBlocks: ()=>parseIndentedBlocks,\n    renderNestedMarkdownContent: ()=>renderNestedMarkdownContent,\n    serializeAttributes: ()=>serializeAttributes\n});\n// src/utilities/markdown/attributeUtils.ts\nfunction parseAttributes(attrString) {\n    if (!(attrString == null ? void 0 : attrString.trim())) {\n        return {};\n    }\n    const attributes = {};\n    const quotedStrings = [];\n    const tempString = attrString.replace(/[\"']([^\"']*)[\"']/g, (match)=>{\n        quotedStrings.push(match);\n        return `__QUOTED_${quotedStrings.length - 1}__`;\n    });\n    const classMatches = tempString.match(/(?:^|\\s)\\.([a-zA-Z][\\w-]*)/g);\n    if (classMatches) {\n        const classes = classMatches.map((match)=>match.trim().slice(1));\n        attributes.class = classes.join(\" \");\n    }\n    const idMatch = tempString.match(/(?:^|\\s)#([a-zA-Z][\\w-]*)/);\n    if (idMatch) {\n        attributes.id = idMatch[1];\n    }\n    const kvRegex = /([a-zA-Z][\\w-]*)\\s*=\\s*(__QUOTED_\\d+__)/g;\n    const kvMatches = Array.from(tempString.matchAll(kvRegex));\n    kvMatches.forEach(([, key, quotedRef])=>{\n        var _a;\n        const quotedIndex = parseInt(((_a = quotedRef.match(/__QUOTED_(\\d+)__/)) == null ? void 0 : _a[1]) || \"0\", 10);\n        const quotedValue = quotedStrings[quotedIndex];\n        if (quotedValue) {\n            attributes[key] = quotedValue.slice(1, -1);\n        }\n    });\n    const cleanString = tempString.replace(/(?:^|\\s)\\.([a-zA-Z][\\w-]*)/g, \"\").replace(/(?:^|\\s)#([a-zA-Z][\\w-]*)/g, \"\").replace(/([a-zA-Z][\\w-]*)\\s*=\\s*__QUOTED_\\d+__/g, \"\").trim();\n    if (cleanString) {\n        const booleanAttrs = cleanString.split(/\\s+/).filter(Boolean);\n        booleanAttrs.forEach((attr)=>{\n            if (attr.match(/^[a-zA-Z][\\w-]*$/)) {\n                attributes[attr] = true;\n            }\n        });\n    }\n    return attributes;\n}\nfunction serializeAttributes(attributes) {\n    if (!attributes || Object.keys(attributes).length === 0) {\n        return \"\";\n    }\n    const parts = [];\n    if (attributes.class) {\n        const classes = String(attributes.class).split(/\\s+/).filter(Boolean);\n        classes.forEach((cls)=>parts.push(`.${cls}`));\n    }\n    if (attributes.id) {\n        parts.push(`#${attributes.id}`);\n    }\n    Object.entries(attributes).forEach(([key, value])=>{\n        if (key === \"class\" || key === \"id\") {\n            return;\n        }\n        if (value === true) {\n            parts.push(key);\n        } else if (value !== false && value != null) {\n            parts.push(`${key}=\"${String(value)}\"`);\n        }\n    });\n    return parts.join(\" \");\n}\n// src/utilities/markdown/createAtomBlockMarkdownSpec.ts\nfunction createAtomBlockMarkdownSpec(options) {\n    const { nodeName, name: markdownName, parseAttributes: parseAttributes2 = parseAttributes, serializeAttributes: serializeAttributes2 = serializeAttributes, defaultAttributes = {}, requiredAttributes = [], allowedAttributes } = options;\n    const blockName = markdownName || nodeName;\n    const filterAttributes = (attrs)=>{\n        if (!allowedAttributes) {\n            return attrs;\n        }\n        const filtered = {};\n        allowedAttributes.forEach((key)=>{\n            if (key in attrs) {\n                filtered[key] = attrs[key];\n            }\n        });\n        return filtered;\n    };\n    return {\n        parseMarkdown: (token, h2)=>{\n            const attrs = {\n                ...defaultAttributes,\n                ...token.attributes\n            };\n            return h2.createNode(nodeName, attrs, []);\n        },\n        markdownTokenizer: {\n            name: nodeName,\n            level: \"block\",\n            start (src) {\n                var _a;\n                const regex = new RegExp(`^:::${blockName}(?:\\\\s|$)`, \"m\");\n                const index = (_a = src.match(regex)) == null ? void 0 : _a.index;\n                return index !== void 0 ? index : -1;\n            },\n            tokenize (src, _tokens, _lexer) {\n                const regex = new RegExp(`^:::${blockName}(?:\\\\s+\\\\{([^}]*)\\\\})?\\\\s*:::(?:\\\\n|$)`);\n                const match = src.match(regex);\n                if (!match) {\n                    return void 0;\n                }\n                const attrString = match[1] || \"\";\n                const attributes = parseAttributes2(attrString);\n                const missingRequired = requiredAttributes.find((required)=>!(required in attributes));\n                if (missingRequired) {\n                    return void 0;\n                }\n                return {\n                    type: nodeName,\n                    raw: match[0],\n                    attributes\n                };\n            }\n        },\n        renderMarkdown: (node)=>{\n            const filteredAttrs = filterAttributes(node.attrs || {});\n            const attrs = serializeAttributes2(filteredAttrs);\n            const attrString = attrs ? ` {${attrs}}` : \"\";\n            return `:::${blockName}${attrString} :::`;\n        }\n    };\n}\n// src/utilities/markdown/createBlockMarkdownSpec.ts\nfunction createBlockMarkdownSpec(options) {\n    const { nodeName, name: markdownName, getContent, parseAttributes: parseAttributes2 = parseAttributes, serializeAttributes: serializeAttributes2 = serializeAttributes, defaultAttributes = {}, content = \"block\", allowedAttributes } = options;\n    const blockName = markdownName || nodeName;\n    const filterAttributes = (attrs)=>{\n        if (!allowedAttributes) {\n            return attrs;\n        }\n        const filtered = {};\n        allowedAttributes.forEach((key)=>{\n            if (key in attrs) {\n                filtered[key] = attrs[key];\n            }\n        });\n        return filtered;\n    };\n    return {\n        parseMarkdown: (token, h2)=>{\n            let nodeContent;\n            if (getContent) {\n                const contentResult = getContent(token);\n                nodeContent = typeof contentResult === \"string\" ? [\n                    {\n                        type: \"text\",\n                        text: contentResult\n                    }\n                ] : contentResult;\n            } else if (content === \"block\") {\n                nodeContent = h2.parseChildren(token.tokens || []);\n            } else {\n                nodeContent = h2.parseInline(token.tokens || []);\n            }\n            const attrs = {\n                ...defaultAttributes,\n                ...token.attributes\n            };\n            return h2.createNode(nodeName, attrs, nodeContent);\n        },\n        markdownTokenizer: {\n            name: nodeName,\n            level: \"block\",\n            start (src) {\n                var _a;\n                const regex = new RegExp(`^:::${blockName}`, \"m\");\n                const index = (_a = src.match(regex)) == null ? void 0 : _a.index;\n                return index !== void 0 ? index : -1;\n            },\n            tokenize (src, _tokens, lexer) {\n                var _a;\n                const openingRegex = new RegExp(`^:::${blockName}(?:\\\\s+\\\\{([^}]*)\\\\})?\\\\s*\\\\n`);\n                const openingMatch = src.match(openingRegex);\n                if (!openingMatch) {\n                    return void 0;\n                }\n                const [openingTag, attrString = \"\"] = openingMatch;\n                const attributes = parseAttributes2(attrString);\n                let level = 1;\n                const position = openingTag.length;\n                let matchedContent = \"\";\n                const blockPattern = /^:::([\\w-]*)(\\s.*)?/gm;\n                const remaining = src.slice(position);\n                blockPattern.lastIndex = 0;\n                for(;;){\n                    const match = blockPattern.exec(remaining);\n                    if (match === null) {\n                        break;\n                    }\n                    const matchPos = match.index;\n                    const blockType = match[1];\n                    if ((_a = match[2]) == null ? void 0 : _a.endsWith(\":::\")) {\n                        continue;\n                    }\n                    if (blockType) {\n                        level += 1;\n                    } else {\n                        level -= 1;\n                        if (level === 0) {\n                            const rawContent = remaining.slice(0, matchPos);\n                            matchedContent = rawContent.trim();\n                            const fullMatch = src.slice(0, position + matchPos + match[0].length);\n                            let contentTokens = [];\n                            if (matchedContent) {\n                                if (content === \"block\") {\n                                    contentTokens = lexer.blockTokens(rawContent);\n                                    contentTokens.forEach((token)=>{\n                                        if (token.text && (!token.tokens || token.tokens.length === 0)) {\n                                            token.tokens = lexer.inlineTokens(token.text);\n                                        }\n                                    });\n                                    while(contentTokens.length > 0){\n                                        const lastToken = contentTokens[contentTokens.length - 1];\n                                        if (lastToken.type === \"paragraph\" && (!lastToken.text || lastToken.text.trim() === \"\")) {\n                                            contentTokens.pop();\n                                        } else {\n                                            break;\n                                        }\n                                    }\n                                } else {\n                                    contentTokens = lexer.inlineTokens(matchedContent);\n                                }\n                            }\n                            return {\n                                type: nodeName,\n                                raw: fullMatch,\n                                attributes,\n                                content: matchedContent,\n                                tokens: contentTokens\n                            };\n                        }\n                    }\n                }\n                return void 0;\n            }\n        },\n        renderMarkdown: (node, h2)=>{\n            const filteredAttrs = filterAttributes(node.attrs || {});\n            const attrs = serializeAttributes2(filteredAttrs);\n            const attrString = attrs ? ` {${attrs}}` : \"\";\n            const renderedContent = h2.renderChildren(node.content || [], \"\\n\\n\");\n            return `:::${blockName}${attrString}\n\n${renderedContent}\n\n:::`;\n        }\n    };\n}\n// src/utilities/markdown/createInlineMarkdownSpec.ts\nfunction parseShortcodeAttributes(attrString) {\n    if (!attrString.trim()) {\n        return {};\n    }\n    const attributes = {};\n    const regex = /(\\w+)=(?:\"([^\"]*)\"|'([^']*)')/g;\n    let match = regex.exec(attrString);\n    while(match !== null){\n        const [, key, doubleQuoted, singleQuoted] = match;\n        attributes[key] = doubleQuoted || singleQuoted;\n        match = regex.exec(attrString);\n    }\n    return attributes;\n}\nfunction serializeShortcodeAttributes(attrs) {\n    return Object.entries(attrs).filter(([, value])=>value !== void 0 && value !== null).map(([key, value])=>`${key}=\"${value}\"`).join(\" \");\n}\nfunction createInlineMarkdownSpec(options) {\n    const { nodeName, name: shortcodeName, getContent, parseAttributes: parseAttributes2 = parseShortcodeAttributes, serializeAttributes: serializeAttributes2 = serializeShortcodeAttributes, defaultAttributes = {}, selfClosing = false, allowedAttributes } = options;\n    const shortcode = shortcodeName || nodeName;\n    const filterAttributes = (attrs)=>{\n        if (!allowedAttributes) {\n            return attrs;\n        }\n        const filtered = {};\n        allowedAttributes.forEach((attr)=>{\n            const attrName = typeof attr === \"string\" ? attr : attr.name;\n            const skipIfDefault = typeof attr === \"string\" ? void 0 : attr.skipIfDefault;\n            if (attrName in attrs) {\n                const value = attrs[attrName];\n                if (skipIfDefault !== void 0 && value === skipIfDefault) {\n                    return;\n                }\n                filtered[attrName] = value;\n            }\n        });\n        return filtered;\n    };\n    const escapedShortcode = shortcode.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n    return {\n        parseMarkdown: (token, h2)=>{\n            const attrs = {\n                ...defaultAttributes,\n                ...token.attributes\n            };\n            if (selfClosing) {\n                return h2.createNode(nodeName, attrs);\n            }\n            const content = getContent ? getContent(token) : token.content || \"\";\n            if (content) {\n                return h2.createNode(nodeName, attrs, [\n                    h2.createTextNode(content)\n                ]);\n            }\n            return h2.createNode(nodeName, attrs, []);\n        },\n        markdownTokenizer: {\n            name: nodeName,\n            level: \"inline\",\n            start (src) {\n                const startPattern = selfClosing ? new RegExp(`\\\\[${escapedShortcode}\\\\s*[^\\\\]]*\\\\]`) : new RegExp(`\\\\[${escapedShortcode}\\\\s*[^\\\\]]*\\\\][\\\\s\\\\S]*?\\\\[\\\\/${escapedShortcode}\\\\]`);\n                const match = src.match(startPattern);\n                const index = match == null ? void 0 : match.index;\n                return index !== void 0 ? index : -1;\n            },\n            tokenize (src, _tokens, _lexer) {\n                const tokenPattern = selfClosing ? new RegExp(`^\\\\[${escapedShortcode}\\\\s*([^\\\\]]*)\\\\]`) : new RegExp(`^\\\\[${escapedShortcode}\\\\s*([^\\\\]]*)\\\\]([\\\\s\\\\S]*?)\\\\[\\\\/${escapedShortcode}\\\\]`);\n                const match = src.match(tokenPattern);\n                if (!match) {\n                    return void 0;\n                }\n                let content = \"\";\n                let attrString = \"\";\n                if (selfClosing) {\n                    const [, attrs] = match;\n                    attrString = attrs;\n                } else {\n                    const [, attrs, contentMatch] = match;\n                    attrString = attrs;\n                    content = contentMatch || \"\";\n                }\n                const attributes = parseAttributes2(attrString.trim());\n                return {\n                    type: nodeName,\n                    raw: match[0],\n                    content: content.trim(),\n                    attributes\n                };\n            }\n        },\n        renderMarkdown: (node)=>{\n            let content = \"\";\n            if (getContent) {\n                content = getContent(node);\n            } else if (node.content && node.content.length > 0) {\n                content = node.content.filter((child)=>child.type === \"text\").map((child)=>child.text).join(\"\");\n            }\n            const filteredAttrs = filterAttributes(node.attrs || {});\n            const attrs = serializeAttributes2(filteredAttrs);\n            const attrString = attrs ? ` ${attrs}` : \"\";\n            if (selfClosing) {\n                return `[${shortcode}${attrString}]`;\n            }\n            return `[${shortcode}${attrString}]${content}[/${shortcode}]`;\n        }\n    };\n}\n// src/utilities/markdown/parseIndentedBlocks.ts\nfunction parseIndentedBlocks(src, config, lexer) {\n    var _a, _b, _c, _d;\n    const lines = src.split(\"\\n\");\n    const items = [];\n    let totalRaw = \"\";\n    let i = 0;\n    const baseIndentSize = config.baseIndentSize || 2;\n    while(i < lines.length){\n        const currentLine = lines[i];\n        const itemMatch = currentLine.match(config.itemPattern);\n        if (!itemMatch) {\n            if (items.length > 0) {\n                break;\n            } else if (currentLine.trim() === \"\") {\n                i += 1;\n                totalRaw = `${totalRaw}${currentLine}\n`;\n                continue;\n            } else {\n                return void 0;\n            }\n        }\n        const itemData = config.extractItemData(itemMatch);\n        const { indentLevel, mainContent } = itemData;\n        totalRaw = `${totalRaw}${currentLine}\n`;\n        const itemContent = [\n            mainContent\n        ];\n        i += 1;\n        while(i < lines.length){\n            const nextLine = lines[i];\n            if (nextLine.trim() === \"\") {\n                const nextNonEmptyIndex = lines.slice(i + 1).findIndex((l)=>l.trim() !== \"\");\n                if (nextNonEmptyIndex === -1) {\n                    break;\n                }\n                const nextNonEmpty = lines[i + 1 + nextNonEmptyIndex];\n                const nextIndent2 = ((_b = (_a = nextNonEmpty.match(/^(\\s*)/)) == null ? void 0 : _a[1]) == null ? void 0 : _b.length) || 0;\n                if (nextIndent2 > indentLevel) {\n                    itemContent.push(nextLine);\n                    totalRaw = `${totalRaw}${nextLine}\n`;\n                    i += 1;\n                    continue;\n                } else {\n                    break;\n                }\n            }\n            const nextIndent = ((_d = (_c = nextLine.match(/^(\\s*)/)) == null ? void 0 : _c[1]) == null ? void 0 : _d.length) || 0;\n            if (nextIndent > indentLevel) {\n                itemContent.push(nextLine);\n                totalRaw = `${totalRaw}${nextLine}\n`;\n                i += 1;\n            } else {\n                break;\n            }\n        }\n        let nestedTokens;\n        const nestedContent = itemContent.slice(1);\n        if (nestedContent.length > 0) {\n            const dedentedNested = nestedContent.map((nestedLine)=>nestedLine.slice(indentLevel + baseIndentSize)).join(\"\\n\");\n            if (dedentedNested.trim()) {\n                if (config.customNestedParser) {\n                    nestedTokens = config.customNestedParser(dedentedNested);\n                } else {\n                    nestedTokens = lexer.blockTokens(dedentedNested);\n                }\n            }\n        }\n        const token = config.createToken(itemData, nestedTokens);\n        items.push(token);\n    }\n    if (items.length === 0) {\n        return void 0;\n    }\n    return {\n        items,\n        raw: totalRaw\n    };\n}\n// src/utilities/markdown/renderNestedMarkdownContent.ts\nfunction renderNestedMarkdownContent(node, h2, prefixOrGenerator, ctx) {\n    if (!node || !Array.isArray(node.content)) {\n        return \"\";\n    }\n    const prefix = typeof prefixOrGenerator === \"function\" ? prefixOrGenerator(ctx) : prefixOrGenerator;\n    const [content, ...children] = node.content;\n    const mainContent = h2.renderChildren([\n        content\n    ]);\n    const output = [\n        `${prefix}${mainContent}`\n    ];\n    if (children && children.length > 0) {\n        children.forEach((child)=>{\n            const childContent = h2.renderChildren([\n                child\n            ]);\n            if (childContent) {\n                const indentedChild = childContent.split(\"\\n\").map((line)=>line ? h2.indent(line) : \"\").join(\"\\n\");\n                output.push(indentedChild);\n            }\n        });\n    }\n    return output.join(\"\\n\");\n}\n// src/MarkView.ts\nfunction updateMarkViewAttributes(checkMark, editor, attrs = {}) {\n    const { state } = editor;\n    const { doc, tr } = state;\n    const thisMark = checkMark;\n    doc.descendants((node, pos)=>{\n        const from = tr.mapping.map(pos);\n        const to = tr.mapping.map(pos) + node.nodeSize;\n        let foundMark = null;\n        node.marks.forEach((mark)=>{\n            if (mark !== thisMark) {\n                return false;\n            }\n            foundMark = mark;\n        });\n        if (!foundMark) {\n            return;\n        }\n        let needsUpdate = false;\n        Object.keys(attrs).forEach((k)=>{\n            if (attrs[k] !== foundMark.attrs[k]) {\n                needsUpdate = true;\n            }\n        });\n        if (needsUpdate) {\n            const updatedMark = checkMark.type.create({\n                ...checkMark.attrs,\n                ...attrs\n            });\n            tr.removeMark(from, to, checkMark.type);\n            tr.addMark(from, to, updatedMark);\n        }\n    });\n    if (tr.docChanged) {\n        editor.view.dispatch(tr);\n    }\n}\nvar MarkView = class {\n    constructor(component, props, options){\n        this.component = component;\n        this.editor = props.editor;\n        this.options = {\n            ...options\n        };\n        this.mark = props.mark;\n        this.HTMLAttributes = props.HTMLAttributes;\n    }\n    get dom() {\n        return this.editor.view.dom;\n    }\n    get contentDOM() {\n        return null;\n    }\n    /**\n   * Update the attributes of the mark in the document.\n   * @param attrs The attributes to update.\n   */ updateAttributes(attrs, checkMark) {\n        updateMarkViewAttributes(checkMark || this.mark, this.editor, attrs);\n    }\n    ignoreMutation(mutation) {\n        if (!this.dom || !this.contentDOM) {\n            return true;\n        }\n        if (typeof this.options.ignoreMutation === \"function\") {\n            return this.options.ignoreMutation({\n                mutation\n            });\n        }\n        if (mutation.type === \"selection\") {\n            return false;\n        }\n        if (this.dom.contains(mutation.target) && mutation.type === \"childList\" && (isiOS() || isAndroid()) && this.editor.isFocused) {\n            const changedNodes = [\n                ...Array.from(mutation.addedNodes),\n                ...Array.from(mutation.removedNodes)\n            ];\n            if (changedNodes.every((node)=>node.isContentEditable)) {\n                return false;\n            }\n        }\n        if (this.contentDOM === mutation.target && mutation.type === \"attributes\") {\n            return true;\n        }\n        if (this.contentDOM.contains(mutation.target)) {\n            return false;\n        }\n        return true;\n    }\n};\n// src/Node.ts\nvar Node3 = class _Node extends Extendable {\n    constructor(){\n        super(...arguments);\n        this.type = \"node\";\n    }\n    /**\n   * Create a new Node instance\n   * @param config - Node configuration object or a function that returns a configuration object\n   */ static create(config = {}) {\n        const resolvedConfig = typeof config === \"function\" ? config() : config;\n        return new _Node(resolvedConfig);\n    }\n    configure(options) {\n        return super.configure(options);\n    }\n    extend(extendedConfig) {\n        const resolvedConfig = typeof extendedConfig === \"function\" ? extendedConfig() : extendedConfig;\n        return super.extend(resolvedConfig);\n    }\n};\n// src/NodeView.ts\n\nvar NodeView = class {\n    constructor(component, props, options){\n        this.isDragging = false;\n        this.component = component;\n        this.editor = props.editor;\n        this.options = {\n            stopEvent: null,\n            ignoreMutation: null,\n            ...options\n        };\n        this.extension = props.extension;\n        this.node = props.node;\n        this.decorations = props.decorations;\n        this.innerDecorations = props.innerDecorations;\n        this.view = props.view;\n        this.HTMLAttributes = props.HTMLAttributes;\n        this.getPos = props.getPos;\n        this.mount();\n    }\n    mount() {\n        return;\n    }\n    get dom() {\n        return this.editor.view.dom;\n    }\n    get contentDOM() {\n        return null;\n    }\n    onDragStart(event) {\n        var _a, _b, _c, _d, _e, _f, _g;\n        const { view } = this.editor;\n        const target = event.target;\n        const dragHandle = target.nodeType === 3 ? (_a = target.parentElement) == null ? void 0 : _a.closest(\"[data-drag-handle]\") : target.closest(\"[data-drag-handle]\");\n        if (!this.dom || ((_b = this.contentDOM) == null ? void 0 : _b.contains(target)) || !dragHandle) {\n            return;\n        }\n        let x = 0;\n        let y = 0;\n        if (this.dom !== dragHandle) {\n            const domBox = this.dom.getBoundingClientRect();\n            const handleBox = dragHandle.getBoundingClientRect();\n            const offsetX = (_d = event.offsetX) != null ? _d : (_c = event.nativeEvent) == null ? void 0 : _c.offsetX;\n            const offsetY = (_f = event.offsetY) != null ? _f : (_e = event.nativeEvent) == null ? void 0 : _e.offsetY;\n            x = handleBox.x - domBox.x + offsetX;\n            y = handleBox.y - domBox.y + offsetY;\n        }\n        const clonedNode = this.dom.cloneNode(true);\n        try {\n            const domBox = this.dom.getBoundingClientRect();\n            clonedNode.style.width = `${Math.round(domBox.width)}px`;\n            clonedNode.style.height = `${Math.round(domBox.height)}px`;\n            clonedNode.style.boxSizing = \"border-box\";\n            clonedNode.style.pointerEvents = \"none\";\n        } catch  {}\n        let dragImageWrapper = null;\n        try {\n            dragImageWrapper = document.createElement(\"div\");\n            dragImageWrapper.style.position = \"absolute\";\n            dragImageWrapper.style.top = \"-9999px\";\n            dragImageWrapper.style.left = \"-9999px\";\n            dragImageWrapper.style.pointerEvents = \"none\";\n            dragImageWrapper.appendChild(clonedNode);\n            document.body.appendChild(dragImageWrapper);\n            (_g = event.dataTransfer) == null ? void 0 : _g.setDragImage(clonedNode, x, y);\n        } finally{\n            if (dragImageWrapper) {\n                setTimeout(()=>{\n                    try {\n                        dragImageWrapper == null ? void 0 : dragImageWrapper.remove();\n                    } catch  {}\n                }, 0);\n            }\n        }\n        const pos = this.getPos();\n        if (typeof pos !== \"number\") {\n            return;\n        }\n        const selection = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.NodeSelection.create(view.state.doc, pos);\n        const transaction = view.state.tr.setSelection(selection);\n        view.dispatch(transaction);\n    }\n    stopEvent(event) {\n        var _a;\n        if (!this.dom) {\n            return false;\n        }\n        if (typeof this.options.stopEvent === \"function\") {\n            return this.options.stopEvent({\n                event\n            });\n        }\n        const target = event.target;\n        const isInElement = this.dom.contains(target) && !((_a = this.contentDOM) == null ? void 0 : _a.contains(target));\n        if (!isInElement) {\n            return false;\n        }\n        const isDragEvent = event.type.startsWith(\"drag\");\n        const isDropEvent = event.type === \"drop\";\n        const isInput = [\n            \"INPUT\",\n            \"BUTTON\",\n            \"SELECT\",\n            \"TEXTAREA\"\n        ].includes(target.tagName) || target.isContentEditable;\n        if (isInput && !isDropEvent && !isDragEvent) {\n            return true;\n        }\n        const { isEditable } = this.editor;\n        const { isDragging } = this;\n        const isDraggable = !!this.node.type.spec.draggable;\n        const isSelectable = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.NodeSelection.isSelectable(this.node);\n        const isCopyEvent = event.type === \"copy\";\n        const isPasteEvent = event.type === \"paste\";\n        const isCutEvent = event.type === \"cut\";\n        const isClickEvent = event.type === \"mousedown\";\n        if (!isDraggable && isSelectable && isDragEvent && event.target === this.dom) {\n            event.preventDefault();\n        }\n        if (isDraggable && isDragEvent && !isDragging && event.target === this.dom) {\n            event.preventDefault();\n            return false;\n        }\n        if (isDraggable && isEditable && !isDragging && isClickEvent) {\n            const dragHandle = target.closest(\"[data-drag-handle]\");\n            const isValidDragHandle = dragHandle && (this.dom === dragHandle || this.dom.contains(dragHandle));\n            if (isValidDragHandle) {\n                this.isDragging = true;\n                document.addEventListener(\"dragend\", ()=>{\n                    this.isDragging = false;\n                }, {\n                    once: true\n                });\n                document.addEventListener(\"drop\", ()=>{\n                    this.isDragging = false;\n                }, {\n                    once: true\n                });\n                document.addEventListener(\"mouseup\", ()=>{\n                    this.isDragging = false;\n                }, {\n                    once: true\n                });\n            }\n        }\n        if (isDragging || isDropEvent || isCopyEvent || isPasteEvent || isCutEvent || isClickEvent && isSelectable) {\n            return false;\n        }\n        return true;\n    }\n    /**\n   * Called when a DOM [mutation](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver) or a selection change happens within the view.\n   * @return `false` if the editor should re-read the selection or re-parse the range around the mutation\n   * @return `true` if it can safely be ignored.\n   */ ignoreMutation(mutation) {\n        if (!this.dom || !this.contentDOM) {\n            return true;\n        }\n        if (typeof this.options.ignoreMutation === \"function\") {\n            return this.options.ignoreMutation({\n                mutation\n            });\n        }\n        if (this.node.isLeaf || this.node.isAtom) {\n            return true;\n        }\n        if (mutation.type === \"selection\") {\n            return false;\n        }\n        if (this.dom.contains(mutation.target) && mutation.type === \"childList\" && (isiOS() || isAndroid()) && this.editor.isFocused) {\n            const changedNodes = [\n                ...Array.from(mutation.addedNodes),\n                ...Array.from(mutation.removedNodes)\n            ];\n            if (changedNodes.every((node)=>node.isContentEditable)) {\n                return false;\n            }\n        }\n        if (this.contentDOM === mutation.target && mutation.type === \"attributes\") {\n            return true;\n        }\n        if (this.contentDOM.contains(mutation.target)) {\n            return false;\n        }\n        return true;\n    }\n    /**\n   * Update the attributes of the prosemirror node.\n   */ updateAttributes(attributes) {\n        this.editor.commands.command(({ tr })=>{\n            const pos = this.getPos();\n            if (typeof pos !== \"number\") {\n                return false;\n            }\n            tr.setNodeMarkup(pos, void 0, {\n                ...this.node.attrs,\n                ...attributes\n            });\n            return true;\n        });\n    }\n    /**\n   * Delete the node.\n   */ deleteNode() {\n        const from = this.getPos();\n        if (typeof from !== \"number\") {\n            return;\n        }\n        const to = from + this.node.nodeSize;\n        this.editor.commands.deleteRange({\n            from,\n            to\n        });\n    }\n};\n// src/pasteRules/markPasteRule.ts\nfunction markPasteRule(config) {\n    return new PasteRule({\n        find: config.find,\n        handler: ({ state, range, match, pasteEvent })=>{\n            const attributes = callOrReturn(config.getAttributes, void 0, match, pasteEvent);\n            if (attributes === false || attributes === null) {\n                return null;\n            }\n            const { tr } = state;\n            const captureGroup = match[match.length - 1];\n            const fullMatch = match[0];\n            let markEnd = range.to;\n            if (captureGroup) {\n                const startSpaces = fullMatch.search(/\\S/);\n                const textStart = range.from + fullMatch.indexOf(captureGroup);\n                const textEnd = textStart + captureGroup.length;\n                const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter((item)=>{\n                    const excluded = item.mark.type.excluded;\n                    return excluded.find((type)=>type === config.type && type !== item.mark.type);\n                }).filter((item)=>item.to > textStart);\n                if (excludedMarks.length) {\n                    return null;\n                }\n                if (textEnd < range.to) {\n                    tr.delete(textEnd, range.to);\n                }\n                if (textStart > range.from) {\n                    tr.delete(range.from + startSpaces, textStart);\n                }\n                markEnd = range.from + startSpaces + captureGroup.length;\n                tr.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));\n                tr.removeStoredMark(config.type);\n            }\n        }\n    });\n}\n// src/pasteRules/nodePasteRule.ts\nfunction nodePasteRule(config) {\n    return new PasteRule({\n        find: config.find,\n        handler ({ match, chain, range, pasteEvent }) {\n            const attributes = callOrReturn(config.getAttributes, void 0, match, pasteEvent);\n            const content = callOrReturn(config.getContent, void 0, attributes);\n            if (attributes === false || attributes === null) {\n                return null;\n            }\n            const node = {\n                type: config.type.name,\n                attrs: attributes\n            };\n            if (content) {\n                node.content = content;\n            }\n            if (match.input) {\n                chain().deleteRange(range).insertContentAt(range.from, node);\n            }\n        }\n    });\n}\n// src/pasteRules/textPasteRule.ts\nfunction textPasteRule(config) {\n    return new PasteRule({\n        find: config.find,\n        handler: ({ state, range, match })=>{\n            let insert = config.replace;\n            let start = range.from;\n            const end = range.to;\n            if (match[1]) {\n                const offset = match[0].lastIndexOf(match[1]);\n                insert += match[0].slice(offset + match[1].length);\n                start += offset;\n                const cutOff = start - end;\n                if (cutOff > 0) {\n                    insert = match[0].slice(offset - cutOff, offset) + insert;\n                    start = end;\n                }\n            }\n            state.tr.insertText(insert, start, end);\n        }\n    });\n}\n// src/Tracker.ts\nvar Tracker = class {\n    constructor(transaction){\n        this.transaction = transaction;\n        this.currentStep = this.transaction.steps.length;\n    }\n    map(position) {\n        let deleted = false;\n        const mappedPosition = this.transaction.steps.slice(this.currentStep).reduce((newPosition, step)=>{\n            const mapResult = step.getMap().mapResult(newPosition);\n            if (mapResult.deleted) {\n                deleted = true;\n            }\n            return mapResult.pos;\n        }, position);\n        return {\n            position: mappedPosition,\n            deleted\n        };\n    }\n};\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLElBQUlBLFlBQVlDLE9BQU9DLGNBQWM7QUFDckMsSUFBSUMsV0FBVyxDQUFDQyxRQUFRQztJQUN0QixJQUFLLElBQUlDLFFBQVFELElBQ2ZMLFVBQVVJLFFBQVFFLE1BQU07UUFBRUMsS0FBS0YsR0FBRyxDQUFDQyxLQUFLO1FBQUVFLFlBQVk7SUFBSztBQUMvRDtBQUVBLHNDQUFzQztBQUN0QyxTQUFTQyxxQkFBcUJDLE1BQU07SUFDbEMsTUFBTSxFQUFFQyxLQUFLLEVBQUVDLFdBQVcsRUFBRSxHQUFHRjtJQUMvQixJQUFJLEVBQUVHLFNBQVMsRUFBRSxHQUFHRDtJQUNwQixJQUFJLEVBQUVFLEdBQUcsRUFBRSxHQUFHRjtJQUNkLElBQUksRUFBRUcsV0FBVyxFQUFFLEdBQUdIO0lBQ3RCLE9BQU87UUFDTCxHQUFHRCxLQUFLO1FBQ1JLLE9BQU9MLE1BQU1LLEtBQUssQ0FBQ0MsSUFBSSxDQUFDTjtRQUN4Qk8sa0JBQWtCUCxNQUFNTyxnQkFBZ0IsQ0FBQ0QsSUFBSSxDQUFDTjtRQUM5Q1EsU0FBU1IsTUFBTVEsT0FBTztRQUN0QkMsUUFBUVQsTUFBTVMsTUFBTTtRQUNwQkMsYUFBYVYsTUFBTVUsV0FBVyxDQUFDSixJQUFJLENBQUNOO1FBQ3BDVyxRQUFRWCxNQUFNVyxNQUFNLENBQUNMLElBQUksQ0FBQ047UUFDMUIsSUFBSUksZUFBYztZQUNoQixPQUFPQTtRQUNUO1FBQ0EsSUFBSUYsYUFBWTtZQUNkLE9BQU9BO1FBQ1Q7UUFDQSxJQUFJQyxPQUFNO1lBQ1IsT0FBT0E7UUFDVDtRQUNBLElBQUlTLE1BQUs7WUFD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NUMsU0FBU2dFO2dCQUNULE1BQU13M0IsU0FBU3g3QixRQUFRK0o7Z0JBQ3ZCLElBQUl5eEIsU0FBUyxHQUFHO29CQUNkNzZCLFNBQVNpUSxLQUFLLENBQUMsRUFBRSxDQUFDclEsS0FBSyxDQUFDeUQsU0FBU3czQixRQUFReDNCLFVBQVVyRDtvQkFDbkRYLFFBQVErSjtnQkFDVjtZQUNGO1lBQ0ExUyxNQUFNWSxFQUFFLENBQUMwVCxVQUFVLENBQUNoTCxRQUFRWCxPQUFPK0o7UUFDckM7SUFDRjtBQUNGO0FBRUEsaUJBQWlCO0FBQ2pCLElBQUl3aUMsVUFBVTtJQUNacDBDLFlBQVliLFdBQVcsQ0FBRTtRQUN2QixJQUFJLENBQUNBLFdBQVcsR0FBR0E7UUFDbkIsSUFBSSxDQUFDazFDLFdBQVcsR0FBRyxJQUFJLENBQUNsMUMsV0FBVyxDQUFDc1MsS0FBSyxDQUFDaEgsTUFBTTtJQUNsRDtJQUNBN0osSUFBSWtNLFFBQVEsRUFBRTtRQUNaLElBQUl3bkMsVUFBVTtRQUNkLE1BQU1DLGlCQUFpQixJQUFJLENBQUNwMUMsV0FBVyxDQUFDc1MsS0FBSyxDQUFDckosS0FBSyxDQUFDLElBQUksQ0FBQ2lzQyxXQUFXLEVBQUU3OUIsTUFBTSxDQUFDLENBQUNnK0IsYUFBYTlpQztZQUN6RixNQUFNMFUsWUFBWTFVLEtBQUsraUMsTUFBTSxHQUFHcnVCLFNBQVMsQ0FBQ291QjtZQUMxQyxJQUFJcHVCLFVBQVVrdUIsT0FBTyxFQUFFO2dCQUNyQkEsVUFBVTtZQUNaO1lBQ0EsT0FBT2x1QixVQUFVemYsR0FBRztRQUN0QixHQUFHbUc7UUFDSCxPQUFPO1lBQ0xBLFVBQVV5bkM7WUFDVkQ7UUFDRjtJQUNGO0FBQ0Y7QUF1SEUsQ0FDRixpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcmFzb2JwYWktd2ViLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9kaXN0L2luZGV4LmpzP2U1NDMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcblxuLy8gc3JjL2hlbHBlcnMvY3JlYXRlQ2hhaW5hYmxlU3RhdGUudHNcbmZ1bmN0aW9uIGNyZWF0ZUNoYWluYWJsZVN0YXRlKGNvbmZpZykge1xuICBjb25zdCB7IHN0YXRlLCB0cmFuc2FjdGlvbiB9ID0gY29uZmlnO1xuICBsZXQgeyBzZWxlY3Rpb24gfSA9IHRyYW5zYWN0aW9uO1xuICBsZXQgeyBkb2MgfSA9IHRyYW5zYWN0aW9uO1xuICBsZXQgeyBzdG9yZWRNYXJrcyB9ID0gdHJhbnNhY3Rpb247XG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgYXBwbHk6IHN0YXRlLmFwcGx5LmJpbmQoc3RhdGUpLFxuICAgIGFwcGx5VHJhbnNhY3Rpb246IHN0YXRlLmFwcGx5VHJhbnNhY3Rpb24uYmluZChzdGF0ZSksXG4gICAgcGx1Z2luczogc3RhdGUucGx1Z2lucyxcbiAgICBzY2hlbWE6IHN0YXRlLnNjaGVtYSxcbiAgICByZWNvbmZpZ3VyZTogc3RhdGUucmVjb25maWd1cmUuYmluZChzdGF0ZSksXG4gICAgdG9KU09OOiBzdGF0ZS50b0pTT04uYmluZChzdGF0ZSksXG4gICAgZ2V0IHN0b3JlZE1hcmtzKCkge1xuICAgICAgcmV0dXJuIHN0b3JlZE1hcmtzO1xuICAgIH0sXG4gICAgZ2V0IHNlbGVjdGlvbigpIHtcbiAgICAgIHJldHVybiBzZWxlY3Rpb247XG4gICAgfSxcbiAgICBnZXQgZG9jKCkge1xuICAgICAgcmV0dXJuIGRvYztcbiAgICB9LFxuICAgIGdldCB0cigpIHtcbiAgICAgIHNlbGVjdGlvbiA9IHRyYW5zYWN0aW9uLnNlbGVjdGlvbjtcbiAgICAgIGRvYyA9IHRyYW5zYWN0aW9uLmRvYztcbiAgICAgIHN0b3JlZE1hcmtzID0gdHJhbnNhY3Rpb24uc3RvcmVkTWFya3M7XG4gICAgICByZXR1cm4gdHJhbnNhY3Rpb247XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvQ29tbWFuZE1hbmFnZXIudHNcbnZhciBDb21tYW5kTWFuYWdlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICB0aGlzLmVkaXRvciA9IHByb3BzLmVkaXRvcjtcbiAgICB0aGlzLnJhd0NvbW1hbmRzID0gdGhpcy5lZGl0b3IuZXh0ZW5zaW9uTWFuYWdlci5jb21tYW5kcztcbiAgICB0aGlzLmN1c3RvbVN0YXRlID0gcHJvcHMuc3RhdGU7XG4gIH1cbiAgZ2V0IGhhc0N1c3RvbVN0YXRlKCkge1xuICAgIHJldHVybiAhIXRoaXMuY3VzdG9tU3RhdGU7XG4gIH1cbiAgZ2V0IHN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLmN1c3RvbVN0YXRlIHx8IHRoaXMuZWRpdG9yLnN0YXRlO1xuICB9XG4gIGdldCBjb21tYW5kcygpIHtcbiAgICBjb25zdCB7IHJhd0NvbW1hbmRzLCBlZGl0b3IsIHN0YXRlIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgdmlldyB9ID0gZWRpdG9yO1xuICAgIGNvbnN0IHsgdHIgfSA9IHN0YXRlO1xuICAgIGNvbnN0IHByb3BzID0gdGhpcy5idWlsZFByb3BzKHRyKTtcbiAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgT2JqZWN0LmVudHJpZXMocmF3Q29tbWFuZHMpLm1hcCgoW25hbWUsIGNvbW1hbmQyXSkgPT4ge1xuICAgICAgICBjb25zdCBtZXRob2QgPSAoLi4uYXJncykgPT4ge1xuICAgICAgICAgIGNvbnN0IGNhbGxiYWNrID0gY29tbWFuZDIoLi4uYXJncykocHJvcHMpO1xuICAgICAgICAgIGlmICghdHIuZ2V0TWV0YShcInByZXZlbnREaXNwYXRjaFwiKSAmJiAhdGhpcy5oYXNDdXN0b21TdGF0ZSkge1xuICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh0cik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjYWxsYmFjaztcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFtuYW1lLCBtZXRob2RdO1xuICAgICAgfSlcbiAgICApO1xuICB9XG4gIGdldCBjaGFpbigpIHtcbiAgICByZXR1cm4gKCkgPT4gdGhpcy5jcmVhdGVDaGFpbigpO1xuICB9XG4gIGdldCBjYW4oKSB7XG4gICAgcmV0dXJuICgpID0+IHRoaXMuY3JlYXRlQ2FuKCk7XG4gIH1cbiAgY3JlYXRlQ2hhaW4oc3RhcnRUciwgc2hvdWxkRGlzcGF0Y2ggPSB0cnVlKSB7XG4gICAgY29uc3QgeyByYXdDb21tYW5kcywgZWRpdG9yLCBzdGF0ZSB9ID0gdGhpcztcbiAgICBjb25zdCB7IHZpZXcgfSA9IGVkaXRvcjtcbiAgICBjb25zdCBjYWxsYmFja3MgPSBbXTtcbiAgICBjb25zdCBoYXNTdGFydFRyYW5zYWN0aW9uID0gISFzdGFydFRyO1xuICAgIGNvbnN0IHRyID0gc3RhcnRUciB8fCBzdGF0ZS50cjtcbiAgICBjb25zdCBydW4zID0gKCkgPT4ge1xuICAgICAgaWYgKCFoYXNTdGFydFRyYW5zYWN0aW9uICYmIHNob3VsZERpc3BhdGNoICYmICF0ci5nZXRNZXRhKFwicHJldmVudERpc3BhdGNoXCIpICYmICF0aGlzLmhhc0N1c3RvbVN0YXRlKSB7XG4gICAgICAgIHZpZXcuZGlzcGF0Y2godHIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNhbGxiYWNrcy5ldmVyeSgoY2FsbGJhY2spID0+IGNhbGxiYWNrID09PSB0cnVlKTtcbiAgICB9O1xuICAgIGNvbnN0IGNoYWluID0ge1xuICAgICAgLi4uT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICBPYmplY3QuZW50cmllcyhyYXdDb21tYW5kcykubWFwKChbbmFtZSwgY29tbWFuZDJdKSA9PiB7XG4gICAgICAgICAgY29uc3QgY2hhaW5lZENvbW1hbmQgPSAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgY29uc3QgcHJvcHMgPSB0aGlzLmJ1aWxkUHJvcHModHIsIHNob3VsZERpc3BhdGNoKTtcbiAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrID0gY29tbWFuZDIoLi4uYXJncykocHJvcHMpO1xuICAgICAgICAgICAgY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgICAgcmV0dXJuIGNoYWluO1xuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIFtuYW1lLCBjaGFpbmVkQ29tbWFuZF07XG4gICAgICAgIH0pXG4gICAgICApLFxuICAgICAgcnVuOiBydW4zXG4gICAgfTtcbiAgICByZXR1cm4gY2hhaW47XG4gIH1cbiAgY3JlYXRlQ2FuKHN0YXJ0VHIpIHtcbiAgICBjb25zdCB7IHJhd0NvbW1hbmRzLCBzdGF0ZSB9ID0gdGhpcztcbiAgICBjb25zdCBkaXNwYXRjaCA9IGZhbHNlO1xuICAgIGNvbnN0IHRyID0gc3RhcnRUciB8fCBzdGF0ZS50cjtcbiAgICBjb25zdCBwcm9wcyA9IHRoaXMuYnVpbGRQcm9wcyh0ciwgZGlzcGF0Y2gpO1xuICAgIGNvbnN0IGZvcm1hdHRlZENvbW1hbmRzID0gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgT2JqZWN0LmVudHJpZXMocmF3Q29tbWFuZHMpLm1hcCgoW25hbWUsIGNvbW1hbmQyXSkgPT4ge1xuICAgICAgICByZXR1cm4gW25hbWUsICguLi5hcmdzKSA9PiBjb21tYW5kMiguLi5hcmdzKSh7IC4uLnByb3BzLCBkaXNwYXRjaDogdm9pZCAwIH0pXTtcbiAgICAgIH0pXG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uZm9ybWF0dGVkQ29tbWFuZHMsXG4gICAgICBjaGFpbjogKCkgPT4gdGhpcy5jcmVhdGVDaGFpbih0ciwgZGlzcGF0Y2gpXG4gICAgfTtcbiAgfVxuICBidWlsZFByb3BzKHRyLCBzaG91bGREaXNwYXRjaCA9IHRydWUpIHtcbiAgICBjb25zdCB7IHJhd0NvbW1hbmRzLCBlZGl0b3IsIHN0YXRlIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgdmlldyB9ID0gZWRpdG9yO1xuICAgIGNvbnN0IHByb3BzID0ge1xuICAgICAgdHIsXG4gICAgICBlZGl0b3IsXG4gICAgICB2aWV3LFxuICAgICAgc3RhdGU6IGNyZWF0ZUNoYWluYWJsZVN0YXRlKHtcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIHRyYW5zYWN0aW9uOiB0clxuICAgICAgfSksXG4gICAgICBkaXNwYXRjaDogc2hvdWxkRGlzcGF0Y2ggPyAoKSA9PiB2b2lkIDAgOiB2b2lkIDAsXG4gICAgICBjaGFpbjogKCkgPT4gdGhpcy5jcmVhdGVDaGFpbih0ciwgc2hvdWxkRGlzcGF0Y2gpLFxuICAgICAgY2FuOiAoKSA9PiB0aGlzLmNyZWF0ZUNhbih0ciksXG4gICAgICBnZXQgY29tbWFuZHMoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgICAgT2JqZWN0LmVudHJpZXMocmF3Q29tbWFuZHMpLm1hcCgoW25hbWUsIGNvbW1hbmQyXSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIFtuYW1lLCAoLi4uYXJncykgPT4gY29tbWFuZDIoLi4uYXJncykocHJvcHMpXTtcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHByb3BzO1xuICB9XG59O1xuXG4vLyBzcmMvY29tbWFuZHMvaW5kZXgudHNcbnZhciBjb21tYW5kc19leHBvcnRzID0ge307XG5fX2V4cG9ydChjb21tYW5kc19leHBvcnRzLCB7XG4gIGJsdXI6ICgpID0+IGJsdXIsXG4gIGNsZWFyQ29udGVudDogKCkgPT4gY2xlYXJDb250ZW50LFxuICBjbGVhck5vZGVzOiAoKSA9PiBjbGVhck5vZGVzLFxuICBjb21tYW5kOiAoKSA9PiBjb21tYW5kLFxuICBjcmVhdGVQYXJhZ3JhcGhOZWFyOiAoKSA9PiBjcmVhdGVQYXJhZ3JhcGhOZWFyLFxuICBjdXQ6ICgpID0+IGN1dCxcbiAgZGVsZXRlQ3VycmVudE5vZGU6ICgpID0+IGRlbGV0ZUN1cnJlbnROb2RlLFxuICBkZWxldGVOb2RlOiAoKSA9PiBkZWxldGVOb2RlLFxuICBkZWxldGVSYW5nZTogKCkgPT4gZGVsZXRlUmFuZ2UsXG4gIGRlbGV0ZVNlbGVjdGlvbjogKCkgPT4gZGVsZXRlU2VsZWN0aW9uLFxuICBlbnRlcjogKCkgPT4gZW50ZXIsXG4gIGV4aXRDb2RlOiAoKSA9PiBleGl0Q29kZSxcbiAgZXh0ZW5kTWFya1JhbmdlOiAoKSA9PiBleHRlbmRNYXJrUmFuZ2UsXG4gIGZpcnN0OiAoKSA9PiBmaXJzdCxcbiAgZm9jdXM6ICgpID0+IGZvY3VzLFxuICBmb3JFYWNoOiAoKSA9PiBmb3JFYWNoLFxuICBpbnNlcnRDb250ZW50OiAoKSA9PiBpbnNlcnRDb250ZW50LFxuICBpbnNlcnRDb250ZW50QXQ6ICgpID0+IGluc2VydENvbnRlbnRBdCxcbiAgam9pbkJhY2t3YXJkOiAoKSA9PiBqb2luQmFja3dhcmQsXG4gIGpvaW5Eb3duOiAoKSA9PiBqb2luRG93bixcbiAgam9pbkZvcndhcmQ6ICgpID0+IGpvaW5Gb3J3YXJkLFxuICBqb2luSXRlbUJhY2t3YXJkOiAoKSA9PiBqb2luSXRlbUJhY2t3YXJkLFxuICBqb2luSXRlbUZvcndhcmQ6ICgpID0+IGpvaW5JdGVtRm9yd2FyZCxcbiAgam9pblRleHRibG9ja0JhY2t3YXJkOiAoKSA9PiBqb2luVGV4dGJsb2NrQmFja3dhcmQsXG4gIGpvaW5UZXh0YmxvY2tGb3J3YXJkOiAoKSA9PiBqb2luVGV4dGJsb2NrRm9yd2FyZCxcbiAgam9pblVwOiAoKSA9PiBqb2luVXAsXG4gIGtleWJvYXJkU2hvcnRjdXQ6ICgpID0+IGtleWJvYXJkU2hvcnRjdXQsXG4gIGxpZnQ6ICgpID0+IGxpZnQsXG4gIGxpZnRFbXB0eUJsb2NrOiAoKSA9PiBsaWZ0RW1wdHlCbG9jayxcbiAgbGlmdExpc3RJdGVtOiAoKSA9PiBsaWZ0TGlzdEl0ZW0sXG4gIG5ld2xpbmVJbkNvZGU6ICgpID0+IG5ld2xpbmVJbkNvZGUsXG4gIHJlc2V0QXR0cmlidXRlczogKCkgPT4gcmVzZXRBdHRyaWJ1dGVzLFxuICBzY3JvbGxJbnRvVmlldzogKCkgPT4gc2Nyb2xsSW50b1ZpZXcsXG4gIHNlbGVjdEFsbDogKCkgPT4gc2VsZWN0QWxsLFxuICBzZWxlY3ROb2RlQmFja3dhcmQ6ICgpID0+IHNlbGVjdE5vZGVCYWNrd2FyZCxcbiAgc2VsZWN0Tm9kZUZvcndhcmQ6ICgpID0+IHNlbGVjdE5vZGVGb3J3YXJkLFxuICBzZWxlY3RQYXJlbnROb2RlOiAoKSA9PiBzZWxlY3RQYXJlbnROb2RlLFxuICBzZWxlY3RUZXh0YmxvY2tFbmQ6ICgpID0+IHNlbGVjdFRleHRibG9ja0VuZCxcbiAgc2VsZWN0VGV4dGJsb2NrU3RhcnQ6ICgpID0+IHNlbGVjdFRleHRibG9ja1N0YXJ0LFxuICBzZXRDb250ZW50OiAoKSA9PiBzZXRDb250ZW50LFxuICBzZXRNYXJrOiAoKSA9PiBzZXRNYXJrLFxuICBzZXRNZXRhOiAoKSA9PiBzZXRNZXRhLFxuICBzZXROb2RlOiAoKSA9PiBzZXROb2RlLFxuICBzZXROb2RlU2VsZWN0aW9uOiAoKSA9PiBzZXROb2RlU2VsZWN0aW9uLFxuICBzZXRUZXh0RGlyZWN0aW9uOiAoKSA9PiBzZXRUZXh0RGlyZWN0aW9uLFxuICBzZXRUZXh0U2VsZWN0aW9uOiAoKSA9PiBzZXRUZXh0U2VsZWN0aW9uLFxuICBzaW5rTGlzdEl0ZW06ICgpID0+IHNpbmtMaXN0SXRlbSxcbiAgc3BsaXRCbG9jazogKCkgPT4gc3BsaXRCbG9jayxcbiAgc3BsaXRMaXN0SXRlbTogKCkgPT4gc3BsaXRMaXN0SXRlbSxcbiAgdG9nZ2xlTGlzdDogKCkgPT4gdG9nZ2xlTGlzdCxcbiAgdG9nZ2xlTWFyazogKCkgPT4gdG9nZ2xlTWFyayxcbiAgdG9nZ2xlTm9kZTogKCkgPT4gdG9nZ2xlTm9kZSxcbiAgdG9nZ2xlV3JhcDogKCkgPT4gdG9nZ2xlV3JhcCxcbiAgdW5kb0lucHV0UnVsZTogKCkgPT4gdW5kb0lucHV0UnVsZSxcbiAgdW5zZXRBbGxNYXJrczogKCkgPT4gdW5zZXRBbGxNYXJrcyxcbiAgdW5zZXRNYXJrOiAoKSA9PiB1bnNldE1hcmssXG4gIHVuc2V0VGV4dERpcmVjdGlvbjogKCkgPT4gdW5zZXRUZXh0RGlyZWN0aW9uLFxuICB1cGRhdGVBdHRyaWJ1dGVzOiAoKSA9PiB1cGRhdGVBdHRyaWJ1dGVzLFxuICB3cmFwSW46ICgpID0+IHdyYXBJbixcbiAgd3JhcEluTGlzdDogKCkgPT4gd3JhcEluTGlzdFxufSk7XG5cbi8vIHNyYy9jb21tYW5kcy9ibHVyLnRzXG52YXIgYmx1ciA9ICgpID0+ICh7IGVkaXRvciwgdmlldyB9KSA9PiB7XG4gIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGlmICghZWRpdG9yLmlzRGVzdHJveWVkKSB7XG4gICAgICA7XG4gICAgICB2aWV3LmRvbS5ibHVyKCk7XG4gICAgICAoX2EgPSB3aW5kb3cgPT0gbnVsbCA/IHZvaWQgMCA6IHdpbmRvdy5nZXRTZWxlY3Rpb24oKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB0cnVlO1xufTtcblxuLy8gc3JjL2NvbW1hbmRzL2NsZWFyQ29udGVudC50c1xudmFyIGNsZWFyQ29udGVudCA9IChlbWl0VXBkYXRlID0gdHJ1ZSkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICByZXR1cm4gY29tbWFuZHMuc2V0Q29udGVudChcIlwiLCB7IGVtaXRVcGRhdGUgfSk7XG59O1xuXG4vLyBzcmMvY29tbWFuZHMvY2xlYXJOb2Rlcy50c1xuaW1wb3J0IHsgbGlmdFRhcmdldCB9IGZyb20gXCJAdGlwdGFwL3BtL3RyYW5zZm9ybVwiO1xudmFyIGNsZWFyTm9kZXMgPSAoKSA9PiAoeyBzdGF0ZSwgdHIsIGRpc3BhdGNoIH0pID0+IHtcbiAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHRyO1xuICBjb25zdCB7IHJhbmdlcyB9ID0gc2VsZWN0aW9uO1xuICBpZiAoIWRpc3BhdGNoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmFuZ2VzLmZvckVhY2goKHsgJGZyb20sICR0byB9KSA9PiB7XG4gICAgc3RhdGUuZG9jLm5vZGVzQmV0d2VlbigkZnJvbS5wb3MsICR0by5wb3MsIChub2RlLCBwb3MpID0+IHtcbiAgICAgIGlmIChub2RlLnR5cGUuaXNUZXh0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgZG9jLCBtYXBwaW5nIH0gPSB0cjtcbiAgICAgIGNvbnN0ICRtYXBwZWRGcm9tID0gZG9jLnJlc29sdmUobWFwcGluZy5tYXAocG9zKSk7XG4gICAgICBjb25zdCAkbWFwcGVkVG8gPSBkb2MucmVzb2x2ZShtYXBwaW5nLm1hcChwb3MgKyBub2RlLm5vZGVTaXplKSk7XG4gICAgICBjb25zdCBub2RlUmFuZ2UgPSAkbWFwcGVkRnJvbS5ibG9ja1JhbmdlKCRtYXBwZWRUbyk7XG4gICAgICBpZiAoIW5vZGVSYW5nZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB0YXJnZXRMaWZ0RGVwdGggPSBsaWZ0VGFyZ2V0KG5vZGVSYW5nZSk7XG4gICAgICBpZiAobm9kZS50eXBlLmlzVGV4dGJsb2NrKSB7XG4gICAgICAgIGNvbnN0IHsgZGVmYXVsdFR5cGUgfSA9ICRtYXBwZWRGcm9tLnBhcmVudC5jb250ZW50TWF0Y2hBdCgkbWFwcGVkRnJvbS5pbmRleCgpKTtcbiAgICAgICAgdHIuc2V0Tm9kZU1hcmt1cChub2RlUmFuZ2Uuc3RhcnQsIGRlZmF1bHRUeXBlKTtcbiAgICAgIH1cbiAgICAgIGlmICh0YXJnZXRMaWZ0RGVwdGggfHwgdGFyZ2V0TGlmdERlcHRoID09PSAwKSB7XG4gICAgICAgIHRyLmxpZnQobm9kZVJhbmdlLCB0YXJnZXRMaWZ0RGVwdGgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vLyBzcmMvY29tbWFuZHMvY29tbWFuZC50c1xudmFyIGNvbW1hbmQgPSAoZm4pID0+IChwcm9wcykgPT4ge1xuICByZXR1cm4gZm4ocHJvcHMpO1xufTtcblxuLy8gc3JjL2NvbW1hbmRzL2NyZWF0ZVBhcmFncmFwaE5lYXIudHNcbmltcG9ydCB7IGNyZWF0ZVBhcmFncmFwaE5lYXIgYXMgb3JpZ2luYWxDcmVhdGVQYXJhZ3JhcGhOZWFyIH0gZnJvbSBcIkB0aXB0YXAvcG0vY29tbWFuZHNcIjtcbnZhciBjcmVhdGVQYXJhZ3JhcGhOZWFyID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgcmV0dXJuIG9yaWdpbmFsQ3JlYXRlUGFyYWdyYXBoTmVhcihzdGF0ZSwgZGlzcGF0Y2gpO1xufTtcblxuLy8gc3JjL2NvbW1hbmRzL2N1dC50c1xuaW1wb3J0IHsgVGV4dFNlbGVjdGlvbiB9IGZyb20gXCJAdGlwdGFwL3BtL3N0YXRlXCI7XG52YXIgY3V0ID0gKG9yaWdpblJhbmdlLCB0YXJnZXRQb3MpID0+ICh7IGVkaXRvciwgdHIgfSkgPT4ge1xuICBjb25zdCB7IHN0YXRlIH0gPSBlZGl0b3I7XG4gIGNvbnN0IGNvbnRlbnRTbGljZSA9IHN0YXRlLmRvYy5zbGljZShvcmlnaW5SYW5nZS5mcm9tLCBvcmlnaW5SYW5nZS50byk7XG4gIHRyLmRlbGV0ZVJhbmdlKG9yaWdpblJhbmdlLmZyb20sIG9yaWdpblJhbmdlLnRvKTtcbiAgY29uc3QgbmV3UG9zID0gdHIubWFwcGluZy5tYXAodGFyZ2V0UG9zKTtcbiAgdHIuaW5zZXJ0KG5ld1BvcywgY29udGVudFNsaWNlLmNvbnRlbnQpO1xuICB0ci5zZXRTZWxlY3Rpb24obmV3IFRleHRTZWxlY3Rpb24odHIuZG9jLnJlc29sdmUoTWF0aC5tYXgobmV3UG9zIC0gMSwgMCkpKSk7XG4gIHJldHVybiB0cnVlO1xufTtcblxuLy8gc3JjL2NvbW1hbmRzL2RlbGV0ZUN1cnJlbnROb2RlLnRzXG52YXIgZGVsZXRlQ3VycmVudE5vZGUgPSAoKSA9PiAoeyB0ciwgZGlzcGF0Y2ggfSkgPT4ge1xuICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gdHI7XG4gIGNvbnN0IGN1cnJlbnROb2RlID0gc2VsZWN0aW9uLiRhbmNob3Iubm9kZSgpO1xuICBpZiAoY3VycmVudE5vZGUuY29udGVudC5zaXplID4gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCAkcG9zID0gdHIuc2VsZWN0aW9uLiRhbmNob3I7XG4gIGZvciAobGV0IGRlcHRoID0gJHBvcy5kZXB0aDsgZGVwdGggPiAwOyBkZXB0aCAtPSAxKSB7XG4gICAgY29uc3Qgbm9kZSA9ICRwb3Mubm9kZShkZXB0aCk7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gY3VycmVudE5vZGUudHlwZSkge1xuICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgIGNvbnN0IGZyb20gPSAkcG9zLmJlZm9yZShkZXB0aCk7XG4gICAgICAgIGNvbnN0IHRvID0gJHBvcy5hZnRlcihkZXB0aCk7XG4gICAgICAgIHRyLmRlbGV0ZShmcm9tLCB0bykuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vLyBzcmMvaGVscGVycy9nZXROb2RlVHlwZS50c1xuZnVuY3Rpb24gZ2V0Tm9kZVR5cGUobmFtZU9yVHlwZSwgc2NoZW1hKSB7XG4gIGlmICh0eXBlb2YgbmFtZU9yVHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGlmICghc2NoZW1hLm5vZGVzW25hbWVPclR5cGVdKSB7XG4gICAgICB0aHJvdyBFcnJvcihgVGhlcmUgaXMgbm8gbm9kZSB0eXBlIG5hbWVkICcke25hbWVPclR5cGV9Jy4gTWF5YmUgeW91IGZvcmdvdCB0byBhZGQgdGhlIGV4dGVuc2lvbj9gKTtcbiAgICB9XG4gICAgcmV0dXJuIHNjaGVtYS5ub2Rlc1tuYW1lT3JUeXBlXTtcbiAgfVxuICByZXR1cm4gbmFtZU9yVHlwZTtcbn1cblxuLy8gc3JjL2NvbW1hbmRzL2RlbGV0ZU5vZGUudHNcbnZhciBkZWxldGVOb2RlID0gKHR5cGVPck5hbWUpID0+ICh7IHRyLCBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICBjb25zdCB0eXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgY29uc3QgJHBvcyA9IHRyLnNlbGVjdGlvbi4kYW5jaG9yO1xuICBmb3IgKGxldCBkZXB0aCA9ICRwb3MuZGVwdGg7IGRlcHRoID4gMDsgZGVwdGggLT0gMSkge1xuICAgIGNvbnN0IG5vZGUgPSAkcG9zLm5vZGUoZGVwdGgpO1xuICAgIGlmIChub2RlLnR5cGUgPT09IHR5cGUpIHtcbiAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICBjb25zdCBmcm9tID0gJHBvcy5iZWZvcmUoZGVwdGgpO1xuICAgICAgICBjb25zdCB0byA9ICRwb3MuYWZ0ZXIoZGVwdGgpO1xuICAgICAgICB0ci5kZWxldGUoZnJvbSwgdG8pLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLy8gc3JjL2NvbW1hbmRzL2RlbGV0ZVJhbmdlLnRzXG52YXIgZGVsZXRlUmFuZ2UgPSAocmFuZ2UpID0+ICh7IHRyLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGNvbnN0IHsgZnJvbSwgdG8gfSA9IHJhbmdlO1xuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICB0ci5kZWxldGUoZnJvbSwgdG8pO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuLy8gc3JjL2NvbW1hbmRzL2RlbGV0ZVNlbGVjdGlvbi50c1xuaW1wb3J0IHsgZGVsZXRlU2VsZWN0aW9uIGFzIG9yaWdpbmFsRGVsZXRlU2VsZWN0aW9uIH0gZnJvbSBcIkB0aXB0YXAvcG0vY29tbWFuZHNcIjtcbnZhciBkZWxldGVTZWxlY3Rpb24gPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICByZXR1cm4gb3JpZ2luYWxEZWxldGVTZWxlY3Rpb24oc3RhdGUsIGRpc3BhdGNoKTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy9lbnRlci50c1xudmFyIGVudGVyID0gKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICByZXR1cm4gY29tbWFuZHMua2V5Ym9hcmRTaG9ydGN1dChcIkVudGVyXCIpO1xufTtcblxuLy8gc3JjL2NvbW1hbmRzL2V4aXRDb2RlLnRzXG5pbXBvcnQgeyBleGl0Q29kZSBhcyBvcmlnaW5hbEV4aXRDb2RlIH0gZnJvbSBcIkB0aXB0YXAvcG0vY29tbWFuZHNcIjtcbnZhciBleGl0Q29kZSA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIHJldHVybiBvcmlnaW5hbEV4aXRDb2RlKHN0YXRlLCBkaXNwYXRjaCk7XG59O1xuXG4vLyBzcmMvY29tbWFuZHMvZXh0ZW5kTWFya1JhbmdlLnRzXG5pbXBvcnQgeyBUZXh0U2VsZWN0aW9uIGFzIFRleHRTZWxlY3Rpb24yIH0gZnJvbSBcIkB0aXB0YXAvcG0vc3RhdGVcIjtcblxuLy8gc3JjL3V0aWxpdGllcy9pc1JlZ0V4cC50c1xuZnVuY3Rpb24gaXNSZWdFeHAodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09IFwiW29iamVjdCBSZWdFeHBdXCI7XG59XG5cbi8vIHNyYy91dGlsaXRpZXMvb2JqZWN0SW5jbHVkZXMudHNcbmZ1bmN0aW9uIG9iamVjdEluY2x1ZGVzKG9iamVjdDEsIG9iamVjdDIsIG9wdGlvbnMgPSB7IHN0cmljdDogdHJ1ZSB9KSB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QyKTtcbiAgaWYgKCFrZXlzLmxlbmd0aCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBrZXlzLmV2ZXJ5KChrZXkpID0+IHtcbiAgICBpZiAob3B0aW9ucy5zdHJpY3QpIHtcbiAgICAgIHJldHVybiBvYmplY3QyW2tleV0gPT09IG9iamVjdDFba2V5XTtcbiAgICB9XG4gICAgaWYgKGlzUmVnRXhwKG9iamVjdDJba2V5XSkpIHtcbiAgICAgIHJldHVybiBvYmplY3QyW2tleV0udGVzdChvYmplY3QxW2tleV0pO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0MltrZXldID09PSBvYmplY3QxW2tleV07XG4gIH0pO1xufVxuXG4vLyBzcmMvaGVscGVycy9nZXRNYXJrUmFuZ2UudHNcbmZ1bmN0aW9uIGZpbmRNYXJrSW5TZXQobWFya3MsIHR5cGUsIGF0dHJpYnV0ZXMgPSB7fSkge1xuICByZXR1cm4gbWFya3MuZmluZCgoaXRlbSkgPT4ge1xuICAgIHJldHVybiBpdGVtLnR5cGUgPT09IHR5cGUgJiYgb2JqZWN0SW5jbHVkZXMoXG4gICAgICAvLyBPbmx5IGNoZWNrIGVxdWFsaXR5IGZvciB0aGUgYXR0cmlidXRlcyB0aGF0IGFyZSBwcm92aWRlZFxuICAgICAgT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLm1hcCgoaykgPT4gW2ssIGl0ZW0uYXR0cnNba11dKSksXG4gICAgICBhdHRyaWJ1dGVzXG4gICAgKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBpc01hcmtJblNldChtYXJrcywgdHlwZSwgYXR0cmlidXRlcyA9IHt9KSB7XG4gIHJldHVybiAhIWZpbmRNYXJrSW5TZXQobWFya3MsIHR5cGUsIGF0dHJpYnV0ZXMpO1xufVxuZnVuY3Rpb24gZ2V0TWFya1JhbmdlKCRwb3MsIHR5cGUsIGF0dHJpYnV0ZXMpIHtcbiAgdmFyIF9hO1xuICBpZiAoISRwb3MgfHwgIXR5cGUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IHN0YXJ0ID0gJHBvcy5wYXJlbnQuY2hpbGRBZnRlcigkcG9zLnBhcmVudE9mZnNldCk7XG4gIGlmICghc3RhcnQubm9kZSB8fCAhc3RhcnQubm9kZS5tYXJrcy5zb21lKChtYXJrMikgPT4gbWFyazIudHlwZSA9PT0gdHlwZSkpIHtcbiAgICBzdGFydCA9ICRwb3MucGFyZW50LmNoaWxkQmVmb3JlKCRwb3MucGFyZW50T2Zmc2V0KTtcbiAgfVxuICBpZiAoIXN0YXJ0Lm5vZGUgfHwgIXN0YXJ0Lm5vZGUubWFya3Muc29tZSgobWFyazIpID0+IG1hcmsyLnR5cGUgPT09IHR5cGUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzIHx8ICgoX2EgPSBzdGFydC5ub2RlLm1hcmtzWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2EuYXR0cnMpO1xuICBjb25zdCBtYXJrID0gZmluZE1hcmtJblNldChbLi4uc3RhcnQubm9kZS5tYXJrc10sIHR5cGUsIGF0dHJpYnV0ZXMpO1xuICBpZiAoIW1hcmspIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IHN0YXJ0SW5kZXggPSBzdGFydC5pbmRleDtcbiAgbGV0IHN0YXJ0UG9zID0gJHBvcy5zdGFydCgpICsgc3RhcnQub2Zmc2V0O1xuICBsZXQgZW5kSW5kZXggPSBzdGFydEluZGV4ICsgMTtcbiAgbGV0IGVuZFBvcyA9IHN0YXJ0UG9zICsgc3RhcnQubm9kZS5ub2RlU2l6ZTtcbiAgd2hpbGUgKHN0YXJ0SW5kZXggPiAwICYmIGlzTWFya0luU2V0KFsuLi4kcG9zLnBhcmVudC5jaGlsZChzdGFydEluZGV4IC0gMSkubWFya3NdLCB0eXBlLCBhdHRyaWJ1dGVzKSkge1xuICAgIHN0YXJ0SW5kZXggLT0gMTtcbiAgICBzdGFydFBvcyAtPSAkcG9zLnBhcmVudC5jaGlsZChzdGFydEluZGV4KS5ub2RlU2l6ZTtcbiAgfVxuICB3aGlsZSAoZW5kSW5kZXggPCAkcG9zLnBhcmVudC5jaGlsZENvdW50ICYmIGlzTWFya0luU2V0KFsuLi4kcG9zLnBhcmVudC5jaGlsZChlbmRJbmRleCkubWFya3NdLCB0eXBlLCBhdHRyaWJ1dGVzKSkge1xuICAgIGVuZFBvcyArPSAkcG9zLnBhcmVudC5jaGlsZChlbmRJbmRleCkubm9kZVNpemU7XG4gICAgZW5kSW5kZXggKz0gMTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGZyb206IHN0YXJ0UG9zLFxuICAgIHRvOiBlbmRQb3NcbiAgfTtcbn1cblxuLy8gc3JjL2hlbHBlcnMvZ2V0TWFya1R5cGUudHNcbmZ1bmN0aW9uIGdldE1hcmtUeXBlKG5hbWVPclR5cGUsIHNjaGVtYSkge1xuICBpZiAodHlwZW9mIG5hbWVPclR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAoIXNjaGVtYS5tYXJrc1tuYW1lT3JUeXBlXSkge1xuICAgICAgdGhyb3cgRXJyb3IoYFRoZXJlIGlzIG5vIG1hcmsgdHlwZSBuYW1lZCAnJHtuYW1lT3JUeXBlfScuIE1heWJlIHlvdSBmb3Jnb3QgdG8gYWRkIHRoZSBleHRlbnNpb24/YCk7XG4gICAgfVxuICAgIHJldHVybiBzY2hlbWEubWFya3NbbmFtZU9yVHlwZV07XG4gIH1cbiAgcmV0dXJuIG5hbWVPclR5cGU7XG59XG5cbi8vIHNyYy9jb21tYW5kcy9leHRlbmRNYXJrUmFuZ2UudHNcbnZhciBleHRlbmRNYXJrUmFuZ2UgPSAodHlwZU9yTmFtZSwgYXR0cmlidXRlcyA9IHt9KSA9PiAoeyB0ciwgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgY29uc3QgdHlwZSA9IGdldE1hcmtUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XG4gIGNvbnN0IHsgZG9jLCBzZWxlY3Rpb24gfSA9IHRyO1xuICBjb25zdCB7ICRmcm9tLCBmcm9tLCB0byB9ID0gc2VsZWN0aW9uO1xuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICBjb25zdCByYW5nZSA9IGdldE1hcmtSYW5nZSgkZnJvbSwgdHlwZSwgYXR0cmlidXRlcyk7XG4gICAgaWYgKHJhbmdlICYmIHJhbmdlLmZyb20gPD0gZnJvbSAmJiByYW5nZS50byA+PSB0bykge1xuICAgICAgY29uc3QgbmV3U2VsZWN0aW9uID0gVGV4dFNlbGVjdGlvbjIuY3JlYXRlKGRvYywgcmFuZ2UuZnJvbSwgcmFuZ2UudG8pO1xuICAgICAgdHIuc2V0U2VsZWN0aW9uKG5ld1NlbGVjdGlvbik7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuLy8gc3JjL2NvbW1hbmRzL2ZpcnN0LnRzXG52YXIgZmlyc3QgPSAoY29tbWFuZHMpID0+IChwcm9wcykgPT4ge1xuICBjb25zdCBpdGVtcyA9IHR5cGVvZiBjb21tYW5kcyA9PT0gXCJmdW5jdGlvblwiID8gY29tbWFuZHMocHJvcHMpIDogY29tbWFuZHM7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBpZiAoaXRlbXNbaV0ocHJvcHMpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLy8gc3JjL2hlbHBlcnMvaXNUZXh0U2VsZWN0aW9uLnRzXG5pbXBvcnQgeyBUZXh0U2VsZWN0aW9uIGFzIFRleHRTZWxlY3Rpb24zIH0gZnJvbSBcIkB0aXB0YXAvcG0vc3RhdGVcIjtcbmZ1bmN0aW9uIGlzVGV4dFNlbGVjdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uMztcbn1cblxuLy8gc3JjL2hlbHBlcnMvcmVzb2x2ZUZvY3VzUG9zaXRpb24udHNcbmltcG9ydCB7IFNlbGVjdGlvbiwgVGV4dFNlbGVjdGlvbiBhcyBUZXh0U2VsZWN0aW9uNCB9IGZyb20gXCJAdGlwdGFwL3BtL3N0YXRlXCI7XG5cbi8vIHNyYy91dGlsaXRpZXMvbWluTWF4LnRzXG5mdW5jdGlvbiBtaW5NYXgodmFsdWUgPSAwLCBtaW4gPSAwLCBtYXggPSAwKSB7XG4gIHJldHVybiBNYXRoLm1pbihNYXRoLm1heCh2YWx1ZSwgbWluKSwgbWF4KTtcbn1cblxuLy8gc3JjL2hlbHBlcnMvcmVzb2x2ZUZvY3VzUG9zaXRpb24udHNcbmZ1bmN0aW9uIHJlc29sdmVGb2N1c1Bvc2l0aW9uKGRvYywgcG9zaXRpb24gPSBudWxsKSB7XG4gIGlmICghcG9zaXRpb24pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBzZWxlY3Rpb25BdFN0YXJ0ID0gU2VsZWN0aW9uLmF0U3RhcnQoZG9jKTtcbiAgY29uc3Qgc2VsZWN0aW9uQXRFbmQgPSBTZWxlY3Rpb24uYXRFbmQoZG9jKTtcbiAgaWYgKHBvc2l0aW9uID09PSBcInN0YXJ0XCIgfHwgcG9zaXRpb24gPT09IHRydWUpIHtcbiAgICByZXR1cm4gc2VsZWN0aW9uQXRTdGFydDtcbiAgfVxuICBpZiAocG9zaXRpb24gPT09IFwiZW5kXCIpIHtcbiAgICByZXR1cm4gc2VsZWN0aW9uQXRFbmQ7XG4gIH1cbiAgY29uc3QgbWluUG9zID0gc2VsZWN0aW9uQXRTdGFydC5mcm9tO1xuICBjb25zdCBtYXhQb3MgPSBzZWxlY3Rpb25BdEVuZC50bztcbiAgaWYgKHBvc2l0aW9uID09PSBcImFsbFwiKSB7XG4gICAgcmV0dXJuIFRleHRTZWxlY3Rpb240LmNyZWF0ZShkb2MsIG1pbk1heCgwLCBtaW5Qb3MsIG1heFBvcyksIG1pbk1heChkb2MuY29udGVudC5zaXplLCBtaW5Qb3MsIG1heFBvcykpO1xuICB9XG4gIHJldHVybiBUZXh0U2VsZWN0aW9uNC5jcmVhdGUoZG9jLCBtaW5NYXgocG9zaXRpb24sIG1pblBvcywgbWF4UG9zKSwgbWluTWF4KHBvc2l0aW9uLCBtaW5Qb3MsIG1heFBvcykpO1xufVxuXG4vLyBzcmMvdXRpbGl0aWVzL2lzQW5kcm9pZC50c1xuZnVuY3Rpb24gaXNBbmRyb2lkKCkge1xuICByZXR1cm4gbmF2aWdhdG9yLnBsYXRmb3JtID09PSBcIkFuZHJvaWRcIiB8fCAvYW5kcm9pZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG59XG5cbi8vIHNyYy91dGlsaXRpZXMvaXNpT1MudHNcbmZ1bmN0aW9uIGlzaU9TKCkge1xuICByZXR1cm4gW1wiaVBhZCBTaW11bGF0b3JcIiwgXCJpUGhvbmUgU2ltdWxhdG9yXCIsIFwiaVBvZCBTaW11bGF0b3JcIiwgXCJpUGFkXCIsIFwiaVBob25lXCIsIFwiaVBvZFwiXS5pbmNsdWRlcyhuYXZpZ2F0b3IucGxhdGZvcm0pIHx8IC8vIGlQYWQgb24gaU9TIDEzIGRldGVjdGlvblxuICBuYXZpZ2F0b3IudXNlckFnZW50LmluY2x1ZGVzKFwiTWFjXCIpICYmIFwib250b3VjaGVuZFwiIGluIGRvY3VtZW50O1xufVxuXG4vLyBzcmMvY29tbWFuZHMvZm9jdXMudHNcbnZhciBmb2N1cyA9IChwb3NpdGlvbiA9IG51bGwsIG9wdGlvbnMgPSB7fSkgPT4gKHsgZWRpdG9yLCB2aWV3LCB0ciwgZGlzcGF0Y2ggfSkgPT4ge1xuICBvcHRpb25zID0ge1xuICAgIHNjcm9sbEludG9WaWV3OiB0cnVlLFxuICAgIC4uLm9wdGlvbnNcbiAgfTtcbiAgY29uc3QgZGVsYXllZEZvY3VzID0gKCkgPT4ge1xuICAgIGlmIChpc2lPUygpIHx8IGlzQW5kcm9pZCgpKSB7XG4gICAgICA7XG4gICAgICB2aWV3LmRvbS5mb2N1cygpO1xuICAgIH1cbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgaWYgKCFlZGl0b3IuaXNEZXN0cm95ZWQpIHtcbiAgICAgICAgdmlldy5mb2N1cygpO1xuICAgICAgICBpZiAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5zY3JvbGxJbnRvVmlldykge1xuICAgICAgICAgIGVkaXRvci5jb21tYW5kcy5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIGlmICh2aWV3Lmhhc0ZvY3VzKCkgJiYgcG9zaXRpb24gPT09IG51bGwgfHwgcG9zaXRpb24gPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGRpc3BhdGNoICYmIHBvc2l0aW9uID09PSBudWxsICYmICFpc1RleHRTZWxlY3Rpb24oZWRpdG9yLnN0YXRlLnNlbGVjdGlvbikpIHtcbiAgICBkZWxheWVkRm9jdXMoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBzZWxlY3Rpb24gPSByZXNvbHZlRm9jdXNQb3NpdGlvbih0ci5kb2MsIHBvc2l0aW9uKSB8fCBlZGl0b3Iuc3RhdGUuc2VsZWN0aW9uO1xuICBjb25zdCBpc1NhbWVTZWxlY3Rpb24gPSBlZGl0b3Iuc3RhdGUuc2VsZWN0aW9uLmVxKHNlbGVjdGlvbik7XG4gIGlmIChkaXNwYXRjaCkge1xuICAgIGlmICghaXNTYW1lU2VsZWN0aW9uKSB7XG4gICAgICB0ci5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgICB9XG4gICAgaWYgKGlzU2FtZVNlbGVjdGlvbiAmJiB0ci5zdG9yZWRNYXJrcykge1xuICAgICAgdHIuc2V0U3RvcmVkTWFya3ModHIuc3RvcmVkTWFya3MpO1xuICAgIH1cbiAgICBkZWxheWVkRm9jdXMoKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy9mb3JFYWNoLnRzXG52YXIgZm9yRWFjaCA9IChpdGVtcywgZm4pID0+IChwcm9wcykgPT4ge1xuICByZXR1cm4gaXRlbXMuZXZlcnkoKGl0ZW0sIGluZGV4KSA9PiBmbihpdGVtLCB7IC4uLnByb3BzLCBpbmRleCB9KSk7XG59O1xuXG4vLyBzcmMvY29tbWFuZHMvaW5zZXJ0Q29udGVudC50c1xudmFyIGluc2VydENvbnRlbnQgPSAodmFsdWUsIG9wdGlvbnMpID0+ICh7IHRyLCBjb21tYW5kcyB9KSA9PiB7XG4gIHJldHVybiBjb21tYW5kcy5pbnNlcnRDb250ZW50QXQoeyBmcm9tOiB0ci5zZWxlY3Rpb24uZnJvbSwgdG86IHRyLnNlbGVjdGlvbi50byB9LCB2YWx1ZSwgb3B0aW9ucyk7XG59O1xuXG4vLyBzcmMvY29tbWFuZHMvaW5zZXJ0Q29udGVudEF0LnRzXG5pbXBvcnQgeyBGcmFnbWVudCBhcyBGcmFnbWVudDIgfSBmcm9tIFwiQHRpcHRhcC9wbS9tb2RlbFwiO1xuXG4vLyBzcmMvaGVscGVycy9jcmVhdGVOb2RlRnJvbUNvbnRlbnQudHNcbmltcG9ydCB7IERPTVBhcnNlciwgRnJhZ21lbnQsIE5vZGUgYXMgUHJvc2VNaXJyb3JOb2RlLCBTY2hlbWEgfSBmcm9tIFwiQHRpcHRhcC9wbS9tb2RlbFwiO1xuXG4vLyBzcmMvdXRpbGl0aWVzL2VsZW1lbnRGcm9tU3RyaW5nLnRzXG52YXIgcmVtb3ZlV2hpdGVzcGFjZXMgPSAobm9kZSkgPT4ge1xuICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuY2hpbGROb2RlcztcbiAgZm9yIChsZXQgaSA9IGNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT09IDMgJiYgY2hpbGQubm9kZVZhbHVlICYmIC9eKFxcblxcc1xcc3xcXG4pJC8udGVzdChjaGlsZC5ub2RlVmFsdWUpKSB7XG4gICAgICBub2RlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICB9IGVsc2UgaWYgKGNoaWxkLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICByZW1vdmVXaGl0ZXNwYWNlcyhjaGlsZCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBub2RlO1xufTtcbmZ1bmN0aW9uIGVsZW1lbnRGcm9tU3RyaW5nKHZhbHVlKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiW3RpcHRhcCBlcnJvcl06IHRoZXJlIGlzIG5vIHdpbmRvdyBvYmplY3QgYXZhaWxhYmxlLCBzbyB0aGlzIGZ1bmN0aW9uIGNhbm5vdCBiZSB1c2VkXCIpO1xuICB9XG4gIGNvbnN0IHdyYXBwZWRWYWx1ZSA9IGA8Ym9keT4ke3ZhbHVlfTwvYm9keT5gO1xuICBjb25zdCBodG1sID0gbmV3IHdpbmRvdy5ET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcod3JhcHBlZFZhbHVlLCBcInRleHQvaHRtbFwiKS5ib2R5O1xuICByZXR1cm4gcmVtb3ZlV2hpdGVzcGFjZXMoaHRtbCk7XG59XG5cbi8vIHNyYy9oZWxwZXJzL2NyZWF0ZU5vZGVGcm9tQ29udGVudC50c1xuZnVuY3Rpb24gY3JlYXRlTm9kZUZyb21Db250ZW50KGNvbnRlbnQsIHNjaGVtYSwgb3B0aW9ucykge1xuICBpZiAoY29udGVudCBpbnN0YW5jZW9mIFByb3NlTWlycm9yTm9kZSB8fCBjb250ZW50IGluc3RhbmNlb2YgRnJhZ21lbnQpIHtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuICBvcHRpb25zID0ge1xuICAgIHNsaWNlOiB0cnVlLFxuICAgIHBhcnNlT3B0aW9uczoge30sXG4gICAgLi4ub3B0aW9uc1xuICB9O1xuICBjb25zdCBpc0pTT05Db250ZW50ID0gdHlwZW9mIGNvbnRlbnQgPT09IFwib2JqZWN0XCIgJiYgY29udGVudCAhPT0gbnVsbDtcbiAgY29uc3QgaXNUZXh0Q29udGVudCA9IHR5cGVvZiBjb250ZW50ID09PSBcInN0cmluZ1wiO1xuICBpZiAoaXNKU09OQ29udGVudCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBpc0FycmF5Q29udGVudCA9IEFycmF5LmlzQXJyYXkoY29udGVudCkgJiYgY29udGVudC5sZW5ndGggPiAwO1xuICAgICAgaWYgKGlzQXJyYXlDb250ZW50KSB7XG4gICAgICAgIHJldHVybiBGcmFnbWVudC5mcm9tQXJyYXkoY29udGVudC5tYXAoKGl0ZW0pID0+IHNjaGVtYS5ub2RlRnJvbUpTT04oaXRlbSkpKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5vZGUgPSBzY2hlbWEubm9kZUZyb21KU09OKGNvbnRlbnQpO1xuICAgICAgaWYgKG9wdGlvbnMuZXJyb3JPbkludmFsaWRDb250ZW50KSB7XG4gICAgICAgIG5vZGUuY2hlY2soKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAob3B0aW9ucy5lcnJvck9uSW52YWxpZENvbnRlbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiW3RpcHRhcCBlcnJvcl06IEludmFsaWQgSlNPTiBjb250ZW50XCIsIHsgY2F1c2U6IGVycm9yIH0pO1xuICAgICAgfVxuICAgICAgY29uc29sZS53YXJuKFwiW3RpcHRhcCB3YXJuXTogSW52YWxpZCBjb250ZW50LlwiLCBcIlBhc3NlZCB2YWx1ZTpcIiwgY29udGVudCwgXCJFcnJvcjpcIiwgZXJyb3IpO1xuICAgICAgcmV0dXJuIGNyZWF0ZU5vZGVGcm9tQ29udGVudChcIlwiLCBzY2hlbWEsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNUZXh0Q29udGVudCkge1xuICAgIGlmIChvcHRpb25zLmVycm9yT25JbnZhbGlkQ29udGVudCkge1xuICAgICAgbGV0IGhhc0ludmFsaWRDb250ZW50ID0gZmFsc2U7XG4gICAgICBsZXQgaW52YWxpZENvbnRlbnQgPSBcIlwiO1xuICAgICAgY29uc3QgY29udGVudENoZWNrU2NoZW1hID0gbmV3IFNjaGVtYSh7XG4gICAgICAgIHRvcE5vZGU6IHNjaGVtYS5zcGVjLnRvcE5vZGUsXG4gICAgICAgIG1hcmtzOiBzY2hlbWEuc3BlYy5tYXJrcyxcbiAgICAgICAgLy8gUHJvc2VtaXJyb3IncyBzY2hlbWFzIGFyZSBleGVjdXRlZCBzdWNoIHRoYXQ6IHRoZSBsYXN0IHRvIGV4ZWN1dGUsIG1hdGNoZXMgbGFzdFxuICAgICAgICAvLyBUaGlzIG1lYW5zIHRoYXQgd2UgY2FuIGFkZCBhIGNhdGNoLWFsbCBub2RlIGF0IHRoZSBlbmQgb2YgdGhlIHNjaGVtYSB0byBjYXRjaCBhbnkgY29udGVudCB0aGF0IHdlIGRvbid0IGtub3cgaG93IHRvIGhhbmRsZVxuICAgICAgICBub2Rlczogc2NoZW1hLnNwZWMubm9kZXMuYXBwZW5kKHtcbiAgICAgICAgICBfX3RpcHRhcF9fcHJpdmF0ZV9fdW5rbm93bl9fY2F0Y2hfX2FsbF9fbm9kZToge1xuICAgICAgICAgICAgY29udGVudDogXCJpbmxpbmUqXCIsXG4gICAgICAgICAgICBncm91cDogXCJibG9ja1wiLFxuICAgICAgICAgICAgcGFyc2VET006IFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRhZzogXCIqXCIsXG4gICAgICAgICAgICAgICAgZ2V0QXR0cnM6IChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICBoYXNJbnZhbGlkQ29udGVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICBpbnZhbGlkQ29udGVudCA9IHR5cGVvZiBlID09PSBcInN0cmluZ1wiID8gZSA6IGUub3V0ZXJIVE1MO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICBpZiAob3B0aW9ucy5zbGljZSkge1xuICAgICAgICBET01QYXJzZXIuZnJvbVNjaGVtYShjb250ZW50Q2hlY2tTY2hlbWEpLnBhcnNlU2xpY2UoZWxlbWVudEZyb21TdHJpbmcoY29udGVudCksIG9wdGlvbnMucGFyc2VPcHRpb25zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIERPTVBhcnNlci5mcm9tU2NoZW1hKGNvbnRlbnRDaGVja1NjaGVtYSkucGFyc2UoZWxlbWVudEZyb21TdHJpbmcoY29udGVudCksIG9wdGlvbnMucGFyc2VPcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmVycm9yT25JbnZhbGlkQ29udGVudCAmJiBoYXNJbnZhbGlkQ29udGVudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJbdGlwdGFwIGVycm9yXTogSW52YWxpZCBIVE1MIGNvbnRlbnRcIiwge1xuICAgICAgICAgIGNhdXNlOiBuZXcgRXJyb3IoYEludmFsaWQgZWxlbWVudCBmb3VuZDogJHtpbnZhbGlkQ29udGVudH1gKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcGFyc2VyID0gRE9NUGFyc2VyLmZyb21TY2hlbWEoc2NoZW1hKTtcbiAgICBpZiAob3B0aW9ucy5zbGljZSkge1xuICAgICAgcmV0dXJuIHBhcnNlci5wYXJzZVNsaWNlKGVsZW1lbnRGcm9tU3RyaW5nKGNvbnRlbnQpLCBvcHRpb25zLnBhcnNlT3B0aW9ucykuY29udGVudDtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlci5wYXJzZShlbGVtZW50RnJvbVN0cmluZyhjb250ZW50KSwgb3B0aW9ucy5wYXJzZU9wdGlvbnMpO1xuICB9XG4gIHJldHVybiBjcmVhdGVOb2RlRnJvbUNvbnRlbnQoXCJcIiwgc2NoZW1hLCBvcHRpb25zKTtcbn1cblxuLy8gc3JjL2hlbHBlcnMvc2VsZWN0aW9uVG9JbnNlcnRpb25FbmQudHNcbmltcG9ydCB7IFNlbGVjdGlvbiBhcyBTZWxlY3Rpb24yIH0gZnJvbSBcIkB0aXB0YXAvcG0vc3RhdGVcIjtcbmltcG9ydCB7IFJlcGxhY2VBcm91bmRTdGVwLCBSZXBsYWNlU3RlcCB9IGZyb20gXCJAdGlwdGFwL3BtL3RyYW5zZm9ybVwiO1xuZnVuY3Rpb24gc2VsZWN0aW9uVG9JbnNlcnRpb25FbmQodHIsIHN0YXJ0TGVuLCBiaWFzKSB7XG4gIGNvbnN0IGxhc3QgPSB0ci5zdGVwcy5sZW5ndGggLSAxO1xuICBpZiAobGFzdCA8IHN0YXJ0TGVuKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHN0ZXAgPSB0ci5zdGVwc1tsYXN0XTtcbiAgaWYgKCEoc3RlcCBpbnN0YW5jZW9mIFJlcGxhY2VTdGVwIHx8IHN0ZXAgaW5zdGFuY2VvZiBSZXBsYWNlQXJvdW5kU3RlcCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgbWFwID0gdHIubWFwcGluZy5tYXBzW2xhc3RdO1xuICBsZXQgZW5kID0gMDtcbiAgbWFwLmZvckVhY2goKF9mcm9tLCBfdG8sIF9uZXdGcm9tLCBuZXdUbykgPT4ge1xuICAgIGlmIChlbmQgPT09IDApIHtcbiAgICAgIGVuZCA9IG5ld1RvO1xuICAgIH1cbiAgfSk7XG4gIHRyLnNldFNlbGVjdGlvbihTZWxlY3Rpb24yLm5lYXIodHIuZG9jLnJlc29sdmUoZW5kKSwgYmlhcykpO1xufVxuXG4vLyBzcmMvY29tbWFuZHMvaW5zZXJ0Q29udGVudEF0LnRzXG52YXIgaXNGcmFnbWVudCA9IChub2RlT3JGcmFnbWVudCkgPT4ge1xuICByZXR1cm4gIShcInR5cGVcIiBpbiBub2RlT3JGcmFnbWVudCk7XG59O1xudmFyIGluc2VydENvbnRlbnRBdCA9IChwb3NpdGlvbiwgdmFsdWUsIG9wdGlvbnMpID0+ICh7IHRyLCBkaXNwYXRjaCwgZWRpdG9yIH0pID0+IHtcbiAgdmFyIF9hO1xuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICBvcHRpb25zID0ge1xuICAgICAgcGFyc2VPcHRpb25zOiBlZGl0b3Iub3B0aW9ucy5wYXJzZU9wdGlvbnMsXG4gICAgICB1cGRhdGVTZWxlY3Rpb246IHRydWUsXG4gICAgICBhcHBseUlucHV0UnVsZXM6IGZhbHNlLFxuICAgICAgYXBwbHlQYXN0ZVJ1bGVzOiBmYWxzZSxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuICAgIGxldCBjb250ZW50O1xuICAgIGNvbnN0IGVtaXRDb250ZW50RXJyb3IgPSAoZXJyb3IpID0+IHtcbiAgICAgIGVkaXRvci5lbWl0KFwiY29udGVudEVycm9yXCIsIHtcbiAgICAgICAgZWRpdG9yLFxuICAgICAgICBlcnJvcixcbiAgICAgICAgZGlzYWJsZUNvbGxhYm9yYXRpb246ICgpID0+IHtcbiAgICAgICAgICBpZiAoXCJjb2xsYWJvcmF0aW9uXCIgaW4gZWRpdG9yLnN0b3JhZ2UgJiYgdHlwZW9mIGVkaXRvci5zdG9yYWdlLmNvbGxhYm9yYXRpb24gPT09IFwib2JqZWN0XCIgJiYgZWRpdG9yLnN0b3JhZ2UuY29sbGFib3JhdGlvbikge1xuICAgICAgICAgICAgO1xuICAgICAgICAgICAgZWRpdG9yLnN0b3JhZ2UuY29sbGFib3JhdGlvbi5pc0Rpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgcGFyc2VPcHRpb25zID0ge1xuICAgICAgcHJlc2VydmVXaGl0ZXNwYWNlOiBcImZ1bGxcIixcbiAgICAgIC4uLm9wdGlvbnMucGFyc2VPcHRpb25zXG4gICAgfTtcbiAgICBpZiAoIW9wdGlvbnMuZXJyb3JPbkludmFsaWRDb250ZW50ICYmICFlZGl0b3Iub3B0aW9ucy5lbmFibGVDb250ZW50Q2hlY2sgJiYgZWRpdG9yLm9wdGlvbnMuZW1pdENvbnRlbnRFcnJvcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY3JlYXRlTm9kZUZyb21Db250ZW50KHZhbHVlLCBlZGl0b3Iuc2NoZW1hLCB7XG4gICAgICAgICAgcGFyc2VPcHRpb25zLFxuICAgICAgICAgIGVycm9yT25JbnZhbGlkQ29udGVudDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZW1pdENvbnRlbnRFcnJvcihlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnRlbnQgPSBjcmVhdGVOb2RlRnJvbUNvbnRlbnQodmFsdWUsIGVkaXRvci5zY2hlbWEsIHtcbiAgICAgICAgcGFyc2VPcHRpb25zLFxuICAgICAgICBlcnJvck9uSW52YWxpZENvbnRlbnQ6IChfYSA9IG9wdGlvbnMuZXJyb3JPbkludmFsaWRDb250ZW50KSAhPSBudWxsID8gX2EgOiBlZGl0b3Iub3B0aW9ucy5lbmFibGVDb250ZW50Q2hlY2tcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVtaXRDb250ZW50RXJyb3IoZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCB7IGZyb20sIHRvIH0gPSB0eXBlb2YgcG9zaXRpb24gPT09IFwibnVtYmVyXCIgPyB7IGZyb206IHBvc2l0aW9uLCB0bzogcG9zaXRpb24gfSA6IHsgZnJvbTogcG9zaXRpb24uZnJvbSwgdG86IHBvc2l0aW9uLnRvIH07XG4gICAgbGV0IGlzT25seVRleHRDb250ZW50ID0gdHJ1ZTtcbiAgICBsZXQgaXNPbmx5QmxvY2tDb250ZW50ID0gdHJ1ZTtcbiAgICBjb25zdCBub2RlcyA9IGlzRnJhZ21lbnQoY29udGVudCkgPyBjb250ZW50IDogW2NvbnRlbnRdO1xuICAgIG5vZGVzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgIG5vZGUuY2hlY2soKTtcbiAgICAgIGlzT25seVRleHRDb250ZW50ID0gaXNPbmx5VGV4dENvbnRlbnQgPyBub2RlLmlzVGV4dCAmJiBub2RlLm1hcmtzLmxlbmd0aCA9PT0gMCA6IGZhbHNlO1xuICAgICAgaXNPbmx5QmxvY2tDb250ZW50ID0gaXNPbmx5QmxvY2tDb250ZW50ID8gbm9kZS5pc0Jsb2NrIDogZmFsc2U7XG4gICAgfSk7XG4gICAgaWYgKGZyb20gPT09IHRvICYmIGlzT25seUJsb2NrQ29udGVudCkge1xuICAgICAgY29uc3QgeyBwYXJlbnQgfSA9IHRyLmRvYy5yZXNvbHZlKGZyb20pO1xuICAgICAgY29uc3QgaXNFbXB0eVRleHRCbG9jayA9IHBhcmVudC5pc1RleHRibG9jayAmJiAhcGFyZW50LnR5cGUuc3BlYy5jb2RlICYmICFwYXJlbnQuY2hpbGRDb3VudDtcbiAgICAgIGlmIChpc0VtcHR5VGV4dEJsb2NrKSB7XG4gICAgICAgIGZyb20gLT0gMTtcbiAgICAgICAgdG8gKz0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IG5ld0NvbnRlbnQ7XG4gICAgaWYgKGlzT25seVRleHRDb250ZW50KSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgbmV3Q29udGVudCA9IHZhbHVlLm1hcCgodikgPT4gdi50ZXh0IHx8IFwiXCIpLmpvaW4oXCJcIik7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgRnJhZ21lbnQyKSB7XG4gICAgICAgIGxldCB0ZXh0ID0gXCJcIjtcbiAgICAgICAgdmFsdWUuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgICAgIGlmIChub2RlLnRleHQpIHtcbiAgICAgICAgICAgIHRleHQgKz0gbm9kZS50ZXh0O1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIG5ld0NvbnRlbnQgPSB0ZXh0O1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgISF2YWx1ZSAmJiAhIXZhbHVlLnRleHQpIHtcbiAgICAgICAgbmV3Q29udGVudCA9IHZhbHVlLnRleHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdDb250ZW50ID0gdmFsdWU7XG4gICAgICB9XG4gICAgICB0ci5pbnNlcnRUZXh0KG5ld0NvbnRlbnQsIGZyb20sIHRvKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3Q29udGVudCA9IGNvbnRlbnQ7XG4gICAgICBjb25zdCAkZnJvbSA9IHRyLmRvYy5yZXNvbHZlKGZyb20pO1xuICAgICAgY29uc3QgJGZyb21Ob2RlID0gJGZyb20ubm9kZSgpO1xuICAgICAgY29uc3QgZnJvbVNlbGVjdGlvbkF0U3RhcnQgPSAkZnJvbS5wYXJlbnRPZmZzZXQgPT09IDA7XG4gICAgICBjb25zdCBpc1RleHRTZWxlY3Rpb24yID0gJGZyb21Ob2RlLmlzVGV4dCB8fCAkZnJvbU5vZGUuaXNUZXh0YmxvY2s7XG4gICAgICBjb25zdCBoYXNDb250ZW50ID0gJGZyb21Ob2RlLmNvbnRlbnQuc2l6ZSA+IDA7XG4gICAgICBpZiAoZnJvbVNlbGVjdGlvbkF0U3RhcnQgJiYgaXNUZXh0U2VsZWN0aW9uMiAmJiBoYXNDb250ZW50KSB7XG4gICAgICAgIGZyb20gPSBNYXRoLm1heCgwLCBmcm9tIC0gMSk7XG4gICAgICB9XG4gICAgICB0ci5yZXBsYWNlV2l0aChmcm9tLCB0bywgbmV3Q29udGVudCk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnVwZGF0ZVNlbGVjdGlvbikge1xuICAgICAgc2VsZWN0aW9uVG9JbnNlcnRpb25FbmQodHIsIHRyLnN0ZXBzLmxlbmd0aCAtIDEsIC0xKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuYXBwbHlJbnB1dFJ1bGVzKSB7XG4gICAgICB0ci5zZXRNZXRhKFwiYXBwbHlJbnB1dFJ1bGVzXCIsIHsgZnJvbSwgdGV4dDogbmV3Q29udGVudCB9KTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuYXBwbHlQYXN0ZVJ1bGVzKSB7XG4gICAgICB0ci5zZXRNZXRhKFwiYXBwbHlQYXN0ZVJ1bGVzXCIsIHsgZnJvbSwgdGV4dDogbmV3Q29udGVudCB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vLyBzcmMvY29tbWFuZHMvam9pbi50c1xuaW1wb3J0IHtcbiAgam9pbkJhY2t3YXJkIGFzIG9yaWdpbmFsSm9pbkJhY2t3YXJkLFxuICBqb2luRG93biBhcyBvcmlnaW5hbEpvaW5Eb3duLFxuICBqb2luRm9yd2FyZCBhcyBvcmlnaW5hbEpvaW5Gb3J3YXJkLFxuICBqb2luVXAgYXMgb3JpZ2luYWxKb2luVXBcbn0gZnJvbSBcIkB0aXB0YXAvcG0vY29tbWFuZHNcIjtcbnZhciBqb2luVXAgPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICByZXR1cm4gb3JpZ2luYWxKb2luVXAoc3RhdGUsIGRpc3BhdGNoKTtcbn07XG52YXIgam9pbkRvd24gPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICByZXR1cm4gb3JpZ2luYWxKb2luRG93bihzdGF0ZSwgZGlzcGF0Y2gpO1xufTtcbnZhciBqb2luQmFja3dhcmQgPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICByZXR1cm4gb3JpZ2luYWxKb2luQmFja3dhcmQoc3RhdGUsIGRpc3BhdGNoKTtcbn07XG52YXIgam9pbkZvcndhcmQgPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICByZXR1cm4gb3JpZ2luYWxKb2luRm9yd2FyZChzdGF0ZSwgZGlzcGF0Y2gpO1xufTtcblxuLy8gc3JjL2NvbW1hbmRzL2pvaW5JdGVtQmFja3dhcmQudHNcbmltcG9ydCB7IGpvaW5Qb2ludCB9IGZyb20gXCJAdGlwdGFwL3BtL3RyYW5zZm9ybVwiO1xudmFyIGpvaW5JdGVtQmFja3dhcmQgPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2gsIHRyIH0pID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBwb2ludCA9IGpvaW5Qb2ludChzdGF0ZS5kb2MsIHN0YXRlLnNlbGVjdGlvbi4kZnJvbS5wb3MsIC0xKTtcbiAgICBpZiAocG9pbnQgPT09IG51bGwgfHwgcG9pbnQgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0ci5qb2luKHBvaW50LCAyKTtcbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgIGRpc3BhdGNoKHRyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuLy8gc3JjL2NvbW1hbmRzL2pvaW5JdGVtRm9yd2FyZC50c1xuaW1wb3J0IHsgam9pblBvaW50IGFzIGpvaW5Qb2ludDIgfSBmcm9tIFwiQHRpcHRhcC9wbS90cmFuc2Zvcm1cIjtcbnZhciBqb2luSXRlbUZvcndhcmQgPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2gsIHRyIH0pID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBwb2ludCA9IGpvaW5Qb2ludDIoc3RhdGUuZG9jLCBzdGF0ZS5zZWxlY3Rpb24uJGZyb20ucG9zLCAxKTtcbiAgICBpZiAocG9pbnQgPT09IG51bGwgfHwgcG9pbnQgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0ci5qb2luKHBvaW50LCAyKTtcbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgIGRpc3BhdGNoKHRyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuLy8gc3JjL2NvbW1hbmRzL2pvaW5UZXh0YmxvY2tCYWNrd2FyZC50c1xuaW1wb3J0IHsgam9pblRleHRibG9ja0JhY2t3YXJkIGFzIG9yaWdpbmFsQ29tbWFuZCB9IGZyb20gXCJAdGlwdGFwL3BtL2NvbW1hbmRzXCI7XG52YXIgam9pblRleHRibG9ja0JhY2t3YXJkID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgcmV0dXJuIG9yaWdpbmFsQ29tbWFuZChzdGF0ZSwgZGlzcGF0Y2gpO1xufTtcblxuLy8gc3JjL2NvbW1hbmRzL2pvaW5UZXh0YmxvY2tGb3J3YXJkLnRzXG5pbXBvcnQgeyBqb2luVGV4dGJsb2NrRm9yd2FyZCBhcyBvcmlnaW5hbENvbW1hbmQyIH0gZnJvbSBcIkB0aXB0YXAvcG0vY29tbWFuZHNcIjtcbnZhciBqb2luVGV4dGJsb2NrRm9yd2FyZCA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIHJldHVybiBvcmlnaW5hbENvbW1hbmQyKHN0YXRlLCBkaXNwYXRjaCk7XG59O1xuXG4vLyBzcmMvdXRpbGl0aWVzL2lzTWFjT1MudHNcbmZ1bmN0aW9uIGlzTWFjT1MoKSB7XG4gIHJldHVybiB0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiID8gL01hYy8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pIDogZmFsc2U7XG59XG5cbi8vIHNyYy9jb21tYW5kcy9rZXlib2FyZFNob3J0Y3V0LnRzXG5mdW5jdGlvbiBub3JtYWxpemVLZXlOYW1lKG5hbWUpIHtcbiAgY29uc3QgcGFydHMgPSBuYW1lLnNwbGl0KC8tKD8hJCkvKTtcbiAgbGV0IHJlc3VsdCA9IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdO1xuICBpZiAocmVzdWx0ID09PSBcIlNwYWNlXCIpIHtcbiAgICByZXN1bHQgPSBcIiBcIjtcbiAgfVxuICBsZXQgYWx0O1xuICBsZXQgY3RybDtcbiAgbGV0IHNoaWZ0O1xuICBsZXQgbWV0YTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGggLSAxOyBpICs9IDEpIHtcbiAgICBjb25zdCBtb2QgPSBwYXJ0c1tpXTtcbiAgICBpZiAoL14oY21kfG1ldGF8bSkkL2kudGVzdChtb2QpKSB7XG4gICAgICBtZXRhID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKC9eYShsdCk/JC9pLnRlc3QobW9kKSkge1xuICAgICAgYWx0ID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKC9eKGN8Y3RybHxjb250cm9sKSQvaS50ZXN0KG1vZCkpIHtcbiAgICAgIGN0cmwgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoL15zKGhpZnQpPyQvaS50ZXN0KG1vZCkpIHtcbiAgICAgIHNoaWZ0ID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKC9ebW9kJC9pLnRlc3QobW9kKSkge1xuICAgICAgaWYgKGlzaU9TKCkgfHwgaXNNYWNPUygpKSB7XG4gICAgICAgIG1ldGEgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3RybCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5yZWNvZ25pemVkIG1vZGlmaWVyIG5hbWU6ICR7bW9kfWApO1xuICAgIH1cbiAgfVxuICBpZiAoYWx0KSB7XG4gICAgcmVzdWx0ID0gYEFsdC0ke3Jlc3VsdH1gO1xuICB9XG4gIGlmIChjdHJsKSB7XG4gICAgcmVzdWx0ID0gYEN0cmwtJHtyZXN1bHR9YDtcbiAgfVxuICBpZiAobWV0YSkge1xuICAgIHJlc3VsdCA9IGBNZXRhLSR7cmVzdWx0fWA7XG4gIH1cbiAgaWYgKHNoaWZ0KSB7XG4gICAgcmVzdWx0ID0gYFNoaWZ0LSR7cmVzdWx0fWA7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbnZhciBrZXlib2FyZFNob3J0Y3V0ID0gKG5hbWUpID0+ICh7IGVkaXRvciwgdmlldywgdHIsIGRpc3BhdGNoIH0pID0+IHtcbiAgY29uc3Qga2V5cyA9IG5vcm1hbGl6ZUtleU5hbWUobmFtZSkuc3BsaXQoLy0oPyEkKS8pO1xuICBjb25zdCBrZXkgPSBrZXlzLmZpbmQoKGl0ZW0pID0+ICFbXCJBbHRcIiwgXCJDdHJsXCIsIFwiTWV0YVwiLCBcIlNoaWZ0XCJdLmluY2x1ZGVzKGl0ZW0pKTtcbiAgY29uc3QgZXZlbnQgPSBuZXcgS2V5Ym9hcmRFdmVudChcImtleWRvd25cIiwge1xuICAgIGtleToga2V5ID09PSBcIlNwYWNlXCIgPyBcIiBcIiA6IGtleSxcbiAgICBhbHRLZXk6IGtleXMuaW5jbHVkZXMoXCJBbHRcIiksXG4gICAgY3RybEtleToga2V5cy5pbmNsdWRlcyhcIkN0cmxcIiksXG4gICAgbWV0YUtleToga2V5cy5pbmNsdWRlcyhcIk1ldGFcIiksXG4gICAgc2hpZnRLZXk6IGtleXMuaW5jbHVkZXMoXCJTaGlmdFwiKSxcbiAgICBidWJibGVzOiB0cnVlLFxuICAgIGNhbmNlbGFibGU6IHRydWVcbiAgfSk7XG4gIGNvbnN0IGNhcHR1cmVkVHJhbnNhY3Rpb24gPSBlZGl0b3IuY2FwdHVyZVRyYW5zYWN0aW9uKCgpID0+IHtcbiAgICB2aWV3LnNvbWVQcm9wKFwiaGFuZGxlS2V5RG93blwiLCAoZikgPT4gZih2aWV3LCBldmVudCkpO1xuICB9KTtcbiAgY2FwdHVyZWRUcmFuc2FjdGlvbiA9PSBudWxsID8gdm9pZCAwIDogY2FwdHVyZWRUcmFuc2FjdGlvbi5zdGVwcy5mb3JFYWNoKChzdGVwKSA9PiB7XG4gICAgY29uc3QgbmV3U3RlcCA9IHN0ZXAubWFwKHRyLm1hcHBpbmcpO1xuICAgIGlmIChuZXdTdGVwICYmIGRpc3BhdGNoKSB7XG4gICAgICB0ci5tYXliZVN0ZXAobmV3U3RlcCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vLyBzcmMvY29tbWFuZHMvbGlmdC50c1xuaW1wb3J0IHsgbGlmdCBhcyBvcmlnaW5hbExpZnQgfSBmcm9tIFwiQHRpcHRhcC9wbS9jb21tYW5kc1wiO1xuXG4vLyBzcmMvaGVscGVycy9pc05vZGVBY3RpdmUudHNcbmZ1bmN0aW9uIGlzTm9kZUFjdGl2ZShzdGF0ZSwgdHlwZU9yTmFtZSwgYXR0cmlidXRlcyA9IHt9KSB7XG4gIGNvbnN0IHsgZnJvbSwgdG8sIGVtcHR5IH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gIGNvbnN0IHR5cGUgPSB0eXBlT3JOYW1lID8gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKSA6IG51bGw7XG4gIGNvbnN0IG5vZGVSYW5nZXMgPSBbXTtcbiAgc3RhdGUuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUsIHBvcykgPT4ge1xuICAgIGlmIChub2RlLmlzVGV4dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZWxhdGl2ZUZyb20gPSBNYXRoLm1heChmcm9tLCBwb3MpO1xuICAgIGNvbnN0IHJlbGF0aXZlVG8gPSBNYXRoLm1pbih0bywgcG9zICsgbm9kZS5ub2RlU2l6ZSk7XG4gICAgbm9kZVJhbmdlcy5wdXNoKHtcbiAgICAgIG5vZGUsXG4gICAgICBmcm9tOiByZWxhdGl2ZUZyb20sXG4gICAgICB0bzogcmVsYXRpdmVUb1xuICAgIH0pO1xuICB9KTtcbiAgY29uc3Qgc2VsZWN0aW9uUmFuZ2UgPSB0byAtIGZyb207XG4gIGNvbnN0IG1hdGNoZWROb2RlUmFuZ2VzID0gbm9kZVJhbmdlcy5maWx0ZXIoKG5vZGVSYW5nZSkgPT4ge1xuICAgIGlmICghdHlwZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiB0eXBlLm5hbWUgPT09IG5vZGVSYW5nZS5ub2RlLnR5cGUubmFtZTtcbiAgfSkuZmlsdGVyKChub2RlUmFuZ2UpID0+IG9iamVjdEluY2x1ZGVzKG5vZGVSYW5nZS5ub2RlLmF0dHJzLCBhdHRyaWJ1dGVzLCB7IHN0cmljdDogZmFsc2UgfSkpO1xuICBpZiAoZW1wdHkpIHtcbiAgICByZXR1cm4gISFtYXRjaGVkTm9kZVJhbmdlcy5sZW5ndGg7XG4gIH1cbiAgY29uc3QgcmFuZ2UgPSBtYXRjaGVkTm9kZVJhbmdlcy5yZWR1Y2UoKHN1bSwgbm9kZVJhbmdlKSA9PiBzdW0gKyBub2RlUmFuZ2UudG8gLSBub2RlUmFuZ2UuZnJvbSwgMCk7XG4gIHJldHVybiByYW5nZSA+PSBzZWxlY3Rpb25SYW5nZTtcbn1cblxuLy8gc3JjL2NvbW1hbmRzL2xpZnQudHNcbnZhciBsaWZ0ID0gKHR5cGVPck5hbWUsIGF0dHJpYnV0ZXMgPSB7fSkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgY29uc3QgdHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XG4gIGNvbnN0IGlzQWN0aXZlMiA9IGlzTm9kZUFjdGl2ZShzdGF0ZSwgdHlwZSwgYXR0cmlidXRlcyk7XG4gIGlmICghaXNBY3RpdmUyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBvcmlnaW5hbExpZnQoc3RhdGUsIGRpc3BhdGNoKTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy9saWZ0RW1wdHlCbG9jay50c1xuaW1wb3J0IHsgbGlmdEVtcHR5QmxvY2sgYXMgb3JpZ2luYWxMaWZ0RW1wdHlCbG9jayB9IGZyb20gXCJAdGlwdGFwL3BtL2NvbW1hbmRzXCI7XG52YXIgbGlmdEVtcHR5QmxvY2sgPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICByZXR1cm4gb3JpZ2luYWxMaWZ0RW1wdHlCbG9jayhzdGF0ZSwgZGlzcGF0Y2gpO1xufTtcblxuLy8gc3JjL2NvbW1hbmRzL2xpZnRMaXN0SXRlbS50c1xuaW1wb3J0IHsgbGlmdExpc3RJdGVtIGFzIG9yaWdpbmFsTGlmdExpc3RJdGVtIH0gZnJvbSBcIkB0aXB0YXAvcG0vc2NoZW1hLWxpc3RcIjtcbnZhciBsaWZ0TGlzdEl0ZW0gPSAodHlwZU9yTmFtZSkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgY29uc3QgdHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XG4gIHJldHVybiBvcmlnaW5hbExpZnRMaXN0SXRlbSh0eXBlKShzdGF0ZSwgZGlzcGF0Y2gpO1xufTtcblxuLy8gc3JjL2NvbW1hbmRzL25ld2xpbmVJbkNvZGUudHNcbmltcG9ydCB7IG5ld2xpbmVJbkNvZGUgYXMgb3JpZ2luYWxOZXdsaW5lSW5Db2RlIH0gZnJvbSBcIkB0aXB0YXAvcG0vY29tbWFuZHNcIjtcbnZhciBuZXdsaW5lSW5Db2RlID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgcmV0dXJuIG9yaWdpbmFsTmV3bGluZUluQ29kZShzdGF0ZSwgZGlzcGF0Y2gpO1xufTtcblxuLy8gc3JjL2hlbHBlcnMvZ2V0U2NoZW1hVHlwZU5hbWVCeU5hbWUudHNcbmZ1bmN0aW9uIGdldFNjaGVtYVR5cGVOYW1lQnlOYW1lKG5hbWUsIHNjaGVtYSkge1xuICBpZiAoc2NoZW1hLm5vZGVzW25hbWVdKSB7XG4gICAgcmV0dXJuIFwibm9kZVwiO1xuICB9XG4gIGlmIChzY2hlbWEubWFya3NbbmFtZV0pIHtcbiAgICByZXR1cm4gXCJtYXJrXCI7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8vIHNyYy91dGlsaXRpZXMvZGVsZXRlUHJvcHMudHNcbmZ1bmN0aW9uIGRlbGV0ZVByb3BzKG9iaiwgcHJvcE9yUHJvcHMpIHtcbiAgY29uc3QgcHJvcHMgPSB0eXBlb2YgcHJvcE9yUHJvcHMgPT09IFwic3RyaW5nXCIgPyBbcHJvcE9yUHJvcHNdIDogcHJvcE9yUHJvcHM7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmopLnJlZHVjZSgobmV3T2JqLCBwcm9wKSA9PiB7XG4gICAgaWYgKCFwcm9wcy5pbmNsdWRlcyhwcm9wKSkge1xuICAgICAgbmV3T2JqW3Byb3BdID0gb2JqW3Byb3BdO1xuICAgIH1cbiAgICByZXR1cm4gbmV3T2JqO1xuICB9LCB7fSk7XG59XG5cbi8vIHNyYy9jb21tYW5kcy9yZXNldEF0dHJpYnV0ZXMudHNcbnZhciByZXNldEF0dHJpYnV0ZXMgPSAodHlwZU9yTmFtZSwgYXR0cmlidXRlcykgPT4gKHsgdHIsIHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGxldCBub2RlVHlwZSA9IG51bGw7XG4gIGxldCBtYXJrVHlwZSA9IG51bGw7XG4gIGNvbnN0IHNjaGVtYVR5cGUgPSBnZXRTY2hlbWFUeXBlTmFtZUJ5TmFtZShcbiAgICB0eXBlb2YgdHlwZU9yTmFtZSA9PT0gXCJzdHJpbmdcIiA/IHR5cGVPck5hbWUgOiB0eXBlT3JOYW1lLm5hbWUsXG4gICAgc3RhdGUuc2NoZW1hXG4gICk7XG4gIGlmICghc2NoZW1hVHlwZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoc2NoZW1hVHlwZSA9PT0gXCJub2RlXCIpIHtcbiAgICBub2RlVHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XG4gIH1cbiAgaWYgKHNjaGVtYVR5cGUgPT09IFwibWFya1wiKSB7XG4gICAgbWFya1R5cGUgPSBnZXRNYXJrVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xuICB9XG4gIGxldCBjYW5SZXNldCA9IGZhbHNlO1xuICB0ci5zZWxlY3Rpb24ucmFuZ2VzLmZvckVhY2goKHJhbmdlKSA9PiB7XG4gICAgc3RhdGUuZG9jLm5vZGVzQmV0d2VlbihyYW5nZS4kZnJvbS5wb3MsIHJhbmdlLiR0by5wb3MsIChub2RlLCBwb3MpID0+IHtcbiAgICAgIGlmIChub2RlVHlwZSAmJiBub2RlVHlwZSA9PT0gbm9kZS50eXBlKSB7XG4gICAgICAgIGNhblJlc2V0ID0gdHJ1ZTtcbiAgICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgICAgdHIuc2V0Tm9kZU1hcmt1cChwb3MsIHZvaWQgMCwgZGVsZXRlUHJvcHMobm9kZS5hdHRycywgYXR0cmlidXRlcykpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobWFya1R5cGUgJiYgbm9kZS5tYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgbm9kZS5tYXJrcy5mb3JFYWNoKChtYXJrKSA9PiB7XG4gICAgICAgICAgaWYgKG1hcmtUeXBlID09PSBtYXJrLnR5cGUpIHtcbiAgICAgICAgICAgIGNhblJlc2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICAgICAgICB0ci5hZGRNYXJrKHBvcywgcG9zICsgbm9kZS5ub2RlU2l6ZSwgbWFya1R5cGUuY3JlYXRlKGRlbGV0ZVByb3BzKG1hcmsuYXR0cnMsIGF0dHJpYnV0ZXMpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBjYW5SZXNldDtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy9zY3JvbGxJbnRvVmlldy50c1xudmFyIHNjcm9sbEludG9WaWV3ID0gKCkgPT4gKHsgdHIsIGRpc3BhdGNoIH0pID0+IHtcbiAgaWYgKGRpc3BhdGNoKSB7XG4gICAgdHIuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy9zZWxlY3RBbGwudHNcbmltcG9ydCB7IEFsbFNlbGVjdGlvbiB9IGZyb20gXCJAdGlwdGFwL3BtL3N0YXRlXCI7XG52YXIgc2VsZWN0QWxsID0gKCkgPT4gKHsgdHIsIGRpc3BhdGNoIH0pID0+IHtcbiAgaWYgKGRpc3BhdGNoKSB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gbmV3IEFsbFNlbGVjdGlvbih0ci5kb2MpO1xuICAgIHRyLnNldFNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuLy8gc3JjL2NvbW1hbmRzL3NlbGVjdE5vZGVCYWNrd2FyZC50c1xuaW1wb3J0IHsgc2VsZWN0Tm9kZUJhY2t3YXJkIGFzIG9yaWdpbmFsU2VsZWN0Tm9kZUJhY2t3YXJkIH0gZnJvbSBcIkB0aXB0YXAvcG0vY29tbWFuZHNcIjtcbnZhciBzZWxlY3ROb2RlQmFja3dhcmQgPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICByZXR1cm4gb3JpZ2luYWxTZWxlY3ROb2RlQmFja3dhcmQoc3RhdGUsIGRpc3BhdGNoKTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy9zZWxlY3ROb2RlRm9yd2FyZC50c1xuaW1wb3J0IHsgc2VsZWN0Tm9kZUZvcndhcmQgYXMgb3JpZ2luYWxTZWxlY3ROb2RlRm9yd2FyZCB9IGZyb20gXCJAdGlwdGFwL3BtL2NvbW1hbmRzXCI7XG52YXIgc2VsZWN0Tm9kZUZvcndhcmQgPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICByZXR1cm4gb3JpZ2luYWxTZWxlY3ROb2RlRm9yd2FyZChzdGF0ZSwgZGlzcGF0Y2gpO1xufTtcblxuLy8gc3JjL2NvbW1hbmRzL3NlbGVjdFBhcmVudE5vZGUudHNcbmltcG9ydCB7IHNlbGVjdFBhcmVudE5vZGUgYXMgb3JpZ2luYWxTZWxlY3RQYXJlbnROb2RlIH0gZnJvbSBcIkB0aXB0YXAvcG0vY29tbWFuZHNcIjtcbnZhciBzZWxlY3RQYXJlbnROb2RlID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgcmV0dXJuIG9yaWdpbmFsU2VsZWN0UGFyZW50Tm9kZShzdGF0ZSwgZGlzcGF0Y2gpO1xufTtcblxuLy8gc3JjL2NvbW1hbmRzL3NlbGVjdFRleHRibG9ja0VuZC50c1xuaW1wb3J0IHsgc2VsZWN0VGV4dGJsb2NrRW5kIGFzIG9yaWdpbmFsU2VsZWN0VGV4dGJsb2NrRW5kIH0gZnJvbSBcIkB0aXB0YXAvcG0vY29tbWFuZHNcIjtcbnZhciBzZWxlY3RUZXh0YmxvY2tFbmQgPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICByZXR1cm4gb3JpZ2luYWxTZWxlY3RUZXh0YmxvY2tFbmQoc3RhdGUsIGRpc3BhdGNoKTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy9zZWxlY3RUZXh0YmxvY2tTdGFydC50c1xuaW1wb3J0IHsgc2VsZWN0VGV4dGJsb2NrU3RhcnQgYXMgb3JpZ2luYWxTZWxlY3RUZXh0YmxvY2tTdGFydCB9IGZyb20gXCJAdGlwdGFwL3BtL2NvbW1hbmRzXCI7XG52YXIgc2VsZWN0VGV4dGJsb2NrU3RhcnQgPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICByZXR1cm4gb3JpZ2luYWxTZWxlY3RUZXh0YmxvY2tTdGFydChzdGF0ZSwgZGlzcGF0Y2gpO1xufTtcblxuLy8gc3JjL2hlbHBlcnMvY3JlYXRlRG9jdW1lbnQudHNcbmZ1bmN0aW9uIGNyZWF0ZURvY3VtZW50KGNvbnRlbnQsIHNjaGVtYSwgcGFyc2VPcHRpb25zID0ge30sIG9wdGlvbnMgPSB7fSkge1xuICByZXR1cm4gY3JlYXRlTm9kZUZyb21Db250ZW50KGNvbnRlbnQsIHNjaGVtYSwge1xuICAgIHNsaWNlOiBmYWxzZSxcbiAgICBwYXJzZU9wdGlvbnMsXG4gICAgZXJyb3JPbkludmFsaWRDb250ZW50OiBvcHRpb25zLmVycm9yT25JbnZhbGlkQ29udGVudFxuICB9KTtcbn1cblxuLy8gc3JjL2NvbW1hbmRzL3NldENvbnRlbnQudHNcbnZhciBzZXRDb250ZW50ID0gKGNvbnRlbnQsIHsgZXJyb3JPbkludmFsaWRDb250ZW50LCBlbWl0VXBkYXRlID0gdHJ1ZSwgcGFyc2VPcHRpb25zID0ge30gfSA9IHt9KSA9PiAoeyBlZGl0b3IsIHRyLCBkaXNwYXRjaCwgY29tbWFuZHMgfSkgPT4ge1xuICBjb25zdCB7IGRvYyB9ID0gdHI7XG4gIGlmIChwYXJzZU9wdGlvbnMucHJlc2VydmVXaGl0ZXNwYWNlICE9PSBcImZ1bGxcIikge1xuICAgIGNvbnN0IGRvY3VtZW50MiA9IGNyZWF0ZURvY3VtZW50KGNvbnRlbnQsIGVkaXRvci5zY2hlbWEsIHBhcnNlT3B0aW9ucywge1xuICAgICAgZXJyb3JPbkludmFsaWRDb250ZW50OiBlcnJvck9uSW52YWxpZENvbnRlbnQgIT0gbnVsbCA/IGVycm9yT25JbnZhbGlkQ29udGVudCA6IGVkaXRvci5vcHRpb25zLmVuYWJsZUNvbnRlbnRDaGVja1xuICAgIH0pO1xuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgdHIucmVwbGFjZVdpdGgoMCwgZG9jLmNvbnRlbnQuc2l6ZSwgZG9jdW1lbnQyKS5zZXRNZXRhKFwicHJldmVudFVwZGF0ZVwiLCAhZW1pdFVwZGF0ZSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChkaXNwYXRjaCkge1xuICAgIHRyLnNldE1ldGEoXCJwcmV2ZW50VXBkYXRlXCIsICFlbWl0VXBkYXRlKTtcbiAgfVxuICByZXR1cm4gY29tbWFuZHMuaW5zZXJ0Q29udGVudEF0KHsgZnJvbTogMCwgdG86IGRvYy5jb250ZW50LnNpemUgfSwgY29udGVudCwge1xuICAgIHBhcnNlT3B0aW9ucyxcbiAgICBlcnJvck9uSW52YWxpZENvbnRlbnQ6IGVycm9yT25JbnZhbGlkQ29udGVudCAhPSBudWxsID8gZXJyb3JPbkludmFsaWRDb250ZW50IDogZWRpdG9yLm9wdGlvbnMuZW5hYmxlQ29udGVudENoZWNrXG4gIH0pO1xufTtcblxuLy8gc3JjL2hlbHBlcnMvZ2V0TWFya0F0dHJpYnV0ZXMudHNcbmZ1bmN0aW9uIGdldE1hcmtBdHRyaWJ1dGVzKHN0YXRlLCB0eXBlT3JOYW1lKSB7XG4gIGNvbnN0IHR5cGUgPSBnZXRNYXJrVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xuICBjb25zdCB7IGZyb20sIHRvLCBlbXB0eSB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICBjb25zdCBtYXJrcyA9IFtdO1xuICBpZiAoZW1wdHkpIHtcbiAgICBpZiAoc3RhdGUuc3RvcmVkTWFya3MpIHtcbiAgICAgIG1hcmtzLnB1c2goLi4uc3RhdGUuc3RvcmVkTWFya3MpO1xuICAgIH1cbiAgICBtYXJrcy5wdXNoKC4uLnN0YXRlLnNlbGVjdGlvbi4kaGVhZC5tYXJrcygpKTtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5kb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCAobm9kZSkgPT4ge1xuICAgICAgbWFya3MucHVzaCguLi5ub2RlLm1hcmtzKTtcbiAgICB9KTtcbiAgfVxuICBjb25zdCBtYXJrID0gbWFya3MuZmluZCgobWFya0l0ZW0pID0+IG1hcmtJdGVtLnR5cGUubmFtZSA9PT0gdHlwZS5uYW1lKTtcbiAgaWYgKCFtYXJrKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIHJldHVybiB7IC4uLm1hcmsuYXR0cnMgfTtcbn1cblxuLy8gc3JjL2hlbHBlcnMvY29tYmluZVRyYW5zYWN0aW9uU3RlcHMudHNcbmltcG9ydCB7IFRyYW5zZm9ybSB9IGZyb20gXCJAdGlwdGFwL3BtL3RyYW5zZm9ybVwiO1xuZnVuY3Rpb24gY29tYmluZVRyYW5zYWN0aW9uU3RlcHMob2xkRG9jLCB0cmFuc2FjdGlvbnMpIHtcbiAgY29uc3QgdHJhbnNmb3JtID0gbmV3IFRyYW5zZm9ybShvbGREb2MpO1xuICB0cmFuc2FjdGlvbnMuZm9yRWFjaCgodHJhbnNhY3Rpb24pID0+IHtcbiAgICB0cmFuc2FjdGlvbi5zdGVwcy5mb3JFYWNoKChzdGVwKSA9PiB7XG4gICAgICB0cmFuc2Zvcm0uc3RlcChzdGVwKTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiB0cmFuc2Zvcm07XG59XG5cbi8vIHNyYy9oZWxwZXJzL2RlZmF1bHRCbG9ja0F0LnRzXG5mdW5jdGlvbiBkZWZhdWx0QmxvY2tBdChtYXRjaCkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG1hdGNoLmVkZ2VDb3VudDsgaSArPSAxKSB7XG4gICAgY29uc3QgeyB0eXBlIH0gPSBtYXRjaC5lZGdlKGkpO1xuICAgIGlmICh0eXBlLmlzVGV4dGJsb2NrICYmICF0eXBlLmhhc1JlcXVpcmVkQXR0cnMoKSkge1xuICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBzcmMvaGVscGVycy9maW5kQ2hpbGRyZW4udHNcbmZ1bmN0aW9uIGZpbmRDaGlsZHJlbihub2RlLCBwcmVkaWNhdGUpIHtcbiAgY29uc3Qgbm9kZXNXaXRoUG9zID0gW107XG4gIG5vZGUuZGVzY2VuZGFudHMoKGNoaWxkLCBwb3MpID0+IHtcbiAgICBpZiAocHJlZGljYXRlKGNoaWxkKSkge1xuICAgICAgbm9kZXNXaXRoUG9zLnB1c2goe1xuICAgICAgICBub2RlOiBjaGlsZCxcbiAgICAgICAgcG9zXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbm9kZXNXaXRoUG9zO1xufVxuXG4vLyBzcmMvaGVscGVycy9maW5kQ2hpbGRyZW5JblJhbmdlLnRzXG5mdW5jdGlvbiBmaW5kQ2hpbGRyZW5JblJhbmdlKG5vZGUsIHJhbmdlLCBwcmVkaWNhdGUpIHtcbiAgY29uc3Qgbm9kZXNXaXRoUG9zID0gW107XG4gIG5vZGUubm9kZXNCZXR3ZWVuKHJhbmdlLmZyb20sIHJhbmdlLnRvLCAoY2hpbGQsIHBvcykgPT4ge1xuICAgIGlmIChwcmVkaWNhdGUoY2hpbGQpKSB7XG4gICAgICBub2Rlc1dpdGhQb3MucHVzaCh7XG4gICAgICAgIG5vZGU6IGNoaWxkLFxuICAgICAgICBwb3NcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBub2Rlc1dpdGhQb3M7XG59XG5cbi8vIHNyYy9oZWxwZXJzL2ZpbmRQYXJlbnROb2RlQ2xvc2VzdFRvUG9zLnRzXG5mdW5jdGlvbiBmaW5kUGFyZW50Tm9kZUNsb3Nlc3RUb1BvcygkcG9zLCBwcmVkaWNhdGUpIHtcbiAgZm9yIChsZXQgaSA9ICRwb3MuZGVwdGg7IGkgPiAwOyBpIC09IDEpIHtcbiAgICBjb25zdCBub2RlID0gJHBvcy5ub2RlKGkpO1xuICAgIGlmIChwcmVkaWNhdGUobm9kZSkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBvczogaSA+IDAgPyAkcG9zLmJlZm9yZShpKSA6IDAsXG4gICAgICAgIHN0YXJ0OiAkcG9zLnN0YXJ0KGkpLFxuICAgICAgICBkZXB0aDogaSxcbiAgICAgICAgbm9kZVxuICAgICAgfTtcbiAgICB9XG4gIH1cbn1cblxuLy8gc3JjL2hlbHBlcnMvZmluZFBhcmVudE5vZGUudHNcbmZ1bmN0aW9uIGZpbmRQYXJlbnROb2RlKHByZWRpY2F0ZSkge1xuICByZXR1cm4gKHNlbGVjdGlvbikgPT4gZmluZFBhcmVudE5vZGVDbG9zZXN0VG9Qb3Moc2VsZWN0aW9uLiRmcm9tLCBwcmVkaWNhdGUpO1xufVxuXG4vLyBzcmMvaGVscGVycy9nZXRFeHRlbnNpb25GaWVsZC50c1xuZnVuY3Rpb24gZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCBmaWVsZCwgY29udGV4dCkge1xuICBpZiAoZXh0ZW5zaW9uLmNvbmZpZ1tmaWVsZF0gPT09IHZvaWQgMCAmJiBleHRlbnNpb24ucGFyZW50KSB7XG4gICAgcmV0dXJuIGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbi5wYXJlbnQsIGZpZWxkLCBjb250ZXh0KTtcbiAgfVxuICBpZiAodHlwZW9mIGV4dGVuc2lvbi5jb25maWdbZmllbGRdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGV4dGVuc2lvbi5jb25maWdbZmllbGRdLmJpbmQoe1xuICAgICAgLi4uY29udGV4dCxcbiAgICAgIHBhcmVudDogZXh0ZW5zaW9uLnBhcmVudCA/IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbi5wYXJlbnQsIGZpZWxkLCBjb250ZXh0KSA6IG51bGxcbiAgICB9KTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIGV4dGVuc2lvbi5jb25maWdbZmllbGRdO1xufVxuXG4vLyBzcmMvaGVscGVycy9mbGF0dGVuRXh0ZW5zaW9ucy50c1xuZnVuY3Rpb24gZmxhdHRlbkV4dGVuc2lvbnMoZXh0ZW5zaW9ucykge1xuICByZXR1cm4gZXh0ZW5zaW9ucy5tYXAoKGV4dGVuc2lvbikgPT4ge1xuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2VcbiAgICB9O1xuICAgIGNvbnN0IGFkZEV4dGVuc2lvbnMgPSBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sIFwiYWRkRXh0ZW5zaW9uc1wiLCBjb250ZXh0KTtcbiAgICBpZiAoYWRkRXh0ZW5zaW9ucykge1xuICAgICAgcmV0dXJuIFtleHRlbnNpb24sIC4uLmZsYXR0ZW5FeHRlbnNpb25zKGFkZEV4dGVuc2lvbnMoKSldO1xuICAgIH1cbiAgICByZXR1cm4gZXh0ZW5zaW9uO1xuICB9KS5mbGF0KDEwKTtcbn1cblxuLy8gc3JjL2hlbHBlcnMvZ2VuZXJhdGVIVE1MLnRzXG5pbXBvcnQgeyBOb2RlIH0gZnJvbSBcIkB0aXB0YXAvcG0vbW9kZWxcIjtcblxuLy8gc3JjL2hlbHBlcnMvZ2V0SFRNTEZyb21GcmFnbWVudC50c1xuaW1wb3J0IHsgRE9NU2VyaWFsaXplciB9IGZyb20gXCJAdGlwdGFwL3BtL21vZGVsXCI7XG5mdW5jdGlvbiBnZXRIVE1MRnJvbUZyYWdtZW50KGZyYWdtZW50LCBzY2hlbWEpIHtcbiAgY29uc3QgZG9jdW1lbnRGcmFnbWVudCA9IERPTVNlcmlhbGl6ZXIuZnJvbVNjaGVtYShzY2hlbWEpLnNlcmlhbGl6ZUZyYWdtZW50KGZyYWdtZW50KTtcbiAgY29uc3QgdGVtcG9yYXJ5RG9jdW1lbnQgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoKTtcbiAgY29uc3QgY29udGFpbmVyID0gdGVtcG9yYXJ5RG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgY29udGFpbmVyLmFwcGVuZENoaWxkKGRvY3VtZW50RnJhZ21lbnQpO1xuICByZXR1cm4gY29udGFpbmVyLmlubmVySFRNTDtcbn1cblxuLy8gc3JjL2hlbHBlcnMvZ2V0U2NoZW1hQnlSZXNvbHZlZEV4dGVuc2lvbnMudHNcbmltcG9ydCB7IFNjaGVtYSBhcyBTY2hlbWEyIH0gZnJvbSBcIkB0aXB0YXAvcG0vbW9kZWxcIjtcblxuLy8gc3JjL3V0aWxpdGllcy9pc0Z1bmN0aW9uLnRzXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIjtcbn1cblxuLy8gc3JjL3V0aWxpdGllcy9jYWxsT3JSZXR1cm4udHNcbmZ1bmN0aW9uIGNhbGxPclJldHVybih2YWx1ZSwgY29udGV4dCA9IHZvaWQgMCwgLi4ucHJvcHMpIHtcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgaWYgKGNvbnRleHQpIHtcbiAgICAgIHJldHVybiB2YWx1ZS5iaW5kKGNvbnRleHQpKC4uLnByb3BzKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlKC4uLnByb3BzKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbi8vIHNyYy91dGlsaXRpZXMvaXNFbXB0eU9iamVjdC50c1xuZnVuY3Rpb24gaXNFbXB0eU9iamVjdCh2YWx1ZSA9IHt9KSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoID09PSAwICYmIHZhbHVlLmNvbnN0cnVjdG9yID09PSBPYmplY3Q7XG59XG5cbi8vIHNyYy9oZWxwZXJzL3NwbGl0RXh0ZW5zaW9ucy50c1xuZnVuY3Rpb24gc3BsaXRFeHRlbnNpb25zKGV4dGVuc2lvbnMpIHtcbiAgY29uc3QgYmFzZUV4dGVuc2lvbnMgPSBleHRlbnNpb25zLmZpbHRlcigoZXh0ZW5zaW9uKSA9PiBleHRlbnNpb24udHlwZSA9PT0gXCJleHRlbnNpb25cIik7XG4gIGNvbnN0IG5vZGVFeHRlbnNpb25zID0gZXh0ZW5zaW9ucy5maWx0ZXIoKGV4dGVuc2lvbikgPT4gZXh0ZW5zaW9uLnR5cGUgPT09IFwibm9kZVwiKTtcbiAgY29uc3QgbWFya0V4dGVuc2lvbnMgPSBleHRlbnNpb25zLmZpbHRlcigoZXh0ZW5zaW9uKSA9PiBleHRlbnNpb24udHlwZSA9PT0gXCJtYXJrXCIpO1xuICByZXR1cm4ge1xuICAgIGJhc2VFeHRlbnNpb25zLFxuICAgIG5vZGVFeHRlbnNpb25zLFxuICAgIG1hcmtFeHRlbnNpb25zXG4gIH07XG59XG5cbi8vIHNyYy9oZWxwZXJzL2dldEF0dHJpYnV0ZXNGcm9tRXh0ZW5zaW9ucy50c1xuZnVuY3Rpb24gZ2V0QXR0cmlidXRlc0Zyb21FeHRlbnNpb25zKGV4dGVuc2lvbnMpIHtcbiAgY29uc3QgZXh0ZW5zaW9uQXR0cmlidXRlcyA9IFtdO1xuICBjb25zdCB7IG5vZGVFeHRlbnNpb25zLCBtYXJrRXh0ZW5zaW9ucyB9ID0gc3BsaXRFeHRlbnNpb25zKGV4dGVuc2lvbnMpO1xuICBjb25zdCBub2RlQW5kTWFya0V4dGVuc2lvbnMgPSBbLi4ubm9kZUV4dGVuc2lvbnMsIC4uLm1hcmtFeHRlbnNpb25zXTtcbiAgY29uc3QgZGVmYXVsdEF0dHJpYnV0ZSA9IHtcbiAgICBkZWZhdWx0OiBudWxsLFxuICAgIHZhbGlkYXRlOiB2b2lkIDAsXG4gICAgcmVuZGVyZWQ6IHRydWUsXG4gICAgcmVuZGVySFRNTDogbnVsbCxcbiAgICBwYXJzZUhUTUw6IG51bGwsXG4gICAga2VlcE9uU3BsaXQ6IHRydWUsXG4gICAgaXNSZXF1aXJlZDogZmFsc2VcbiAgfTtcbiAgZXh0ZW5zaW9ucy5mb3JFYWNoKChleHRlbnNpb24pID0+IHtcbiAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcbiAgICAgIHN0b3JhZ2U6IGV4dGVuc2lvbi5zdG9yYWdlLFxuICAgICAgZXh0ZW5zaW9uczogbm9kZUFuZE1hcmtFeHRlbnNpb25zXG4gICAgfTtcbiAgICBjb25zdCBhZGRHbG9iYWxBdHRyaWJ1dGVzID0gZ2V0RXh0ZW5zaW9uRmllbGQoXG4gICAgICBleHRlbnNpb24sXG4gICAgICBcImFkZEdsb2JhbEF0dHJpYnV0ZXNcIixcbiAgICAgIGNvbnRleHRcbiAgICApO1xuICAgIGlmICghYWRkR2xvYmFsQXR0cmlidXRlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBnbG9iYWxBdHRyaWJ1dGVzID0gYWRkR2xvYmFsQXR0cmlidXRlcygpO1xuICAgIGdsb2JhbEF0dHJpYnV0ZXMuZm9yRWFjaCgoZ2xvYmFsQXR0cmlidXRlKSA9PiB7XG4gICAgICBnbG9iYWxBdHRyaWJ1dGUudHlwZXMuZm9yRWFjaCgodHlwZSkgPT4ge1xuICAgICAgICBPYmplY3QuZW50cmllcyhnbG9iYWxBdHRyaWJ1dGUuYXR0cmlidXRlcykuZm9yRWFjaCgoW25hbWUsIGF0dHJpYnV0ZV0pID0+IHtcbiAgICAgICAgICBleHRlbnNpb25BdHRyaWJ1dGVzLnB1c2goe1xuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBhdHRyaWJ1dGU6IHtcbiAgICAgICAgICAgICAgLi4uZGVmYXVsdEF0dHJpYnV0ZSxcbiAgICAgICAgICAgICAgLi4uYXR0cmlidXRlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuICBub2RlQW5kTWFya0V4dGVuc2lvbnMuZm9yRWFjaCgoZXh0ZW5zaW9uKSA9PiB7XG4gICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICBzdG9yYWdlOiBleHRlbnNpb24uc3RvcmFnZVxuICAgIH07XG4gICAgY29uc3QgYWRkQXR0cmlidXRlcyA9IGdldEV4dGVuc2lvbkZpZWxkKFxuICAgICAgZXh0ZW5zaW9uLFxuICAgICAgXCJhZGRBdHRyaWJ1dGVzXCIsXG4gICAgICBjb250ZXh0XG4gICAgKTtcbiAgICBpZiAoIWFkZEF0dHJpYnV0ZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IGFkZEF0dHJpYnV0ZXMoKTtcbiAgICBPYmplY3QuZW50cmllcyhhdHRyaWJ1dGVzKS5mb3JFYWNoKChbbmFtZSwgYXR0cmlidXRlXSkgPT4ge1xuICAgICAgY29uc3QgbWVyZ2VkQXR0ciA9IHtcbiAgICAgICAgLi4uZGVmYXVsdEF0dHJpYnV0ZSxcbiAgICAgICAgLi4uYXR0cmlidXRlXG4gICAgICB9O1xuICAgICAgaWYgKHR5cGVvZiAobWVyZ2VkQXR0ciA9PSBudWxsID8gdm9pZCAwIDogbWVyZ2VkQXR0ci5kZWZhdWx0KSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIG1lcmdlZEF0dHIuZGVmYXVsdCA9IG1lcmdlZEF0dHIuZGVmYXVsdCgpO1xuICAgICAgfVxuICAgICAgaWYgKChtZXJnZWRBdHRyID09IG51bGwgPyB2b2lkIDAgOiBtZXJnZWRBdHRyLmlzUmVxdWlyZWQpICYmIChtZXJnZWRBdHRyID09IG51bGwgPyB2b2lkIDAgOiBtZXJnZWRBdHRyLmRlZmF1bHQpID09PSB2b2lkIDApIHtcbiAgICAgICAgZGVsZXRlIG1lcmdlZEF0dHIuZGVmYXVsdDtcbiAgICAgIH1cbiAgICAgIGV4dGVuc2lvbkF0dHJpYnV0ZXMucHVzaCh7XG4gICAgICAgIHR5cGU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICBuYW1lLFxuICAgICAgICBhdHRyaWJ1dGU6IG1lcmdlZEF0dHJcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIGV4dGVuc2lvbkF0dHJpYnV0ZXM7XG59XG5cbi8vIHNyYy91dGlsaXRpZXMvbWVyZ2VBdHRyaWJ1dGVzLnRzXG5mdW5jdGlvbiBtZXJnZUF0dHJpYnV0ZXMoLi4ub2JqZWN0cykge1xuICByZXR1cm4gb2JqZWN0cy5maWx0ZXIoKGl0ZW0pID0+ICEhaXRlbSkucmVkdWNlKChpdGVtcywgaXRlbSkgPT4ge1xuICAgIGNvbnN0IG1lcmdlZEF0dHJpYnV0ZXMgPSB7IC4uLml0ZW1zIH07XG4gICAgT2JqZWN0LmVudHJpZXMoaXRlbSkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICBjb25zdCBleGlzdHMgPSBtZXJnZWRBdHRyaWJ1dGVzW2tleV07XG4gICAgICBpZiAoIWV4aXN0cykge1xuICAgICAgICBtZXJnZWRBdHRyaWJ1dGVzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGtleSA9PT0gXCJjbGFzc1wiKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlQ2xhc3NlcyA9IHZhbHVlID8gU3RyaW5nKHZhbHVlKS5zcGxpdChcIiBcIikgOiBbXTtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdDbGFzc2VzID0gbWVyZ2VkQXR0cmlidXRlc1trZXldID8gbWVyZ2VkQXR0cmlidXRlc1trZXldLnNwbGl0KFwiIFwiKSA6IFtdO1xuICAgICAgICBjb25zdCBpbnNlcnRDbGFzc2VzID0gdmFsdWVDbGFzc2VzLmZpbHRlcigodmFsdWVDbGFzcykgPT4gIWV4aXN0aW5nQ2xhc3Nlcy5pbmNsdWRlcyh2YWx1ZUNsYXNzKSk7XG4gICAgICAgIG1lcmdlZEF0dHJpYnV0ZXNba2V5XSA9IFsuLi5leGlzdGluZ0NsYXNzZXMsIC4uLmluc2VydENsYXNzZXNdLmpvaW4oXCIgXCIpO1xuICAgICAgfSBlbHNlIGlmIChrZXkgPT09IFwic3R5bGVcIikge1xuICAgICAgICBjb25zdCBuZXdTdHlsZXMgPSB2YWx1ZSA/IHZhbHVlLnNwbGl0KFwiO1wiKS5tYXAoKHN0eWxlMikgPT4gc3R5bGUyLnRyaW0oKSkuZmlsdGVyKEJvb2xlYW4pIDogW107XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nU3R5bGVzID0gbWVyZ2VkQXR0cmlidXRlc1trZXldID8gbWVyZ2VkQXR0cmlidXRlc1trZXldLnNwbGl0KFwiO1wiKS5tYXAoKHN0eWxlMikgPT4gc3R5bGUyLnRyaW0oKSkuZmlsdGVyKEJvb2xlYW4pIDogW107XG4gICAgICAgIGNvbnN0IHN0eWxlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgICAgZXhpc3RpbmdTdHlsZXMuZm9yRWFjaCgoc3R5bGUyKSA9PiB7XG4gICAgICAgICAgY29uc3QgW3Byb3BlcnR5LCB2YWxdID0gc3R5bGUyLnNwbGl0KFwiOlwiKS5tYXAoKHBhcnQpID0+IHBhcnQudHJpbSgpKTtcbiAgICAgICAgICBzdHlsZU1hcC5zZXQocHJvcGVydHksIHZhbCk7XG4gICAgICAgIH0pO1xuICAgICAgICBuZXdTdHlsZXMuZm9yRWFjaCgoc3R5bGUyKSA9PiB7XG4gICAgICAgICAgY29uc3QgW3Byb3BlcnR5LCB2YWxdID0gc3R5bGUyLnNwbGl0KFwiOlwiKS5tYXAoKHBhcnQpID0+IHBhcnQudHJpbSgpKTtcbiAgICAgICAgICBzdHlsZU1hcC5zZXQocHJvcGVydHksIHZhbCk7XG4gICAgICAgIH0pO1xuICAgICAgICBtZXJnZWRBdHRyaWJ1dGVzW2tleV0gPSBBcnJheS5mcm9tKHN0eWxlTWFwLmVudHJpZXMoKSkubWFwKChbcHJvcGVydHksIHZhbF0pID0+IGAke3Byb3BlcnR5fTogJHt2YWx9YCkuam9pbihcIjsgXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWVyZ2VkQXR0cmlidXRlc1trZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG1lcmdlZEF0dHJpYnV0ZXM7XG4gIH0sIHt9KTtcbn1cblxuLy8gc3JjL2hlbHBlcnMvZ2V0UmVuZGVyZWRBdHRyaWJ1dGVzLnRzXG5mdW5jdGlvbiBnZXRSZW5kZXJlZEF0dHJpYnV0ZXMobm9kZU9yTWFyaywgZXh0ZW5zaW9uQXR0cmlidXRlcykge1xuICByZXR1cm4gZXh0ZW5zaW9uQXR0cmlidXRlcy5maWx0ZXIoKGF0dHJpYnV0ZSkgPT4gYXR0cmlidXRlLnR5cGUgPT09IG5vZGVPck1hcmsudHlwZS5uYW1lKS5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0uYXR0cmlidXRlLnJlbmRlcmVkKS5tYXAoKGl0ZW0pID0+IHtcbiAgICBpZiAoIWl0ZW0uYXR0cmlidXRlLnJlbmRlckhUTUwpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIFtpdGVtLm5hbWVdOiBub2RlT3JNYXJrLmF0dHJzW2l0ZW0ubmFtZV1cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBpdGVtLmF0dHJpYnV0ZS5yZW5kZXJIVE1MKG5vZGVPck1hcmsuYXR0cnMpIHx8IHt9O1xuICB9KS5yZWR1Y2UoKGF0dHJpYnV0ZXMsIGF0dHJpYnV0ZSkgPT4gbWVyZ2VBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMsIGF0dHJpYnV0ZSksIHt9KTtcbn1cblxuLy8gc3JjL3V0aWxpdGllcy9mcm9tU3RyaW5nLnRzXG5mdW5jdGlvbiBmcm9tU3RyaW5nKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKHZhbHVlLm1hdGNoKC9eWystXT8oPzpcXGQqXFwuKT9cXGQrJC8pKSB7XG4gICAgcmV0dXJuIE51bWJlcih2YWx1ZSk7XG4gIH1cbiAgaWYgKHZhbHVlID09PSBcInRydWVcIikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PT0gXCJmYWxzZVwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLy8gc3JjL2hlbHBlcnMvaW5qZWN0RXh0ZW5zaW9uQXR0cmlidXRlc1RvUGFyc2VSdWxlLnRzXG5mdW5jdGlvbiBpbmplY3RFeHRlbnNpb25BdHRyaWJ1dGVzVG9QYXJzZVJ1bGUocGFyc2VSdWxlLCBleHRlbnNpb25BdHRyaWJ1dGVzKSB7XG4gIGlmIChcInN0eWxlXCIgaW4gcGFyc2VSdWxlKSB7XG4gICAgcmV0dXJuIHBhcnNlUnVsZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIC4uLnBhcnNlUnVsZSxcbiAgICBnZXRBdHRyczogKG5vZGUpID0+IHtcbiAgICAgIGNvbnN0IG9sZEF0dHJpYnV0ZXMgPSBwYXJzZVJ1bGUuZ2V0QXR0cnMgPyBwYXJzZVJ1bGUuZ2V0QXR0cnMobm9kZSkgOiBwYXJzZVJ1bGUuYXR0cnM7XG4gICAgICBpZiAob2xkQXR0cmlidXRlcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3QgbmV3QXR0cmlidXRlcyA9IGV4dGVuc2lvbkF0dHJpYnV0ZXMucmVkdWNlKChpdGVtcywgaXRlbSkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGl0ZW0uYXR0cmlidXRlLnBhcnNlSFRNTCA/IGl0ZW0uYXR0cmlidXRlLnBhcnNlSFRNTChub2RlKSA6IGZyb21TdHJpbmcobm9kZS5nZXRBdHRyaWJ1dGUoaXRlbS5uYW1lKSk7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uaXRlbXMsXG4gICAgICAgICAgW2l0ZW0ubmFtZV06IHZhbHVlXG4gICAgICAgIH07XG4gICAgICB9LCB7fSk7XG4gICAgICByZXR1cm4geyAuLi5vbGRBdHRyaWJ1dGVzLCAuLi5uZXdBdHRyaWJ1dGVzIH07XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvaGVscGVycy9nZXRTY2hlbWFCeVJlc29sdmVkRXh0ZW5zaW9ucy50c1xuZnVuY3Rpb24gY2xlYW5VcFNjaGVtYUl0ZW0oZGF0YSkge1xuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBPYmplY3QuZW50cmllcyhkYXRhKS5maWx0ZXIoKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgaWYgKGtleSA9PT0gXCJhdHRyc1wiICYmIGlzRW1wdHlPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdm9pZCAwO1xuICAgIH0pXG4gICk7XG59XG5mdW5jdGlvbiBidWlsZEF0dHJpYnV0ZVNwZWMoZXh0ZW5zaW9uQXR0cmlidXRlKSB7XG4gIHZhciBfYSwgX2I7XG4gIGNvbnN0IHNwZWMgPSB7fTtcbiAgaWYgKCEoKF9hID0gZXh0ZW5zaW9uQXR0cmlidXRlID09IG51bGwgPyB2b2lkIDAgOiBleHRlbnNpb25BdHRyaWJ1dGUuYXR0cmlidXRlKSA9PSBudWxsID8gdm9pZCAwIDogX2EuaXNSZXF1aXJlZCkgJiYgXCJkZWZhdWx0XCIgaW4gKChleHRlbnNpb25BdHRyaWJ1dGUgPT0gbnVsbCA/IHZvaWQgMCA6IGV4dGVuc2lvbkF0dHJpYnV0ZS5hdHRyaWJ1dGUpIHx8IHt9KSkge1xuICAgIHNwZWMuZGVmYXVsdCA9IGV4dGVuc2lvbkF0dHJpYnV0ZS5hdHRyaWJ1dGUuZGVmYXVsdDtcbiAgfVxuICBpZiAoKChfYiA9IGV4dGVuc2lvbkF0dHJpYnV0ZSA9PSBudWxsID8gdm9pZCAwIDogZXh0ZW5zaW9uQXR0cmlidXRlLmF0dHJpYnV0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnZhbGlkYXRlKSAhPT0gdm9pZCAwKSB7XG4gICAgc3BlYy52YWxpZGF0ZSA9IGV4dGVuc2lvbkF0dHJpYnV0ZS5hdHRyaWJ1dGUudmFsaWRhdGU7XG4gIH1cbiAgcmV0dXJuIFtleHRlbnNpb25BdHRyaWJ1dGUubmFtZSwgc3BlY107XG59XG5mdW5jdGlvbiBnZXRTY2hlbWFCeVJlc29sdmVkRXh0ZW5zaW9ucyhleHRlbnNpb25zLCBlZGl0b3IpIHtcbiAgdmFyIF9hO1xuICBjb25zdCBhbGxBdHRyaWJ1dGVzID0gZ2V0QXR0cmlidXRlc0Zyb21FeHRlbnNpb25zKGV4dGVuc2lvbnMpO1xuICBjb25zdCB7IG5vZGVFeHRlbnNpb25zLCBtYXJrRXh0ZW5zaW9ucyB9ID0gc3BsaXRFeHRlbnNpb25zKGV4dGVuc2lvbnMpO1xuICBjb25zdCB0b3BOb2RlID0gKF9hID0gbm9kZUV4dGVuc2lvbnMuZmluZCgoZXh0ZW5zaW9uKSA9PiBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sIFwidG9wTm9kZVwiKSkpID09IG51bGwgPyB2b2lkIDAgOiBfYS5uYW1lO1xuICBjb25zdCBub2RlcyA9IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBub2RlRXh0ZW5zaW9ucy5tYXAoKGV4dGVuc2lvbikgPT4ge1xuICAgICAgY29uc3QgZXh0ZW5zaW9uQXR0cmlidXRlcyA9IGFsbEF0dHJpYnV0ZXMuZmlsdGVyKChhdHRyaWJ1dGUpID0+IGF0dHJpYnV0ZS50eXBlID09PSBleHRlbnNpb24ubmFtZSk7XG4gICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICAgIHN0b3JhZ2U6IGV4dGVuc2lvbi5zdG9yYWdlLFxuICAgICAgICBlZGl0b3JcbiAgICAgIH07XG4gICAgICBjb25zdCBleHRyYU5vZGVGaWVsZHMgPSBleHRlbnNpb25zLnJlZHVjZSgoZmllbGRzLCBlKSA9PiB7XG4gICAgICAgIGNvbnN0IGV4dGVuZE5vZGVTY2hlbWEgPSBnZXRFeHRlbnNpb25GaWVsZChlLCBcImV4dGVuZE5vZGVTY2hlbWFcIiwgY29udGV4dCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uZmllbGRzLFxuICAgICAgICAgIC4uLmV4dGVuZE5vZGVTY2hlbWEgPyBleHRlbmROb2RlU2NoZW1hKGV4dGVuc2lvbikgOiB7fVxuICAgICAgICB9O1xuICAgICAgfSwge30pO1xuICAgICAgY29uc3Qgc2NoZW1hID0gY2xlYW5VcFNjaGVtYUl0ZW0oe1xuICAgICAgICAuLi5leHRyYU5vZGVGaWVsZHMsXG4gICAgICAgIGNvbnRlbnQ6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sIFwiY29udGVudFwiLCBjb250ZXh0KSksXG4gICAgICAgIG1hcmtzOiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCBcIm1hcmtzXCIsIGNvbnRleHQpKSxcbiAgICAgICAgZ3JvdXA6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sIFwiZ3JvdXBcIiwgY29udGV4dCkpLFxuICAgICAgICBpbmxpbmU6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sIFwiaW5saW5lXCIsIGNvbnRleHQpKSxcbiAgICAgICAgYXRvbTogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgXCJhdG9tXCIsIGNvbnRleHQpKSxcbiAgICAgICAgc2VsZWN0YWJsZTogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgXCJzZWxlY3RhYmxlXCIsIGNvbnRleHQpKSxcbiAgICAgICAgZHJhZ2dhYmxlOiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCBcImRyYWdnYWJsZVwiLCBjb250ZXh0KSksXG4gICAgICAgIGNvZGU6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sIFwiY29kZVwiLCBjb250ZXh0KSksXG4gICAgICAgIHdoaXRlc3BhY2U6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sIFwid2hpdGVzcGFjZVwiLCBjb250ZXh0KSksXG4gICAgICAgIGxpbmVicmVha1JlcGxhY2VtZW50OiBjYWxsT3JSZXR1cm4oXG4gICAgICAgICAgZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCBcImxpbmVicmVha1JlcGxhY2VtZW50XCIsIGNvbnRleHQpXG4gICAgICAgICksXG4gICAgICAgIGRlZmluaW5nOiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCBcImRlZmluaW5nXCIsIGNvbnRleHQpKSxcbiAgICAgICAgaXNvbGF0aW5nOiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCBcImlzb2xhdGluZ1wiLCBjb250ZXh0KSksXG4gICAgICAgIGF0dHJzOiBPYmplY3QuZnJvbUVudHJpZXMoZXh0ZW5zaW9uQXR0cmlidXRlcy5tYXAoYnVpbGRBdHRyaWJ1dGVTcGVjKSlcbiAgICAgIH0pO1xuICAgICAgY29uc3QgcGFyc2VIVE1MID0gY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgXCJwYXJzZUhUTUxcIiwgY29udGV4dCkpO1xuICAgICAgaWYgKHBhcnNlSFRNTCkge1xuICAgICAgICBzY2hlbWEucGFyc2VET00gPSBwYXJzZUhUTUwubWFwKFxuICAgICAgICAgIChwYXJzZVJ1bGUpID0+IGluamVjdEV4dGVuc2lvbkF0dHJpYnV0ZXNUb1BhcnNlUnVsZShwYXJzZVJ1bGUsIGV4dGVuc2lvbkF0dHJpYnV0ZXMpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb25zdCByZW5kZXJIVE1MID0gZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCBcInJlbmRlckhUTUxcIiwgY29udGV4dCk7XG4gICAgICBpZiAocmVuZGVySFRNTCkge1xuICAgICAgICBzY2hlbWEudG9ET00gPSAobm9kZSkgPT4gcmVuZGVySFRNTCh7XG4gICAgICAgICAgbm9kZSxcbiAgICAgICAgICBIVE1MQXR0cmlidXRlczogZ2V0UmVuZGVyZWRBdHRyaWJ1dGVzKG5vZGUsIGV4dGVuc2lvbkF0dHJpYnV0ZXMpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVuZGVyVGV4dCA9IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgXCJyZW5kZXJUZXh0XCIsIGNvbnRleHQpO1xuICAgICAgaWYgKHJlbmRlclRleHQpIHtcbiAgICAgICAgc2NoZW1hLnRvVGV4dCA9IHJlbmRlclRleHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gW2V4dGVuc2lvbi5uYW1lLCBzY2hlbWFdO1xuICAgIH0pXG4gICk7XG4gIGNvbnN0IG1hcmtzID0gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgIG1hcmtFeHRlbnNpb25zLm1hcCgoZXh0ZW5zaW9uKSA9PiB7XG4gICAgICBjb25zdCBleHRlbnNpb25BdHRyaWJ1dGVzID0gYWxsQXR0cmlidXRlcy5maWx0ZXIoKGF0dHJpYnV0ZSkgPT4gYXR0cmlidXRlLnR5cGUgPT09IGV4dGVuc2lvbi5uYW1lKTtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcbiAgICAgICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2UsXG4gICAgICAgIGVkaXRvclxuICAgICAgfTtcbiAgICAgIGNvbnN0IGV4dHJhTWFya0ZpZWxkcyA9IGV4dGVuc2lvbnMucmVkdWNlKChmaWVsZHMsIGUpID0+IHtcbiAgICAgICAgY29uc3QgZXh0ZW5kTWFya1NjaGVtYSA9IGdldEV4dGVuc2lvbkZpZWxkKGUsIFwiZXh0ZW5kTWFya1NjaGVtYVwiLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5maWVsZHMsXG4gICAgICAgICAgLi4uZXh0ZW5kTWFya1NjaGVtYSA/IGV4dGVuZE1hcmtTY2hlbWEoZXh0ZW5zaW9uKSA6IHt9XG4gICAgICAgIH07XG4gICAgICB9LCB7fSk7XG4gICAgICBjb25zdCBzY2hlbWEgPSBjbGVhblVwU2NoZW1hSXRlbSh7XG4gICAgICAgIC4uLmV4dHJhTWFya0ZpZWxkcyxcbiAgICAgICAgaW5jbHVzaXZlOiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCBcImluY2x1c2l2ZVwiLCBjb250ZXh0KSksXG4gICAgICAgIGV4Y2x1ZGVzOiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCBcImV4Y2x1ZGVzXCIsIGNvbnRleHQpKSxcbiAgICAgICAgZ3JvdXA6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sIFwiZ3JvdXBcIiwgY29udGV4dCkpLFxuICAgICAgICBzcGFubmluZzogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgXCJzcGFubmluZ1wiLCBjb250ZXh0KSksXG4gICAgICAgIGNvZGU6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sIFwiY29kZVwiLCBjb250ZXh0KSksXG4gICAgICAgIGF0dHJzOiBPYmplY3QuZnJvbUVudHJpZXMoZXh0ZW5zaW9uQXR0cmlidXRlcy5tYXAoYnVpbGRBdHRyaWJ1dGVTcGVjKSlcbiAgICAgIH0pO1xuICAgICAgY29uc3QgcGFyc2VIVE1MID0gY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgXCJwYXJzZUhUTUxcIiwgY29udGV4dCkpO1xuICAgICAgaWYgKHBhcnNlSFRNTCkge1xuICAgICAgICBzY2hlbWEucGFyc2VET00gPSBwYXJzZUhUTUwubWFwKFxuICAgICAgICAgIChwYXJzZVJ1bGUpID0+IGluamVjdEV4dGVuc2lvbkF0dHJpYnV0ZXNUb1BhcnNlUnVsZShwYXJzZVJ1bGUsIGV4dGVuc2lvbkF0dHJpYnV0ZXMpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb25zdCByZW5kZXJIVE1MID0gZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCBcInJlbmRlckhUTUxcIiwgY29udGV4dCk7XG4gICAgICBpZiAocmVuZGVySFRNTCkge1xuICAgICAgICBzY2hlbWEudG9ET00gPSAobWFyaykgPT4gcmVuZGVySFRNTCh7XG4gICAgICAgICAgbWFyayxcbiAgICAgICAgICBIVE1MQXR0cmlidXRlczogZ2V0UmVuZGVyZWRBdHRyaWJ1dGVzKG1hcmssIGV4dGVuc2lvbkF0dHJpYnV0ZXMpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtleHRlbnNpb24ubmFtZSwgc2NoZW1hXTtcbiAgICB9KVxuICApO1xuICByZXR1cm4gbmV3IFNjaGVtYTIoe1xuICAgIHRvcE5vZGUsXG4gICAgbm9kZXMsXG4gICAgbWFya3NcbiAgfSk7XG59XG5cbi8vIHNyYy91dGlsaXRpZXMvZmluZER1cGxpY2F0ZXMudHNcbmZ1bmN0aW9uIGZpbmREdXBsaWNhdGVzKGl0ZW1zKSB7XG4gIGNvbnN0IGZpbHRlcmVkID0gaXRlbXMuZmlsdGVyKChlbCwgaW5kZXgpID0+IGl0ZW1zLmluZGV4T2YoZWwpICE9PSBpbmRleCk7XG4gIHJldHVybiBBcnJheS5mcm9tKG5ldyBTZXQoZmlsdGVyZWQpKTtcbn1cblxuLy8gc3JjL2hlbHBlcnMvc29ydEV4dGVuc2lvbnMudHNcbmZ1bmN0aW9uIHNvcnRFeHRlbnNpb25zKGV4dGVuc2lvbnMpIHtcbiAgY29uc3QgZGVmYXVsdFByaW9yaXR5ID0gMTAwO1xuICByZXR1cm4gZXh0ZW5zaW9ucy5zb3J0KChhLCBiKSA9PiB7XG4gICAgY29uc3QgcHJpb3JpdHlBID0gZ2V0RXh0ZW5zaW9uRmllbGQoYSwgXCJwcmlvcml0eVwiKSB8fCBkZWZhdWx0UHJpb3JpdHk7XG4gICAgY29uc3QgcHJpb3JpdHlCID0gZ2V0RXh0ZW5zaW9uRmllbGQoYiwgXCJwcmlvcml0eVwiKSB8fCBkZWZhdWx0UHJpb3JpdHk7XG4gICAgaWYgKHByaW9yaXR5QSA+IHByaW9yaXR5Qikge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBpZiAocHJpb3JpdHlBIDwgcHJpb3JpdHlCKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH0pO1xufVxuXG4vLyBzcmMvaGVscGVycy9yZXNvbHZlRXh0ZW5zaW9ucy50c1xuZnVuY3Rpb24gcmVzb2x2ZUV4dGVuc2lvbnMoZXh0ZW5zaW9ucykge1xuICBjb25zdCByZXNvbHZlZEV4dGVuc2lvbnMgPSBzb3J0RXh0ZW5zaW9ucyhmbGF0dGVuRXh0ZW5zaW9ucyhleHRlbnNpb25zKSk7XG4gIGNvbnN0IGR1cGxpY2F0ZWROYW1lcyA9IGZpbmREdXBsaWNhdGVzKHJlc29sdmVkRXh0ZW5zaW9ucy5tYXAoKGV4dGVuc2lvbikgPT4gZXh0ZW5zaW9uLm5hbWUpKTtcbiAgaWYgKGR1cGxpY2F0ZWROYW1lcy5sZW5ndGgpIHtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICBgW3RpcHRhcCB3YXJuXTogRHVwbGljYXRlIGV4dGVuc2lvbiBuYW1lcyBmb3VuZDogWyR7ZHVwbGljYXRlZE5hbWVzLm1hcCgoaXRlbSkgPT4gYCcke2l0ZW19J2ApLmpvaW4oXCIsIFwiKX1dLiBUaGlzIGNhbiBsZWFkIHRvIGlzc3Vlcy5gXG4gICAgKTtcbiAgfVxuICByZXR1cm4gcmVzb2x2ZWRFeHRlbnNpb25zO1xufVxuXG4vLyBzcmMvaGVscGVycy9nZXRTY2hlbWEudHNcbmZ1bmN0aW9uIGdldFNjaGVtYShleHRlbnNpb25zLCBlZGl0b3IpIHtcbiAgY29uc3QgcmVzb2x2ZWRFeHRlbnNpb25zID0gcmVzb2x2ZUV4dGVuc2lvbnMoZXh0ZW5zaW9ucyk7XG4gIHJldHVybiBnZXRTY2hlbWFCeVJlc29sdmVkRXh0ZW5zaW9ucyhyZXNvbHZlZEV4dGVuc2lvbnMsIGVkaXRvcik7XG59XG5cbi8vIHNyYy9oZWxwZXJzL2dlbmVyYXRlSFRNTC50c1xuZnVuY3Rpb24gZ2VuZXJhdGVIVE1MKGRvYywgZXh0ZW5zaW9ucykge1xuICBjb25zdCBzY2hlbWEgPSBnZXRTY2hlbWEoZXh0ZW5zaW9ucyk7XG4gIGNvbnN0IGNvbnRlbnROb2RlID0gTm9kZS5mcm9tSlNPTihzY2hlbWEsIGRvYyk7XG4gIHJldHVybiBnZXRIVE1MRnJvbUZyYWdtZW50KGNvbnRlbnROb2RlLmNvbnRlbnQsIHNjaGVtYSk7XG59XG5cbi8vIHNyYy9oZWxwZXJzL2dlbmVyYXRlSlNPTi50c1xuaW1wb3J0IHsgRE9NUGFyc2VyIGFzIERPTVBhcnNlcjIgfSBmcm9tIFwiQHRpcHRhcC9wbS9tb2RlbFwiO1xuZnVuY3Rpb24gZ2VuZXJhdGVKU09OKGh0bWwsIGV4dGVuc2lvbnMpIHtcbiAgY29uc3Qgc2NoZW1hID0gZ2V0U2NoZW1hKGV4dGVuc2lvbnMpO1xuICBjb25zdCBkb20gPSBlbGVtZW50RnJvbVN0cmluZyhodG1sKTtcbiAgcmV0dXJuIERPTVBhcnNlcjIuZnJvbVNjaGVtYShzY2hlbWEpLnBhcnNlKGRvbSkudG9KU09OKCk7XG59XG5cbi8vIHNyYy9oZWxwZXJzL2dlbmVyYXRlVGV4dC50c1xuaW1wb3J0IHsgTm9kZSBhcyBOb2RlMiB9IGZyb20gXCJAdGlwdGFwL3BtL21vZGVsXCI7XG5cbi8vIHNyYy9oZWxwZXJzL2dldFRleHRCZXR3ZWVuLnRzXG5mdW5jdGlvbiBnZXRUZXh0QmV0d2VlbihzdGFydE5vZGUsIHJhbmdlLCBvcHRpb25zKSB7XG4gIGNvbnN0IHsgZnJvbSwgdG8gfSA9IHJhbmdlO1xuICBjb25zdCB7IGJsb2NrU2VwYXJhdG9yID0gXCJcXG5cXG5cIiwgdGV4dFNlcmlhbGl6ZXJzID0ge30gfSA9IG9wdGlvbnMgfHwge307XG4gIGxldCB0ZXh0ID0gXCJcIjtcbiAgc3RhcnROb2RlLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUsIHBvcywgcGFyZW50LCBpbmRleCkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBpZiAobm9kZS5pc0Jsb2NrICYmIHBvcyA+IGZyb20pIHtcbiAgICAgIHRleHQgKz0gYmxvY2tTZXBhcmF0b3I7XG4gICAgfVxuICAgIGNvbnN0IHRleHRTZXJpYWxpemVyID0gdGV4dFNlcmlhbGl6ZXJzID09IG51bGwgPyB2b2lkIDAgOiB0ZXh0U2VyaWFsaXplcnNbbm9kZS50eXBlLm5hbWVdO1xuICAgIGlmICh0ZXh0U2VyaWFsaXplcikge1xuICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICB0ZXh0ICs9IHRleHRTZXJpYWxpemVyKHtcbiAgICAgICAgICBub2RlLFxuICAgICAgICAgIHBvcyxcbiAgICAgICAgICBwYXJlbnQsXG4gICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgcmFuZ2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChub2RlLmlzVGV4dCkge1xuICAgICAgdGV4dCArPSAoX2EgPSBub2RlID09IG51bGwgPyB2b2lkIDAgOiBub2RlLnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5zbGljZShNYXRoLm1heChmcm9tLCBwb3MpIC0gcG9zLCB0byAtIHBvcyk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHRleHQ7XG59XG5cbi8vIHNyYy9oZWxwZXJzL2dldFRleHQudHNcbmZ1bmN0aW9uIGdldFRleHQobm9kZSwgb3B0aW9ucykge1xuICBjb25zdCByYW5nZSA9IHtcbiAgICBmcm9tOiAwLFxuICAgIHRvOiBub2RlLmNvbnRlbnQuc2l6ZVxuICB9O1xuICByZXR1cm4gZ2V0VGV4dEJldHdlZW4obm9kZSwgcmFuZ2UsIG9wdGlvbnMpO1xufVxuXG4vLyBzcmMvaGVscGVycy9nZXRUZXh0U2VyaWFsaXplcnNGcm9tU2NoZW1hLnRzXG5mdW5jdGlvbiBnZXRUZXh0U2VyaWFsaXplcnNGcm9tU2NoZW1hKHNjaGVtYSkge1xuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgIE9iamVjdC5lbnRyaWVzKHNjaGVtYS5ub2RlcykuZmlsdGVyKChbLCBub2RlXSkgPT4gbm9kZS5zcGVjLnRvVGV4dCkubWFwKChbbmFtZSwgbm9kZV0pID0+IFtuYW1lLCBub2RlLnNwZWMudG9UZXh0XSlcbiAgKTtcbn1cblxuLy8gc3JjL2hlbHBlcnMvZ2VuZXJhdGVUZXh0LnRzXG5mdW5jdGlvbiBnZW5lcmF0ZVRleHQoZG9jLCBleHRlbnNpb25zLCBvcHRpb25zKSB7XG4gIGNvbnN0IHsgYmxvY2tTZXBhcmF0b3IgPSBcIlxcblxcblwiLCB0ZXh0U2VyaWFsaXplcnMgPSB7fSB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgY29uc3Qgc2NoZW1hID0gZ2V0U2NoZW1hKGV4dGVuc2lvbnMpO1xuICBjb25zdCBjb250ZW50Tm9kZSA9IE5vZGUyLmZyb21KU09OKHNjaGVtYSwgZG9jKTtcbiAgcmV0dXJuIGdldFRleHQoY29udGVudE5vZGUsIHtcbiAgICBibG9ja1NlcGFyYXRvcixcbiAgICB0ZXh0U2VyaWFsaXplcnM6IHtcbiAgICAgIC4uLmdldFRleHRTZXJpYWxpemVyc0Zyb21TY2hlbWEoc2NoZW1hKSxcbiAgICAgIC4uLnRleHRTZXJpYWxpemVyc1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIHNyYy9oZWxwZXJzL2dldE5vZGVBdHRyaWJ1dGVzLnRzXG5mdW5jdGlvbiBnZXROb2RlQXR0cmlidXRlcyhzdGF0ZSwgdHlwZU9yTmFtZSkge1xuICBjb25zdCB0eXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgY29uc3QgeyBmcm9tLCB0byB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICBjb25zdCBub2RlcyA9IFtdO1xuICBzdGF0ZS5kb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCAobm9kZTIpID0+IHtcbiAgICBub2Rlcy5wdXNoKG5vZGUyKTtcbiAgfSk7XG4gIGNvbnN0IG5vZGUgPSBub2Rlcy5yZXZlcnNlKCkuZmluZCgobm9kZUl0ZW0pID0+IG5vZGVJdGVtLnR5cGUubmFtZSA9PT0gdHlwZS5uYW1lKTtcbiAgaWYgKCFub2RlKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIHJldHVybiB7IC4uLm5vZGUuYXR0cnMgfTtcbn1cblxuLy8gc3JjL2hlbHBlcnMvZ2V0QXR0cmlidXRlcy50c1xuZnVuY3Rpb24gZ2V0QXR0cmlidXRlcyhzdGF0ZSwgdHlwZU9yTmFtZSkge1xuICBjb25zdCBzY2hlbWFUeXBlID0gZ2V0U2NoZW1hVHlwZU5hbWVCeU5hbWUoXG4gICAgdHlwZW9mIHR5cGVPck5hbWUgPT09IFwic3RyaW5nXCIgPyB0eXBlT3JOYW1lIDogdHlwZU9yTmFtZS5uYW1lLFxuICAgIHN0YXRlLnNjaGVtYVxuICApO1xuICBpZiAoc2NoZW1hVHlwZSA9PT0gXCJub2RlXCIpIHtcbiAgICByZXR1cm4gZ2V0Tm9kZUF0dHJpYnV0ZXMoc3RhdGUsIHR5cGVPck5hbWUpO1xuICB9XG4gIGlmIChzY2hlbWFUeXBlID09PSBcIm1hcmtcIikge1xuICAgIHJldHVybiBnZXRNYXJrQXR0cmlidXRlcyhzdGF0ZSwgdHlwZU9yTmFtZSk7XG4gIH1cbiAgcmV0dXJuIHt9O1xufVxuXG4vLyBzcmMvdXRpbGl0aWVzL3JlbW92ZUR1cGxpY2F0ZXMudHNcbmZ1bmN0aW9uIHJlbW92ZUR1cGxpY2F0ZXMoYXJyYXksIGJ5ID0gSlNPTi5zdHJpbmdpZnkpIHtcbiAgY29uc3Qgc2VlbiA9IHt9O1xuICByZXR1cm4gYXJyYXkuZmlsdGVyKChpdGVtKSA9PiB7XG4gICAgY29uc3Qga2V5ID0gYnkoaXRlbSk7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZWVuLCBrZXkpID8gZmFsc2UgOiBzZWVuW2tleV0gPSB0cnVlO1xuICB9KTtcbn1cblxuLy8gc3JjL2hlbHBlcnMvZ2V0Q2hhbmdlZFJhbmdlcy50c1xuZnVuY3Rpb24gc2ltcGxpZnlDaGFuZ2VkUmFuZ2VzKGNoYW5nZXMpIHtcbiAgY29uc3QgdW5pcXVlQ2hhbmdlcyA9IHJlbW92ZUR1cGxpY2F0ZXMoY2hhbmdlcyk7XG4gIHJldHVybiB1bmlxdWVDaGFuZ2VzLmxlbmd0aCA9PT0gMSA/IHVuaXF1ZUNoYW5nZXMgOiB1bmlxdWVDaGFuZ2VzLmZpbHRlcigoY2hhbmdlLCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IHJlc3QgPSB1bmlxdWVDaGFuZ2VzLmZpbHRlcigoXywgaSkgPT4gaSAhPT0gaW5kZXgpO1xuICAgIHJldHVybiAhcmVzdC5zb21lKChvdGhlckNoYW5nZSkgPT4ge1xuICAgICAgcmV0dXJuIGNoYW5nZS5vbGRSYW5nZS5mcm9tID49IG90aGVyQ2hhbmdlLm9sZFJhbmdlLmZyb20gJiYgY2hhbmdlLm9sZFJhbmdlLnRvIDw9IG90aGVyQ2hhbmdlLm9sZFJhbmdlLnRvICYmIGNoYW5nZS5uZXdSYW5nZS5mcm9tID49IG90aGVyQ2hhbmdlLm5ld1JhbmdlLmZyb20gJiYgY2hhbmdlLm5ld1JhbmdlLnRvIDw9IG90aGVyQ2hhbmdlLm5ld1JhbmdlLnRvO1xuICAgIH0pO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGdldENoYW5nZWRSYW5nZXModHJhbnNmb3JtKSB7XG4gIGNvbnN0IHsgbWFwcGluZywgc3RlcHMgfSA9IHRyYW5zZm9ybTtcbiAgY29uc3QgY2hhbmdlcyA9IFtdO1xuICBtYXBwaW5nLm1hcHMuZm9yRWFjaCgoc3RlcE1hcCwgaW5kZXgpID0+IHtcbiAgICBjb25zdCByYW5nZXMgPSBbXTtcbiAgICBpZiAoIXN0ZXBNYXAucmFuZ2VzLmxlbmd0aCkge1xuICAgICAgY29uc3QgeyBmcm9tLCB0byB9ID0gc3RlcHNbaW5kZXhdO1xuICAgICAgaWYgKGZyb20gPT09IHZvaWQgMCB8fCB0byA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJhbmdlcy5wdXNoKHsgZnJvbSwgdG8gfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ZXBNYXAuZm9yRWFjaCgoZnJvbSwgdG8pID0+IHtcbiAgICAgICAgcmFuZ2VzLnB1c2goeyBmcm9tLCB0byB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByYW5nZXMuZm9yRWFjaCgoeyBmcm9tLCB0byB9KSA9PiB7XG4gICAgICBjb25zdCBuZXdTdGFydCA9IG1hcHBpbmcuc2xpY2UoaW5kZXgpLm1hcChmcm9tLCAtMSk7XG4gICAgICBjb25zdCBuZXdFbmQgPSBtYXBwaW5nLnNsaWNlKGluZGV4KS5tYXAodG8pO1xuICAgICAgY29uc3Qgb2xkU3RhcnQgPSBtYXBwaW5nLmludmVydCgpLm1hcChuZXdTdGFydCwgLTEpO1xuICAgICAgY29uc3Qgb2xkRW5kID0gbWFwcGluZy5pbnZlcnQoKS5tYXAobmV3RW5kKTtcbiAgICAgIGNoYW5nZXMucHVzaCh7XG4gICAgICAgIG9sZFJhbmdlOiB7XG4gICAgICAgICAgZnJvbTogb2xkU3RhcnQsXG4gICAgICAgICAgdG86IG9sZEVuZFxuICAgICAgICB9LFxuICAgICAgICBuZXdSYW5nZToge1xuICAgICAgICAgIGZyb206IG5ld1N0YXJ0LFxuICAgICAgICAgIHRvOiBuZXdFbmRcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gc2ltcGxpZnlDaGFuZ2VkUmFuZ2VzKGNoYW5nZXMpO1xufVxuXG4vLyBzcmMvaGVscGVycy9nZXREZWJ1Z0pTT04udHNcbmZ1bmN0aW9uIGdldERlYnVnSlNPTihub2RlLCBzdGFydE9mZnNldCA9IDApIHtcbiAgY29uc3QgaXNUb3BOb2RlID0gbm9kZS50eXBlID09PSBub2RlLnR5cGUuc2NoZW1hLnRvcE5vZGVUeXBlO1xuICBjb25zdCBpbmNyZW1lbnQgPSBpc1RvcE5vZGUgPyAwIDogMTtcbiAgY29uc3QgZnJvbSA9IHN0YXJ0T2Zmc2V0O1xuICBjb25zdCB0byA9IGZyb20gKyBub2RlLm5vZGVTaXplO1xuICBjb25zdCBtYXJrcyA9IG5vZGUubWFya3MubWFwKChtYXJrKSA9PiB7XG4gICAgY29uc3Qgb3V0cHV0MiA9IHtcbiAgICAgIHR5cGU6IG1hcmsudHlwZS5uYW1lXG4gICAgfTtcbiAgICBpZiAoT2JqZWN0LmtleXMobWFyay5hdHRycykubGVuZ3RoKSB7XG4gICAgICBvdXRwdXQyLmF0dHJzID0geyAuLi5tYXJrLmF0dHJzIH07XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQyO1xuICB9KTtcbiAgY29uc3QgYXR0cnMgPSB7IC4uLm5vZGUuYXR0cnMgfTtcbiAgY29uc3Qgb3V0cHV0ID0ge1xuICAgIHR5cGU6IG5vZGUudHlwZS5uYW1lLFxuICAgIGZyb20sXG4gICAgdG9cbiAgfTtcbiAgaWYgKE9iamVjdC5rZXlzKGF0dHJzKS5sZW5ndGgpIHtcbiAgICBvdXRwdXQuYXR0cnMgPSBhdHRycztcbiAgfVxuICBpZiAobWFya3MubGVuZ3RoKSB7XG4gICAgb3V0cHV0Lm1hcmtzID0gbWFya3M7XG4gIH1cbiAgaWYgKG5vZGUuY29udGVudC5jaGlsZENvdW50KSB7XG4gICAgb3V0cHV0LmNvbnRlbnQgPSBbXTtcbiAgICBub2RlLmZvckVhY2goKGNoaWxkLCBvZmZzZXQpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIChfYSA9IG91dHB1dC5jb250ZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2EucHVzaChnZXREZWJ1Z0pTT04oY2hpbGQsIHN0YXJ0T2Zmc2V0ICsgb2Zmc2V0ICsgaW5jcmVtZW50KSk7XG4gICAgfSk7XG4gIH1cbiAgaWYgKG5vZGUudGV4dCkge1xuICAgIG91dHB1dC50ZXh0ID0gbm9kZS50ZXh0O1xuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbi8vIHNyYy9oZWxwZXJzL2dldE1hcmtzQmV0d2Vlbi50c1xuZnVuY3Rpb24gZ2V0TWFya3NCZXR3ZWVuKGZyb20sIHRvLCBkb2MpIHtcbiAgY29uc3QgbWFya3MgPSBbXTtcbiAgaWYgKGZyb20gPT09IHRvKSB7XG4gICAgZG9jLnJlc29sdmUoZnJvbSkubWFya3MoKS5mb3JFYWNoKChtYXJrKSA9PiB7XG4gICAgICBjb25zdCAkcG9zID0gZG9jLnJlc29sdmUoZnJvbSk7XG4gICAgICBjb25zdCByYW5nZSA9IGdldE1hcmtSYW5nZSgkcG9zLCBtYXJrLnR5cGUpO1xuICAgICAgaWYgKCFyYW5nZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBtYXJrcy5wdXNoKHtcbiAgICAgICAgbWFyayxcbiAgICAgICAgLi4ucmFuZ2VcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MpID0+IHtcbiAgICAgIGlmICghbm9kZSB8fCAobm9kZSA9PSBudWxsID8gdm9pZCAwIDogbm9kZS5ub2RlU2l6ZSkgPT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBtYXJrcy5wdXNoKFxuICAgICAgICAuLi5ub2RlLm1hcmtzLm1hcCgobWFyaykgPT4gKHtcbiAgICAgICAgICBmcm9tOiBwb3MsXG4gICAgICAgICAgdG86IHBvcyArIG5vZGUubm9kZVNpemUsXG4gICAgICAgICAgbWFya1xuICAgICAgICB9KSlcbiAgICAgICk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG1hcmtzO1xufVxuXG4vLyBzcmMvaGVscGVycy9nZXROb2RlQXRQb3NpdGlvbi50c1xudmFyIGdldE5vZGVBdFBvc2l0aW9uID0gKHN0YXRlLCB0eXBlT3JOYW1lLCBwb3MsIG1heERlcHRoID0gMjApID0+IHtcbiAgY29uc3QgJHBvcyA9IHN0YXRlLmRvYy5yZXNvbHZlKHBvcyk7XG4gIGxldCBjdXJyZW50RGVwdGggPSBtYXhEZXB0aDtcbiAgbGV0IG5vZGUgPSBudWxsO1xuICB3aGlsZSAoY3VycmVudERlcHRoID4gMCAmJiBub2RlID09PSBudWxsKSB7XG4gICAgY29uc3QgY3VycmVudE5vZGUgPSAkcG9zLm5vZGUoY3VycmVudERlcHRoKTtcbiAgICBpZiAoKGN1cnJlbnROb2RlID09IG51bGwgPyB2b2lkIDAgOiBjdXJyZW50Tm9kZS50eXBlLm5hbWUpID09PSB0eXBlT3JOYW1lKSB7XG4gICAgICBub2RlID0gY3VycmVudE5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnREZXB0aCAtPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gW25vZGUsIGN1cnJlbnREZXB0aF07XG59O1xuXG4vLyBzcmMvaGVscGVycy9nZXRTY2hlbWFUeXBlQnlOYW1lLnRzXG5mdW5jdGlvbiBnZXRTY2hlbWFUeXBlQnlOYW1lKG5hbWUsIHNjaGVtYSkge1xuICByZXR1cm4gc2NoZW1hLm5vZGVzW25hbWVdIHx8IHNjaGVtYS5tYXJrc1tuYW1lXSB8fCBudWxsO1xufVxuXG4vLyBzcmMvaGVscGVycy9nZXRTcGxpdHRlZEF0dHJpYnV0ZXMudHNcbmZ1bmN0aW9uIGdldFNwbGl0dGVkQXR0cmlidXRlcyhleHRlbnNpb25BdHRyaWJ1dGVzLCB0eXBlTmFtZSwgYXR0cmlidXRlcykge1xuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgIE9iamVjdC5lbnRyaWVzKGF0dHJpYnV0ZXMpLmZpbHRlcigoW25hbWVdKSA9PiB7XG4gICAgICBjb25zdCBleHRlbnNpb25BdHRyaWJ1dGUgPSBleHRlbnNpb25BdHRyaWJ1dGVzLmZpbmQoKGl0ZW0pID0+IHtcbiAgICAgICAgcmV0dXJuIGl0ZW0udHlwZSA9PT0gdHlwZU5hbWUgJiYgaXRlbS5uYW1lID09PSBuYW1lO1xuICAgICAgfSk7XG4gICAgICBpZiAoIWV4dGVuc2lvbkF0dHJpYnV0ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gZXh0ZW5zaW9uQXR0cmlidXRlLmF0dHJpYnV0ZS5rZWVwT25TcGxpdDtcbiAgICB9KVxuICApO1xufVxuXG4vLyBzcmMvaGVscGVycy9nZXRUZXh0Q29udGVudEZyb21Ob2Rlcy50c1xudmFyIGdldFRleHRDb250ZW50RnJvbU5vZGVzID0gKCRmcm9tLCBtYXhNYXRjaCA9IDUwMCkgPT4ge1xuICBsZXQgdGV4dEJlZm9yZSA9IFwiXCI7XG4gIGNvbnN0IHNsaWNlRW5kUG9zID0gJGZyb20ucGFyZW50T2Zmc2V0O1xuICAkZnJvbS5wYXJlbnQubm9kZXNCZXR3ZWVuKE1hdGgubWF4KDAsIHNsaWNlRW5kUG9zIC0gbWF4TWF0Y2gpLCBzbGljZUVuZFBvcywgKG5vZGUsIHBvcywgcGFyZW50LCBpbmRleCkgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgY2h1bmsgPSAoKF9iID0gKF9hID0gbm9kZS50eXBlLnNwZWMpLnRvVGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIHtcbiAgICAgIG5vZGUsXG4gICAgICBwb3MsXG4gICAgICBwYXJlbnQsXG4gICAgICBpbmRleFxuICAgIH0pKSB8fCBub2RlLnRleHRDb250ZW50IHx8IFwiJWxlYWYlXCI7XG4gICAgdGV4dEJlZm9yZSArPSBub2RlLmlzQXRvbSAmJiAhbm9kZS5pc1RleHQgPyBjaHVuayA6IGNodW5rLnNsaWNlKDAsIE1hdGgubWF4KDAsIHNsaWNlRW5kUG9zIC0gcG9zKSk7XG4gIH0pO1xuICByZXR1cm4gdGV4dEJlZm9yZTtcbn07XG5cbi8vIHNyYy9oZWxwZXJzL2lzTWFya0FjdGl2ZS50c1xuZnVuY3Rpb24gaXNNYXJrQWN0aXZlKHN0YXRlLCB0eXBlT3JOYW1lLCBhdHRyaWJ1dGVzID0ge30pIHtcbiAgY29uc3QgeyBlbXB0eSwgcmFuZ2VzIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gIGNvbnN0IHR5cGUgPSB0eXBlT3JOYW1lID8gZ2V0TWFya1R5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKSA6IG51bGw7XG4gIGlmIChlbXB0eSkge1xuICAgIHJldHVybiAhIShzdGF0ZS5zdG9yZWRNYXJrcyB8fCBzdGF0ZS5zZWxlY3Rpb24uJGZyb20ubWFya3MoKSkuZmlsdGVyKChtYXJrKSA9PiB7XG4gICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHlwZS5uYW1lID09PSBtYXJrLnR5cGUubmFtZTtcbiAgICB9KS5maW5kKChtYXJrKSA9PiBvYmplY3RJbmNsdWRlcyhtYXJrLmF0dHJzLCBhdHRyaWJ1dGVzLCB7IHN0cmljdDogZmFsc2UgfSkpO1xuICB9XG4gIGxldCBzZWxlY3Rpb25SYW5nZSA9IDA7XG4gIGNvbnN0IG1hcmtSYW5nZXMgPSBbXTtcbiAgcmFuZ2VzLmZvckVhY2goKHsgJGZyb20sICR0byB9KSA9PiB7XG4gICAgY29uc3QgZnJvbSA9ICRmcm9tLnBvcztcbiAgICBjb25zdCB0byA9ICR0by5wb3M7XG4gICAgc3RhdGUuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUsIHBvcykgPT4ge1xuICAgICAgaWYgKCFub2RlLmlzVGV4dCAmJiAhbm9kZS5tYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVsYXRpdmVGcm9tID0gTWF0aC5tYXgoZnJvbSwgcG9zKTtcbiAgICAgIGNvbnN0IHJlbGF0aXZlVG8gPSBNYXRoLm1pbih0bywgcG9zICsgbm9kZS5ub2RlU2l6ZSk7XG4gICAgICBjb25zdCByYW5nZTIgPSByZWxhdGl2ZVRvIC0gcmVsYXRpdmVGcm9tO1xuICAgICAgc2VsZWN0aW9uUmFuZ2UgKz0gcmFuZ2UyO1xuICAgICAgbWFya1Jhbmdlcy5wdXNoKFxuICAgICAgICAuLi5ub2RlLm1hcmtzLm1hcCgobWFyaykgPT4gKHtcbiAgICAgICAgICBtYXJrLFxuICAgICAgICAgIGZyb206IHJlbGF0aXZlRnJvbSxcbiAgICAgICAgICB0bzogcmVsYXRpdmVUb1xuICAgICAgICB9KSlcbiAgICAgICk7XG4gICAgfSk7XG4gIH0pO1xuICBpZiAoc2VsZWN0aW9uUmFuZ2UgPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgbWF0Y2hlZFJhbmdlID0gbWFya1Jhbmdlcy5maWx0ZXIoKG1hcmtSYW5nZSkgPT4ge1xuICAgIGlmICghdHlwZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiB0eXBlLm5hbWUgPT09IG1hcmtSYW5nZS5tYXJrLnR5cGUubmFtZTtcbiAgfSkuZmlsdGVyKChtYXJrUmFuZ2UpID0+IG9iamVjdEluY2x1ZGVzKG1hcmtSYW5nZS5tYXJrLmF0dHJzLCBhdHRyaWJ1dGVzLCB7IHN0cmljdDogZmFsc2UgfSkpLnJlZHVjZSgoc3VtLCBtYXJrUmFuZ2UpID0+IHN1bSArIG1hcmtSYW5nZS50byAtIG1hcmtSYW5nZS5mcm9tLCAwKTtcbiAgY29uc3QgZXhjbHVkZWRSYW5nZSA9IG1hcmtSYW5nZXMuZmlsdGVyKChtYXJrUmFuZ2UpID0+IHtcbiAgICBpZiAoIXR5cGUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gbWFya1JhbmdlLm1hcmsudHlwZSAhPT0gdHlwZSAmJiBtYXJrUmFuZ2UubWFyay50eXBlLmV4Y2x1ZGVzKHR5cGUpO1xuICB9KS5yZWR1Y2UoKHN1bSwgbWFya1JhbmdlKSA9PiBzdW0gKyBtYXJrUmFuZ2UudG8gLSBtYXJrUmFuZ2UuZnJvbSwgMCk7XG4gIGNvbnN0IHJhbmdlID0gbWF0Y2hlZFJhbmdlID4gMCA/IG1hdGNoZWRSYW5nZSArIGV4Y2x1ZGVkUmFuZ2UgOiBtYXRjaGVkUmFuZ2U7XG4gIHJldHVybiByYW5nZSA+PSBzZWxlY3Rpb25SYW5nZTtcbn1cblxuLy8gc3JjL2hlbHBlcnMvaXNBY3RpdmUudHNcbmZ1bmN0aW9uIGlzQWN0aXZlKHN0YXRlLCBuYW1lLCBhdHRyaWJ1dGVzID0ge30pIHtcbiAgaWYgKCFuYW1lKSB7XG4gICAgcmV0dXJuIGlzTm9kZUFjdGl2ZShzdGF0ZSwgbnVsbCwgYXR0cmlidXRlcykgfHwgaXNNYXJrQWN0aXZlKHN0YXRlLCBudWxsLCBhdHRyaWJ1dGVzKTtcbiAgfVxuICBjb25zdCBzY2hlbWFUeXBlID0gZ2V0U2NoZW1hVHlwZU5hbWVCeU5hbWUobmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgaWYgKHNjaGVtYVR5cGUgPT09IFwibm9kZVwiKSB7XG4gICAgcmV0dXJuIGlzTm9kZUFjdGl2ZShzdGF0ZSwgbmFtZSwgYXR0cmlidXRlcyk7XG4gIH1cbiAgaWYgKHNjaGVtYVR5cGUgPT09IFwibWFya1wiKSB7XG4gICAgcmV0dXJuIGlzTWFya0FjdGl2ZShzdGF0ZSwgbmFtZSwgYXR0cmlidXRlcyk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBzcmMvaGVscGVycy9pc0F0RW5kT2ZOb2RlLnRzXG52YXIgaXNBdEVuZE9mTm9kZSA9IChzdGF0ZSwgbm9kZVR5cGUpID0+IHtcbiAgY29uc3QgeyAkZnJvbSwgJHRvLCAkYW5jaG9yIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gIGlmIChub2RlVHlwZSkge1xuICAgIGNvbnN0IHBhcmVudE5vZGUgPSBmaW5kUGFyZW50Tm9kZSgobm9kZSkgPT4gbm9kZS50eXBlLm5hbWUgPT09IG5vZGVUeXBlKShzdGF0ZS5zZWxlY3Rpb24pO1xuICAgIGlmICghcGFyZW50Tm9kZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCAkcGFyZW50UG9zID0gc3RhdGUuZG9jLnJlc29sdmUocGFyZW50Tm9kZS5wb3MgKyAxKTtcbiAgICBpZiAoJGFuY2hvci5wb3MgKyAxID09PSAkcGFyZW50UG9zLmVuZCgpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICgkdG8ucGFyZW50T2Zmc2V0IDwgJHRvLnBhcmVudC5ub2RlU2l6ZSAtIDIgfHwgJGZyb20ucG9zICE9PSAkdG8ucG9zKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuLy8gc3JjL2hlbHBlcnMvaXNBdFN0YXJ0T2ZOb2RlLnRzXG52YXIgaXNBdFN0YXJ0T2ZOb2RlID0gKHN0YXRlKSA9PiB7XG4gIGNvbnN0IHsgJGZyb20sICR0byB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICBpZiAoJGZyb20ucGFyZW50T2Zmc2V0ID4gMCB8fCAkZnJvbS5wb3MgIT09ICR0by5wb3MpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vLyBzcmMvaGVscGVycy9pc0V4dGVuc2lvblJ1bGVzRW5hYmxlZC50c1xuZnVuY3Rpb24gaXNFeHRlbnNpb25SdWxlc0VuYWJsZWQoZXh0ZW5zaW9uLCBlbmFibGVkKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGVuYWJsZWQpKSB7XG4gICAgcmV0dXJuIGVuYWJsZWQuc29tZSgoZW5hYmxlZEV4dGVuc2lvbikgPT4ge1xuICAgICAgY29uc3QgbmFtZSA9IHR5cGVvZiBlbmFibGVkRXh0ZW5zaW9uID09PSBcInN0cmluZ1wiID8gZW5hYmxlZEV4dGVuc2lvbiA6IGVuYWJsZWRFeHRlbnNpb24ubmFtZTtcbiAgICAgIHJldHVybiBuYW1lID09PSBleHRlbnNpb24ubmFtZTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gZW5hYmxlZDtcbn1cblxuLy8gc3JjL2hlbHBlcnMvaXNMaXN0LnRzXG5mdW5jdGlvbiBpc0xpc3QobmFtZSwgZXh0ZW5zaW9ucykge1xuICBjb25zdCB7IG5vZGVFeHRlbnNpb25zIH0gPSBzcGxpdEV4dGVuc2lvbnMoZXh0ZW5zaW9ucyk7XG4gIGNvbnN0IGV4dGVuc2lvbiA9IG5vZGVFeHRlbnNpb25zLmZpbmQoKGl0ZW0pID0+IGl0ZW0ubmFtZSA9PT0gbmFtZSk7XG4gIGlmICghZXh0ZW5zaW9uKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2VcbiAgfTtcbiAgY29uc3QgZ3JvdXAgPSBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCBcImdyb3VwXCIsIGNvbnRleHQpKTtcbiAgaWYgKHR5cGVvZiBncm91cCAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gZ3JvdXAuc3BsaXQoXCIgXCIpLmluY2x1ZGVzKFwibGlzdFwiKTtcbn1cblxuLy8gc3JjL2hlbHBlcnMvaXNOb2RlRW1wdHkudHNcbmZ1bmN0aW9uIGlzTm9kZUVtcHR5KG5vZGUsIHtcbiAgY2hlY2tDaGlsZHJlbiA9IHRydWUsXG4gIGlnbm9yZVdoaXRlc3BhY2UgPSBmYWxzZVxufSA9IHt9KSB7XG4gIHZhciBfYTtcbiAgaWYgKGlnbm9yZVdoaXRlc3BhY2UpIHtcbiAgICBpZiAobm9kZS50eXBlLm5hbWUgPT09IFwiaGFyZEJyZWFrXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAobm9kZS5pc1RleHQpIHtcbiAgICAgIHJldHVybiAvXlxccyokL20udGVzdCgoX2EgPSBub2RlLnRleHQpICE9IG51bGwgPyBfYSA6IFwiXCIpO1xuICAgIH1cbiAgfVxuICBpZiAobm9kZS5pc1RleHQpIHtcbiAgICByZXR1cm4gIW5vZGUudGV4dDtcbiAgfVxuICBpZiAobm9kZS5pc0F0b20gfHwgbm9kZS5pc0xlYWYpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKG5vZGUuY29udGVudC5jaGlsZENvdW50ID09PSAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGNoZWNrQ2hpbGRyZW4pIHtcbiAgICBsZXQgaXNDb250ZW50RW1wdHkgPSB0cnVlO1xuICAgIG5vZGUuY29udGVudC5mb3JFYWNoKChjaGlsZE5vZGUpID0+IHtcbiAgICAgIGlmIChpc0NvbnRlbnRFbXB0eSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFpc05vZGVFbXB0eShjaGlsZE5vZGUsIHsgaWdub3JlV2hpdGVzcGFjZSwgY2hlY2tDaGlsZHJlbiB9KSkge1xuICAgICAgICBpc0NvbnRlbnRFbXB0eSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBpc0NvbnRlbnRFbXB0eTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIHNyYy9oZWxwZXJzL2lzTm9kZVNlbGVjdGlvbi50c1xuaW1wb3J0IHsgTm9kZVNlbGVjdGlvbiB9IGZyb20gXCJAdGlwdGFwL3BtL3N0YXRlXCI7XG5mdW5jdGlvbiBpc05vZGVTZWxlY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbjtcbn1cblxuLy8gc3JjL2hlbHBlcnMvTWFwcGFibGVQb3NpdGlvbi50c1xudmFyIE1hcHBhYmxlUG9zaXRpb24gPSBjbGFzcyBfTWFwcGFibGVQb3NpdGlvbiB7XG4gIGNvbnN0cnVjdG9yKHBvc2l0aW9uKSB7XG4gICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgTWFwcGFibGVQb3NpdGlvbiBmcm9tIGEgSlNPTiBvYmplY3QuXG4gICAqL1xuICBzdGF0aWMgZnJvbUpTT04oanNvbikge1xuICAgIHJldHVybiBuZXcgX01hcHBhYmxlUG9zaXRpb24oanNvbi5wb3NpdGlvbik7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBNYXBwYWJsZVBvc2l0aW9uIHRvIGEgSlNPTiBvYmplY3QuXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvc2l0aW9uOiB0aGlzLnBvc2l0aW9uXG4gICAgfTtcbiAgfVxufTtcbmZ1bmN0aW9uIGdldFVwZGF0ZWRQb3NpdGlvbihwb3NpdGlvbiwgdHJhbnNhY3Rpb24pIHtcbiAgY29uc3QgbWFwUmVzdWx0ID0gdHJhbnNhY3Rpb24ubWFwcGluZy5tYXBSZXN1bHQocG9zaXRpb24ucG9zaXRpb24pO1xuICByZXR1cm4ge1xuICAgIHBvc2l0aW9uOiBuZXcgTWFwcGFibGVQb3NpdGlvbihtYXBSZXN1bHQucG9zKSxcbiAgICBtYXBSZXN1bHRcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU1hcHBhYmxlUG9zaXRpb24ocG9zaXRpb24pIHtcbiAgcmV0dXJuIG5ldyBNYXBwYWJsZVBvc2l0aW9uKHBvc2l0aW9uKTtcbn1cblxuLy8gc3JjL2hlbHBlcnMvcG9zVG9ET01SZWN0LnRzXG5mdW5jdGlvbiBwb3NUb0RPTVJlY3QodmlldywgZnJvbSwgdG8pIHtcbiAgY29uc3QgbWluUG9zID0gMDtcbiAgY29uc3QgbWF4UG9zID0gdmlldy5zdGF0ZS5kb2MuY29udGVudC5zaXplO1xuICBjb25zdCByZXNvbHZlZEZyb20gPSBtaW5NYXgoZnJvbSwgbWluUG9zLCBtYXhQb3MpO1xuICBjb25zdCByZXNvbHZlZEVuZCA9IG1pbk1heCh0bywgbWluUG9zLCBtYXhQb3MpO1xuICBjb25zdCBzdGFydCA9IHZpZXcuY29vcmRzQXRQb3MocmVzb2x2ZWRGcm9tKTtcbiAgY29uc3QgZW5kID0gdmlldy5jb29yZHNBdFBvcyhyZXNvbHZlZEVuZCwgLTEpO1xuICBjb25zdCB0b3AgPSBNYXRoLm1pbihzdGFydC50b3AsIGVuZC50b3ApO1xuICBjb25zdCBib3R0b20gPSBNYXRoLm1heChzdGFydC5ib3R0b20sIGVuZC5ib3R0b20pO1xuICBjb25zdCBsZWZ0ID0gTWF0aC5taW4oc3RhcnQubGVmdCwgZW5kLmxlZnQpO1xuICBjb25zdCByaWdodCA9IE1hdGgubWF4KHN0YXJ0LnJpZ2h0LCBlbmQucmlnaHQpO1xuICBjb25zdCB3aWR0aCA9IHJpZ2h0IC0gbGVmdDtcbiAgY29uc3QgaGVpZ2h0ID0gYm90dG9tIC0gdG9wO1xuICBjb25zdCB4ID0gbGVmdDtcbiAgY29uc3QgeSA9IHRvcDtcbiAgY29uc3QgZGF0YSA9IHtcbiAgICB0b3AsXG4gICAgYm90dG9tLFxuICAgIGxlZnQsXG4gICAgcmlnaHQsXG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIHgsXG4gICAgeVxuICB9O1xuICByZXR1cm4ge1xuICAgIC4uLmRhdGEsXG4gICAgdG9KU09OOiAoKSA9PiBkYXRhXG4gIH07XG59XG5cbi8vIHNyYy9oZWxwZXJzL3Jld3JpdGVVbmtub3duQ29udGVudC50c1xuZnVuY3Rpb24gcmV3cml0ZVVua25vd25Db250ZW50SW5uZXIoe1xuICBqc29uLFxuICB2YWxpZE1hcmtzLFxuICB2YWxpZE5vZGVzLFxuICBvcHRpb25zLFxuICByZXdyaXR0ZW5Db250ZW50ID0gW11cbn0pIHtcbiAgaWYgKGpzb24ubWFya3MgJiYgQXJyYXkuaXNBcnJheShqc29uLm1hcmtzKSkge1xuICAgIGpzb24ubWFya3MgPSBqc29uLm1hcmtzLmZpbHRlcigobWFyaykgPT4ge1xuICAgICAgY29uc3QgbmFtZSA9IHR5cGVvZiBtYXJrID09PSBcInN0cmluZ1wiID8gbWFyayA6IG1hcmsudHlwZTtcbiAgICAgIGlmICh2YWxpZE1hcmtzLmhhcyhuYW1lKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJld3JpdHRlbkNvbnRlbnQucHVzaCh7XG4gICAgICAgIG9yaWdpbmFsOiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG1hcmspKSxcbiAgICAgICAgdW5zdXBwb3J0ZWQ6IG5hbWVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xuICB9XG4gIGlmIChqc29uLmNvbnRlbnQgJiYgQXJyYXkuaXNBcnJheShqc29uLmNvbnRlbnQpKSB7XG4gICAganNvbi5jb250ZW50ID0ganNvbi5jb250ZW50Lm1hcChcbiAgICAgICh2YWx1ZSkgPT4gcmV3cml0ZVVua25vd25Db250ZW50SW5uZXIoe1xuICAgICAgICBqc29uOiB2YWx1ZSxcbiAgICAgICAgdmFsaWRNYXJrcyxcbiAgICAgICAgdmFsaWROb2RlcyxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgcmV3cml0dGVuQ29udGVudFxuICAgICAgfSkuanNvblxuICAgICkuZmlsdGVyKChhKSA9PiBhICE9PSBudWxsICYmIGEgIT09IHZvaWQgMCk7XG4gIH1cbiAgaWYgKGpzb24udHlwZSAmJiAhdmFsaWROb2Rlcy5oYXMoanNvbi50eXBlKSkge1xuICAgIHJld3JpdHRlbkNvbnRlbnQucHVzaCh7XG4gICAgICBvcmlnaW5hbDogSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShqc29uKSksXG4gICAgICB1bnN1cHBvcnRlZDoganNvbi50eXBlXG4gICAgfSk7XG4gICAgaWYgKGpzb24uY29udGVudCAmJiBBcnJheS5pc0FycmF5KGpzb24uY29udGVudCkgJiYgKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuZmFsbGJhY2tUb1BhcmFncmFwaCkgIT09IGZhbHNlKSB7XG4gICAgICBqc29uLnR5cGUgPSBcInBhcmFncmFwaFwiO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAganNvbixcbiAgICAgICAgcmV3cml0dGVuQ29udGVudFxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGpzb246IG51bGwsXG4gICAgICByZXdyaXR0ZW5Db250ZW50XG4gICAgfTtcbiAgfVxuICByZXR1cm4geyBqc29uLCByZXdyaXR0ZW5Db250ZW50IH07XG59XG5mdW5jdGlvbiByZXdyaXRlVW5rbm93bkNvbnRlbnQoanNvbiwgc2NoZW1hLCBvcHRpb25zKSB7XG4gIHJldHVybiByZXdyaXRlVW5rbm93bkNvbnRlbnRJbm5lcih7XG4gICAganNvbixcbiAgICB2YWxpZE5vZGVzOiBuZXcgU2V0KE9iamVjdC5rZXlzKHNjaGVtYS5ub2RlcykpLFxuICAgIHZhbGlkTWFya3M6IG5ldyBTZXQoT2JqZWN0LmtleXMoc2NoZW1hLm1hcmtzKSksXG4gICAgb3B0aW9uc1xuICB9KTtcbn1cblxuLy8gc3JjL2NvbW1hbmRzL3NldE1hcmsudHNcbmZ1bmN0aW9uIGNhblNldE1hcmsoc3RhdGUsIHRyLCBuZXdNYXJrVHlwZSkge1xuICB2YXIgX2E7XG4gIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSB0cjtcbiAgbGV0IGN1cnNvciA9IG51bGw7XG4gIGlmIChpc1RleHRTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgIGN1cnNvciA9IHNlbGVjdGlvbi4kY3Vyc29yO1xuICB9XG4gIGlmIChjdXJzb3IpIHtcbiAgICBjb25zdCBjdXJyZW50TWFya3MgPSAoX2EgPSBzdGF0ZS5zdG9yZWRNYXJrcykgIT0gbnVsbCA/IF9hIDogY3Vyc29yLm1hcmtzKCk7XG4gICAgY29uc3QgcGFyZW50QWxsb3dzTWFya1R5cGUgPSBjdXJzb3IucGFyZW50LnR5cGUuYWxsb3dzTWFya1R5cGUobmV3TWFya1R5cGUpO1xuICAgIHJldHVybiBwYXJlbnRBbGxvd3NNYXJrVHlwZSAmJiAoISFuZXdNYXJrVHlwZS5pc0luU2V0KGN1cnJlbnRNYXJrcykgfHwgIWN1cnJlbnRNYXJrcy5zb21lKChtYXJrKSA9PiBtYXJrLnR5cGUuZXhjbHVkZXMobmV3TWFya1R5cGUpKSk7XG4gIH1cbiAgY29uc3QgeyByYW5nZXMgfSA9IHNlbGVjdGlvbjtcbiAgcmV0dXJuIHJhbmdlcy5zb21lKCh7ICRmcm9tLCAkdG8gfSkgPT4ge1xuICAgIGxldCBzb21lTm9kZVN1cHBvcnRzTWFyayA9ICRmcm9tLmRlcHRoID09PSAwID8gc3RhdGUuZG9jLmlubGluZUNvbnRlbnQgJiYgc3RhdGUuZG9jLnR5cGUuYWxsb3dzTWFya1R5cGUobmV3TWFya1R5cGUpIDogZmFsc2U7XG4gICAgc3RhdGUuZG9jLm5vZGVzQmV0d2VlbigkZnJvbS5wb3MsICR0by5wb3MsIChub2RlLCBfcG9zLCBwYXJlbnQpID0+IHtcbiAgICAgIGlmIChzb21lTm9kZVN1cHBvcnRzTWFyaykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAobm9kZS5pc0lubGluZSkge1xuICAgICAgICBjb25zdCBwYXJlbnRBbGxvd3NNYXJrVHlwZSA9ICFwYXJlbnQgfHwgcGFyZW50LnR5cGUuYWxsb3dzTWFya1R5cGUobmV3TWFya1R5cGUpO1xuICAgICAgICBjb25zdCBjdXJyZW50TWFya3NBbGxvd01hcmtUeXBlID0gISFuZXdNYXJrVHlwZS5pc0luU2V0KG5vZGUubWFya3MpIHx8ICFub2RlLm1hcmtzLnNvbWUoKG90aGVyTWFyaykgPT4gb3RoZXJNYXJrLnR5cGUuZXhjbHVkZXMobmV3TWFya1R5cGUpKTtcbiAgICAgICAgc29tZU5vZGVTdXBwb3J0c01hcmsgPSBwYXJlbnRBbGxvd3NNYXJrVHlwZSAmJiBjdXJyZW50TWFya3NBbGxvd01hcmtUeXBlO1xuICAgICAgfVxuICAgICAgcmV0dXJuICFzb21lTm9kZVN1cHBvcnRzTWFyaztcbiAgICB9KTtcbiAgICByZXR1cm4gc29tZU5vZGVTdXBwb3J0c01hcms7XG4gIH0pO1xufVxudmFyIHNldE1hcmsgPSAodHlwZU9yTmFtZSwgYXR0cmlidXRlcyA9IHt9KSA9PiAoeyB0ciwgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHRyO1xuICBjb25zdCB7IGVtcHR5LCByYW5nZXMgfSA9IHNlbGVjdGlvbjtcbiAgY29uc3QgdHlwZSA9IGdldE1hcmtUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XG4gIGlmIChkaXNwYXRjaCkge1xuICAgIGlmIChlbXB0eSkge1xuICAgICAgY29uc3Qgb2xkQXR0cmlidXRlcyA9IGdldE1hcmtBdHRyaWJ1dGVzKHN0YXRlLCB0eXBlKTtcbiAgICAgIHRyLmFkZFN0b3JlZE1hcmsoXG4gICAgICAgIHR5cGUuY3JlYXRlKHtcbiAgICAgICAgICAuLi5vbGRBdHRyaWJ1dGVzLFxuICAgICAgICAgIC4uLmF0dHJpYnV0ZXNcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJhbmdlcy5mb3JFYWNoKChyYW5nZSkgPT4ge1xuICAgICAgICBjb25zdCBmcm9tID0gcmFuZ2UuJGZyb20ucG9zO1xuICAgICAgICBjb25zdCB0byA9IHJhbmdlLiR0by5wb3M7XG4gICAgICAgIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MpID0+IHtcbiAgICAgICAgICBjb25zdCB0cmltbWVkRnJvbSA9IE1hdGgubWF4KHBvcywgZnJvbSk7XG4gICAgICAgICAgY29uc3QgdHJpbW1lZFRvID0gTWF0aC5taW4ocG9zICsgbm9kZS5ub2RlU2l6ZSwgdG8pO1xuICAgICAgICAgIGNvbnN0IHNvbWVIYXNNYXJrID0gbm9kZS5tYXJrcy5maW5kKChtYXJrKSA9PiBtYXJrLnR5cGUgPT09IHR5cGUpO1xuICAgICAgICAgIGlmIChzb21lSGFzTWFyaykge1xuICAgICAgICAgICAgbm9kZS5tYXJrcy5mb3JFYWNoKChtYXJrKSA9PiB7XG4gICAgICAgICAgICAgIGlmICh0eXBlID09PSBtYXJrLnR5cGUpIHtcbiAgICAgICAgICAgICAgICB0ci5hZGRNYXJrKFxuICAgICAgICAgICAgICAgICAgdHJpbW1lZEZyb20sXG4gICAgICAgICAgICAgICAgICB0cmltbWVkVG8sXG4gICAgICAgICAgICAgICAgICB0eXBlLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIC4uLm1hcmsuYXR0cnMsXG4gICAgICAgICAgICAgICAgICAgIC4uLmF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyLmFkZE1hcmsodHJpbW1lZEZyb20sIHRyaW1tZWRUbywgdHlwZS5jcmVhdGUoYXR0cmlidXRlcykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNhblNldE1hcmsoc3RhdGUsIHRyLCB0eXBlKTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy9zZXRNZXRhLnRzXG52YXIgc2V0TWV0YSA9IChrZXksIHZhbHVlKSA9PiAoeyB0ciB9KSA9PiB7XG4gIHRyLnNldE1ldGEoa2V5LCB2YWx1ZSk7XG4gIHJldHVybiB0cnVlO1xufTtcblxuLy8gc3JjL2NvbW1hbmRzL3NldE5vZGUudHNcbmltcG9ydCB7IHNldEJsb2NrVHlwZSB9IGZyb20gXCJAdGlwdGFwL3BtL2NvbW1hbmRzXCI7XG52YXIgc2V0Tm9kZSA9ICh0eXBlT3JOYW1lLCBhdHRyaWJ1dGVzID0ge30pID0+ICh7IHN0YXRlLCBkaXNwYXRjaCwgY2hhaW4gfSkgPT4ge1xuICBjb25zdCB0eXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgbGV0IGF0dHJpYnV0ZXNUb0NvcHk7XG4gIGlmIChzdGF0ZS5zZWxlY3Rpb24uJGFuY2hvci5zYW1lUGFyZW50KHN0YXRlLnNlbGVjdGlvbi4kaGVhZCkpIHtcbiAgICBhdHRyaWJ1dGVzVG9Db3B5ID0gc3RhdGUuc2VsZWN0aW9uLiRhbmNob3IucGFyZW50LmF0dHJzO1xuICB9XG4gIGlmICghdHlwZS5pc1RleHRibG9jaykge1xuICAgIGNvbnNvbGUud2FybignW3RpcHRhcCB3YXJuXTogQ3VycmVudGx5IFwic2V0Tm9kZSgpXCIgb25seSBzdXBwb3J0cyB0ZXh0IGJsb2NrIG5vZGVzLicpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gY2hhaW4oKS5jb21tYW5kKCh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICBjb25zdCBjYW5TZXRCbG9jayA9IHNldEJsb2NrVHlwZSh0eXBlLCB7IC4uLmF0dHJpYnV0ZXNUb0NvcHksIC4uLmF0dHJpYnV0ZXMgfSkoc3RhdGUpO1xuICAgIGlmIChjYW5TZXRCbG9jaykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBjb21tYW5kcy5jbGVhck5vZGVzKCk7XG4gIH0pLmNvbW1hbmQoKHsgc3RhdGU6IHVwZGF0ZWRTdGF0ZSB9KSA9PiB7XG4gICAgcmV0dXJuIHNldEJsb2NrVHlwZSh0eXBlLCB7IC4uLmF0dHJpYnV0ZXNUb0NvcHksIC4uLmF0dHJpYnV0ZXMgfSkodXBkYXRlZFN0YXRlLCBkaXNwYXRjaCk7XG4gIH0pLnJ1bigpO1xufTtcblxuLy8gc3JjL2NvbW1hbmRzL3NldE5vZGVTZWxlY3Rpb24udHNcbmltcG9ydCB7IE5vZGVTZWxlY3Rpb24gYXMgTm9kZVNlbGVjdGlvbjIgfSBmcm9tIFwiQHRpcHRhcC9wbS9zdGF0ZVwiO1xudmFyIHNldE5vZGVTZWxlY3Rpb24gPSAocG9zaXRpb24pID0+ICh7IHRyLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGlmIChkaXNwYXRjaCkge1xuICAgIGNvbnN0IHsgZG9jIH0gPSB0cjtcbiAgICBjb25zdCBmcm9tID0gbWluTWF4KHBvc2l0aW9uLCAwLCBkb2MuY29udGVudC5zaXplKTtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBOb2RlU2VsZWN0aW9uMi5jcmVhdGUoZG9jLCBmcm9tKTtcbiAgICB0ci5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy9zZXRUZXh0RGlyZWN0aW9uLnRzXG52YXIgc2V0VGV4dERpcmVjdGlvbiA9IChkaXJlY3Rpb24sIHBvc2l0aW9uKSA9PiAoeyB0ciwgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHN0YXRlO1xuICBsZXQgZnJvbTtcbiAgbGV0IHRvO1xuICBpZiAodHlwZW9mIHBvc2l0aW9uID09PSBcIm51bWJlclwiKSB7XG4gICAgZnJvbSA9IHBvc2l0aW9uO1xuICAgIHRvID0gcG9zaXRpb247XG4gIH0gZWxzZSBpZiAocG9zaXRpb24gJiYgXCJmcm9tXCIgaW4gcG9zaXRpb24gJiYgXCJ0b1wiIGluIHBvc2l0aW9uKSB7XG4gICAgZnJvbSA9IHBvc2l0aW9uLmZyb207XG4gICAgdG8gPSBwb3NpdGlvbi50bztcbiAgfSBlbHNlIHtcbiAgICBmcm9tID0gc2VsZWN0aW9uLmZyb207XG4gICAgdG8gPSBzZWxlY3Rpb24udG87XG4gIH1cbiAgaWYgKGRpc3BhdGNoKSB7XG4gICAgdHIuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUsIHBvcykgPT4ge1xuICAgICAgaWYgKG5vZGUuaXNUZXh0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRyLnNldE5vZGVNYXJrdXAocG9zLCB2b2lkIDAsIHtcbiAgICAgICAgLi4ubm9kZS5hdHRycyxcbiAgICAgICAgZGlyOiBkaXJlY3Rpb25cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuLy8gc3JjL2NvbW1hbmRzL3NldFRleHRTZWxlY3Rpb24udHNcbmltcG9ydCB7IFRleHRTZWxlY3Rpb24gYXMgVGV4dFNlbGVjdGlvbjUgfSBmcm9tIFwiQHRpcHRhcC9wbS9zdGF0ZVwiO1xudmFyIHNldFRleHRTZWxlY3Rpb24gPSAocG9zaXRpb24pID0+ICh7IHRyLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGlmIChkaXNwYXRjaCkge1xuICAgIGNvbnN0IHsgZG9jIH0gPSB0cjtcbiAgICBjb25zdCB7IGZyb20sIHRvIH0gPSB0eXBlb2YgcG9zaXRpb24gPT09IFwibnVtYmVyXCIgPyB7IGZyb206IHBvc2l0aW9uLCB0bzogcG9zaXRpb24gfSA6IHBvc2l0aW9uO1xuICAgIGNvbnN0IG1pblBvcyA9IFRleHRTZWxlY3Rpb241LmF0U3RhcnQoZG9jKS5mcm9tO1xuICAgIGNvbnN0IG1heFBvcyA9IFRleHRTZWxlY3Rpb241LmF0RW5kKGRvYykudG87XG4gICAgY29uc3QgcmVzb2x2ZWRGcm9tID0gbWluTWF4KGZyb20sIG1pblBvcywgbWF4UG9zKTtcbiAgICBjb25zdCByZXNvbHZlZEVuZCA9IG1pbk1heCh0bywgbWluUG9zLCBtYXhQb3MpO1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IFRleHRTZWxlY3Rpb241LmNyZWF0ZShkb2MsIHJlc29sdmVkRnJvbSwgcmVzb2x2ZWRFbmQpO1xuICAgIHRyLnNldFNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuLy8gc3JjL2NvbW1hbmRzL3NpbmtMaXN0SXRlbS50c1xuaW1wb3J0IHsgc2lua0xpc3RJdGVtIGFzIG9yaWdpbmFsU2lua0xpc3RJdGVtIH0gZnJvbSBcIkB0aXB0YXAvcG0vc2NoZW1hLWxpc3RcIjtcbnZhciBzaW5rTGlzdEl0ZW0gPSAodHlwZU9yTmFtZSkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgY29uc3QgdHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XG4gIHJldHVybiBvcmlnaW5hbFNpbmtMaXN0SXRlbSh0eXBlKShzdGF0ZSwgZGlzcGF0Y2gpO1xufTtcblxuLy8gc3JjL2NvbW1hbmRzL3NwbGl0QmxvY2sudHNcbmltcG9ydCB7IE5vZGVTZWxlY3Rpb24gYXMgTm9kZVNlbGVjdGlvbjMsIFRleHRTZWxlY3Rpb24gYXMgVGV4dFNlbGVjdGlvbjYgfSBmcm9tIFwiQHRpcHRhcC9wbS9zdGF0ZVwiO1xuaW1wb3J0IHsgY2FuU3BsaXQgfSBmcm9tIFwiQHRpcHRhcC9wbS90cmFuc2Zvcm1cIjtcbmZ1bmN0aW9uIGVuc3VyZU1hcmtzKHN0YXRlLCBzcGxpdHRhYmxlTWFya3MpIHtcbiAgY29uc3QgbWFya3MgPSBzdGF0ZS5zdG9yZWRNYXJrcyB8fCBzdGF0ZS5zZWxlY3Rpb24uJHRvLnBhcmVudE9mZnNldCAmJiBzdGF0ZS5zZWxlY3Rpb24uJGZyb20ubWFya3MoKTtcbiAgaWYgKG1hcmtzKSB7XG4gICAgY29uc3QgZmlsdGVyZWRNYXJrcyA9IG1hcmtzLmZpbHRlcigobWFyaykgPT4gc3BsaXR0YWJsZU1hcmtzID09IG51bGwgPyB2b2lkIDAgOiBzcGxpdHRhYmxlTWFya3MuaW5jbHVkZXMobWFyay50eXBlLm5hbWUpKTtcbiAgICBzdGF0ZS50ci5lbnN1cmVNYXJrcyhmaWx0ZXJlZE1hcmtzKTtcbiAgfVxufVxudmFyIHNwbGl0QmxvY2sgPSAoeyBrZWVwTWFya3MgPSB0cnVlIH0gPSB7fSkgPT4gKHsgdHIsIHN0YXRlLCBkaXNwYXRjaCwgZWRpdG9yIH0pID0+IHtcbiAgY29uc3QgeyBzZWxlY3Rpb24sIGRvYyB9ID0gdHI7XG4gIGNvbnN0IHsgJGZyb20sICR0byB9ID0gc2VsZWN0aW9uO1xuICBjb25zdCBleHRlbnNpb25BdHRyaWJ1dGVzID0gZWRpdG9yLmV4dGVuc2lvbk1hbmFnZXIuYXR0cmlidXRlcztcbiAgY29uc3QgbmV3QXR0cmlidXRlcyA9IGdldFNwbGl0dGVkQXR0cmlidXRlcyhleHRlbnNpb25BdHRyaWJ1dGVzLCAkZnJvbS5ub2RlKCkudHlwZS5uYW1lLCAkZnJvbS5ub2RlKCkuYXR0cnMpO1xuICBpZiAoc2VsZWN0aW9uIGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbjMgJiYgc2VsZWN0aW9uLm5vZGUuaXNCbG9jaykge1xuICAgIGlmICghJGZyb20ucGFyZW50T2Zmc2V0IHx8ICFjYW5TcGxpdChkb2MsICRmcm9tLnBvcykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICBpZiAoa2VlcE1hcmtzKSB7XG4gICAgICAgIGVuc3VyZU1hcmtzKHN0YXRlLCBlZGl0b3IuZXh0ZW5zaW9uTWFuYWdlci5zcGxpdHRhYmxlTWFya3MpO1xuICAgICAgfVxuICAgICAgdHIuc3BsaXQoJGZyb20ucG9zKS5zY3JvbGxJbnRvVmlldygpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoISRmcm9tLnBhcmVudC5pc0Jsb2NrKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGF0RW5kID0gJHRvLnBhcmVudE9mZnNldCA9PT0gJHRvLnBhcmVudC5jb250ZW50LnNpemU7XG4gIGNvbnN0IGRlZmx0ID0gJGZyb20uZGVwdGggPT09IDAgPyB2b2lkIDAgOiBkZWZhdWx0QmxvY2tBdCgkZnJvbS5ub2RlKC0xKS5jb250ZW50TWF0Y2hBdCgkZnJvbS5pbmRleEFmdGVyKC0xKSkpO1xuICBsZXQgdHlwZXMgPSBhdEVuZCAmJiBkZWZsdCA/IFtcbiAgICB7XG4gICAgICB0eXBlOiBkZWZsdCxcbiAgICAgIGF0dHJzOiBuZXdBdHRyaWJ1dGVzXG4gICAgfVxuICBdIDogdm9pZCAwO1xuICBsZXQgY2FuID0gY2FuU3BsaXQodHIuZG9jLCB0ci5tYXBwaW5nLm1hcCgkZnJvbS5wb3MpLCAxLCB0eXBlcyk7XG4gIGlmICghdHlwZXMgJiYgIWNhbiAmJiBjYW5TcGxpdCh0ci5kb2MsIHRyLm1hcHBpbmcubWFwKCRmcm9tLnBvcyksIDEsIGRlZmx0ID8gW3sgdHlwZTogZGVmbHQgfV0gOiB2b2lkIDApKSB7XG4gICAgY2FuID0gdHJ1ZTtcbiAgICB0eXBlcyA9IGRlZmx0ID8gW1xuICAgICAge1xuICAgICAgICB0eXBlOiBkZWZsdCxcbiAgICAgICAgYXR0cnM6IG5ld0F0dHJpYnV0ZXNcbiAgICAgIH1cbiAgICBdIDogdm9pZCAwO1xuICB9XG4gIGlmIChkaXNwYXRjaCkge1xuICAgIGlmIChjYW4pIHtcbiAgICAgIGlmIChzZWxlY3Rpb24gaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uNikge1xuICAgICAgICB0ci5kZWxldGVTZWxlY3Rpb24oKTtcbiAgICAgIH1cbiAgICAgIHRyLnNwbGl0KHRyLm1hcHBpbmcubWFwKCRmcm9tLnBvcyksIDEsIHR5cGVzKTtcbiAgICAgIGlmIChkZWZsdCAmJiAhYXRFbmQgJiYgISRmcm9tLnBhcmVudE9mZnNldCAmJiAkZnJvbS5wYXJlbnQudHlwZSAhPT0gZGVmbHQpIHtcbiAgICAgICAgY29uc3QgZmlyc3QyID0gdHIubWFwcGluZy5tYXAoJGZyb20uYmVmb3JlKCkpO1xuICAgICAgICBjb25zdCAkZmlyc3QgPSB0ci5kb2MucmVzb2x2ZShmaXJzdDIpO1xuICAgICAgICBpZiAoJGZyb20ubm9kZSgtMSkuY2FuUmVwbGFjZVdpdGgoJGZpcnN0LmluZGV4KCksICRmaXJzdC5pbmRleCgpICsgMSwgZGVmbHQpKSB7XG4gICAgICAgICAgdHIuc2V0Tm9kZU1hcmt1cCh0ci5tYXBwaW5nLm1hcCgkZnJvbS5iZWZvcmUoKSksIGRlZmx0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoa2VlcE1hcmtzKSB7XG4gICAgICBlbnN1cmVNYXJrcyhzdGF0ZSwgZWRpdG9yLmV4dGVuc2lvbk1hbmFnZXIuc3BsaXR0YWJsZU1hcmtzKTtcbiAgICB9XG4gICAgdHIuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgfVxuICByZXR1cm4gY2FuO1xufTtcblxuLy8gc3JjL2NvbW1hbmRzL3NwbGl0TGlzdEl0ZW0udHNcbmltcG9ydCB7IEZyYWdtZW50IGFzIEZyYWdtZW50MywgU2xpY2UgfSBmcm9tIFwiQHRpcHRhcC9wbS9tb2RlbFwiO1xuaW1wb3J0IHsgVGV4dFNlbGVjdGlvbiBhcyBUZXh0U2VsZWN0aW9uNyB9IGZyb20gXCJAdGlwdGFwL3BtL3N0YXRlXCI7XG5pbXBvcnQgeyBjYW5TcGxpdCBhcyBjYW5TcGxpdDIgfSBmcm9tIFwiQHRpcHRhcC9wbS90cmFuc2Zvcm1cIjtcbnZhciBzcGxpdExpc3RJdGVtID0gKHR5cGVPck5hbWUsIG92ZXJyaWRlQXR0cnMgPSB7fSkgPT4gKHsgdHIsIHN0YXRlLCBkaXNwYXRjaCwgZWRpdG9yIH0pID0+IHtcbiAgdmFyIF9hO1xuICBjb25zdCB0eXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgY29uc3QgeyAkZnJvbSwgJHRvIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gIGNvbnN0IG5vZGUgPSBzdGF0ZS5zZWxlY3Rpb24ubm9kZTtcbiAgaWYgKG5vZGUgJiYgbm9kZS5pc0Jsb2NrIHx8ICRmcm9tLmRlcHRoIDwgMiB8fCAhJGZyb20uc2FtZVBhcmVudCgkdG8pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGdyYW5kUGFyZW50ID0gJGZyb20ubm9kZSgtMSk7XG4gIGlmIChncmFuZFBhcmVudC50eXBlICE9PSB0eXBlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGV4dGVuc2lvbkF0dHJpYnV0ZXMgPSBlZGl0b3IuZXh0ZW5zaW9uTWFuYWdlci5hdHRyaWJ1dGVzO1xuICBpZiAoJGZyb20ucGFyZW50LmNvbnRlbnQuc2l6ZSA9PT0gMCAmJiAkZnJvbS5ub2RlKC0xKS5jaGlsZENvdW50ID09PSAkZnJvbS5pbmRleEFmdGVyKC0xKSkge1xuICAgIGlmICgkZnJvbS5kZXB0aCA9PT0gMiB8fCAkZnJvbS5ub2RlKC0zKS50eXBlICE9PSB0eXBlIHx8ICRmcm9tLmluZGV4KC0yKSAhPT0gJGZyb20ubm9kZSgtMikuY2hpbGRDb3VudCAtIDEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICBsZXQgd3JhcCA9IEZyYWdtZW50My5lbXB0eTtcbiAgICAgIGNvbnN0IGRlcHRoQmVmb3JlID0gJGZyb20uaW5kZXgoLTEpID8gMSA6ICRmcm9tLmluZGV4KC0yKSA/IDIgOiAzO1xuICAgICAgZm9yIChsZXQgZCA9ICRmcm9tLmRlcHRoIC0gZGVwdGhCZWZvcmU7IGQgPj0gJGZyb20uZGVwdGggLSAzOyBkIC09IDEpIHtcbiAgICAgICAgd3JhcCA9IEZyYWdtZW50My5mcm9tKCRmcm9tLm5vZGUoZCkuY29weSh3cmFwKSk7XG4gICAgICB9XG4gICAgICBjb25zdCBkZXB0aEFmdGVyID0gKFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcbiAgICAgICAgJGZyb20uaW5kZXhBZnRlcigtMSkgPCAkZnJvbS5ub2RlKC0yKS5jaGlsZENvdW50ID8gMSA6ICRmcm9tLmluZGV4QWZ0ZXIoLTIpIDwgJGZyb20ubm9kZSgtMykuY2hpbGRDb3VudCA/IDIgOiAzXG4gICAgICApO1xuICAgICAgY29uc3QgbmV3TmV4dFR5cGVBdHRyaWJ1dGVzMiA9IHtcbiAgICAgICAgLi4uZ2V0U3BsaXR0ZWRBdHRyaWJ1dGVzKGV4dGVuc2lvbkF0dHJpYnV0ZXMsICRmcm9tLm5vZGUoKS50eXBlLm5hbWUsICRmcm9tLm5vZGUoKS5hdHRycyksXG4gICAgICAgIC4uLm92ZXJyaWRlQXR0cnNcbiAgICAgIH07XG4gICAgICBjb25zdCBuZXh0VHlwZTIgPSAoKF9hID0gdHlwZS5jb250ZW50TWF0Y2guZGVmYXVsdFR5cGUpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jcmVhdGVBbmRGaWxsKG5ld05leHRUeXBlQXR0cmlidXRlczIpKSB8fCB2b2lkIDA7XG4gICAgICB3cmFwID0gd3JhcC5hcHBlbmQoRnJhZ21lbnQzLmZyb20odHlwZS5jcmVhdGVBbmRGaWxsKG51bGwsIG5leHRUeXBlMikgfHwgdm9pZCAwKSk7XG4gICAgICBjb25zdCBzdGFydCA9ICRmcm9tLmJlZm9yZSgkZnJvbS5kZXB0aCAtIChkZXB0aEJlZm9yZSAtIDEpKTtcbiAgICAgIHRyLnJlcGxhY2Uoc3RhcnQsICRmcm9tLmFmdGVyKC1kZXB0aEFmdGVyKSwgbmV3IFNsaWNlKHdyYXAsIDQgLSBkZXB0aEJlZm9yZSwgMCkpO1xuICAgICAgbGV0IHNlbCA9IC0xO1xuICAgICAgdHIuZG9jLm5vZGVzQmV0d2VlbihzdGFydCwgdHIuZG9jLmNvbnRlbnQuc2l6ZSwgKG4sIHBvcykgPT4ge1xuICAgICAgICBpZiAoc2VsID4gLTEpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG4uaXNUZXh0YmxvY2sgJiYgbi5jb250ZW50LnNpemUgPT09IDApIHtcbiAgICAgICAgICBzZWwgPSBwb3MgKyAxO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChzZWwgPiAtMSkge1xuICAgICAgICB0ci5zZXRTZWxlY3Rpb24oVGV4dFNlbGVjdGlvbjcubmVhcih0ci5kb2MucmVzb2x2ZShzZWwpKSk7XG4gICAgICB9XG4gICAgICB0ci5zY3JvbGxJbnRvVmlldygpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBuZXh0VHlwZSA9ICR0by5wb3MgPT09ICRmcm9tLmVuZCgpID8gZ3JhbmRQYXJlbnQuY29udGVudE1hdGNoQXQoMCkuZGVmYXVsdFR5cGUgOiBudWxsO1xuICBjb25zdCBuZXdUeXBlQXR0cmlidXRlcyA9IHtcbiAgICAuLi5nZXRTcGxpdHRlZEF0dHJpYnV0ZXMoZXh0ZW5zaW9uQXR0cmlidXRlcywgZ3JhbmRQYXJlbnQudHlwZS5uYW1lLCBncmFuZFBhcmVudC5hdHRycyksXG4gICAgLi4ub3ZlcnJpZGVBdHRyc1xuICB9O1xuICBjb25zdCBuZXdOZXh0VHlwZUF0dHJpYnV0ZXMgPSB7XG4gICAgLi4uZ2V0U3BsaXR0ZWRBdHRyaWJ1dGVzKGV4dGVuc2lvbkF0dHJpYnV0ZXMsICRmcm9tLm5vZGUoKS50eXBlLm5hbWUsICRmcm9tLm5vZGUoKS5hdHRycyksXG4gICAgLi4ub3ZlcnJpZGVBdHRyc1xuICB9O1xuICB0ci5kZWxldGUoJGZyb20ucG9zLCAkdG8ucG9zKTtcbiAgY29uc3QgdHlwZXMgPSBuZXh0VHlwZSA/IFtcbiAgICB7IHR5cGUsIGF0dHJzOiBuZXdUeXBlQXR0cmlidXRlcyB9LFxuICAgIHsgdHlwZTogbmV4dFR5cGUsIGF0dHJzOiBuZXdOZXh0VHlwZUF0dHJpYnV0ZXMgfVxuICBdIDogW3sgdHlwZSwgYXR0cnM6IG5ld1R5cGVBdHRyaWJ1dGVzIH1dO1xuICBpZiAoIWNhblNwbGl0Mih0ci5kb2MsICRmcm9tLnBvcywgMikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGRpc3BhdGNoKSB7XG4gICAgY29uc3QgeyBzZWxlY3Rpb24sIHN0b3JlZE1hcmtzIH0gPSBzdGF0ZTtcbiAgICBjb25zdCB7IHNwbGl0dGFibGVNYXJrcyB9ID0gZWRpdG9yLmV4dGVuc2lvbk1hbmFnZXI7XG4gICAgY29uc3QgbWFya3MgPSBzdG9yZWRNYXJrcyB8fCBzZWxlY3Rpb24uJHRvLnBhcmVudE9mZnNldCAmJiBzZWxlY3Rpb24uJGZyb20ubWFya3MoKTtcbiAgICB0ci5zcGxpdCgkZnJvbS5wb3MsIDIsIHR5cGVzKS5zY3JvbGxJbnRvVmlldygpO1xuICAgIGlmICghbWFya3MgfHwgIWRpc3BhdGNoKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgZmlsdGVyZWRNYXJrcyA9IG1hcmtzLmZpbHRlcigobWFyaykgPT4gc3BsaXR0YWJsZU1hcmtzLmluY2x1ZGVzKG1hcmsudHlwZS5uYW1lKSk7XG4gICAgdHIuZW5zdXJlTWFya3MoZmlsdGVyZWRNYXJrcyk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vLyBzcmMvY29tbWFuZHMvdG9nZ2xlTGlzdC50c1xuaW1wb3J0IHsgY2FuSm9pbiB9IGZyb20gXCJAdGlwdGFwL3BtL3RyYW5zZm9ybVwiO1xudmFyIGpvaW5MaXN0QmFja3dhcmRzID0gKHRyLCBsaXN0VHlwZSkgPT4ge1xuICBjb25zdCBsaXN0ID0gZmluZFBhcmVudE5vZGUoKG5vZGUpID0+IG5vZGUudHlwZSA9PT0gbGlzdFR5cGUpKHRyLnNlbGVjdGlvbik7XG4gIGlmICghbGlzdCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IGJlZm9yZSA9IHRyLmRvYy5yZXNvbHZlKE1hdGgubWF4KDAsIGxpc3QucG9zIC0gMSkpLmJlZm9yZShsaXN0LmRlcHRoKTtcbiAgaWYgKGJlZm9yZSA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3Qgbm9kZUJlZm9yZSA9IHRyLmRvYy5ub2RlQXQoYmVmb3JlKTtcbiAgY29uc3QgY2FuSm9pbkJhY2t3YXJkcyA9IGxpc3Qubm9kZS50eXBlID09PSAobm9kZUJlZm9yZSA9PSBudWxsID8gdm9pZCAwIDogbm9kZUJlZm9yZS50eXBlKSAmJiBjYW5Kb2luKHRyLmRvYywgbGlzdC5wb3MpO1xuICBpZiAoIWNhbkpvaW5CYWNrd2FyZHMpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB0ci5qb2luKGxpc3QucG9zKTtcbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIGpvaW5MaXN0Rm9yd2FyZHMgPSAodHIsIGxpc3RUeXBlKSA9PiB7XG4gIGNvbnN0IGxpc3QgPSBmaW5kUGFyZW50Tm9kZSgobm9kZSkgPT4gbm9kZS50eXBlID09PSBsaXN0VHlwZSkodHIuc2VsZWN0aW9uKTtcbiAgaWYgKCFsaXN0KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgYWZ0ZXIgPSB0ci5kb2MucmVzb2x2ZShsaXN0LnN0YXJ0KS5hZnRlcihsaXN0LmRlcHRoKTtcbiAgaWYgKGFmdGVyID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBub2RlQWZ0ZXIgPSB0ci5kb2Mubm9kZUF0KGFmdGVyKTtcbiAgY29uc3QgY2FuSm9pbkZvcndhcmRzID0gbGlzdC5ub2RlLnR5cGUgPT09IChub2RlQWZ0ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IG5vZGVBZnRlci50eXBlKSAmJiBjYW5Kb2luKHRyLmRvYywgYWZ0ZXIpO1xuICBpZiAoIWNhbkpvaW5Gb3J3YXJkcykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHRyLmpvaW4oYWZ0ZXIpO1xuICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgdG9nZ2xlTGlzdCA9IChsaXN0VHlwZU9yTmFtZSwgaXRlbVR5cGVPck5hbWUsIGtlZXBNYXJrcywgYXR0cmlidXRlcyA9IHt9KSA9PiAoeyBlZGl0b3IsIHRyLCBzdGF0ZSwgZGlzcGF0Y2gsIGNoYWluLCBjb21tYW5kcywgY2FuIH0pID0+IHtcbiAgY29uc3QgeyBleHRlbnNpb25zLCBzcGxpdHRhYmxlTWFya3MgfSA9IGVkaXRvci5leHRlbnNpb25NYW5hZ2VyO1xuICBjb25zdCBsaXN0VHlwZSA9IGdldE5vZGVUeXBlKGxpc3RUeXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xuICBjb25zdCBpdGVtVHlwZSA9IGdldE5vZGVUeXBlKGl0ZW1UeXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xuICBjb25zdCB7IHNlbGVjdGlvbiwgc3RvcmVkTWFya3MgfSA9IHN0YXRlO1xuICBjb25zdCB7ICRmcm9tLCAkdG8gfSA9IHNlbGVjdGlvbjtcbiAgY29uc3QgcmFuZ2UgPSAkZnJvbS5ibG9ja1JhbmdlKCR0byk7XG4gIGNvbnN0IG1hcmtzID0gc3RvcmVkTWFya3MgfHwgc2VsZWN0aW9uLiR0by5wYXJlbnRPZmZzZXQgJiYgc2VsZWN0aW9uLiRmcm9tLm1hcmtzKCk7XG4gIGlmICghcmFuZ2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgcGFyZW50TGlzdCA9IGZpbmRQYXJlbnROb2RlKChub2RlKSA9PiBpc0xpc3Qobm9kZS50eXBlLm5hbWUsIGV4dGVuc2lvbnMpKShzZWxlY3Rpb24pO1xuICBpZiAocmFuZ2UuZGVwdGggPj0gMSAmJiBwYXJlbnRMaXN0ICYmIHJhbmdlLmRlcHRoIC0gcGFyZW50TGlzdC5kZXB0aCA8PSAxKSB7XG4gICAgaWYgKHBhcmVudExpc3Qubm9kZS50eXBlID09PSBsaXN0VHlwZSkge1xuICAgICAgcmV0dXJuIGNvbW1hbmRzLmxpZnRMaXN0SXRlbShpdGVtVHlwZSk7XG4gICAgfVxuICAgIGlmIChpc0xpc3QocGFyZW50TGlzdC5ub2RlLnR5cGUubmFtZSwgZXh0ZW5zaW9ucykgJiYgbGlzdFR5cGUudmFsaWRDb250ZW50KHBhcmVudExpc3Qubm9kZS5jb250ZW50KSAmJiBkaXNwYXRjaCkge1xuICAgICAgcmV0dXJuIGNoYWluKCkuY29tbWFuZCgoKSA9PiB7XG4gICAgICAgIHRyLnNldE5vZGVNYXJrdXAocGFyZW50TGlzdC5wb3MsIGxpc3RUeXBlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9KS5jb21tYW5kKCgpID0+IGpvaW5MaXN0QmFja3dhcmRzKHRyLCBsaXN0VHlwZSkpLmNvbW1hbmQoKCkgPT4gam9pbkxpc3RGb3J3YXJkcyh0ciwgbGlzdFR5cGUpKS5ydW4oKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFrZWVwTWFya3MgfHwgIW1hcmtzIHx8ICFkaXNwYXRjaCkge1xuICAgIHJldHVybiBjaGFpbigpLmNvbW1hbmQoKCkgPT4ge1xuICAgICAgY29uc3QgY2FuV3JhcEluTGlzdCA9IGNhbigpLndyYXBJbkxpc3QobGlzdFR5cGUsIGF0dHJpYnV0ZXMpO1xuICAgICAgaWYgKGNhbldyYXBJbkxpc3QpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29tbWFuZHMuY2xlYXJOb2RlcygpO1xuICAgIH0pLndyYXBJbkxpc3QobGlzdFR5cGUsIGF0dHJpYnV0ZXMpLmNvbW1hbmQoKCkgPT4gam9pbkxpc3RCYWNrd2FyZHModHIsIGxpc3RUeXBlKSkuY29tbWFuZCgoKSA9PiBqb2luTGlzdEZvcndhcmRzKHRyLCBsaXN0VHlwZSkpLnJ1bigpO1xuICB9XG4gIHJldHVybiBjaGFpbigpLmNvbW1hbmQoKCkgPT4ge1xuICAgIGNvbnN0IGNhbldyYXBJbkxpc3QgPSBjYW4oKS53cmFwSW5MaXN0KGxpc3RUeXBlLCBhdHRyaWJ1dGVzKTtcbiAgICBjb25zdCBmaWx0ZXJlZE1hcmtzID0gbWFya3MuZmlsdGVyKChtYXJrKSA9PiBzcGxpdHRhYmxlTWFya3MuaW5jbHVkZXMobWFyay50eXBlLm5hbWUpKTtcbiAgICB0ci5lbnN1cmVNYXJrcyhmaWx0ZXJlZE1hcmtzKTtcbiAgICBpZiAoY2FuV3JhcEluTGlzdCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBjb21tYW5kcy5jbGVhck5vZGVzKCk7XG4gIH0pLndyYXBJbkxpc3QobGlzdFR5cGUsIGF0dHJpYnV0ZXMpLmNvbW1hbmQoKCkgPT4gam9pbkxpc3RCYWNrd2FyZHModHIsIGxpc3RUeXBlKSkuY29tbWFuZCgoKSA9PiBqb2luTGlzdEZvcndhcmRzKHRyLCBsaXN0VHlwZSkpLnJ1bigpO1xufTtcblxuLy8gc3JjL2NvbW1hbmRzL3RvZ2dsZU1hcmsudHNcbnZhciB0b2dnbGVNYXJrID0gKHR5cGVPck5hbWUsIGF0dHJpYnV0ZXMgPSB7fSwgb3B0aW9ucyA9IHt9KSA9PiAoeyBzdGF0ZSwgY29tbWFuZHMgfSkgPT4ge1xuICBjb25zdCB7IGV4dGVuZEVtcHR5TWFya1JhbmdlID0gZmFsc2UgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHR5cGUgPSBnZXRNYXJrVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xuICBjb25zdCBpc0FjdGl2ZTIgPSBpc01hcmtBY3RpdmUoc3RhdGUsIHR5cGUsIGF0dHJpYnV0ZXMpO1xuICBpZiAoaXNBY3RpdmUyKSB7XG4gICAgcmV0dXJuIGNvbW1hbmRzLnVuc2V0TWFyayh0eXBlLCB7IGV4dGVuZEVtcHR5TWFya1JhbmdlIH0pO1xuICB9XG4gIHJldHVybiBjb21tYW5kcy5zZXRNYXJrKHR5cGUsIGF0dHJpYnV0ZXMpO1xufTtcblxuLy8gc3JjL2NvbW1hbmRzL3RvZ2dsZU5vZGUudHNcbnZhciB0b2dnbGVOb2RlID0gKHR5cGVPck5hbWUsIHRvZ2dsZVR5cGVPck5hbWUsIGF0dHJpYnV0ZXMgPSB7fSkgPT4gKHsgc3RhdGUsIGNvbW1hbmRzIH0pID0+IHtcbiAgY29uc3QgdHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XG4gIGNvbnN0IHRvZ2dsZVR5cGUgPSBnZXROb2RlVHlwZSh0b2dnbGVUeXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xuICBjb25zdCBpc0FjdGl2ZTIgPSBpc05vZGVBY3RpdmUoc3RhdGUsIHR5cGUsIGF0dHJpYnV0ZXMpO1xuICBsZXQgYXR0cmlidXRlc1RvQ29weTtcbiAgaWYgKHN0YXRlLnNlbGVjdGlvbi4kYW5jaG9yLnNhbWVQYXJlbnQoc3RhdGUuc2VsZWN0aW9uLiRoZWFkKSkge1xuICAgIGF0dHJpYnV0ZXNUb0NvcHkgPSBzdGF0ZS5zZWxlY3Rpb24uJGFuY2hvci5wYXJlbnQuYXR0cnM7XG4gIH1cbiAgaWYgKGlzQWN0aXZlMikge1xuICAgIHJldHVybiBjb21tYW5kcy5zZXROb2RlKHRvZ2dsZVR5cGUsIGF0dHJpYnV0ZXNUb0NvcHkpO1xuICB9XG4gIHJldHVybiBjb21tYW5kcy5zZXROb2RlKHR5cGUsIHsgLi4uYXR0cmlidXRlc1RvQ29weSwgLi4uYXR0cmlidXRlcyB9KTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy90b2dnbGVXcmFwLnRzXG52YXIgdG9nZ2xlV3JhcCA9ICh0eXBlT3JOYW1lLCBhdHRyaWJ1dGVzID0ge30pID0+ICh7IHN0YXRlLCBjb21tYW5kcyB9KSA9PiB7XG4gIGNvbnN0IHR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xuICBjb25zdCBpc0FjdGl2ZTIgPSBpc05vZGVBY3RpdmUoc3RhdGUsIHR5cGUsIGF0dHJpYnV0ZXMpO1xuICBpZiAoaXNBY3RpdmUyKSB7XG4gICAgcmV0dXJuIGNvbW1hbmRzLmxpZnQodHlwZSk7XG4gIH1cbiAgcmV0dXJuIGNvbW1hbmRzLndyYXBJbih0eXBlLCBhdHRyaWJ1dGVzKTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy91bmRvSW5wdXRSdWxlLnRzXG52YXIgdW5kb0lucHV0UnVsZSA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGNvbnN0IHBsdWdpbnMgPSBzdGF0ZS5wbHVnaW5zO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBsdWdpbnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBjb25zdCBwbHVnaW4gPSBwbHVnaW5zW2ldO1xuICAgIGxldCB1bmRvYWJsZTtcbiAgICBpZiAocGx1Z2luLnNwZWMuaXNJbnB1dFJ1bGVzICYmICh1bmRvYWJsZSA9IHBsdWdpbi5nZXRTdGF0ZShzdGF0ZSkpKSB7XG4gICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgY29uc3QgdHIgPSBzdGF0ZS50cjtcbiAgICAgICAgY29uc3QgdG9VbmRvID0gdW5kb2FibGUudHJhbnNmb3JtO1xuICAgICAgICBmb3IgKGxldCBqID0gdG9VbmRvLnN0ZXBzLmxlbmd0aCAtIDE7IGogPj0gMDsgaiAtPSAxKSB7XG4gICAgICAgICAgdHIuc3RlcCh0b1VuZG8uc3RlcHNbal0uaW52ZXJ0KHRvVW5kby5kb2NzW2pdKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVuZG9hYmxlLnRleHQpIHtcbiAgICAgICAgICBjb25zdCBtYXJrcyA9IHRyLmRvYy5yZXNvbHZlKHVuZG9hYmxlLmZyb20pLm1hcmtzKCk7XG4gICAgICAgICAgdHIucmVwbGFjZVdpdGgodW5kb2FibGUuZnJvbSwgdW5kb2FibGUudG8sIHN0YXRlLnNjaGVtYS50ZXh0KHVuZG9hYmxlLnRleHQsIG1hcmtzKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHIuZGVsZXRlKHVuZG9hYmxlLmZyb20sIHVuZG9hYmxlLnRvKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy91bnNldEFsbE1hcmtzLnRzXG52YXIgdW5zZXRBbGxNYXJrcyA9ICgpID0+ICh7IHRyLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSB0cjtcbiAgY29uc3QgeyBlbXB0eSwgcmFuZ2VzIH0gPSBzZWxlY3Rpb247XG4gIGlmIChlbXB0eSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChkaXNwYXRjaCkge1xuICAgIHJhbmdlcy5mb3JFYWNoKChyYW5nZSkgPT4ge1xuICAgICAgdHIucmVtb3ZlTWFyayhyYW5nZS4kZnJvbS5wb3MsIHJhbmdlLiR0by5wb3MpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuLy8gc3JjL2NvbW1hbmRzL3Vuc2V0TWFyay50c1xudmFyIHVuc2V0TWFyayA9ICh0eXBlT3JOYW1lLCBvcHRpb25zID0ge30pID0+ICh7IHRyLCBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICB2YXIgX2E7XG4gIGNvbnN0IHsgZXh0ZW5kRW1wdHlNYXJrUmFuZ2UgPSBmYWxzZSB9ID0gb3B0aW9ucztcbiAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHRyO1xuICBjb25zdCB0eXBlID0gZ2V0TWFya1R5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgY29uc3QgeyAkZnJvbSwgZW1wdHksIHJhbmdlcyB9ID0gc2VsZWN0aW9uO1xuICBpZiAoIWRpc3BhdGNoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGVtcHR5ICYmIGV4dGVuZEVtcHR5TWFya1JhbmdlKSB7XG4gICAgbGV0IHsgZnJvbSwgdG8gfSA9IHNlbGVjdGlvbjtcbiAgICBjb25zdCBhdHRycyA9IChfYSA9ICRmcm9tLm1hcmtzKCkuZmluZCgobWFyaykgPT4gbWFyay50eXBlID09PSB0eXBlKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmF0dHJzO1xuICAgIGNvbnN0IHJhbmdlID0gZ2V0TWFya1JhbmdlKCRmcm9tLCB0eXBlLCBhdHRycyk7XG4gICAgaWYgKHJhbmdlKSB7XG4gICAgICBmcm9tID0gcmFuZ2UuZnJvbTtcbiAgICAgIHRvID0gcmFuZ2UudG87XG4gICAgfVxuICAgIHRyLnJlbW92ZU1hcmsoZnJvbSwgdG8sIHR5cGUpO1xuICB9IGVsc2Uge1xuICAgIHJhbmdlcy5mb3JFYWNoKChyYW5nZSkgPT4ge1xuICAgICAgdHIucmVtb3ZlTWFyayhyYW5nZS4kZnJvbS5wb3MsIHJhbmdlLiR0by5wb3MsIHR5cGUpO1xuICAgIH0pO1xuICB9XG4gIHRyLnJlbW92ZVN0b3JlZE1hcmsodHlwZSk7XG4gIHJldHVybiB0cnVlO1xufTtcblxuLy8gc3JjL2NvbW1hbmRzL3Vuc2V0VGV4dERpcmVjdGlvbi50c1xudmFyIHVuc2V0VGV4dERpcmVjdGlvbiA9IChwb3NpdGlvbikgPT4gKHsgdHIsIHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSBzdGF0ZTtcbiAgbGV0IGZyb207XG4gIGxldCB0bztcbiAgaWYgKHR5cGVvZiBwb3NpdGlvbiA9PT0gXCJudW1iZXJcIikge1xuICAgIGZyb20gPSBwb3NpdGlvbjtcbiAgICB0byA9IHBvc2l0aW9uO1xuICB9IGVsc2UgaWYgKHBvc2l0aW9uICYmIFwiZnJvbVwiIGluIHBvc2l0aW9uICYmIFwidG9cIiBpbiBwb3NpdGlvbikge1xuICAgIGZyb20gPSBwb3NpdGlvbi5mcm9tO1xuICAgIHRvID0gcG9zaXRpb24udG87XG4gIH0gZWxzZSB7XG4gICAgZnJvbSA9IHNlbGVjdGlvbi5mcm9tO1xuICAgIHRvID0gc2VsZWN0aW9uLnRvO1xuICB9XG4gIGlmIChkaXNwYXRjaCkge1xuICAgIHRyLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MpID0+IHtcbiAgICAgIGlmIChub2RlLmlzVGV4dCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBuZXdBdHRycyA9IHsgLi4ubm9kZS5hdHRycyB9O1xuICAgICAgZGVsZXRlIG5ld0F0dHJzLmRpcjtcbiAgICAgIHRyLnNldE5vZGVNYXJrdXAocG9zLCB2b2lkIDAsIG5ld0F0dHJzKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy91cGRhdGVBdHRyaWJ1dGVzLnRzXG52YXIgdXBkYXRlQXR0cmlidXRlcyA9ICh0eXBlT3JOYW1lLCBhdHRyaWJ1dGVzID0ge30pID0+ICh7IHRyLCBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICBsZXQgbm9kZVR5cGUgPSBudWxsO1xuICBsZXQgbWFya1R5cGUgPSBudWxsO1xuICBjb25zdCBzY2hlbWFUeXBlID0gZ2V0U2NoZW1hVHlwZU5hbWVCeU5hbWUoXG4gICAgdHlwZW9mIHR5cGVPck5hbWUgPT09IFwic3RyaW5nXCIgPyB0eXBlT3JOYW1lIDogdHlwZU9yTmFtZS5uYW1lLFxuICAgIHN0YXRlLnNjaGVtYVxuICApO1xuICBpZiAoIXNjaGVtYVR5cGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHNjaGVtYVR5cGUgPT09IFwibm9kZVwiKSB7XG4gICAgbm9kZVR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xuICB9XG4gIGlmIChzY2hlbWFUeXBlID09PSBcIm1hcmtcIikge1xuICAgIG1hcmtUeXBlID0gZ2V0TWFya1R5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgfVxuICBsZXQgY2FuVXBkYXRlID0gZmFsc2U7XG4gIHRyLnNlbGVjdGlvbi5yYW5nZXMuZm9yRWFjaCgocmFuZ2UpID0+IHtcbiAgICBjb25zdCBmcm9tID0gcmFuZ2UuJGZyb20ucG9zO1xuICAgIGNvbnN0IHRvID0gcmFuZ2UuJHRvLnBvcztcbiAgICBsZXQgbGFzdFBvcztcbiAgICBsZXQgbGFzdE5vZGU7XG4gICAgbGV0IHRyaW1tZWRGcm9tO1xuICAgIGxldCB0cmltbWVkVG87XG4gICAgaWYgKHRyLnNlbGVjdGlvbi5lbXB0eSkge1xuICAgICAgc3RhdGUuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUsIHBvcykgPT4ge1xuICAgICAgICBpZiAobm9kZVR5cGUgJiYgbm9kZVR5cGUgPT09IG5vZGUudHlwZSkge1xuICAgICAgICAgIGNhblVwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgdHJpbW1lZEZyb20gPSBNYXRoLm1heChwb3MsIGZyb20pO1xuICAgICAgICAgIHRyaW1tZWRUbyA9IE1hdGgubWluKHBvcyArIG5vZGUubm9kZVNpemUsIHRvKTtcbiAgICAgICAgICBsYXN0UG9zID0gcG9zO1xuICAgICAgICAgIGxhc3ROb2RlID0gbm9kZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MpID0+IHtcbiAgICAgICAgaWYgKHBvcyA8IGZyb20gJiYgbm9kZVR5cGUgJiYgbm9kZVR5cGUgPT09IG5vZGUudHlwZSkge1xuICAgICAgICAgIGNhblVwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgdHJpbW1lZEZyb20gPSBNYXRoLm1heChwb3MsIGZyb20pO1xuICAgICAgICAgIHRyaW1tZWRUbyA9IE1hdGgubWluKHBvcyArIG5vZGUubm9kZVNpemUsIHRvKTtcbiAgICAgICAgICBsYXN0UG9zID0gcG9zO1xuICAgICAgICAgIGxhc3ROb2RlID0gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zID49IGZyb20gJiYgcG9zIDw9IHRvKSB7XG4gICAgICAgICAgaWYgKG5vZGVUeXBlICYmIG5vZGVUeXBlID09PSBub2RlLnR5cGUpIHtcbiAgICAgICAgICAgIGNhblVwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgICAgdHIuc2V0Tm9kZU1hcmt1cChwb3MsIHZvaWQgMCwge1xuICAgICAgICAgICAgICAgIC4uLm5vZGUuYXR0cnMsXG4gICAgICAgICAgICAgICAgLi4uYXR0cmlidXRlc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1hcmtUeXBlICYmIG5vZGUubWFya3MubGVuZ3RoKSB7XG4gICAgICAgICAgICBub2RlLm1hcmtzLmZvckVhY2goKG1hcmspID0+IHtcbiAgICAgICAgICAgICAgaWYgKG1hcmtUeXBlID09PSBtYXJrLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYW5VcGRhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgdHJpbW1lZEZyb20yID0gTWF0aC5tYXgocG9zLCBmcm9tKTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHRyaW1tZWRUbzIgPSBNYXRoLm1pbihwb3MgKyBub2RlLm5vZGVTaXplLCB0byk7XG4gICAgICAgICAgICAgICAgICB0ci5hZGRNYXJrKFxuICAgICAgICAgICAgICAgICAgICB0cmltbWVkRnJvbTIsXG4gICAgICAgICAgICAgICAgICAgIHRyaW1tZWRUbzIsXG4gICAgICAgICAgICAgICAgICAgIG1hcmtUeXBlLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgLi4ubWFyay5hdHRycyxcbiAgICAgICAgICAgICAgICAgICAgICAuLi5hdHRyaWJ1dGVzXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGxhc3ROb2RlKSB7XG4gICAgICBpZiAobGFzdFBvcyAhPT0gdm9pZCAwICYmIGRpc3BhdGNoKSB7XG4gICAgICAgIHRyLnNldE5vZGVNYXJrdXAobGFzdFBvcywgdm9pZCAwLCB7XG4gICAgICAgICAgLi4ubGFzdE5vZGUuYXR0cnMsXG4gICAgICAgICAgLi4uYXR0cmlidXRlc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXJrVHlwZSAmJiBsYXN0Tm9kZS5tYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgbGFzdE5vZGUubWFya3MuZm9yRWFjaCgobWFyaykgPT4ge1xuICAgICAgICAgIGlmIChtYXJrVHlwZSA9PT0gbWFyay50eXBlICYmIGRpc3BhdGNoKSB7XG4gICAgICAgICAgICB0ci5hZGRNYXJrKFxuICAgICAgICAgICAgICB0cmltbWVkRnJvbSxcbiAgICAgICAgICAgICAgdHJpbW1lZFRvLFxuICAgICAgICAgICAgICBtYXJrVHlwZS5jcmVhdGUoe1xuICAgICAgICAgICAgICAgIC4uLm1hcmsuYXR0cnMsXG4gICAgICAgICAgICAgICAgLi4uYXR0cmlidXRlc1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBjYW5VcGRhdGU7XG59O1xuXG4vLyBzcmMvY29tbWFuZHMvd3JhcEluLnRzXG5pbXBvcnQgeyB3cmFwSW4gYXMgb3JpZ2luYWxXcmFwSW4gfSBmcm9tIFwiQHRpcHRhcC9wbS9jb21tYW5kc1wiO1xudmFyIHdyYXBJbiA9ICh0eXBlT3JOYW1lLCBhdHRyaWJ1dGVzID0ge30pID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGNvbnN0IHR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xuICByZXR1cm4gb3JpZ2luYWxXcmFwSW4odHlwZSwgYXR0cmlidXRlcykoc3RhdGUsIGRpc3BhdGNoKTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy93cmFwSW5MaXN0LnRzXG5pbXBvcnQgeyB3cmFwSW5MaXN0IGFzIG9yaWdpbmFsV3JhcEluTGlzdCB9IGZyb20gXCJAdGlwdGFwL3BtL3NjaGVtYS1saXN0XCI7XG52YXIgd3JhcEluTGlzdCA9ICh0eXBlT3JOYW1lLCBhdHRyaWJ1dGVzID0ge30pID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGNvbnN0IHR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xuICByZXR1cm4gb3JpZ2luYWxXcmFwSW5MaXN0KHR5cGUsIGF0dHJpYnV0ZXMpKHN0YXRlLCBkaXNwYXRjaCk7XG59O1xuXG4vLyBzcmMvRWRpdG9yLnRzXG5pbXBvcnQgeyBFZGl0b3JTdGF0ZSB9IGZyb20gXCJAdGlwdGFwL3BtL3N0YXRlXCI7XG5pbXBvcnQgeyBFZGl0b3JWaWV3IH0gZnJvbSBcIkB0aXB0YXAvcG0vdmlld1wiO1xuXG4vLyBzcmMvRXZlbnRFbWl0dGVyLnRzXG52YXIgRXZlbnRFbWl0dGVyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmNhbGxiYWNrcyA9IHt9O1xuICB9XG4gIG9uKGV2ZW50LCBmbikge1xuICAgIGlmICghdGhpcy5jYWxsYmFja3NbZXZlbnRdKSB7XG4gICAgICB0aGlzLmNhbGxiYWNrc1tldmVudF0gPSBbXTtcbiAgICB9XG4gICAgdGhpcy5jYWxsYmFja3NbZXZlbnRdLnB1c2goZm4pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGVtaXQoZXZlbnQsIC4uLmFyZ3MpIHtcbiAgICBjb25zdCBjYWxsYmFja3MgPSB0aGlzLmNhbGxiYWNrc1tldmVudF07XG4gICAgaWYgKGNhbGxiYWNrcykge1xuICAgICAgY2FsbGJhY2tzLmZvckVhY2goKGNhbGxiYWNrKSA9PiBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmdzKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIG9mZihldmVudCwgZm4pIHtcbiAgICBjb25zdCBjYWxsYmFja3MgPSB0aGlzLmNhbGxiYWNrc1tldmVudF07XG4gICAgaWYgKGNhbGxiYWNrcykge1xuICAgICAgaWYgKGZuKSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzW2V2ZW50XSA9IGNhbGxiYWNrcy5maWx0ZXIoKGNhbGxiYWNrKSA9PiBjYWxsYmFjayAhPT0gZm4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuY2FsbGJhY2tzW2V2ZW50XTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgb25jZShldmVudCwgZm4pIHtcbiAgICBjb25zdCBvbmNlRm4gPSAoLi4uYXJncykgPT4ge1xuICAgICAgdGhpcy5vZmYoZXZlbnQsIG9uY2VGbik7XG4gICAgICBmbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLm9uKGV2ZW50LCBvbmNlRm4pO1xuICB9XG4gIHJlbW92ZUFsbExpc3RlbmVycygpIHtcbiAgICB0aGlzLmNhbGxiYWNrcyA9IHt9O1xuICB9XG59O1xuXG4vLyBzcmMvRXh0ZW5zaW9uTWFuYWdlci50c1xuaW1wb3J0IHsga2V5bWFwIH0gZnJvbSBcIkB0aXB0YXAvcG0va2V5bWFwXCI7XG5cbi8vIHNyYy9JbnB1dFJ1bGUudHNcbmltcG9ydCB7IEZyYWdtZW50IGFzIEZyYWdtZW50NCB9IGZyb20gXCJAdGlwdGFwL3BtL21vZGVsXCI7XG5pbXBvcnQgeyBQbHVnaW4gfSBmcm9tIFwiQHRpcHRhcC9wbS9zdGF0ZVwiO1xudmFyIElucHV0UnVsZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgdmFyIF9hO1xuICAgIHRoaXMuZmluZCA9IGNvbmZpZy5maW5kO1xuICAgIHRoaXMuaGFuZGxlciA9IGNvbmZpZy5oYW5kbGVyO1xuICAgIHRoaXMudW5kb2FibGUgPSAoX2EgPSBjb25maWcudW5kb2FibGUpICE9IG51bGwgPyBfYSA6IHRydWU7XG4gIH1cbn07XG52YXIgaW5wdXRSdWxlTWF0Y2hlckhhbmRsZXIgPSAodGV4dCwgZmluZCkgPT4ge1xuICBpZiAoaXNSZWdFeHAoZmluZCkpIHtcbiAgICByZXR1cm4gZmluZC5leGVjKHRleHQpO1xuICB9XG4gIGNvbnN0IGlucHV0UnVsZU1hdGNoID0gZmluZCh0ZXh0KTtcbiAgaWYgKCFpbnB1dFJ1bGVNYXRjaCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IFtpbnB1dFJ1bGVNYXRjaC50ZXh0XTtcbiAgcmVzdWx0LmluZGV4ID0gaW5wdXRSdWxlTWF0Y2guaW5kZXg7XG4gIHJlc3VsdC5pbnB1dCA9IHRleHQ7XG4gIHJlc3VsdC5kYXRhID0gaW5wdXRSdWxlTWF0Y2guZGF0YTtcbiAgaWYgKGlucHV0UnVsZU1hdGNoLnJlcGxhY2VXaXRoKSB7XG4gICAgaWYgKCFpbnB1dFJ1bGVNYXRjaC50ZXh0LmluY2x1ZGVzKGlucHV0UnVsZU1hdGNoLnJlcGxhY2VXaXRoKSkge1xuICAgICAgY29uc29sZS53YXJuKCdbdGlwdGFwIHdhcm5dOiBcImlucHV0UnVsZU1hdGNoLnJlcGxhY2VXaXRoXCIgbXVzdCBiZSBwYXJ0IG9mIFwiaW5wdXRSdWxlTWF0Y2gudGV4dFwiLicpO1xuICAgIH1cbiAgICByZXN1bHQucHVzaChpbnB1dFJ1bGVNYXRjaC5yZXBsYWNlV2l0aCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5mdW5jdGlvbiBydW4oY29uZmlnKSB7XG4gIHZhciBfYTtcbiAgY29uc3QgeyBlZGl0b3IsIGZyb20sIHRvLCB0ZXh0LCBydWxlcywgcGx1Z2luIH0gPSBjb25maWc7XG4gIGNvbnN0IHsgdmlldyB9ID0gZWRpdG9yO1xuICBpZiAodmlldy5jb21wb3NpbmcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgJGZyb20gPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKGZyb20pO1xuICBpZiAoXG4gICAgLy8gY2hlY2sgZm9yIGNvZGUgbm9kZVxuICAgICRmcm9tLnBhcmVudC50eXBlLnNwZWMuY29kZSB8fCAvLyBjaGVjayBmb3IgY29kZSBtYXJrXG4gICAgISEoKF9hID0gJGZyb20ubm9kZUJlZm9yZSB8fCAkZnJvbS5ub2RlQWZ0ZXIpID09IG51bGwgPyB2b2lkIDAgOiBfYS5tYXJrcy5maW5kKChtYXJrKSA9PiBtYXJrLnR5cGUuc3BlYy5jb2RlKSlcbiAgKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGxldCBtYXRjaGVkID0gZmFsc2U7XG4gIGNvbnN0IHRleHRCZWZvcmUgPSBnZXRUZXh0Q29udGVudEZyb21Ob2RlcygkZnJvbSkgKyB0ZXh0O1xuICBydWxlcy5mb3JFYWNoKChydWxlKSA9PiB7XG4gICAgaWYgKG1hdGNoZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbWF0Y2ggPSBpbnB1dFJ1bGVNYXRjaGVySGFuZGxlcih0ZXh0QmVmb3JlLCBydWxlLmZpbmQpO1xuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdHIgPSB2aWV3LnN0YXRlLnRyO1xuICAgIGNvbnN0IHN0YXRlID0gY3JlYXRlQ2hhaW5hYmxlU3RhdGUoe1xuICAgICAgc3RhdGU6IHZpZXcuc3RhdGUsXG4gICAgICB0cmFuc2FjdGlvbjogdHJcbiAgICB9KTtcbiAgICBjb25zdCByYW5nZSA9IHtcbiAgICAgIGZyb206IGZyb20gLSAobWF0Y2hbMF0ubGVuZ3RoIC0gdGV4dC5sZW5ndGgpLFxuICAgICAgdG9cbiAgICB9O1xuICAgIGNvbnN0IHsgY29tbWFuZHMsIGNoYWluLCBjYW4gfSA9IG5ldyBDb21tYW5kTWFuYWdlcih7XG4gICAgICBlZGl0b3IsXG4gICAgICBzdGF0ZVxuICAgIH0pO1xuICAgIGNvbnN0IGhhbmRsZXIgPSBydWxlLmhhbmRsZXIoe1xuICAgICAgc3RhdGUsXG4gICAgICByYW5nZSxcbiAgICAgIG1hdGNoLFxuICAgICAgY29tbWFuZHMsXG4gICAgICBjaGFpbixcbiAgICAgIGNhblxuICAgIH0pO1xuICAgIGlmIChoYW5kbGVyID09PSBudWxsIHx8ICF0ci5zdGVwcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHJ1bGUudW5kb2FibGUpIHtcbiAgICAgIHRyLnNldE1ldGEocGx1Z2luLCB7XG4gICAgICAgIHRyYW5zZm9ybTogdHIsXG4gICAgICAgIGZyb20sXG4gICAgICAgIHRvLFxuICAgICAgICB0ZXh0XG4gICAgICB9KTtcbiAgICB9XG4gICAgdmlldy5kaXNwYXRjaCh0cik7XG4gICAgbWF0Y2hlZCA9IHRydWU7XG4gIH0pO1xuICByZXR1cm4gbWF0Y2hlZDtcbn1cbmZ1bmN0aW9uIGlucHV0UnVsZXNQbHVnaW4ocHJvcHMpIHtcbiAgY29uc3QgeyBlZGl0b3IsIHJ1bGVzIH0gPSBwcm9wcztcbiAgY29uc3QgcGx1Z2luID0gbmV3IFBsdWdpbih7XG4gICAgc3RhdGU6IHtcbiAgICAgIGluaXQoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSxcbiAgICAgIGFwcGx5KHRyLCBwcmV2LCBzdGF0ZSkge1xuICAgICAgICBjb25zdCBzdG9yZWQgPSB0ci5nZXRNZXRhKHBsdWdpbik7XG4gICAgICAgIGlmIChzdG9yZWQpIHtcbiAgICAgICAgICByZXR1cm4gc3RvcmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNpbXVsYXRlZElucHV0TWV0YSA9IHRyLmdldE1ldGEoXCJhcHBseUlucHV0UnVsZXNcIik7XG4gICAgICAgIGNvbnN0IGlzU2ltdWxhdGVkSW5wdXQgPSAhIXNpbXVsYXRlZElucHV0TWV0YTtcbiAgICAgICAgaWYgKGlzU2ltdWxhdGVkSW5wdXQpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGxldCB7IHRleHQgfSA9IHNpbXVsYXRlZElucHV0TWV0YTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGV4dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICB0ZXh0ID0gdGV4dDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRleHQgPSBnZXRIVE1MRnJvbUZyYWdtZW50KEZyYWdtZW50NC5mcm9tKHRleHQpLCBzdGF0ZS5zY2hlbWEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBmcm9tIH0gPSBzaW11bGF0ZWRJbnB1dE1ldGE7XG4gICAgICAgICAgICBjb25zdCB0byA9IGZyb20gKyB0ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIHJ1bih7XG4gICAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgICAgZnJvbSxcbiAgICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgIHJ1bGVzLFxuICAgICAgICAgICAgICBwbHVnaW5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ci5zZWxlY3Rpb25TZXQgfHwgdHIuZG9jQ2hhbmdlZCA/IG51bGwgOiBwcmV2O1xuICAgICAgfVxuICAgIH0sXG4gICAgcHJvcHM6IHtcbiAgICAgIGhhbmRsZVRleHRJbnB1dCh2aWV3LCBmcm9tLCB0bywgdGV4dCkge1xuICAgICAgICByZXR1cm4gcnVuKHtcbiAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgZnJvbSxcbiAgICAgICAgICB0byxcbiAgICAgICAgICB0ZXh0LFxuICAgICAgICAgIHJ1bGVzLFxuICAgICAgICAgIHBsdWdpblxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBoYW5kbGVET01FdmVudHM6IHtcbiAgICAgICAgY29tcG9zaXRpb25lbmQ6ICh2aWV3KSA9PiB7XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7ICRjdXJzb3IgfSA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICAgICAgaWYgKCRjdXJzb3IpIHtcbiAgICAgICAgICAgICAgcnVuKHtcbiAgICAgICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICAgICAgZnJvbTogJGN1cnNvci5wb3MsXG4gICAgICAgICAgICAgICAgdG86ICRjdXJzb3IucG9zLFxuICAgICAgICAgICAgICAgIHRleHQ6IFwiXCIsXG4gICAgICAgICAgICAgICAgcnVsZXMsXG4gICAgICAgICAgICAgICAgcGx1Z2luXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIGFkZCBzdXBwb3J0IGZvciBpbnB1dCBydWxlcyB0byB0cmlnZ2VyIG9uIGVudGVyXG4gICAgICAvLyB0aGlzIGlzIHVzZWZ1bCBmb3IgZXhhbXBsZSBmb3IgY29kZSBibG9ja3NcbiAgICAgIGhhbmRsZUtleURvd24odmlldywgZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmtleSAhPT0gXCJFbnRlclwiKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgJGN1cnNvciB9ID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIGlmICgkY3Vyc29yKSB7XG4gICAgICAgICAgcmV0dXJuIHJ1bih7XG4gICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICBmcm9tOiAkY3Vyc29yLnBvcyxcbiAgICAgICAgICAgIHRvOiAkY3Vyc29yLnBvcyxcbiAgICAgICAgICAgIHRleHQ6IFwiXFxuXCIsXG4gICAgICAgICAgICBydWxlcyxcbiAgICAgICAgICAgIHBsdWdpblxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpc0lucHV0UnVsZXM6IHRydWVcbiAgfSk7XG4gIHJldHVybiBwbHVnaW47XG59XG5cbi8vIHNyYy91dGlsaXRpZXMvaXNQbGFpbk9iamVjdC50c1xuZnVuY3Rpb24gZ2V0VHlwZSh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSk7XG59XG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIGlmIChnZXRUeXBlKHZhbHVlKSAhPT0gXCJPYmplY3RcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsdWUuY29uc3RydWN0b3IgPT09IE9iamVjdCAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpID09PSBPYmplY3QucHJvdG90eXBlO1xufVxuXG4vLyBzcmMvdXRpbGl0aWVzL21lcmdlRGVlcC50c1xuZnVuY3Rpb24gbWVyZ2VEZWVwKHRhcmdldCwgc291cmNlKSB7XG4gIGNvbnN0IG91dHB1dCA9IHsgLi4udGFyZ2V0IH07XG4gIGlmIChpc1BsYWluT2JqZWN0KHRhcmdldCkgJiYgaXNQbGFpbk9iamVjdChzb3VyY2UpKSB7XG4gICAgT2JqZWN0LmtleXMoc291cmNlKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGlmIChpc1BsYWluT2JqZWN0KHNvdXJjZVtrZXldKSAmJiBpc1BsYWluT2JqZWN0KHRhcmdldFtrZXldKSkge1xuICAgICAgICBvdXRwdXRba2V5XSA9IG1lcmdlRGVlcCh0YXJnZXRba2V5XSwgc291cmNlW2tleV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0cHV0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufVxuXG4vLyBzcmMvRXh0ZW5kYWJsZS50c1xudmFyIEV4dGVuZGFibGUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZyA9IHt9KSB7XG4gICAgdGhpcy50eXBlID0gXCJleHRlbmRhYmxlXCI7XG4gICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgIHRoaXMuY2hpbGQgPSBudWxsO1xuICAgIHRoaXMubmFtZSA9IFwiXCI7XG4gICAgdGhpcy5jb25maWcgPSB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWVcbiAgICB9O1xuICAgIHRoaXMuY29uZmlnID0ge1xuICAgICAgLi4udGhpcy5jb25maWcsXG4gICAgICAuLi5jb25maWdcbiAgICB9O1xuICAgIHRoaXMubmFtZSA9IHRoaXMuY29uZmlnLm5hbWU7XG4gIH1cbiAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmNhbGxPclJldHVybihcbiAgICAgICAgZ2V0RXh0ZW5zaW9uRmllbGQodGhpcywgXCJhZGRPcHRpb25zXCIsIHtcbiAgICAgICAgICBuYW1lOiB0aGlzLm5hbWVcbiAgICAgICAgfSlcbiAgICAgICkgfHwge31cbiAgICB9O1xuICB9XG4gIGdldCBzdG9yYWdlKCkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5jYWxsT3JSZXR1cm4oXG4gICAgICAgIGdldEV4dGVuc2lvbkZpZWxkKHRoaXMsIFwiYWRkU3RvcmFnZVwiLCB7XG4gICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgIG9wdGlvbnM6IHRoaXMub3B0aW9uc1xuICAgICAgICB9KVxuICAgICAgKSB8fCB7fVxuICAgIH07XG4gIH1cbiAgY29uZmlndXJlKG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGV4dGVuc2lvbiA9IHRoaXMuZXh0ZW5kKHtcbiAgICAgIC4uLnRoaXMuY29uZmlnLFxuICAgICAgYWRkT3B0aW9uczogKCkgPT4ge1xuICAgICAgICByZXR1cm4gbWVyZ2VEZWVwKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZXh0ZW5zaW9uLm5hbWUgPSB0aGlzLm5hbWU7XG4gICAgZXh0ZW5zaW9uLnBhcmVudCA9IHRoaXMucGFyZW50O1xuICAgIHJldHVybiBleHRlbnNpb247XG4gIH1cbiAgZXh0ZW5kKGV4dGVuZGVkQ29uZmlnID0ge30pIHtcbiAgICBjb25zdCBleHRlbnNpb24gPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih7IC4uLnRoaXMuY29uZmlnLCAuLi5leHRlbmRlZENvbmZpZyB9KTtcbiAgICBleHRlbnNpb24ucGFyZW50ID0gdGhpcztcbiAgICB0aGlzLmNoaWxkID0gZXh0ZW5zaW9uO1xuICAgIGV4dGVuc2lvbi5uYW1lID0gXCJuYW1lXCIgaW4gZXh0ZW5kZWRDb25maWcgPyBleHRlbmRlZENvbmZpZy5uYW1lIDogZXh0ZW5zaW9uLnBhcmVudC5uYW1lO1xuICAgIHJldHVybiBleHRlbnNpb247XG4gIH1cbn07XG5cbi8vIHNyYy9NYXJrLnRzXG52YXIgTWFyayA9IGNsYXNzIF9NYXJrIGV4dGVuZHMgRXh0ZW5kYWJsZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy50eXBlID0gXCJtYXJrXCI7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBNYXJrIGluc3RhbmNlXG4gICAqIEBwYXJhbSBjb25maWcgLSBNYXJrIGNvbmZpZ3VyYXRpb24gb2JqZWN0IG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICovXG4gIHN0YXRpYyBjcmVhdGUoY29uZmlnID0ge30pIHtcbiAgICBjb25zdCByZXNvbHZlZENvbmZpZyA9IHR5cGVvZiBjb25maWcgPT09IFwiZnVuY3Rpb25cIiA/IGNvbmZpZygpIDogY29uZmlnO1xuICAgIHJldHVybiBuZXcgX01hcmsocmVzb2x2ZWRDb25maWcpO1xuICB9XG4gIHN0YXRpYyBoYW5kbGVFeGl0KHsgZWRpdG9yLCBtYXJrIH0pIHtcbiAgICBjb25zdCB7IHRyIH0gPSBlZGl0b3Iuc3RhdGU7XG4gICAgY29uc3QgY3VycmVudFBvcyA9IGVkaXRvci5zdGF0ZS5zZWxlY3Rpb24uJGZyb207XG4gICAgY29uc3QgaXNBdEVuZCA9IGN1cnJlbnRQb3MucG9zID09PSBjdXJyZW50UG9zLmVuZCgpO1xuICAgIGlmIChpc0F0RW5kKSB7XG4gICAgICBjb25zdCBjdXJyZW50TWFya3MgPSBjdXJyZW50UG9zLm1hcmtzKCk7XG4gICAgICBjb25zdCBpc0luTWFyayA9ICEhY3VycmVudE1hcmtzLmZpbmQoKG0pID0+IChtID09IG51bGwgPyB2b2lkIDAgOiBtLnR5cGUubmFtZSkgPT09IG1hcmsubmFtZSk7XG4gICAgICBpZiAoIWlzSW5NYXJrKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlbW92ZU1hcmsgPSBjdXJyZW50TWFya3MuZmluZCgobSkgPT4gKG0gPT0gbnVsbCA/IHZvaWQgMCA6IG0udHlwZS5uYW1lKSA9PT0gbWFyay5uYW1lKTtcbiAgICAgIGlmIChyZW1vdmVNYXJrKSB7XG4gICAgICAgIHRyLnJlbW92ZVN0b3JlZE1hcmsocmVtb3ZlTWFyayk7XG4gICAgICB9XG4gICAgICB0ci5pbnNlcnRUZXh0KFwiIFwiLCBjdXJyZW50UG9zLnBvcyk7XG4gICAgICBlZGl0b3Iudmlldy5kaXNwYXRjaCh0cik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbmZpZ3VyZShvcHRpb25zKSB7XG4gICAgcmV0dXJuIHN1cGVyLmNvbmZpZ3VyZShvcHRpb25zKTtcbiAgfVxuICBleHRlbmQoZXh0ZW5kZWRDb25maWcpIHtcbiAgICBjb25zdCByZXNvbHZlZENvbmZpZyA9IHR5cGVvZiBleHRlbmRlZENvbmZpZyA9PT0gXCJmdW5jdGlvblwiID8gZXh0ZW5kZWRDb25maWcoKSA6IGV4dGVuZGVkQ29uZmlnO1xuICAgIHJldHVybiBzdXBlci5leHRlbmQocmVzb2x2ZWRDb25maWcpO1xuICB9XG59O1xuXG4vLyBzcmMvUGFzdGVSdWxlLnRzXG5pbXBvcnQgeyBGcmFnbWVudCBhcyBGcmFnbWVudDUgfSBmcm9tIFwiQHRpcHRhcC9wbS9tb2RlbFwiO1xuaW1wb3J0IHsgUGx1Z2luIGFzIFBsdWdpbjIgfSBmcm9tIFwiQHRpcHRhcC9wbS9zdGF0ZVwiO1xuXG4vLyBzcmMvdXRpbGl0aWVzL2lzTnVtYmVyLnRzXG5mdW5jdGlvbiBpc051bWJlcih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiO1xufVxuXG4vLyBzcmMvUGFzdGVSdWxlLnRzXG52YXIgUGFzdGVSdWxlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICB0aGlzLmZpbmQgPSBjb25maWcuZmluZDtcbiAgICB0aGlzLmhhbmRsZXIgPSBjb25maWcuaGFuZGxlcjtcbiAgfVxufTtcbnZhciBwYXN0ZVJ1bGVNYXRjaGVySGFuZGxlciA9ICh0ZXh0LCBmaW5kLCBldmVudCkgPT4ge1xuICBpZiAoaXNSZWdFeHAoZmluZCkpIHtcbiAgICByZXR1cm4gWy4uLnRleHQubWF0Y2hBbGwoZmluZCldO1xuICB9XG4gIGNvbnN0IG1hdGNoZXMgPSBmaW5kKHRleHQsIGV2ZW50KTtcbiAgaWYgKCFtYXRjaGVzKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHJldHVybiBtYXRjaGVzLm1hcCgocGFzdGVSdWxlTWF0Y2gpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSBbcGFzdGVSdWxlTWF0Y2gudGV4dF07XG4gICAgcmVzdWx0LmluZGV4ID0gcGFzdGVSdWxlTWF0Y2guaW5kZXg7XG4gICAgcmVzdWx0LmlucHV0ID0gdGV4dDtcbiAgICByZXN1bHQuZGF0YSA9IHBhc3RlUnVsZU1hdGNoLmRhdGE7XG4gICAgaWYgKHBhc3RlUnVsZU1hdGNoLnJlcGxhY2VXaXRoKSB7XG4gICAgICBpZiAoIXBhc3RlUnVsZU1hdGNoLnRleHQuaW5jbHVkZXMocGFzdGVSdWxlTWF0Y2gucmVwbGFjZVdpdGgpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignW3RpcHRhcCB3YXJuXTogXCJwYXN0ZVJ1bGVNYXRjaC5yZXBsYWNlV2l0aFwiIG11c3QgYmUgcGFydCBvZiBcInBhc3RlUnVsZU1hdGNoLnRleHRcIi4nKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wdXNoKHBhc3RlUnVsZU1hdGNoLnJlcGxhY2VXaXRoKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSk7XG59O1xuZnVuY3Rpb24gcnVuMihjb25maWcpIHtcbiAgY29uc3QgeyBlZGl0b3IsIHN0YXRlLCBmcm9tLCB0bywgcnVsZSwgcGFzdGVFdmVudCwgZHJvcEV2ZW50IH0gPSBjb25maWc7XG4gIGNvbnN0IHsgY29tbWFuZHMsIGNoYWluLCBjYW4gfSA9IG5ldyBDb21tYW5kTWFuYWdlcih7XG4gICAgZWRpdG9yLFxuICAgIHN0YXRlXG4gIH0pO1xuICBjb25zdCBoYW5kbGVycyA9IFtdO1xuICBzdGF0ZS5kb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICBpZiAoKChfYiA9IChfYSA9IG5vZGUudHlwZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnNwZWMpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jb2RlKSB8fCAhKG5vZGUuaXNUZXh0IHx8IG5vZGUuaXNUZXh0YmxvY2sgfHwgbm9kZS5pc0lubGluZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY29udGVudFNpemUgPSAoX2UgPSAoX2QgPSAoX2MgPSBub2RlLmNvbnRlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYy5zaXplKSAhPSBudWxsID8gX2QgOiBub2RlLm5vZGVTaXplKSAhPSBudWxsID8gX2UgOiAwO1xuICAgIGNvbnN0IHJlc29sdmVkRnJvbSA9IE1hdGgubWF4KGZyb20sIHBvcyk7XG4gICAgY29uc3QgcmVzb2x2ZWRUbyA9IE1hdGgubWluKHRvLCBwb3MgKyBjb250ZW50U2l6ZSk7XG4gICAgaWYgKHJlc29sdmVkRnJvbSA+PSByZXNvbHZlZFRvKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRleHRUb01hdGNoID0gbm9kZS5pc1RleHQgPyBub2RlLnRleHQgfHwgXCJcIiA6IG5vZGUudGV4dEJldHdlZW4ocmVzb2x2ZWRGcm9tIC0gcG9zLCByZXNvbHZlZFRvIC0gcG9zLCB2b2lkIDAsIFwiXFx1RkZGQ1wiKTtcbiAgICBjb25zdCBtYXRjaGVzID0gcGFzdGVSdWxlTWF0Y2hlckhhbmRsZXIodGV4dFRvTWF0Y2gsIHJ1bGUuZmluZCwgcGFzdGVFdmVudCk7XG4gICAgbWF0Y2hlcy5mb3JFYWNoKChtYXRjaCkgPT4ge1xuICAgICAgaWYgKG1hdGNoLmluZGV4ID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RhcnQgPSByZXNvbHZlZEZyb20gKyBtYXRjaC5pbmRleCArIDE7XG4gICAgICBjb25zdCBlbmQgPSBzdGFydCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgIGNvbnN0IHJhbmdlID0ge1xuICAgICAgICBmcm9tOiBzdGF0ZS50ci5tYXBwaW5nLm1hcChzdGFydCksXG4gICAgICAgIHRvOiBzdGF0ZS50ci5tYXBwaW5nLm1hcChlbmQpXG4gICAgICB9O1xuICAgICAgY29uc3QgaGFuZGxlciA9IHJ1bGUuaGFuZGxlcih7XG4gICAgICAgIHN0YXRlLFxuICAgICAgICByYW5nZSxcbiAgICAgICAgbWF0Y2gsXG4gICAgICAgIGNvbW1hbmRzLFxuICAgICAgICBjaGFpbixcbiAgICAgICAgY2FuLFxuICAgICAgICBwYXN0ZUV2ZW50LFxuICAgICAgICBkcm9wRXZlbnRcbiAgICAgIH0pO1xuICAgICAgaGFuZGxlcnMucHVzaChoYW5kbGVyKTtcbiAgICB9KTtcbiAgfSk7XG4gIGNvbnN0IHN1Y2Nlc3MgPSBoYW5kbGVycy5ldmVyeSgoaGFuZGxlcikgPT4gaGFuZGxlciAhPT0gbnVsbCk7XG4gIHJldHVybiBzdWNjZXNzO1xufVxudmFyIHRpcHRhcERyYWdGcm9tT3RoZXJFZGl0b3IgPSBudWxsO1xudmFyIGNyZWF0ZUNsaXBib2FyZFBhc3RlRXZlbnQgPSAodGV4dCkgPT4ge1xuICB2YXIgX2E7XG4gIGNvbnN0IGV2ZW50ID0gbmV3IENsaXBib2FyZEV2ZW50KFwicGFzdGVcIiwge1xuICAgIGNsaXBib2FyZERhdGE6IG5ldyBEYXRhVHJhbnNmZXIoKVxuICB9KTtcbiAgKF9hID0gZXZlbnQuY2xpcGJvYXJkRGF0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnNldERhdGEoXCJ0ZXh0L2h0bWxcIiwgdGV4dCk7XG4gIHJldHVybiBldmVudDtcbn07XG5mdW5jdGlvbiBwYXN0ZVJ1bGVzUGx1Z2luKHByb3BzKSB7XG4gIGNvbnN0IHsgZWRpdG9yLCBydWxlcyB9ID0gcHJvcHM7XG4gIGxldCBkcmFnU291cmNlRWxlbWVudCA9IG51bGw7XG4gIGxldCBpc1Bhc3RlZEZyb21Qcm9zZU1pcnJvciA9IGZhbHNlO1xuICBsZXQgaXNEcm9wcGVkRnJvbVByb3NlTWlycm9yID0gZmFsc2U7XG4gIGxldCBwYXN0ZUV2ZW50ID0gdHlwZW9mIENsaXBib2FyZEV2ZW50ICE9PSBcInVuZGVmaW5lZFwiID8gbmV3IENsaXBib2FyZEV2ZW50KFwicGFzdGVcIikgOiBudWxsO1xuICBsZXQgZHJvcEV2ZW50O1xuICB0cnkge1xuICAgIGRyb3BFdmVudCA9IHR5cGVvZiBEcmFnRXZlbnQgIT09IFwidW5kZWZpbmVkXCIgPyBuZXcgRHJhZ0V2ZW50KFwiZHJvcFwiKSA6IG51bGw7XG4gIH0gY2F0Y2gge1xuICAgIGRyb3BFdmVudCA9IG51bGw7XG4gIH1cbiAgY29uc3QgcHJvY2Vzc0V2ZW50ID0gKHtcbiAgICBzdGF0ZSxcbiAgICBmcm9tLFxuICAgIHRvLFxuICAgIHJ1bGUsXG4gICAgcGFzdGVFdnRcbiAgfSkgPT4ge1xuICAgIGNvbnN0IHRyID0gc3RhdGUudHI7XG4gICAgY29uc3QgY2hhaW5hYmxlU3RhdGUgPSBjcmVhdGVDaGFpbmFibGVTdGF0ZSh7XG4gICAgICBzdGF0ZSxcbiAgICAgIHRyYW5zYWN0aW9uOiB0clxuICAgIH0pO1xuICAgIGNvbnN0IGhhbmRsZXIgPSBydW4yKHtcbiAgICAgIGVkaXRvcixcbiAgICAgIHN0YXRlOiBjaGFpbmFibGVTdGF0ZSxcbiAgICAgIGZyb206IE1hdGgubWF4KGZyb20gLSAxLCAwKSxcbiAgICAgIHRvOiB0by5iIC0gMSxcbiAgICAgIHJ1bGUsXG4gICAgICBwYXN0ZUV2ZW50OiBwYXN0ZUV2dCxcbiAgICAgIGRyb3BFdmVudFxuICAgIH0pO1xuICAgIGlmICghaGFuZGxlciB8fCAhdHIuc3RlcHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBkcm9wRXZlbnQgPSB0eXBlb2YgRHJhZ0V2ZW50ICE9PSBcInVuZGVmaW5lZFwiID8gbmV3IERyYWdFdmVudChcImRyb3BcIikgOiBudWxsO1xuICAgIH0gY2F0Y2gge1xuICAgICAgZHJvcEV2ZW50ID0gbnVsbDtcbiAgICB9XG4gICAgcGFzdGVFdmVudCA9IHR5cGVvZiBDbGlwYm9hcmRFdmVudCAhPT0gXCJ1bmRlZmluZWRcIiA/IG5ldyBDbGlwYm9hcmRFdmVudChcInBhc3RlXCIpIDogbnVsbDtcbiAgICByZXR1cm4gdHI7XG4gIH07XG4gIGNvbnN0IHBsdWdpbnMgPSBydWxlcy5tYXAoKHJ1bGUpID0+IHtcbiAgICByZXR1cm4gbmV3IFBsdWdpbjIoe1xuICAgICAgLy8gd2UgcmVnaXN0ZXIgYSBnbG9iYWwgZHJhZyBoYW5kbGVyIHRvIHRyYWNrIHRoZSBjdXJyZW50IGRyYWcgc291cmNlIGVsZW1lbnRcbiAgICAgIHZpZXcodmlldykge1xuICAgICAgICBjb25zdCBoYW5kbGVEcmFnc3RhcnQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgZHJhZ1NvdXJjZUVsZW1lbnQgPSAoKF9hID0gdmlldy5kb20ucGFyZW50RWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpID8gdmlldy5kb20ucGFyZW50RWxlbWVudCA6IG51bGw7XG4gICAgICAgICAgaWYgKGRyYWdTb3VyY2VFbGVtZW50KSB7XG4gICAgICAgICAgICB0aXB0YXBEcmFnRnJvbU90aGVyRWRpdG9yID0gZWRpdG9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgaGFuZGxlRHJhZ2VuZCA9ICgpID0+IHtcbiAgICAgICAgICBpZiAodGlwdGFwRHJhZ0Zyb21PdGhlckVkaXRvcikge1xuICAgICAgICAgICAgdGlwdGFwRHJhZ0Zyb21PdGhlckVkaXRvciA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdzdGFydFwiLCBoYW5kbGVEcmFnc3RhcnQpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdlbmRcIiwgaGFuZGxlRHJhZ2VuZCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGVzdHJveSgpIHtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiZHJhZ3N0YXJ0XCIsIGhhbmRsZURyYWdzdGFydCk7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImRyYWdlbmRcIiwgaGFuZGxlRHJhZ2VuZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIGhhbmRsZURPTUV2ZW50czoge1xuICAgICAgICAgIGRyb3A6ICh2aWV3LCBldmVudCkgPT4ge1xuICAgICAgICAgICAgaXNEcm9wcGVkRnJvbVByb3NlTWlycm9yID0gZHJhZ1NvdXJjZUVsZW1lbnQgPT09IHZpZXcuZG9tLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgICBkcm9wRXZlbnQgPSBldmVudDtcbiAgICAgICAgICAgIGlmICghaXNEcm9wcGVkRnJvbVByb3NlTWlycm9yKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGRyYWdGcm9tT3RoZXJFZGl0b3IgPSB0aXB0YXBEcmFnRnJvbU90aGVyRWRpdG9yO1xuICAgICAgICAgICAgICBpZiAoZHJhZ0Zyb21PdGhlckVkaXRvciA9PSBudWxsID8gdm9pZCAwIDogZHJhZ0Zyb21PdGhlckVkaXRvci5pc0VkaXRhYmxlKSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSBkcmFnRnJvbU90aGVyRWRpdG9yLnN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgZHJhZ0Zyb21PdGhlckVkaXRvci5jb21tYW5kcy5kZWxldGVSYW5nZSh7IGZyb206IHNlbGVjdGlvbi5mcm9tLCB0bzogc2VsZWN0aW9uLnRvIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIDEwKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcGFzdGU6IChfdmlldywgZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGNvbnN0IGh0bWwgPSAoX2EgPSBldmVudC5jbGlwYm9hcmREYXRhKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZ2V0RGF0YShcInRleHQvaHRtbFwiKTtcbiAgICAgICAgICAgIHBhc3RlRXZlbnQgPSBldmVudDtcbiAgICAgICAgICAgIGlzUGFzdGVkRnJvbVByb3NlTWlycm9yID0gISEoaHRtbCA9PSBudWxsID8gdm9pZCAwIDogaHRtbC5pbmNsdWRlcyhcImRhdGEtcG0tc2xpY2VcIikpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGFwcGVuZFRyYW5zYWN0aW9uOiAodHJhbnNhY3Rpb25zLCBvbGRTdGF0ZSwgc3RhdGUpID0+IHtcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbnNbMF07XG4gICAgICAgIGNvbnN0IGlzUGFzdGUgPSB0cmFuc2FjdGlvbi5nZXRNZXRhKFwidWlFdmVudFwiKSA9PT0gXCJwYXN0ZVwiICYmICFpc1Bhc3RlZEZyb21Qcm9zZU1pcnJvcjtcbiAgICAgICAgY29uc3QgaXNEcm9wID0gdHJhbnNhY3Rpb24uZ2V0TWV0YShcInVpRXZlbnRcIikgPT09IFwiZHJvcFwiICYmICFpc0Ryb3BwZWRGcm9tUHJvc2VNaXJyb3I7XG4gICAgICAgIGNvbnN0IHNpbXVsYXRlZFBhc3RlTWV0YSA9IHRyYW5zYWN0aW9uLmdldE1ldGEoXCJhcHBseVBhc3RlUnVsZXNcIik7XG4gICAgICAgIGNvbnN0IGlzU2ltdWxhdGVkUGFzdGUgPSAhIXNpbXVsYXRlZFBhc3RlTWV0YTtcbiAgICAgICAgaWYgKCFpc1Bhc3RlICYmICFpc0Ryb3AgJiYgIWlzU2ltdWxhdGVkUGFzdGUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU2ltdWxhdGVkUGFzdGUpIHtcbiAgICAgICAgICBsZXQgeyB0ZXh0IH0gPSBzaW11bGF0ZWRQYXN0ZU1ldGE7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0ZXh0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0ZXh0ID0gdGV4dDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGV4dCA9IGdldEhUTUxGcm9tRnJhZ21lbnQoRnJhZ21lbnQ1LmZyb20odGV4dCksIHN0YXRlLnNjaGVtYSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHsgZnJvbTogZnJvbTIgfSA9IHNpbXVsYXRlZFBhc3RlTWV0YTtcbiAgICAgICAgICBjb25zdCB0bzIgPSBmcm9tMiArIHRleHQubGVuZ3RoO1xuICAgICAgICAgIGNvbnN0IHBhc3RlRXZ0ID0gY3JlYXRlQ2xpcGJvYXJkUGFzdGVFdmVudCh0ZXh0KTtcbiAgICAgICAgICByZXR1cm4gcHJvY2Vzc0V2ZW50KHtcbiAgICAgICAgICAgIHJ1bGUsXG4gICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgIGZyb206IGZyb20yLFxuICAgICAgICAgICAgdG86IHsgYjogdG8yIH0sXG4gICAgICAgICAgICBwYXN0ZUV2dFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZyb20gPSBvbGRTdGF0ZS5kb2MuY29udGVudC5maW5kRGlmZlN0YXJ0KHN0YXRlLmRvYy5jb250ZW50KTtcbiAgICAgICAgY29uc3QgdG8gPSBvbGRTdGF0ZS5kb2MuY29udGVudC5maW5kRGlmZkVuZChzdGF0ZS5kb2MuY29udGVudCk7XG4gICAgICAgIGlmICghaXNOdW1iZXIoZnJvbSkgfHwgIXRvIHx8IGZyb20gPT09IHRvLmIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb2Nlc3NFdmVudCh7XG4gICAgICAgICAgcnVsZSxcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICBmcm9tLFxuICAgICAgICAgIHRvLFxuICAgICAgICAgIHBhc3RlRXZ0OiBwYXN0ZUV2ZW50XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIHBsdWdpbnM7XG59XG5cbi8vIHNyYy9FeHRlbnNpb25NYW5hZ2VyLnRzXG52YXIgRXh0ZW5zaW9uTWFuYWdlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoZXh0ZW5zaW9ucywgZWRpdG9yKSB7XG4gICAgdGhpcy5zcGxpdHRhYmxlTWFya3MgPSBbXTtcbiAgICB0aGlzLmVkaXRvciA9IGVkaXRvcjtcbiAgICB0aGlzLmJhc2VFeHRlbnNpb25zID0gZXh0ZW5zaW9ucztcbiAgICB0aGlzLmV4dGVuc2lvbnMgPSByZXNvbHZlRXh0ZW5zaW9ucyhleHRlbnNpb25zKTtcbiAgICB0aGlzLnNjaGVtYSA9IGdldFNjaGVtYUJ5UmVzb2x2ZWRFeHRlbnNpb25zKHRoaXMuZXh0ZW5zaW9ucywgZWRpdG9yKTtcbiAgICB0aGlzLnNldHVwRXh0ZW5zaW9ucygpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYWxsIGNvbW1hbmRzIGZyb20gdGhlIGV4dGVuc2lvbnMuXG4gICAqIEByZXR1cm5zIEFuIG9iamVjdCB3aXRoIGFsbCBjb21tYW5kcyB3aGVyZSB0aGUga2V5IGlzIHRoZSBjb21tYW5kIG5hbWUgYW5kIHRoZSB2YWx1ZSBpcyB0aGUgY29tbWFuZCBmdW5jdGlvblxuICAgKi9cbiAgZ2V0IGNvbW1hbmRzKCkge1xuICAgIHJldHVybiB0aGlzLmV4dGVuc2lvbnMucmVkdWNlKChjb21tYW5kcywgZXh0ZW5zaW9uKSA9PiB7XG4gICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICAgIHN0b3JhZ2U6IHRoaXMuZWRpdG9yLmV4dGVuc2lvblN0b3JhZ2VbZXh0ZW5zaW9uLm5hbWVdLFxuICAgICAgICBlZGl0b3I6IHRoaXMuZWRpdG9yLFxuICAgICAgICB0eXBlOiBnZXRTY2hlbWFUeXBlQnlOYW1lKGV4dGVuc2lvbi5uYW1lLCB0aGlzLnNjaGVtYSlcbiAgICAgIH07XG4gICAgICBjb25zdCBhZGRDb21tYW5kcyA9IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgXCJhZGRDb21tYW5kc1wiLCBjb250ZXh0KTtcbiAgICAgIGlmICghYWRkQ29tbWFuZHMpIHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uY29tbWFuZHMsXG4gICAgICAgIC4uLmFkZENvbW1hbmRzKClcbiAgICAgIH07XG4gICAgfSwge30pO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYWxsIHJlZ2lzdGVyZWQgUHJvc2VtaXJyb3IgcGx1Z2lucyBmcm9tIHRoZSBleHRlbnNpb25zLlxuICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiBQcm9zZW1pcnJvciBwbHVnaW5zXG4gICAqL1xuICBnZXQgcGx1Z2lucygpIHtcbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcztcbiAgICBjb25zdCBleHRlbnNpb25zID0gc29ydEV4dGVuc2lvbnMoWy4uLnRoaXMuZXh0ZW5zaW9uc10ucmV2ZXJzZSgpKTtcbiAgICBjb25zdCBhbGxQbHVnaW5zID0gZXh0ZW5zaW9ucy5mbGF0TWFwKChleHRlbnNpb24pID0+IHtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcbiAgICAgICAgc3RvcmFnZTogdGhpcy5lZGl0b3IuZXh0ZW5zaW9uU3RvcmFnZVtleHRlbnNpb24ubmFtZV0sXG4gICAgICAgIGVkaXRvcixcbiAgICAgICAgdHlwZTogZ2V0U2NoZW1hVHlwZUJ5TmFtZShleHRlbnNpb24ubmFtZSwgdGhpcy5zY2hlbWEpXG4gICAgICB9O1xuICAgICAgY29uc3QgcGx1Z2lucyA9IFtdO1xuICAgICAgY29uc3QgYWRkS2V5Ym9hcmRTaG9ydGN1dHMgPSBnZXRFeHRlbnNpb25GaWVsZChcbiAgICAgICAgZXh0ZW5zaW9uLFxuICAgICAgICBcImFkZEtleWJvYXJkU2hvcnRjdXRzXCIsXG4gICAgICAgIGNvbnRleHRcbiAgICAgICk7XG4gICAgICBsZXQgZGVmYXVsdEJpbmRpbmdzID0ge307XG4gICAgICBpZiAoZXh0ZW5zaW9uLnR5cGUgPT09IFwibWFya1wiICYmIGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgXCJleGl0YWJsZVwiLCBjb250ZXh0KSkge1xuICAgICAgICBkZWZhdWx0QmluZGluZ3MuQXJyb3dSaWdodCA9ICgpID0+IE1hcmsuaGFuZGxlRXhpdCh7IGVkaXRvciwgbWFyazogZXh0ZW5zaW9uIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGFkZEtleWJvYXJkU2hvcnRjdXRzKSB7XG4gICAgICAgIGNvbnN0IGJpbmRpbmdzID0gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGFkZEtleWJvYXJkU2hvcnRjdXRzKCkpLm1hcCgoW3Nob3J0Y3V0LCBtZXRob2RdKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gW3Nob3J0Y3V0LCAoKSA9PiBtZXRob2QoeyBlZGl0b3IgfSldO1xuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIGRlZmF1bHRCaW5kaW5ncyA9IHsgLi4uZGVmYXVsdEJpbmRpbmdzLCAuLi5iaW5kaW5ncyB9O1xuICAgICAgfVxuICAgICAgY29uc3Qga2V5TWFwUGx1Z2luID0ga2V5bWFwKGRlZmF1bHRCaW5kaW5ncyk7XG4gICAgICBwbHVnaW5zLnB1c2goa2V5TWFwUGx1Z2luKTtcbiAgICAgIGNvbnN0IGFkZElucHV0UnVsZXMgPSBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sIFwiYWRkSW5wdXRSdWxlc1wiLCBjb250ZXh0KTtcbiAgICAgIGlmIChpc0V4dGVuc2lvblJ1bGVzRW5hYmxlZChleHRlbnNpb24sIGVkaXRvci5vcHRpb25zLmVuYWJsZUlucHV0UnVsZXMpICYmIGFkZElucHV0UnVsZXMpIHtcbiAgICAgICAgY29uc3QgcnVsZXMgPSBhZGRJbnB1dFJ1bGVzKCk7XG4gICAgICAgIGlmIChydWxlcyAmJiBydWxlcy5sZW5ndGgpIHtcbiAgICAgICAgICBjb25zdCBpbnB1dFJlc3VsdCA9IGlucHV0UnVsZXNQbHVnaW4oe1xuICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgcnVsZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb25zdCBpbnB1dFBsdWdpbnMgPSBBcnJheS5pc0FycmF5KGlucHV0UmVzdWx0KSA/IGlucHV0UmVzdWx0IDogW2lucHV0UmVzdWx0XTtcbiAgICAgICAgICBwbHVnaW5zLnB1c2goLi4uaW5wdXRQbHVnaW5zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgYWRkUGFzdGVSdWxlcyA9IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgXCJhZGRQYXN0ZVJ1bGVzXCIsIGNvbnRleHQpO1xuICAgICAgaWYgKGlzRXh0ZW5zaW9uUnVsZXNFbmFibGVkKGV4dGVuc2lvbiwgZWRpdG9yLm9wdGlvbnMuZW5hYmxlUGFzdGVSdWxlcykgJiYgYWRkUGFzdGVSdWxlcykge1xuICAgICAgICBjb25zdCBydWxlcyA9IGFkZFBhc3RlUnVsZXMoKTtcbiAgICAgICAgaWYgKHJ1bGVzICYmIHJ1bGVzLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IHBhc3RlUnVsZXMgPSBwYXN0ZVJ1bGVzUGx1Z2luKHsgZWRpdG9yLCBydWxlcyB9KTtcbiAgICAgICAgICBwbHVnaW5zLnB1c2goLi4ucGFzdGVSdWxlcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGFkZFByb3NlTWlycm9yUGx1Z2lucyA9IGdldEV4dGVuc2lvbkZpZWxkKFxuICAgICAgICBleHRlbnNpb24sXG4gICAgICAgIFwiYWRkUHJvc2VNaXJyb3JQbHVnaW5zXCIsXG4gICAgICAgIGNvbnRleHRcbiAgICAgICk7XG4gICAgICBpZiAoYWRkUHJvc2VNaXJyb3JQbHVnaW5zKSB7XG4gICAgICAgIGNvbnN0IHByb3NlTWlycm9yUGx1Z2lucyA9IGFkZFByb3NlTWlycm9yUGx1Z2lucygpO1xuICAgICAgICBwbHVnaW5zLnB1c2goLi4ucHJvc2VNaXJyb3JQbHVnaW5zKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwbHVnaW5zO1xuICAgIH0pO1xuICAgIHJldHVybiBhbGxQbHVnaW5zO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYWxsIGF0dHJpYnV0ZXMgZnJvbSB0aGUgZXh0ZW5zaW9ucy5cbiAgICogQHJldHVybnMgQW4gYXJyYXkgb2YgYXR0cmlidXRlc1xuICAgKi9cbiAgZ2V0IGF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIGdldEF0dHJpYnV0ZXNGcm9tRXh0ZW5zaW9ucyh0aGlzLmV4dGVuc2lvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYWxsIG5vZGUgdmlld3MgZnJvbSB0aGUgZXh0ZW5zaW9ucy5cbiAgICogQHJldHVybnMgQW4gb2JqZWN0IHdpdGggYWxsIG5vZGUgdmlld3Mgd2hlcmUgdGhlIGtleSBpcyB0aGUgbm9kZSBuYW1lIGFuZCB0aGUgdmFsdWUgaXMgdGhlIG5vZGUgdmlldyBmdW5jdGlvblxuICAgKi9cbiAgZ2V0IG5vZGVWaWV3cygpIHtcbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcztcbiAgICBjb25zdCB7IG5vZGVFeHRlbnNpb25zIH0gPSBzcGxpdEV4dGVuc2lvbnModGhpcy5leHRlbnNpb25zKTtcbiAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgbm9kZUV4dGVuc2lvbnMuZmlsdGVyKChleHRlbnNpb24pID0+ICEhZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCBcImFkZE5vZGVWaWV3XCIpKS5tYXAoKGV4dGVuc2lvbikgPT4ge1xuICAgICAgICBjb25zdCBleHRlbnNpb25BdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzLmZpbHRlcigoYXR0cmlidXRlKSA9PiBhdHRyaWJ1dGUudHlwZSA9PT0gZXh0ZW5zaW9uLm5hbWUpO1xuICAgICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgICAgIHN0b3JhZ2U6IHRoaXMuZWRpdG9yLmV4dGVuc2lvblN0b3JhZ2VbZXh0ZW5zaW9uLm5hbWVdLFxuICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICB0eXBlOiBnZXROb2RlVHlwZShleHRlbnNpb24ubmFtZSwgdGhpcy5zY2hlbWEpXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGFkZE5vZGVWaWV3ID0gZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCBcImFkZE5vZGVWaWV3XCIsIGNvbnRleHQpO1xuICAgICAgICBpZiAoIWFkZE5vZGVWaWV3KSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5vZGVWaWV3UmVzdWx0ID0gYWRkTm9kZVZpZXcoKTtcbiAgICAgICAgaWYgKCFub2RlVmlld1Jlc3VsdCkge1xuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBub2RldmlldyA9IChub2RlLCB2aWV3LCBnZXRQb3MsIGRlY29yYXRpb25zLCBpbm5lckRlY29yYXRpb25zKSA9PiB7XG4gICAgICAgICAgY29uc3QgSFRNTEF0dHJpYnV0ZXMgPSBnZXRSZW5kZXJlZEF0dHJpYnV0ZXMobm9kZSwgZXh0ZW5zaW9uQXR0cmlidXRlcyk7XG4gICAgICAgICAgcmV0dXJuIG5vZGVWaWV3UmVzdWx0KHtcbiAgICAgICAgICAgIC8vIHBhc3MtdGhyb3VnaFxuICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgIHZpZXcsXG4gICAgICAgICAgICBnZXRQb3MsXG4gICAgICAgICAgICBkZWNvcmF0aW9ucyxcbiAgICAgICAgICAgIGlubmVyRGVjb3JhdGlvbnMsXG4gICAgICAgICAgICAvLyB0aXB0YXAtc3BlY2lmaWNcbiAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgIGV4dGVuc2lvbixcbiAgICAgICAgICAgIEhUTUxBdHRyaWJ1dGVzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBbZXh0ZW5zaW9uLm5hbWUsIG5vZGV2aWV3XTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICBnZXQgbWFya1ZpZXdzKCkge1xuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgbWFya0V4dGVuc2lvbnMgfSA9IHNwbGl0RXh0ZW5zaW9ucyh0aGlzLmV4dGVuc2lvbnMpO1xuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICBtYXJrRXh0ZW5zaW9ucy5maWx0ZXIoKGV4dGVuc2lvbikgPT4gISFnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sIFwiYWRkTWFya1ZpZXdcIikpLm1hcCgoZXh0ZW5zaW9uKSA9PiB7XG4gICAgICAgIGNvbnN0IGV4dGVuc2lvbkF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXMuZmlsdGVyKChhdHRyaWJ1dGUpID0+IGF0dHJpYnV0ZS50eXBlID09PSBleHRlbnNpb24ubmFtZSk7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICAgICAgc3RvcmFnZTogdGhpcy5lZGl0b3IuZXh0ZW5zaW9uU3RvcmFnZVtleHRlbnNpb24ubmFtZV0sXG4gICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgIHR5cGU6IGdldE1hcmtUeXBlKGV4dGVuc2lvbi5uYW1lLCB0aGlzLnNjaGVtYSlcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgYWRkTWFya1ZpZXcgPSBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sIFwiYWRkTWFya1ZpZXdcIiwgY29udGV4dCk7XG4gICAgICAgIGlmICghYWRkTWFya1ZpZXcpIHtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWFya1ZpZXcgPSAobWFyaywgdmlldywgaW5saW5lKSA9PiB7XG4gICAgICAgICAgY29uc3QgSFRNTEF0dHJpYnV0ZXMgPSBnZXRSZW5kZXJlZEF0dHJpYnV0ZXMobWFyaywgZXh0ZW5zaW9uQXR0cmlidXRlcyk7XG4gICAgICAgICAgcmV0dXJuIGFkZE1hcmtWaWV3KCkoe1xuICAgICAgICAgICAgLy8gcGFzcy10aHJvdWdoXG4gICAgICAgICAgICBtYXJrLFxuICAgICAgICAgICAgdmlldyxcbiAgICAgICAgICAgIGlubGluZSxcbiAgICAgICAgICAgIC8vIHRpcHRhcC1zcGVjaWZpY1xuICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgZXh0ZW5zaW9uLFxuICAgICAgICAgICAgSFRNTEF0dHJpYnV0ZXMsXG4gICAgICAgICAgICB1cGRhdGVBdHRyaWJ1dGVzOiAoYXR0cnMpID0+IHtcbiAgICAgICAgICAgICAgdXBkYXRlTWFya1ZpZXdBdHRyaWJ1dGVzKG1hcmssIGVkaXRvciwgYXR0cnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gW2V4dGVuc2lvbi5uYW1lLCBtYXJrVmlld107XG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIEdvIHRocm91Z2ggYWxsIGV4dGVuc2lvbnMsIGNyZWF0ZSBleHRlbnNpb24gc3RvcmFnZXMgJiBzZXR1cCBtYXJrc1xuICAgKiAmIGJpbmQgZWRpdG9yIGV2ZW50IGxpc3RlbmVyLlxuICAgKi9cbiAgc2V0dXBFeHRlbnNpb25zKCkge1xuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSB0aGlzLmV4dGVuc2lvbnM7XG4gICAgdGhpcy5lZGl0b3IuZXh0ZW5zaW9uU3RvcmFnZSA9IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgIGV4dGVuc2lvbnMubWFwKChleHRlbnNpb24pID0+IFtleHRlbnNpb24ubmFtZSwgZXh0ZW5zaW9uLnN0b3JhZ2VdKVxuICAgICk7XG4gICAgZXh0ZW5zaW9ucy5mb3JFYWNoKChleHRlbnNpb24pID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcbiAgICAgICAgc3RvcmFnZTogdGhpcy5lZGl0b3IuZXh0ZW5zaW9uU3RvcmFnZVtleHRlbnNpb24ubmFtZV0sXG4gICAgICAgIGVkaXRvcjogdGhpcy5lZGl0b3IsXG4gICAgICAgIHR5cGU6IGdldFNjaGVtYVR5cGVCeU5hbWUoZXh0ZW5zaW9uLm5hbWUsIHRoaXMuc2NoZW1hKVxuICAgICAgfTtcbiAgICAgIGlmIChleHRlbnNpb24udHlwZSA9PT0gXCJtYXJrXCIpIHtcbiAgICAgICAgY29uc3Qga2VlcE9uU3BsaXQgPSAoX2EgPSBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCBcImtlZXBPblNwbGl0XCIsIGNvbnRleHQpKSkgIT0gbnVsbCA/IF9hIDogdHJ1ZTtcbiAgICAgICAgaWYgKGtlZXBPblNwbGl0KSB7XG4gICAgICAgICAgdGhpcy5zcGxpdHRhYmxlTWFya3MucHVzaChleHRlbnNpb24ubmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IG9uQmVmb3JlQ3JlYXRlID0gZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCBcIm9uQmVmb3JlQ3JlYXRlXCIsIGNvbnRleHQpO1xuICAgICAgY29uc3Qgb25DcmVhdGUgPSBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sIFwib25DcmVhdGVcIiwgY29udGV4dCk7XG4gICAgICBjb25zdCBvblVwZGF0ZSA9IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgXCJvblVwZGF0ZVwiLCBjb250ZXh0KTtcbiAgICAgIGNvbnN0IG9uU2VsZWN0aW9uVXBkYXRlID0gZ2V0RXh0ZW5zaW9uRmllbGQoXG4gICAgICAgIGV4dGVuc2lvbixcbiAgICAgICAgXCJvblNlbGVjdGlvblVwZGF0ZVwiLFxuICAgICAgICBjb250ZXh0XG4gICAgICApO1xuICAgICAgY29uc3Qgb25UcmFuc2FjdGlvbiA9IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgXCJvblRyYW5zYWN0aW9uXCIsIGNvbnRleHQpO1xuICAgICAgY29uc3Qgb25Gb2N1cyA9IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgXCJvbkZvY3VzXCIsIGNvbnRleHQpO1xuICAgICAgY29uc3Qgb25CbHVyID0gZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCBcIm9uQmx1clwiLCBjb250ZXh0KTtcbiAgICAgIGNvbnN0IG9uRGVzdHJveSA9IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgXCJvbkRlc3Ryb3lcIiwgY29udGV4dCk7XG4gICAgICBpZiAob25CZWZvcmVDcmVhdGUpIHtcbiAgICAgICAgdGhpcy5lZGl0b3Iub24oXCJiZWZvcmVDcmVhdGVcIiwgb25CZWZvcmVDcmVhdGUpO1xuICAgICAgfVxuICAgICAgaWYgKG9uQ3JlYXRlKSB7XG4gICAgICAgIHRoaXMuZWRpdG9yLm9uKFwiY3JlYXRlXCIsIG9uQ3JlYXRlKTtcbiAgICAgIH1cbiAgICAgIGlmIChvblVwZGF0ZSkge1xuICAgICAgICB0aGlzLmVkaXRvci5vbihcInVwZGF0ZVwiLCBvblVwZGF0ZSk7XG4gICAgICB9XG4gICAgICBpZiAob25TZWxlY3Rpb25VcGRhdGUpIHtcbiAgICAgICAgdGhpcy5lZGl0b3Iub24oXCJzZWxlY3Rpb25VcGRhdGVcIiwgb25TZWxlY3Rpb25VcGRhdGUpO1xuICAgICAgfVxuICAgICAgaWYgKG9uVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgdGhpcy5lZGl0b3Iub24oXCJ0cmFuc2FjdGlvblwiLCBvblRyYW5zYWN0aW9uKTtcbiAgICAgIH1cbiAgICAgIGlmIChvbkZvY3VzKSB7XG4gICAgICAgIHRoaXMuZWRpdG9yLm9uKFwiZm9jdXNcIiwgb25Gb2N1cyk7XG4gICAgICB9XG4gICAgICBpZiAob25CbHVyKSB7XG4gICAgICAgIHRoaXMuZWRpdG9yLm9uKFwiYmx1clwiLCBvbkJsdXIpO1xuICAgICAgfVxuICAgICAgaWYgKG9uRGVzdHJveSkge1xuICAgICAgICB0aGlzLmVkaXRvci5vbihcImRlc3Ryb3lcIiwgb25EZXN0cm95KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcbkV4dGVuc2lvbk1hbmFnZXIucmVzb2x2ZSA9IHJlc29sdmVFeHRlbnNpb25zO1xuRXh0ZW5zaW9uTWFuYWdlci5zb3J0ID0gc29ydEV4dGVuc2lvbnM7XG5FeHRlbnNpb25NYW5hZ2VyLmZsYXR0ZW4gPSBmbGF0dGVuRXh0ZW5zaW9ucztcblxuLy8gc3JjL2V4dGVuc2lvbnMvaW5kZXgudHNcbnZhciBleHRlbnNpb25zX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGV4dGVuc2lvbnNfZXhwb3J0cywge1xuICBDbGlwYm9hcmRUZXh0U2VyaWFsaXplcjogKCkgPT4gQ2xpcGJvYXJkVGV4dFNlcmlhbGl6ZXIsXG4gIENvbW1hbmRzOiAoKSA9PiBDb21tYW5kcyxcbiAgRGVsZXRlOiAoKSA9PiBEZWxldGUsXG4gIERyb3A6ICgpID0+IERyb3AsXG4gIEVkaXRhYmxlOiAoKSA9PiBFZGl0YWJsZSxcbiAgRm9jdXNFdmVudHM6ICgpID0+IEZvY3VzRXZlbnRzLFxuICBLZXltYXA6ICgpID0+IEtleW1hcCxcbiAgUGFzdGU6ICgpID0+IFBhc3RlLFxuICBUYWJpbmRleDogKCkgPT4gVGFiaW5kZXgsXG4gIFRleHREaXJlY3Rpb246ICgpID0+IFRleHREaXJlY3Rpb24sXG4gIGZvY3VzRXZlbnRzUGx1Z2luS2V5OiAoKSA9PiBmb2N1c0V2ZW50c1BsdWdpbktleVxufSk7XG5cbi8vIHNyYy9leHRlbnNpb25zL2NsaXBib2FyZFRleHRTZXJpYWxpemVyLnRzXG5pbXBvcnQgeyBQbHVnaW4gYXMgUGx1Z2luMywgUGx1Z2luS2V5IH0gZnJvbSBcIkB0aXB0YXAvcG0vc3RhdGVcIjtcblxuLy8gc3JjL0V4dGVuc2lvbi50c1xudmFyIEV4dGVuc2lvbiA9IGNsYXNzIF9FeHRlbnNpb24gZXh0ZW5kcyBFeHRlbmRhYmxlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnR5cGUgPSBcImV4dGVuc2lvblwiO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgRXh0ZW5zaW9uIGluc3RhbmNlXG4gICAqIEBwYXJhbSBjb25maWcgLSBFeHRlbnNpb24gY29uZmlndXJhdGlvbiBvYmplY3Qgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBjb25maWd1cmF0aW9uIG9iamVjdFxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZShjb25maWcgPSB7fSkge1xuICAgIGNvbnN0IHJlc29sdmVkQ29uZmlnID0gdHlwZW9mIGNvbmZpZyA9PT0gXCJmdW5jdGlvblwiID8gY29uZmlnKCkgOiBjb25maWc7XG4gICAgcmV0dXJuIG5ldyBfRXh0ZW5zaW9uKHJlc29sdmVkQ29uZmlnKTtcbiAgfVxuICBjb25maWd1cmUob3B0aW9ucykge1xuICAgIHJldHVybiBzdXBlci5jb25maWd1cmUob3B0aW9ucyk7XG4gIH1cbiAgZXh0ZW5kKGV4dGVuZGVkQ29uZmlnKSB7XG4gICAgY29uc3QgcmVzb2x2ZWRDb25maWcgPSB0eXBlb2YgZXh0ZW5kZWRDb25maWcgPT09IFwiZnVuY3Rpb25cIiA/IGV4dGVuZGVkQ29uZmlnKCkgOiBleHRlbmRlZENvbmZpZztcbiAgICByZXR1cm4gc3VwZXIuZXh0ZW5kKHJlc29sdmVkQ29uZmlnKTtcbiAgfVxufTtcblxuLy8gc3JjL2V4dGVuc2lvbnMvY2xpcGJvYXJkVGV4dFNlcmlhbGl6ZXIudHNcbnZhciBDbGlwYm9hcmRUZXh0U2VyaWFsaXplciA9IEV4dGVuc2lvbi5jcmVhdGUoe1xuICBuYW1lOiBcImNsaXBib2FyZFRleHRTZXJpYWxpemVyXCIsXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJsb2NrU2VwYXJhdG9yOiB2b2lkIDBcbiAgICB9O1xuICB9LFxuICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG5ldyBQbHVnaW4zKHtcbiAgICAgICAga2V5OiBuZXcgUGx1Z2luS2V5KFwiY2xpcGJvYXJkVGV4dFNlcmlhbGl6ZXJcIiksXG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgY2xpcGJvYXJkVGV4dFNlcmlhbGl6ZXI6ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgeyBzdGF0ZSwgc2NoZW1hIH0gPSBlZGl0b3I7XG4gICAgICAgICAgICBjb25zdCB7IGRvYywgc2VsZWN0aW9uIH0gPSBzdGF0ZTtcbiAgICAgICAgICAgIGNvbnN0IHsgcmFuZ2VzIH0gPSBzZWxlY3Rpb247XG4gICAgICAgICAgICBjb25zdCBmcm9tID0gTWF0aC5taW4oLi4ucmFuZ2VzLm1hcCgocmFuZ2UyKSA9PiByYW5nZTIuJGZyb20ucG9zKSk7XG4gICAgICAgICAgICBjb25zdCB0byA9IE1hdGgubWF4KC4uLnJhbmdlcy5tYXAoKHJhbmdlMikgPT4gcmFuZ2UyLiR0by5wb3MpKTtcbiAgICAgICAgICAgIGNvbnN0IHRleHRTZXJpYWxpemVycyA9IGdldFRleHRTZXJpYWxpemVyc0Zyb21TY2hlbWEoc2NoZW1hKTtcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlID0geyBmcm9tLCB0byB9O1xuICAgICAgICAgICAgcmV0dXJuIGdldFRleHRCZXR3ZWVuKGRvYywgcmFuZ2UsIHtcbiAgICAgICAgICAgICAgLi4udGhpcy5vcHRpb25zLmJsb2NrU2VwYXJhdG9yICE9PSB2b2lkIDAgPyB7IGJsb2NrU2VwYXJhdG9yOiB0aGlzLm9wdGlvbnMuYmxvY2tTZXBhcmF0b3IgfSA6IHt9LFxuICAgICAgICAgICAgICB0ZXh0U2VyaWFsaXplcnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICBdO1xuICB9XG59KTtcblxuLy8gc3JjL2V4dGVuc2lvbnMvY29tbWFuZHMudHNcbnZhciBDb21tYW5kcyA9IEV4dGVuc2lvbi5jcmVhdGUoe1xuICBuYW1lOiBcImNvbW1hbmRzXCIsXG4gIGFkZENvbW1hbmRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5jb21tYW5kc19leHBvcnRzXG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHNyYy9leHRlbnNpb25zL2RlbGV0ZS50c1xuaW1wb3J0IHsgUmVtb3ZlTWFya1N0ZXAgfSBmcm9tIFwiQHRpcHRhcC9wbS90cmFuc2Zvcm1cIjtcbnZhciBEZWxldGUgPSBFeHRlbnNpb24uY3JlYXRlKHtcbiAgbmFtZTogXCJkZWxldGVcIixcbiAgb25VcGRhdGUoeyB0cmFuc2FjdGlvbiwgYXBwZW5kZWRUcmFuc2FjdGlvbnMgfSkge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIGNvbnN0IGNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgdmFyIF9hMiwgX2IyLCBfYzIsIF9kO1xuICAgICAgaWYgKChfZCA9IChfYzIgPSAoX2IyID0gKF9hMiA9IHRoaXMuZWRpdG9yLm9wdGlvbnMuY29yZUV4dGVuc2lvbk9wdGlvbnMpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuZGVsZXRlKSA9PSBudWxsID8gdm9pZCAwIDogX2IyLmZpbHRlclRyYW5zYWN0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2MyLmNhbGwoX2IyLCB0cmFuc2FjdGlvbikpICE9IG51bGwgPyBfZCA6IHRyYW5zYWN0aW9uLmdldE1ldGEoXCJ5LXN5bmMkXCIpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5leHRUcmFuc2FjdGlvbiA9IGNvbWJpbmVUcmFuc2FjdGlvblN0ZXBzKHRyYW5zYWN0aW9uLmJlZm9yZSwgW3RyYW5zYWN0aW9uLCAuLi5hcHBlbmRlZFRyYW5zYWN0aW9uc10pO1xuICAgICAgY29uc3QgY2hhbmdlcyA9IGdldENoYW5nZWRSYW5nZXMobmV4dFRyYW5zYWN0aW9uKTtcbiAgICAgIGNoYW5nZXMuZm9yRWFjaCgoY2hhbmdlKSA9PiB7XG4gICAgICAgIGlmIChuZXh0VHJhbnNhY3Rpb24ubWFwcGluZy5tYXBSZXN1bHQoY2hhbmdlLm9sZFJhbmdlLmZyb20pLmRlbGV0ZWRBZnRlciAmJiBuZXh0VHJhbnNhY3Rpb24ubWFwcGluZy5tYXBSZXN1bHQoY2hhbmdlLm9sZFJhbmdlLnRvKS5kZWxldGVkQmVmb3JlKSB7XG4gICAgICAgICAgbmV4dFRyYW5zYWN0aW9uLmJlZm9yZS5ub2Rlc0JldHdlZW4oY2hhbmdlLm9sZFJhbmdlLmZyb20sIGNoYW5nZS5vbGRSYW5nZS50bywgKG5vZGUsIGZyb20pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRvID0gZnJvbSArIG5vZGUubm9kZVNpemUgLSAyO1xuICAgICAgICAgICAgY29uc3QgaXNGdWxseVdpdGhpblJhbmdlID0gY2hhbmdlLm9sZFJhbmdlLmZyb20gPD0gZnJvbSAmJiB0byA8PSBjaGFuZ2Uub2xkUmFuZ2UudG87XG4gICAgICAgICAgICB0aGlzLmVkaXRvci5lbWl0KFwiZGVsZXRlXCIsIHtcbiAgICAgICAgICAgICAgdHlwZTogXCJub2RlXCIsXG4gICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgIGZyb20sXG4gICAgICAgICAgICAgIHRvLFxuICAgICAgICAgICAgICBuZXdGcm9tOiBuZXh0VHJhbnNhY3Rpb24ubWFwcGluZy5tYXAoZnJvbSksXG4gICAgICAgICAgICAgIG5ld1RvOiBuZXh0VHJhbnNhY3Rpb24ubWFwcGluZy5tYXAodG8pLFxuICAgICAgICAgICAgICBkZWxldGVkUmFuZ2U6IGNoYW5nZS5vbGRSYW5nZSxcbiAgICAgICAgICAgICAgbmV3UmFuZ2U6IGNoYW5nZS5uZXdSYW5nZSxcbiAgICAgICAgICAgICAgcGFydGlhbDogIWlzRnVsbHlXaXRoaW5SYW5nZSxcbiAgICAgICAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcbiAgICAgICAgICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICAgICAgICAgIGNvbWJpbmVkVHJhbnNmb3JtOiBuZXh0VHJhbnNhY3Rpb25cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG1hcHBpbmcgPSBuZXh0VHJhbnNhY3Rpb24ubWFwcGluZztcbiAgICAgIG5leHRUcmFuc2FjdGlvbi5zdGVwcy5mb3JFYWNoKChzdGVwLCBpbmRleCkgPT4ge1xuICAgICAgICB2YXIgX2EzLCBfYjM7XG4gICAgICAgIGlmIChzdGVwIGluc3RhbmNlb2YgUmVtb3ZlTWFya1N0ZXApIHtcbiAgICAgICAgICBjb25zdCBuZXdTdGFydCA9IG1hcHBpbmcuc2xpY2UoaW5kZXgpLm1hcChzdGVwLmZyb20sIC0xKTtcbiAgICAgICAgICBjb25zdCBuZXdFbmQgPSBtYXBwaW5nLnNsaWNlKGluZGV4KS5tYXAoc3RlcC50byk7XG4gICAgICAgICAgY29uc3Qgb2xkU3RhcnQgPSBtYXBwaW5nLmludmVydCgpLm1hcChuZXdTdGFydCwgLTEpO1xuICAgICAgICAgIGNvbnN0IG9sZEVuZCA9IG1hcHBpbmcuaW52ZXJ0KCkubWFwKG5ld0VuZCk7XG4gICAgICAgICAgY29uc3QgZm91bmRCZWZvcmVNYXJrID0gKF9hMyA9IG5leHRUcmFuc2FjdGlvbi5kb2Mubm9kZUF0KG5ld1N0YXJ0IC0gMSkpID09IG51bGwgPyB2b2lkIDAgOiBfYTMubWFya3Muc29tZSgobWFyaykgPT4gbWFyay5lcShzdGVwLm1hcmspKTtcbiAgICAgICAgICBjb25zdCBmb3VuZEFmdGVyTWFyayA9IChfYjMgPSBuZXh0VHJhbnNhY3Rpb24uZG9jLm5vZGVBdChuZXdFbmQpKSA9PSBudWxsID8gdm9pZCAwIDogX2IzLm1hcmtzLnNvbWUoKG1hcmspID0+IG1hcmsuZXEoc3RlcC5tYXJrKSk7XG4gICAgICAgICAgdGhpcy5lZGl0b3IuZW1pdChcImRlbGV0ZVwiLCB7XG4gICAgICAgICAgICB0eXBlOiBcIm1hcmtcIixcbiAgICAgICAgICAgIG1hcms6IHN0ZXAubWFyayxcbiAgICAgICAgICAgIGZyb206IHN0ZXAuZnJvbSxcbiAgICAgICAgICAgIHRvOiBzdGVwLnRvLFxuICAgICAgICAgICAgZGVsZXRlZFJhbmdlOiB7XG4gICAgICAgICAgICAgIGZyb206IG9sZFN0YXJ0LFxuICAgICAgICAgICAgICB0bzogb2xkRW5kXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmV3UmFuZ2U6IHtcbiAgICAgICAgICAgICAgZnJvbTogbmV3U3RhcnQsXG4gICAgICAgICAgICAgIHRvOiBuZXdFbmRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXJ0aWFsOiBCb29sZWFuKGZvdW5kQWZ0ZXJNYXJrIHx8IGZvdW5kQmVmb3JlTWFyayksXG4gICAgICAgICAgICBlZGl0b3I6IHRoaXMuZWRpdG9yLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICAgICAgICBjb21iaW5lZFRyYW5zZm9ybTogbmV4dFRyYW5zYWN0aW9uXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgaWYgKChfYyA9IChfYiA9IChfYSA9IHRoaXMuZWRpdG9yLm9wdGlvbnMuY29yZUV4dGVuc2lvbk9wdGlvbnMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5kZWxldGUpID09IG51bGwgPyB2b2lkIDAgOiBfYi5hc3luYykgIT0gbnVsbCA/IF9jIDogdHJ1ZSkge1xuICAgICAgc2V0VGltZW91dChjYWxsYmFjaywgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICB9XG59KTtcblxuLy8gc3JjL2V4dGVuc2lvbnMvZHJvcC50c1xuaW1wb3J0IHsgUGx1Z2luIGFzIFBsdWdpbjQsIFBsdWdpbktleSBhcyBQbHVnaW5LZXkyIH0gZnJvbSBcIkB0aXB0YXAvcG0vc3RhdGVcIjtcbnZhciBEcm9wID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gIG5hbWU6IFwiZHJvcFwiLFxuICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG5ldyBQbHVnaW40KHtcbiAgICAgICAga2V5OiBuZXcgUGx1Z2luS2V5MihcInRpcHRhcERyb3BcIiksXG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgaGFuZGxlRHJvcDogKF8sIGUsIHNsaWNlLCBtb3ZlZCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lZGl0b3IuZW1pdChcImRyb3BcIiwge1xuICAgICAgICAgICAgICBlZGl0b3I6IHRoaXMuZWRpdG9yLFxuICAgICAgICAgICAgICBldmVudDogZSxcbiAgICAgICAgICAgICAgc2xpY2UsXG4gICAgICAgICAgICAgIG1vdmVkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgXTtcbiAgfVxufSk7XG5cbi8vIHNyYy9leHRlbnNpb25zL2VkaXRhYmxlLnRzXG5pbXBvcnQgeyBQbHVnaW4gYXMgUGx1Z2luNSwgUGx1Z2luS2V5IGFzIFBsdWdpbktleTMgfSBmcm9tIFwiQHRpcHRhcC9wbS9zdGF0ZVwiO1xudmFyIEVkaXRhYmxlID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gIG5hbWU6IFwiZWRpdGFibGVcIixcbiAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgIHJldHVybiBbXG4gICAgICBuZXcgUGx1Z2luNSh7XG4gICAgICAgIGtleTogbmV3IFBsdWdpbktleTMoXCJlZGl0YWJsZVwiKSxcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBlZGl0YWJsZTogKCkgPT4gdGhpcy5lZGl0b3Iub3B0aW9ucy5lZGl0YWJsZVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIF07XG4gIH1cbn0pO1xuXG4vLyBzcmMvZXh0ZW5zaW9ucy9mb2N1c0V2ZW50cy50c1xuaW1wb3J0IHsgUGx1Z2luIGFzIFBsdWdpbjYsIFBsdWdpbktleSBhcyBQbHVnaW5LZXk0IH0gZnJvbSBcIkB0aXB0YXAvcG0vc3RhdGVcIjtcbnZhciBmb2N1c0V2ZW50c1BsdWdpbktleSA9IG5ldyBQbHVnaW5LZXk0KFwiZm9jdXNFdmVudHNcIik7XG52YXIgRm9jdXNFdmVudHMgPSBFeHRlbnNpb24uY3JlYXRlKHtcbiAgbmFtZTogXCJmb2N1c0V2ZW50c1wiLFxuICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXM7XG4gICAgcmV0dXJuIFtcbiAgICAgIG5ldyBQbHVnaW42KHtcbiAgICAgICAga2V5OiBmb2N1c0V2ZW50c1BsdWdpbktleSxcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBoYW5kbGVET01FdmVudHM6IHtcbiAgICAgICAgICAgIGZvY3VzOiAodmlldywgZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgZWRpdG9yLmlzRm9jdXNlZCA9IHRydWU7XG4gICAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gZWRpdG9yLnN0YXRlLnRyLnNldE1ldGEoXCJmb2N1c1wiLCB7IGV2ZW50IH0pLnNldE1ldGEoXCJhZGRUb0hpc3RvcnlcIiwgZmFsc2UpO1xuICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJsdXI6ICh2aWV3LCBldmVudCkgPT4ge1xuICAgICAgICAgICAgICBlZGl0b3IuaXNGb2N1c2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gZWRpdG9yLnN0YXRlLnRyLnNldE1ldGEoXCJibHVyXCIsIHsgZXZlbnQgfSkuc2V0TWV0YShcImFkZFRvSGlzdG9yeVwiLCBmYWxzZSk7XG4gICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2godHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIF07XG4gIH1cbn0pO1xuXG4vLyBzcmMvZXh0ZW5zaW9ucy9rZXltYXAudHNcbmltcG9ydCB7IFBsdWdpbiBhcyBQbHVnaW43LCBQbHVnaW5LZXkgYXMgUGx1Z2luS2V5NSwgU2VsZWN0aW9uIGFzIFNlbGVjdGlvbjMgfSBmcm9tIFwiQHRpcHRhcC9wbS9zdGF0ZVwiO1xudmFyIEtleW1hcCA9IEV4dGVuc2lvbi5jcmVhdGUoe1xuICBuYW1lOiBcImtleW1hcFwiLFxuICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICBjb25zdCBoYW5kbGVCYWNrc3BhY2UgPSAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5maXJzdCgoeyBjb21tYW5kcyB9KSA9PiBbXG4gICAgICAoKSA9PiBjb21tYW5kcy51bmRvSW5wdXRSdWxlKCksXG4gICAgICAvLyBtYXliZSBjb252ZXJ0IGZpcnN0IHRleHQgYmxvY2sgbm9kZSB0byBkZWZhdWx0IG5vZGVcbiAgICAgICgpID0+IGNvbW1hbmRzLmNvbW1hbmQoKHsgdHIgfSkgPT4ge1xuICAgICAgICBjb25zdCB7IHNlbGVjdGlvbiwgZG9jIH0gPSB0cjtcbiAgICAgICAgY29uc3QgeyBlbXB0eSwgJGFuY2hvciB9ID0gc2VsZWN0aW9uO1xuICAgICAgICBjb25zdCB7IHBvcywgcGFyZW50IH0gPSAkYW5jaG9yO1xuICAgICAgICBjb25zdCAkcGFyZW50UG9zID0gJGFuY2hvci5wYXJlbnQuaXNUZXh0YmxvY2sgJiYgcG9zID4gMCA/IHRyLmRvYy5yZXNvbHZlKHBvcyAtIDEpIDogJGFuY2hvcjtcbiAgICAgICAgY29uc3QgcGFyZW50SXNJc29sYXRpbmcgPSAkcGFyZW50UG9zLnBhcmVudC50eXBlLnNwZWMuaXNvbGF0aW5nO1xuICAgICAgICBjb25zdCBwYXJlbnRQb3MgPSAkYW5jaG9yLnBvcyAtICRhbmNob3IucGFyZW50T2Zmc2V0O1xuICAgICAgICBjb25zdCBpc0F0U3RhcnQgPSBwYXJlbnRJc0lzb2xhdGluZyAmJiAkcGFyZW50UG9zLnBhcmVudC5jaGlsZENvdW50ID09PSAxID8gcGFyZW50UG9zID09PSAkYW5jaG9yLnBvcyA6IFNlbGVjdGlvbjMuYXRTdGFydChkb2MpLmZyb20gPT09IHBvcztcbiAgICAgICAgaWYgKCFlbXB0eSB8fCAhcGFyZW50LnR5cGUuaXNUZXh0YmxvY2sgfHwgcGFyZW50LnRleHRDb250ZW50Lmxlbmd0aCB8fCAhaXNBdFN0YXJ0IHx8IGlzQXRTdGFydCAmJiAkYW5jaG9yLnBhcmVudC50eXBlLm5hbWUgPT09IFwicGFyYWdyYXBoXCIpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLmNsZWFyTm9kZXMoKTtcbiAgICAgIH0pLFxuICAgICAgKCkgPT4gY29tbWFuZHMuZGVsZXRlU2VsZWN0aW9uKCksXG4gICAgICAoKSA9PiBjb21tYW5kcy5qb2luQmFja3dhcmQoKSxcbiAgICAgICgpID0+IGNvbW1hbmRzLnNlbGVjdE5vZGVCYWNrd2FyZCgpXG4gICAgXSk7XG4gICAgY29uc3QgaGFuZGxlRGVsZXRlID0gKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuZmlyc3QoKHsgY29tbWFuZHMgfSkgPT4gW1xuICAgICAgKCkgPT4gY29tbWFuZHMuZGVsZXRlU2VsZWN0aW9uKCksXG4gICAgICAoKSA9PiBjb21tYW5kcy5kZWxldGVDdXJyZW50Tm9kZSgpLFxuICAgICAgKCkgPT4gY29tbWFuZHMuam9pbkZvcndhcmQoKSxcbiAgICAgICgpID0+IGNvbW1hbmRzLnNlbGVjdE5vZGVGb3J3YXJkKClcbiAgICBdKTtcbiAgICBjb25zdCBoYW5kbGVFbnRlciA9ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLmZpcnN0KCh7IGNvbW1hbmRzIH0pID0+IFtcbiAgICAgICgpID0+IGNvbW1hbmRzLm5ld2xpbmVJbkNvZGUoKSxcbiAgICAgICgpID0+IGNvbW1hbmRzLmNyZWF0ZVBhcmFncmFwaE5lYXIoKSxcbiAgICAgICgpID0+IGNvbW1hbmRzLmxpZnRFbXB0eUJsb2NrKCksXG4gICAgICAoKSA9PiBjb21tYW5kcy5zcGxpdEJsb2NrKClcbiAgICBdKTtcbiAgICBjb25zdCBiYXNlS2V5bWFwID0ge1xuICAgICAgRW50ZXI6IGhhbmRsZUVudGVyLFxuICAgICAgXCJNb2QtRW50ZXJcIjogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuZXhpdENvZGUoKSxcbiAgICAgIEJhY2tzcGFjZTogaGFuZGxlQmFja3NwYWNlLFxuICAgICAgXCJNb2QtQmFja3NwYWNlXCI6IGhhbmRsZUJhY2tzcGFjZSxcbiAgICAgIFwiU2hpZnQtQmFja3NwYWNlXCI6IGhhbmRsZUJhY2tzcGFjZSxcbiAgICAgIERlbGV0ZTogaGFuZGxlRGVsZXRlLFxuICAgICAgXCJNb2QtRGVsZXRlXCI6IGhhbmRsZURlbGV0ZSxcbiAgICAgIFwiTW9kLWFcIjogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuc2VsZWN0QWxsKClcbiAgICB9O1xuICAgIGNvbnN0IHBjS2V5bWFwID0ge1xuICAgICAgLi4uYmFzZUtleW1hcFxuICAgIH07XG4gICAgY29uc3QgbWFjS2V5bWFwID0ge1xuICAgICAgLi4uYmFzZUtleW1hcCxcbiAgICAgIFwiQ3RybC1oXCI6IGhhbmRsZUJhY2tzcGFjZSxcbiAgICAgIFwiQWx0LUJhY2tzcGFjZVwiOiBoYW5kbGVCYWNrc3BhY2UsXG4gICAgICBcIkN0cmwtZFwiOiBoYW5kbGVEZWxldGUsXG4gICAgICBcIkN0cmwtQWx0LUJhY2tzcGFjZVwiOiBoYW5kbGVEZWxldGUsXG4gICAgICBcIkFsdC1EZWxldGVcIjogaGFuZGxlRGVsZXRlLFxuICAgICAgXCJBbHQtZFwiOiBoYW5kbGVEZWxldGUsXG4gICAgICBcIkN0cmwtYVwiOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5zZWxlY3RUZXh0YmxvY2tTdGFydCgpLFxuICAgICAgXCJDdHJsLWVcIjogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuc2VsZWN0VGV4dGJsb2NrRW5kKClcbiAgICB9O1xuICAgIGlmIChpc2lPUygpIHx8IGlzTWFjT1MoKSkge1xuICAgICAgcmV0dXJuIG1hY0tleW1hcDtcbiAgICB9XG4gICAgcmV0dXJuIHBjS2V5bWFwO1xuICB9LFxuICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIC8vIFdpdGggdGhpcyBwbHVnaW4gd2UgY2hlY2sgaWYgdGhlIHdob2xlIGRvY3VtZW50IHdhcyBzZWxlY3RlZCBhbmQgZGVsZXRlZC5cbiAgICAgIC8vIEluIHRoaXMgY2FzZSB3ZSB3aWxsIGFkZGl0aW9uYWxseSBjYWxsIGBjbGVhck5vZGVzKClgIHRvIGNvbnZlcnQgZS5nLiBhIGhlYWRpbmdcbiAgICAgIC8vIHRvIGEgcGFyYWdyYXBoIGlmIG5lY2Vzc2FyeS5cbiAgICAgIC8vIFRoaXMgaXMgYW4gYWx0ZXJuYXRpdmUgdG8gUHJvc2VNaXJyb3IncyBgQWxsU2VsZWN0aW9uYCwgd2hpY2ggZG9lc27igJl0IHdvcmsgd2VsbFxuICAgICAgLy8gd2l0aCBtYW55IG90aGVyIGNvbW1hbmRzLlxuICAgICAgbmV3IFBsdWdpbjcoe1xuICAgICAgICBrZXk6IG5ldyBQbHVnaW5LZXk1KFwiY2xlYXJEb2N1bWVudFwiKSxcbiAgICAgICAgYXBwZW5kVHJhbnNhY3Rpb246ICh0cmFuc2FjdGlvbnMsIG9sZFN0YXRlLCBuZXdTdGF0ZSkgPT4ge1xuICAgICAgICAgIGlmICh0cmFuc2FjdGlvbnMuc29tZSgodHIyKSA9PiB0cjIuZ2V0TWV0YShcImNvbXBvc2l0aW9uXCIpKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBkb2NDaGFuZ2VzID0gdHJhbnNhY3Rpb25zLnNvbWUoKHRyYW5zYWN0aW9uKSA9PiB0cmFuc2FjdGlvbi5kb2NDaGFuZ2VkKSAmJiAhb2xkU3RhdGUuZG9jLmVxKG5ld1N0YXRlLmRvYyk7XG4gICAgICAgICAgY29uc3QgaWdub3JlVHIgPSB0cmFuc2FjdGlvbnMuc29tZSgodHJhbnNhY3Rpb24pID0+IHRyYW5zYWN0aW9uLmdldE1ldGEoXCJwcmV2ZW50Q2xlYXJEb2N1bWVudFwiKSk7XG4gICAgICAgICAgaWYgKCFkb2NDaGFuZ2VzIHx8IGlnbm9yZVRyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHsgZW1wdHksIGZyb20sIHRvIH0gPSBvbGRTdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgICAgY29uc3QgYWxsRnJvbSA9IFNlbGVjdGlvbjMuYXRTdGFydChvbGRTdGF0ZS5kb2MpLmZyb207XG4gICAgICAgICAgY29uc3QgYWxsRW5kID0gU2VsZWN0aW9uMy5hdEVuZChvbGRTdGF0ZS5kb2MpLnRvO1xuICAgICAgICAgIGNvbnN0IGFsbFdhc1NlbGVjdGVkID0gZnJvbSA9PT0gYWxsRnJvbSAmJiB0byA9PT0gYWxsRW5kO1xuICAgICAgICAgIGlmIChlbXB0eSB8fCAhYWxsV2FzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgaXNFbXB0eSA9IGlzTm9kZUVtcHR5KG5ld1N0YXRlLmRvYyk7XG4gICAgICAgICAgaWYgKCFpc0VtcHR5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHRyID0gbmV3U3RhdGUudHI7XG4gICAgICAgICAgY29uc3Qgc3RhdGUgPSBjcmVhdGVDaGFpbmFibGVTdGF0ZSh7XG4gICAgICAgICAgICBzdGF0ZTogbmV3U3RhdGUsXG4gICAgICAgICAgICB0cmFuc2FjdGlvbjogdHJcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb25zdCB7IGNvbW1hbmRzIH0gPSBuZXcgQ29tbWFuZE1hbmFnZXIoe1xuICAgICAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcbiAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29tbWFuZHMuY2xlYXJOb2RlcygpO1xuICAgICAgICAgIGlmICghdHIuc3RlcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cjtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICBdO1xuICB9XG59KTtcblxuLy8gc3JjL2V4dGVuc2lvbnMvcGFzdGUudHNcbmltcG9ydCB7IFBsdWdpbiBhcyBQbHVnaW44LCBQbHVnaW5LZXkgYXMgUGx1Z2luS2V5NiB9IGZyb20gXCJAdGlwdGFwL3BtL3N0YXRlXCI7XG52YXIgUGFzdGUgPSBFeHRlbnNpb24uY3JlYXRlKHtcbiAgbmFtZTogXCJwYXN0ZVwiLFxuICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG5ldyBQbHVnaW44KHtcbiAgICAgICAga2V5OiBuZXcgUGx1Z2luS2V5NihcInRpcHRhcFBhc3RlXCIpLFxuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIGhhbmRsZVBhc3RlOiAoX3ZpZXcsIGUsIHNsaWNlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVkaXRvci5lbWl0KFwicGFzdGVcIiwge1xuICAgICAgICAgICAgICBlZGl0b3I6IHRoaXMuZWRpdG9yLFxuICAgICAgICAgICAgICBldmVudDogZSxcbiAgICAgICAgICAgICAgc2xpY2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICBdO1xuICB9XG59KTtcblxuLy8gc3JjL2V4dGVuc2lvbnMvdGFiaW5kZXgudHNcbmltcG9ydCB7IFBsdWdpbiBhcyBQbHVnaW45LCBQbHVnaW5LZXkgYXMgUGx1Z2luS2V5NyB9IGZyb20gXCJAdGlwdGFwL3BtL3N0YXRlXCI7XG52YXIgVGFiaW5kZXggPSBFeHRlbnNpb24uY3JlYXRlKHtcbiAgbmFtZTogXCJ0YWJpbmRleFwiLFxuICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG5ldyBQbHVnaW45KHtcbiAgICAgICAga2V5OiBuZXcgUGx1Z2luS2V5NyhcInRhYmluZGV4XCIpLFxuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIGF0dHJpYnV0ZXM6ICgpID0+IHRoaXMuZWRpdG9yLmlzRWRpdGFibGUgPyB7IHRhYmluZGV4OiBcIjBcIiB9IDoge31cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICBdO1xuICB9XG59KTtcblxuLy8gc3JjL2V4dGVuc2lvbnMvdGV4dERpcmVjdGlvbi50c1xuaW1wb3J0IHsgUGx1Z2luIGFzIFBsdWdpbjEwLCBQbHVnaW5LZXkgYXMgUGx1Z2luS2V5OCB9IGZyb20gXCJAdGlwdGFwL3BtL3N0YXRlXCI7XG52YXIgVGV4dERpcmVjdGlvbiA9IEV4dGVuc2lvbi5jcmVhdGUoe1xuICBuYW1lOiBcInRleHREaXJlY3Rpb25cIixcbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZGlyZWN0aW9uOiB2b2lkIDBcbiAgICB9O1xuICB9LFxuICBhZGRHbG9iYWxBdHRyaWJ1dGVzKCkge1xuICAgIGlmICghdGhpcy5vcHRpb25zLmRpcmVjdGlvbikge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCB7IG5vZGVFeHRlbnNpb25zIH0gPSBzcGxpdEV4dGVuc2lvbnModGhpcy5leHRlbnNpb25zKTtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICB0eXBlczogbm9kZUV4dGVuc2lvbnMuZmlsdGVyKChleHRlbnNpb24pID0+IGV4dGVuc2lvbi5uYW1lICE9PSBcInRleHRcIikubWFwKChleHRlbnNpb24pID0+IGV4dGVuc2lvbi5uYW1lKSxcbiAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgIGRpcjoge1xuICAgICAgICAgICAgZGVmYXVsdDogdGhpcy5vcHRpb25zLmRpcmVjdGlvbixcbiAgICAgICAgICAgIHBhcnNlSFRNTDogKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgZGlyID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkaXJcIik7XG4gICAgICAgICAgICAgIGlmIChkaXIgJiYgKGRpciA9PT0gXCJsdHJcIiB8fCBkaXIgPT09IFwicnRsXCIgfHwgZGlyID09PSBcImF1dG9cIikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZGlyZWN0aW9uO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlbmRlckhUTUw6IChhdHRyaWJ1dGVzKSA9PiB7XG4gICAgICAgICAgICAgIGlmICghYXR0cmlidXRlcy5kaXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkaXI6IGF0dHJpYnV0ZXMuZGlyXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgXTtcbiAgfSxcbiAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgIHJldHVybiBbXG4gICAgICBuZXcgUGx1Z2luMTAoe1xuICAgICAgICBrZXk6IG5ldyBQbHVnaW5LZXk4KFwidGV4dERpcmVjdGlvblwiKSxcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBhdHRyaWJ1dGVzOiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkaXJlY3Rpb24gPSB0aGlzLm9wdGlvbnMuZGlyZWN0aW9uO1xuICAgICAgICAgICAgaWYgKCFkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgZGlyOiBkaXJlY3Rpb25cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIF07XG4gIH1cbn0pO1xuXG4vLyBzcmMvTm9kZVBvcy50c1xudmFyIE5vZGVQb3MgPSBjbGFzcyBfTm9kZVBvcyB7XG4gIGNvbnN0cnVjdG9yKHBvcywgZWRpdG9yLCBpc0Jsb2NrID0gZmFsc2UsIG5vZGUgPSBudWxsKSB7XG4gICAgdGhpcy5jdXJyZW50Tm9kZSA9IG51bGw7XG4gICAgdGhpcy5hY3R1YWxEZXB0aCA9IG51bGw7XG4gICAgdGhpcy5pc0Jsb2NrID0gaXNCbG9jaztcbiAgICB0aGlzLnJlc29sdmVkUG9zID0gcG9zO1xuICAgIHRoaXMuZWRpdG9yID0gZWRpdG9yO1xuICAgIHRoaXMuY3VycmVudE5vZGUgPSBub2RlO1xuICB9XG4gIGdldCBuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLm5vZGUudHlwZS5uYW1lO1xuICB9XG4gIGdldCBub2RlKCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnROb2RlIHx8IHRoaXMucmVzb2x2ZWRQb3Mubm9kZSgpO1xuICB9XG4gIGdldCBlbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLmVkaXRvci52aWV3LmRvbUF0UG9zKHRoaXMucG9zKS5ub2RlO1xuICB9XG4gIGdldCBkZXB0aCgpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIChfYSA9IHRoaXMuYWN0dWFsRGVwdGgpICE9IG51bGwgPyBfYSA6IHRoaXMucmVzb2x2ZWRQb3MuZGVwdGg7XG4gIH1cbiAgZ2V0IHBvcygpIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHZlZFBvcy5wb3M7XG4gIH1cbiAgZ2V0IGNvbnRlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZS5jb250ZW50O1xuICB9XG4gIHNldCBjb250ZW50KGNvbnRlbnQpIHtcbiAgICBsZXQgZnJvbSA9IHRoaXMuZnJvbTtcbiAgICBsZXQgdG8gPSB0aGlzLnRvO1xuICAgIGlmICh0aGlzLmlzQmxvY2spIHtcbiAgICAgIGlmICh0aGlzLmNvbnRlbnQuc2l6ZSA9PT0gMCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBZb3UgY2FuXFx1MjAxOXQgc2V0IGNvbnRlbnQgb24gYSBibG9jayBub2RlLiBUcmllZCB0byBzZXQgY29udGVudCBvbiAke3RoaXMubmFtZX0gYXQgJHt0aGlzLnBvc31gKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZnJvbSA9IHRoaXMuZnJvbSArIDE7XG4gICAgICB0byA9IHRoaXMudG8gLSAxO1xuICAgIH1cbiAgICB0aGlzLmVkaXRvci5jb21tYW5kcy5pbnNlcnRDb250ZW50QXQoeyBmcm9tLCB0byB9LCBjb250ZW50KTtcbiAgfVxuICBnZXQgYXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlLmF0dHJzO1xuICB9XG4gIGdldCB0ZXh0Q29udGVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlLnRleHRDb250ZW50O1xuICB9XG4gIGdldCBzaXplKCkge1xuICAgIHJldHVybiB0aGlzLm5vZGUubm9kZVNpemU7XG4gIH1cbiAgZ2V0IGZyb20oKSB7XG4gICAgaWYgKHRoaXMuaXNCbG9jaykge1xuICAgICAgcmV0dXJuIHRoaXMucG9zO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5yZXNvbHZlZFBvcy5zdGFydCh0aGlzLnJlc29sdmVkUG9zLmRlcHRoKTtcbiAgfVxuICBnZXQgcmFuZ2UoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZyb206IHRoaXMuZnJvbSxcbiAgICAgIHRvOiB0aGlzLnRvXG4gICAgfTtcbiAgfVxuICBnZXQgdG8oKSB7XG4gICAgaWYgKHRoaXMuaXNCbG9jaykge1xuICAgICAgcmV0dXJuIHRoaXMucG9zICsgdGhpcy5zaXplO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5yZXNvbHZlZFBvcy5lbmQodGhpcy5yZXNvbHZlZFBvcy5kZXB0aCkgKyAodGhpcy5ub2RlLmlzVGV4dCA/IDAgOiAxKTtcbiAgfVxuICBnZXQgcGFyZW50KCkge1xuICAgIGlmICh0aGlzLmRlcHRoID09PSAwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcGFyZW50UG9zID0gdGhpcy5yZXNvbHZlZFBvcy5zdGFydCh0aGlzLnJlc29sdmVkUG9zLmRlcHRoIC0gMSk7XG4gICAgY29uc3QgJHBvcyA9IHRoaXMucmVzb2x2ZWRQb3MuZG9jLnJlc29sdmUocGFyZW50UG9zKTtcbiAgICByZXR1cm4gbmV3IF9Ob2RlUG9zKCRwb3MsIHRoaXMuZWRpdG9yKTtcbiAgfVxuICBnZXQgYmVmb3JlKCkge1xuICAgIGxldCAkcG9zID0gdGhpcy5yZXNvbHZlZFBvcy5kb2MucmVzb2x2ZSh0aGlzLmZyb20gLSAodGhpcy5pc0Jsb2NrID8gMSA6IDIpKTtcbiAgICBpZiAoJHBvcy5kZXB0aCAhPT0gdGhpcy5kZXB0aCkge1xuICAgICAgJHBvcyA9IHRoaXMucmVzb2x2ZWRQb3MuZG9jLnJlc29sdmUodGhpcy5mcm9tIC0gMyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgX05vZGVQb3MoJHBvcywgdGhpcy5lZGl0b3IpO1xuICB9XG4gIGdldCBhZnRlcigpIHtcbiAgICBsZXQgJHBvcyA9IHRoaXMucmVzb2x2ZWRQb3MuZG9jLnJlc29sdmUodGhpcy50byArICh0aGlzLmlzQmxvY2sgPyAyIDogMSkpO1xuICAgIGlmICgkcG9zLmRlcHRoICE9PSB0aGlzLmRlcHRoKSB7XG4gICAgICAkcG9zID0gdGhpcy5yZXNvbHZlZFBvcy5kb2MucmVzb2x2ZSh0aGlzLnRvICsgMyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgX05vZGVQb3MoJHBvcywgdGhpcy5lZGl0b3IpO1xuICB9XG4gIGdldCBjaGlsZHJlbigpIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IFtdO1xuICAgIHRoaXMubm9kZS5jb250ZW50LmZvckVhY2goKG5vZGUsIG9mZnNldCkgPT4ge1xuICAgICAgY29uc3QgaXNCbG9jayA9IG5vZGUuaXNCbG9jayAmJiAhbm9kZS5pc1RleHRibG9jaztcbiAgICAgIGNvbnN0IGlzTm9uVGV4dEF0b20gPSBub2RlLmlzQXRvbSAmJiAhbm9kZS5pc1RleHQ7XG4gICAgICBjb25zdCB0YXJnZXRQb3MgPSB0aGlzLnBvcyArIG9mZnNldCArIChpc05vblRleHRBdG9tID8gMCA6IDEpO1xuICAgICAgaWYgKHRhcmdldFBvcyA8IDAgfHwgdGFyZ2V0UG9zID4gdGhpcy5yZXNvbHZlZFBvcy5kb2Mubm9kZVNpemUgLSAyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0ICRwb3MgPSB0aGlzLnJlc29sdmVkUG9zLmRvYy5yZXNvbHZlKHRhcmdldFBvcyk7XG4gICAgICBpZiAoIWlzQmxvY2sgJiYgJHBvcy5kZXB0aCA8PSB0aGlzLmRlcHRoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNoaWxkTm9kZVBvcyA9IG5ldyBfTm9kZVBvcygkcG9zLCB0aGlzLmVkaXRvciwgaXNCbG9jaywgaXNCbG9jayA/IG5vZGUgOiBudWxsKTtcbiAgICAgIGlmIChpc0Jsb2NrKSB7XG4gICAgICAgIGNoaWxkTm9kZVBvcy5hY3R1YWxEZXB0aCA9IHRoaXMuZGVwdGggKyAxO1xuICAgICAgfVxuICAgICAgY2hpbGRyZW4ucHVzaChuZXcgX05vZGVQb3MoJHBvcywgdGhpcy5lZGl0b3IsIGlzQmxvY2ssIGlzQmxvY2sgPyBub2RlIDogbnVsbCkpO1xuICAgIH0pO1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuICBnZXQgZmlyc3RDaGlsZCgpIHtcbiAgICByZXR1cm4gdGhpcy5jaGlsZHJlblswXSB8fCBudWxsO1xuICB9XG4gIGdldCBsYXN0Q2hpbGQoKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuICAgIHJldHVybiBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXSB8fCBudWxsO1xuICB9XG4gIGNsb3Nlc3Qoc2VsZWN0b3IsIGF0dHJpYnV0ZXMgPSB7fSkge1xuICAgIGxldCBub2RlID0gbnVsbDtcbiAgICBsZXQgY3VycmVudE5vZGUgPSB0aGlzLnBhcmVudDtcbiAgICB3aGlsZSAoY3VycmVudE5vZGUgJiYgIW5vZGUpIHtcbiAgICAgIGlmIChjdXJyZW50Tm9kZS5ub2RlLnR5cGUubmFtZSA9PT0gc2VsZWN0b3IpIHtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zdCBub2RlQXR0cmlidXRlcyA9IGN1cnJlbnROb2RlLm5vZGUuYXR0cnM7XG4gICAgICAgICAgY29uc3QgYXR0cktleXMgPSBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKTtcbiAgICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgYXR0cktleXMubGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBhdHRyS2V5c1tpbmRleF07XG4gICAgICAgICAgICBpZiAobm9kZUF0dHJpYnV0ZXNba2V5XSAhPT0gYXR0cmlidXRlc1trZXldKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlID0gY3VycmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUucGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBxdWVyeVNlbGVjdG9yKHNlbGVjdG9yLCBhdHRyaWJ1dGVzID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yLCBhdHRyaWJ1dGVzLCB0cnVlKVswXSB8fCBudWxsO1xuICB9XG4gIHF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IsIGF0dHJpYnV0ZXMgPSB7fSwgZmlyc3RJdGVtT25seSA9IGZhbHNlKSB7XG4gICAgbGV0IG5vZGVzID0gW107XG4gICAgaWYgKCF0aGlzLmNoaWxkcmVuIHx8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gbm9kZXM7XG4gICAgfVxuICAgIGNvbnN0IGF0dHJLZXlzID0gT2JqZWN0LmtleXMoYXR0cmlidXRlcyk7XG4gICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKChjaGlsZFBvcykgPT4ge1xuICAgICAgaWYgKGZpcnN0SXRlbU9ubHkgJiYgbm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoY2hpbGRQb3Mubm9kZS50eXBlLm5hbWUgPT09IHNlbGVjdG9yKSB7XG4gICAgICAgIGNvbnN0IGRvZXNBbGxBdHRyaWJ1dGVzTWF0Y2ggPSBhdHRyS2V5cy5ldmVyeSgoa2V5KSA9PiBhdHRyaWJ1dGVzW2tleV0gPT09IGNoaWxkUG9zLm5vZGUuYXR0cnNba2V5XSk7XG4gICAgICAgIGlmIChkb2VzQWxsQXR0cmlidXRlc01hdGNoKSB7XG4gICAgICAgICAgbm9kZXMucHVzaChjaGlsZFBvcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmaXJzdEl0ZW1Pbmx5ICYmIG5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbm9kZXMgPSBub2Rlcy5jb25jYXQoY2hpbGRQb3MucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvciwgYXR0cmlidXRlcywgZmlyc3RJdGVtT25seSkpO1xuICAgIH0pO1xuICAgIHJldHVybiBub2RlcztcbiAgfVxuICBzZXRBdHRyaWJ1dGUoYXR0cmlidXRlcykge1xuICAgIGNvbnN0IHsgdHIgfSA9IHRoaXMuZWRpdG9yLnN0YXRlO1xuICAgIHRyLnNldE5vZGVNYXJrdXAodGhpcy5mcm9tLCB2b2lkIDAsIHtcbiAgICAgIC4uLnRoaXMubm9kZS5hdHRycyxcbiAgICAgIC4uLmF0dHJpYnV0ZXNcbiAgICB9KTtcbiAgICB0aGlzLmVkaXRvci52aWV3LmRpc3BhdGNoKHRyKTtcbiAgfVxufTtcblxuLy8gc3JjL3N0eWxlLnRzXG52YXIgc3R5bGUgPSBgLlByb3NlTWlycm9yIHtcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xufVxuXG4uUHJvc2VNaXJyb3Ige1xuICB3b3JkLXdyYXA6IGJyZWFrLXdvcmQ7XG4gIHdoaXRlLXNwYWNlOiBwcmUtd3JhcDtcbiAgd2hpdGUtc3BhY2U6IGJyZWFrLXNwYWNlcztcbiAgLXdlYmtpdC1mb250LXZhcmlhbnQtbGlnYXR1cmVzOiBub25lO1xuICBmb250LXZhcmlhbnQtbGlnYXR1cmVzOiBub25lO1xuICBmb250LWZlYXR1cmUtc2V0dGluZ3M6IFwibGlnYVwiIDA7IC8qIHRoZSBhYm92ZSBkb2Vzbid0IHNlZW0gdG8gd29yayBpbiBFZGdlICovXG59XG5cbi5Qcm9zZU1pcnJvciBbY29udGVudGVkaXRhYmxlPVwiZmFsc2VcIl0ge1xuICB3aGl0ZS1zcGFjZTogbm9ybWFsO1xufVxuXG4uUHJvc2VNaXJyb3IgW2NvbnRlbnRlZGl0YWJsZT1cImZhbHNlXCJdIFtjb250ZW50ZWRpdGFibGU9XCJ0cnVlXCJdIHtcbiAgd2hpdGUtc3BhY2U6IHByZS13cmFwO1xufVxuXG4uUHJvc2VNaXJyb3IgcHJlIHtcbiAgd2hpdGUtc3BhY2U6IHByZS13cmFwO1xufVxuXG5pbWcuUHJvc2VNaXJyb3Itc2VwYXJhdG9yIHtcbiAgZGlzcGxheTogaW5saW5lICFpbXBvcnRhbnQ7XG4gIGJvcmRlcjogbm9uZSAhaW1wb3J0YW50O1xuICBtYXJnaW46IDAgIWltcG9ydGFudDtcbiAgd2lkdGg6IDAgIWltcG9ydGFudDtcbiAgaGVpZ2h0OiAwICFpbXBvcnRhbnQ7XG59XG5cbi5Qcm9zZU1pcnJvci1nYXBjdXJzb3Ige1xuICBkaXNwbGF5OiBub25lO1xuICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICBtYXJnaW46IDA7XG59XG5cbi5Qcm9zZU1pcnJvci1nYXBjdXJzb3I6YWZ0ZXIge1xuICBjb250ZW50OiBcIlwiO1xuICBkaXNwbGF5OiBibG9jaztcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICB0b3A6IC0ycHg7XG4gIHdpZHRoOiAyMHB4O1xuICBib3JkZXItdG9wOiAxcHggc29saWQgYmxhY2s7XG4gIGFuaW1hdGlvbjogUHJvc2VNaXJyb3ItY3Vyc29yLWJsaW5rIDEuMXMgc3RlcHMoMiwgc3RhcnQpIGluZmluaXRlO1xufVxuXG5Aa2V5ZnJhbWVzIFByb3NlTWlycm9yLWN1cnNvci1ibGluayB7XG4gIHRvIHtcbiAgICB2aXNpYmlsaXR5OiBoaWRkZW47XG4gIH1cbn1cblxuLlByb3NlTWlycm9yLWhpZGVzZWxlY3Rpb24gKjo6c2VsZWN0aW9uIHtcbiAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XG59XG5cbi5Qcm9zZU1pcnJvci1oaWRlc2VsZWN0aW9uICo6Oi1tb3otc2VsZWN0aW9uIHtcbiAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XG59XG5cbi5Qcm9zZU1pcnJvci1oaWRlc2VsZWN0aW9uICoge1xuICBjYXJldC1jb2xvcjogdHJhbnNwYXJlbnQ7XG59XG5cbi5Qcm9zZU1pcnJvci1mb2N1c2VkIC5Qcm9zZU1pcnJvci1nYXBjdXJzb3Ige1xuICBkaXNwbGF5OiBibG9jaztcbn1gO1xuXG4vLyBzcmMvdXRpbGl0aWVzL2NyZWF0ZVN0eWxlVGFnLnRzXG5mdW5jdGlvbiBjcmVhdGVTdHlsZVRhZyhzdHlsZTIsIG5vbmNlLCBzdWZmaXgpIHtcbiAgY29uc3QgdGlwdGFwU3R5bGVUYWcgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBzdHlsZVtkYXRhLXRpcHRhcC1zdHlsZSR7c3VmZml4ID8gYC0ke3N1ZmZpeH1gIDogXCJcIn1dYCk7XG4gIGlmICh0aXB0YXBTdHlsZVRhZyAhPT0gbnVsbCkge1xuICAgIHJldHVybiB0aXB0YXBTdHlsZVRhZztcbiAgfVxuICBjb25zdCBzdHlsZU5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gIGlmIChub25jZSkge1xuICAgIHN0eWxlTm9kZS5zZXRBdHRyaWJ1dGUoXCJub25jZVwiLCBub25jZSk7XG4gIH1cbiAgc3R5bGVOb2RlLnNldEF0dHJpYnV0ZShgZGF0YS10aXB0YXAtc3R5bGUke3N1ZmZpeCA/IGAtJHtzdWZmaXh9YCA6IFwiXCJ9YCwgXCJcIik7XG4gIHN0eWxlTm9kZS5pbm5lckhUTUwgPSBzdHlsZTI7XG4gIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXS5hcHBlbmRDaGlsZChzdHlsZU5vZGUpO1xuICByZXR1cm4gc3R5bGVOb2RlO1xufVxuXG4vLyBzcmMvRWRpdG9yLnRzXG52YXIgRWRpdG9yID0gY2xhc3MgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuY3NzID0gbnVsbDtcbiAgICB0aGlzLmNsYXNzTmFtZSA9IFwidGlwdGFwXCI7XG4gICAgdGhpcy5lZGl0b3JWaWV3ID0gbnVsbDtcbiAgICB0aGlzLmlzRm9jdXNlZCA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIFRoZSBlZGl0b3IgaXMgY29uc2lkZXJlZCBpbml0aWFsaXplZCBhZnRlciB0aGUgYGNyZWF0ZWAgZXZlbnQgaGFzIGJlZW4gZW1pdHRlZC5cbiAgICAgKi9cbiAgICB0aGlzLmlzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmV4dGVuc2lvblN0b3JhZ2UgPSB7fTtcbiAgICAvKipcbiAgICAgKiBBIHVuaXF1ZSBJRCBmb3IgdGhpcyBlZGl0b3IgaW5zdGFuY2UuXG4gICAgICovXG4gICAgdGhpcy5pbnN0YW5jZUlkID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMiwgOSk7XG4gICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgZWxlbWVudDogdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSA6IG51bGwsXG4gICAgICBjb250ZW50OiBcIlwiLFxuICAgICAgaW5qZWN0Q1NTOiB0cnVlLFxuICAgICAgaW5qZWN0Tm9uY2U6IHZvaWQgMCxcbiAgICAgIGV4dGVuc2lvbnM6IFtdLFxuICAgICAgYXV0b2ZvY3VzOiBmYWxzZSxcbiAgICAgIGVkaXRhYmxlOiB0cnVlLFxuICAgICAgdGV4dERpcmVjdGlvbjogdm9pZCAwLFxuICAgICAgZWRpdG9yUHJvcHM6IHt9LFxuICAgICAgcGFyc2VPcHRpb25zOiB7fSxcbiAgICAgIGNvcmVFeHRlbnNpb25PcHRpb25zOiB7fSxcbiAgICAgIGVuYWJsZUlucHV0UnVsZXM6IHRydWUsXG4gICAgICBlbmFibGVQYXN0ZVJ1bGVzOiB0cnVlLFxuICAgICAgZW5hYmxlQ29yZUV4dGVuc2lvbnM6IHRydWUsXG4gICAgICBlbmFibGVDb250ZW50Q2hlY2s6IGZhbHNlLFxuICAgICAgZW1pdENvbnRlbnRFcnJvcjogZmFsc2UsXG4gICAgICBvbkJlZm9yZUNyZWF0ZTogKCkgPT4gbnVsbCxcbiAgICAgIG9uQ3JlYXRlOiAoKSA9PiBudWxsLFxuICAgICAgb25Nb3VudDogKCkgPT4gbnVsbCxcbiAgICAgIG9uVW5tb3VudDogKCkgPT4gbnVsbCxcbiAgICAgIG9uVXBkYXRlOiAoKSA9PiBudWxsLFxuICAgICAgb25TZWxlY3Rpb25VcGRhdGU6ICgpID0+IG51bGwsXG4gICAgICBvblRyYW5zYWN0aW9uOiAoKSA9PiBudWxsLFxuICAgICAgb25Gb2N1czogKCkgPT4gbnVsbCxcbiAgICAgIG9uQmx1cjogKCkgPT4gbnVsbCxcbiAgICAgIG9uRGVzdHJveTogKCkgPT4gbnVsbCxcbiAgICAgIG9uQ29udGVudEVycm9yOiAoeyBlcnJvciB9KSA9PiB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfSxcbiAgICAgIG9uUGFzdGU6ICgpID0+IG51bGwsXG4gICAgICBvbkRyb3A6ICgpID0+IG51bGwsXG4gICAgICBvbkRlbGV0ZTogKCkgPT4gbnVsbFxuICAgIH07XG4gICAgdGhpcy5pc0NhcHR1cmluZ1RyYW5zYWN0aW9uID0gZmFsc2U7XG4gICAgdGhpcy5jYXB0dXJlZFRyYW5zYWN0aW9uID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc2V0IG9mIHV0aWxpdGllcyBmb3Igd29ya2luZyB3aXRoIHBvc2l0aW9ucyBhbmQgcmFuZ2VzLlxuICAgICAqL1xuICAgIHRoaXMudXRpbHMgPSB7XG4gICAgICBnZXRVcGRhdGVkUG9zaXRpb24sXG4gICAgICBjcmVhdGVNYXBwYWJsZVBvc2l0aW9uXG4gICAgfTtcbiAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgdGhpcy5jcmVhdGVFeHRlbnNpb25NYW5hZ2VyKCk7XG4gICAgdGhpcy5jcmVhdGVDb21tYW5kTWFuYWdlcigpO1xuICAgIHRoaXMuY3JlYXRlU2NoZW1hKCk7XG4gICAgdGhpcy5vbihcImJlZm9yZUNyZWF0ZVwiLCB0aGlzLm9wdGlvbnMub25CZWZvcmVDcmVhdGUpO1xuICAgIHRoaXMuZW1pdChcImJlZm9yZUNyZWF0ZVwiLCB7IGVkaXRvcjogdGhpcyB9KTtcbiAgICB0aGlzLm9uKFwibW91bnRcIiwgdGhpcy5vcHRpb25zLm9uTW91bnQpO1xuICAgIHRoaXMub24oXCJ1bm1vdW50XCIsIHRoaXMub3B0aW9ucy5vblVubW91bnQpO1xuICAgIHRoaXMub24oXCJjb250ZW50RXJyb3JcIiwgdGhpcy5vcHRpb25zLm9uQ29udGVudEVycm9yKTtcbiAgICB0aGlzLm9uKFwiY3JlYXRlXCIsIHRoaXMub3B0aW9ucy5vbkNyZWF0ZSk7XG4gICAgdGhpcy5vbihcInVwZGF0ZVwiLCB0aGlzLm9wdGlvbnMub25VcGRhdGUpO1xuICAgIHRoaXMub24oXCJzZWxlY3Rpb25VcGRhdGVcIiwgdGhpcy5vcHRpb25zLm9uU2VsZWN0aW9uVXBkYXRlKTtcbiAgICB0aGlzLm9uKFwidHJhbnNhY3Rpb25cIiwgdGhpcy5vcHRpb25zLm9uVHJhbnNhY3Rpb24pO1xuICAgIHRoaXMub24oXCJmb2N1c1wiLCB0aGlzLm9wdGlvbnMub25Gb2N1cyk7XG4gICAgdGhpcy5vbihcImJsdXJcIiwgdGhpcy5vcHRpb25zLm9uQmx1cik7XG4gICAgdGhpcy5vbihcImRlc3Ryb3lcIiwgdGhpcy5vcHRpb25zLm9uRGVzdHJveSk7XG4gICAgdGhpcy5vbihcImRyb3BcIiwgKHsgZXZlbnQsIHNsaWNlLCBtb3ZlZCB9KSA9PiB0aGlzLm9wdGlvbnMub25Ecm9wKGV2ZW50LCBzbGljZSwgbW92ZWQpKTtcbiAgICB0aGlzLm9uKFwicGFzdGVcIiwgKHsgZXZlbnQsIHNsaWNlIH0pID0+IHRoaXMub3B0aW9ucy5vblBhc3RlKGV2ZW50LCBzbGljZSkpO1xuICAgIHRoaXMub24oXCJkZWxldGVcIiwgdGhpcy5vcHRpb25zLm9uRGVsZXRlKTtcbiAgICBjb25zdCBpbml0aWFsRG9jID0gdGhpcy5jcmVhdGVEb2MoKTtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSByZXNvbHZlRm9jdXNQb3NpdGlvbihpbml0aWFsRG9jLCB0aGlzLm9wdGlvbnMuYXV0b2ZvY3VzKTtcbiAgICB0aGlzLmVkaXRvclN0YXRlID0gRWRpdG9yU3RhdGUuY3JlYXRlKHtcbiAgICAgIGRvYzogaW5pdGlhbERvYyxcbiAgICAgIHNjaGVtYTogdGhpcy5zY2hlbWEsXG4gICAgICBzZWxlY3Rpb246IHNlbGVjdGlvbiB8fCB2b2lkIDBcbiAgICB9KTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVsZW1lbnQpIHtcbiAgICAgIHRoaXMubW91bnQodGhpcy5vcHRpb25zLmVsZW1lbnQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQXR0YWNoIHRoZSBlZGl0b3IgdG8gdGhlIERPTSwgY3JlYXRpbmcgYSBuZXcgZWRpdG9yIHZpZXcuXG4gICAqL1xuICBtb3VudChlbCkge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFt0aXB0YXAgZXJyb3JdOiBUaGUgZWRpdG9yIGNhbm5vdCBiZSBtb3VudGVkIGJlY2F1c2UgdGhlcmUgaXMgbm8gJ2RvY3VtZW50JyBkZWZpbmVkIGluIHRoaXMgZW52aXJvbm1lbnQuYFxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5jcmVhdGVWaWV3KGVsKTtcbiAgICB0aGlzLmVtaXQoXCJtb3VudFwiLCB7IGVkaXRvcjogdGhpcyB9KTtcbiAgICBpZiAodGhpcy5jc3MgJiYgIWRvY3VtZW50LmhlYWQuY29udGFpbnModGhpcy5jc3MpKSB7XG4gICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHRoaXMuY3NzKTtcbiAgICB9XG4gICAgd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuaXNEZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvZm9jdXMgIT09IGZhbHNlICYmIHRoaXMub3B0aW9ucy5hdXRvZm9jdXMgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5jb21tYW5kcy5mb2N1cyh0aGlzLm9wdGlvbnMuYXV0b2ZvY3VzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZW1pdChcImNyZWF0ZVwiLCB7IGVkaXRvcjogdGhpcyB9KTtcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCA9IHRydWU7XG4gICAgfSwgMCk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgZWRpdG9yIGZyb20gdGhlIERPTSwgYnV0IHN0aWxsIGFsbG93IHJlbW91bnRpbmcgYXQgYSBkaWZmZXJlbnQgcG9pbnQgaW4gdGltZVxuICAgKi9cbiAgdW5tb3VudCgpIHtcbiAgICBpZiAodGhpcy5lZGl0b3JWaWV3KSB7XG4gICAgICBjb25zdCBkb20gPSB0aGlzLmVkaXRvclZpZXcuZG9tO1xuICAgICAgaWYgKGRvbSA9PSBudWxsID8gdm9pZCAwIDogZG9tLmVkaXRvcikge1xuICAgICAgICBkZWxldGUgZG9tLmVkaXRvcjtcbiAgICAgIH1cbiAgICAgIHRoaXMuZWRpdG9yVmlldy5kZXN0cm95KCk7XG4gICAgfVxuICAgIHRoaXMuZWRpdG9yVmlldyA9IG51bGw7XG4gICAgdGhpcy5pc0luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgaWYgKHRoaXMuY3NzICYmICFkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGAuJHt0aGlzLmNsYXNzTmFtZX1gKS5sZW5ndGgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5jc3MucmVtb3ZlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICB0aGlzLmNzcy5yZW1vdmUoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmNzcy5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgdGhpcy5jc3MucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmNzcyk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIkZhaWxlZCB0byByZW1vdmUgQ1NTIGVsZW1lbnQ6XCIsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jc3MgPSBudWxsO1xuICAgIHRoaXMuZW1pdChcInVubW91bnRcIiwgeyBlZGl0b3I6IHRoaXMgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVkaXRvciBzdG9yYWdlLlxuICAgKi9cbiAgZ2V0IHN0b3JhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuZXh0ZW5zaW9uU3RvcmFnZTtcbiAgfVxuICAvKipcbiAgICogQW4gb2JqZWN0IG9mIGFsbCByZWdpc3RlcmVkIGNvbW1hbmRzLlxuICAgKi9cbiAgZ2V0IGNvbW1hbmRzKCkge1xuICAgIHJldHVybiB0aGlzLmNvbW1hbmRNYW5hZ2VyLmNvbW1hbmRzO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBjb21tYW5kIGNoYWluIHRvIGNhbGwgbXVsdGlwbGUgY29tbWFuZHMgYXQgb25jZS5cbiAgICovXG4gIGNoYWluKCkge1xuICAgIHJldHVybiB0aGlzLmNvbW1hbmRNYW5hZ2VyLmNoYWluKCk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgY29tbWFuZCBvciBhIGNvbW1hbmQgY2hhaW4gY2FuIGJlIGV4ZWN1dGVkLiBXaXRob3V0IGV4ZWN1dGluZyBpdC5cbiAgICovXG4gIGNhbigpIHtcbiAgICByZXR1cm4gdGhpcy5jb21tYW5kTWFuYWdlci5jYW4oKTtcbiAgfVxuICAvKipcbiAgICogSW5qZWN0IENTUyBzdHlsZXMuXG4gICAqL1xuICBpbmplY3RDU1MoKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5pbmplY3RDU1MgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB0aGlzLmNzcyA9IGNyZWF0ZVN0eWxlVGFnKHN0eWxlLCB0aGlzLm9wdGlvbnMuaW5qZWN0Tm9uY2UpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVXBkYXRlIGVkaXRvciBvcHRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyBBIGxpc3Qgb2Ygb3B0aW9uc1xuICAgKi9cbiAgc2V0T3B0aW9ucyhvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICAuLi50aGlzLm9wdGlvbnMsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfTtcbiAgICBpZiAoIXRoaXMuZWRpdG9yVmlldyB8fCAhdGhpcy5zdGF0ZSB8fCB0aGlzLmlzRGVzdHJveWVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuZWRpdG9yUHJvcHMpIHtcbiAgICAgIHRoaXMudmlldy5zZXRQcm9wcyh0aGlzLm9wdGlvbnMuZWRpdG9yUHJvcHMpO1xuICAgIH1cbiAgICB0aGlzLnZpZXcudXBkYXRlU3RhdGUodGhpcy5zdGF0ZSk7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZSBlZGl0YWJsZSBzdGF0ZSBvZiB0aGUgZWRpdG9yLlxuICAgKi9cbiAgc2V0RWRpdGFibGUoZWRpdGFibGUsIGVtaXRVcGRhdGUgPSB0cnVlKSB7XG4gICAgdGhpcy5zZXRPcHRpb25zKHsgZWRpdGFibGUgfSk7XG4gICAgaWYgKGVtaXRVcGRhdGUpIHtcbiAgICAgIHRoaXMuZW1pdChcInVwZGF0ZVwiLCB7IGVkaXRvcjogdGhpcywgdHJhbnNhY3Rpb246IHRoaXMuc3RhdGUudHIsIGFwcGVuZGVkVHJhbnNhY3Rpb25zOiBbXSB9KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgZWRpdG9yIGlzIGVkaXRhYmxlLlxuICAgKi9cbiAgZ2V0IGlzRWRpdGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5lZGl0YWJsZSAmJiB0aGlzLnZpZXcgJiYgdGhpcy52aWV3LmVkaXRhYmxlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlZGl0b3Igc3RhdGUuXG4gICAqL1xuICBnZXQgdmlldygpIHtcbiAgICBpZiAodGhpcy5lZGl0b3JWaWV3KSB7XG4gICAgICByZXR1cm4gdGhpcy5lZGl0b3JWaWV3O1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFByb3h5KFxuICAgICAge1xuICAgICAgICBzdGF0ZTogdGhpcy5lZGl0b3JTdGF0ZSxcbiAgICAgICAgdXBkYXRlU3RhdGU6IChzdGF0ZSkgPT4ge1xuICAgICAgICAgIHRoaXMuZWRpdG9yU3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZGlzcGF0Y2g6ICh0cikgPT4ge1xuICAgICAgICAgIHRoaXMuZGlzcGF0Y2hUcmFuc2FjdGlvbih0cik7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFN0dWIgc29tZSBjb21tb25seSBhY2Nlc3NlZCBwcm9wZXJ0aWVzIHRvIHByZXZlbnQgZXJyb3JzXG4gICAgICAgIGNvbXBvc2luZzogZmFsc2UsXG4gICAgICAgIGRyYWdnaW5nOiBudWxsLFxuICAgICAgICBlZGl0YWJsZTogdHJ1ZSxcbiAgICAgICAgaXNEZXN0cm95ZWQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBnZXQ6IChvYmosIGtleSkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLmVkaXRvclZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVkaXRvclZpZXdba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGtleSA9PT0gXCJzdGF0ZVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lZGl0b3JTdGF0ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldChvYmosIGtleSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBbdGlwdGFwIGVycm9yXTogVGhlIGVkaXRvciB2aWV3IGlzIG5vdCBhdmFpbGFibGUuIENhbm5vdCBhY2Nlc3Mgdmlld1snJHtrZXl9J10uIFRoZSBlZGl0b3IgbWF5IG5vdCBiZSBtb3VudGVkIHlldC5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVkaXRvciBzdGF0ZS5cbiAgICovXG4gIGdldCBzdGF0ZSgpIHtcbiAgICBpZiAodGhpcy5lZGl0b3JWaWV3KSB7XG4gICAgICB0aGlzLmVkaXRvclN0YXRlID0gdGhpcy52aWV3LnN0YXRlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5lZGl0b3JTdGF0ZTtcbiAgfVxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBQcm9zZU1pcnJvciBwbHVnaW4uXG4gICAqXG4gICAqIEBwYXJhbSBwbHVnaW4gQSBQcm9zZU1pcnJvciBwbHVnaW5cbiAgICogQHBhcmFtIGhhbmRsZVBsdWdpbnMgQ29udHJvbCBob3cgdG8gbWVyZ2UgdGhlIHBsdWdpbiBpbnRvIHRoZSBleGlzdGluZyBwbHVnaW5zLlxuICAgKiBAcmV0dXJucyBUaGUgbmV3IGVkaXRvciBzdGF0ZVxuICAgKi9cbiAgcmVnaXN0ZXJQbHVnaW4ocGx1Z2luLCBoYW5kbGVQbHVnaW5zKSB7XG4gICAgY29uc3QgcGx1Z2lucyA9IGlzRnVuY3Rpb24oaGFuZGxlUGx1Z2lucykgPyBoYW5kbGVQbHVnaW5zKHBsdWdpbiwgWy4uLnRoaXMuc3RhdGUucGx1Z2luc10pIDogWy4uLnRoaXMuc3RhdGUucGx1Z2lucywgcGx1Z2luXTtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGUucmVjb25maWd1cmUoeyBwbHVnaW5zIH0pO1xuICAgIHRoaXMudmlldy51cGRhdGVTdGF0ZShzdGF0ZSk7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG4gIC8qKlxuICAgKiBVbnJlZ2lzdGVyIGEgUHJvc2VNaXJyb3IgcGx1Z2luLlxuICAgKlxuICAgKiBAcGFyYW0gbmFtZU9yUGx1Z2luS2V5VG9SZW1vdmUgVGhlIHBsdWdpbnMgbmFtZVxuICAgKiBAcmV0dXJucyBUaGUgbmV3IGVkaXRvciBzdGF0ZSBvciB1bmRlZmluZWQgaWYgdGhlIGVkaXRvciBpcyBkZXN0cm95ZWRcbiAgICovXG4gIHVucmVnaXN0ZXJQbHVnaW4obmFtZU9yUGx1Z2luS2V5VG9SZW1vdmUpIHtcbiAgICBpZiAodGhpcy5pc0Rlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgY29uc3QgcHJldlBsdWdpbnMgPSB0aGlzLnN0YXRlLnBsdWdpbnM7XG4gICAgbGV0IHBsdWdpbnMgPSBwcmV2UGx1Z2lucztcbiAgICBbXS5jb25jYXQobmFtZU9yUGx1Z2luS2V5VG9SZW1vdmUpLmZvckVhY2goKG5hbWVPclBsdWdpbktleSkgPT4ge1xuICAgICAgY29uc3QgbmFtZSA9IHR5cGVvZiBuYW1lT3JQbHVnaW5LZXkgPT09IFwic3RyaW5nXCIgPyBgJHtuYW1lT3JQbHVnaW5LZXl9JGAgOiBuYW1lT3JQbHVnaW5LZXkua2V5O1xuICAgICAgcGx1Z2lucyA9IHBsdWdpbnMuZmlsdGVyKChwbHVnaW4pID0+ICFwbHVnaW4ua2V5LnN0YXJ0c1dpdGgobmFtZSkpO1xuICAgIH0pO1xuICAgIGlmIChwcmV2UGx1Z2lucy5sZW5ndGggPT09IHBsdWdpbnMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGUucmVjb25maWd1cmUoe1xuICAgICAgcGx1Z2luc1xuICAgIH0pO1xuICAgIHRoaXMudmlldy51cGRhdGVTdGF0ZShzdGF0ZSk7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGV4dGVuc2lvbiBtYW5hZ2VyLlxuICAgKi9cbiAgY3JlYXRlRXh0ZW5zaW9uTWFuYWdlcigpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IGNvcmVFeHRlbnNpb25zID0gdGhpcy5vcHRpb25zLmVuYWJsZUNvcmVFeHRlbnNpb25zID8gW1xuICAgICAgRWRpdGFibGUsXG4gICAgICBDbGlwYm9hcmRUZXh0U2VyaWFsaXplci5jb25maWd1cmUoe1xuICAgICAgICBibG9ja1NlcGFyYXRvcjogKF9iID0gKF9hID0gdGhpcy5vcHRpb25zLmNvcmVFeHRlbnNpb25PcHRpb25zKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2xpcGJvYXJkVGV4dFNlcmlhbGl6ZXIpID09IG51bGwgPyB2b2lkIDAgOiBfYi5ibG9ja1NlcGFyYXRvclxuICAgICAgfSksXG4gICAgICBDb21tYW5kcyxcbiAgICAgIEZvY3VzRXZlbnRzLFxuICAgICAgS2V5bWFwLFxuICAgICAgVGFiaW5kZXgsXG4gICAgICBEcm9wLFxuICAgICAgUGFzdGUsXG4gICAgICBEZWxldGUsXG4gICAgICBUZXh0RGlyZWN0aW9uLmNvbmZpZ3VyZSh7XG4gICAgICAgIGRpcmVjdGlvbjogdGhpcy5vcHRpb25zLnRleHREaXJlY3Rpb25cbiAgICAgIH0pXG4gICAgXS5maWx0ZXIoKGV4dCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuZW5hYmxlQ29yZUV4dGVuc2lvbnMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5lbmFibGVDb3JlRXh0ZW5zaW9uc1tleHQubmFtZV0gIT09IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSkgOiBbXTtcbiAgICBjb25zdCBhbGxFeHRlbnNpb25zID0gWy4uLmNvcmVFeHRlbnNpb25zLCAuLi50aGlzLm9wdGlvbnMuZXh0ZW5zaW9uc10uZmlsdGVyKChleHRlbnNpb24pID0+IHtcbiAgICAgIHJldHVybiBbXCJleHRlbnNpb25cIiwgXCJub2RlXCIsIFwibWFya1wiXS5pbmNsdWRlcyhleHRlbnNpb24gPT0gbnVsbCA/IHZvaWQgMCA6IGV4dGVuc2lvbi50eXBlKTtcbiAgICB9KTtcbiAgICB0aGlzLmV4dGVuc2lvbk1hbmFnZXIgPSBuZXcgRXh0ZW5zaW9uTWFuYWdlcihhbGxFeHRlbnNpb25zLCB0aGlzKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBjb21tYW5kIG1hbmFnZXIuXG4gICAqL1xuICBjcmVhdGVDb21tYW5kTWFuYWdlcigpIHtcbiAgICB0aGlzLmNvbW1hbmRNYW5hZ2VyID0gbmV3IENvbW1hbmRNYW5hZ2VyKHtcbiAgICAgIGVkaXRvcjogdGhpc1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgUHJvc2VNaXJyb3Igc2NoZW1hLlxuICAgKi9cbiAgY3JlYXRlU2NoZW1hKCkge1xuICAgIHRoaXMuc2NoZW1hID0gdGhpcy5leHRlbnNpb25NYW5hZ2VyLnNjaGVtYTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyB0aGUgaW5pdGlhbCBkb2N1bWVudC5cbiAgICovXG4gIGNyZWF0ZURvYygpIHtcbiAgICBsZXQgZG9jO1xuICAgIHRyeSB7XG4gICAgICBkb2MgPSBjcmVhdGVEb2N1bWVudCh0aGlzLm9wdGlvbnMuY29udGVudCwgdGhpcy5zY2hlbWEsIHRoaXMub3B0aW9ucy5wYXJzZU9wdGlvbnMsIHtcbiAgICAgICAgZXJyb3JPbkludmFsaWRDb250ZW50OiB0aGlzLm9wdGlvbnMuZW5hYmxlQ29udGVudENoZWNrXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoIShlIGluc3RhbmNlb2YgRXJyb3IpIHx8ICFbXCJbdGlwdGFwIGVycm9yXTogSW52YWxpZCBKU09OIGNvbnRlbnRcIiwgXCJbdGlwdGFwIGVycm9yXTogSW52YWxpZCBIVE1MIGNvbnRlbnRcIl0uaW5jbHVkZXMoZS5tZXNzYWdlKSkge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgICAgdGhpcy5lbWl0KFwiY29udGVudEVycm9yXCIsIHtcbiAgICAgICAgZWRpdG9yOiB0aGlzLFxuICAgICAgICBlcnJvcjogZSxcbiAgICAgICAgZGlzYWJsZUNvbGxhYm9yYXRpb246ICgpID0+IHtcbiAgICAgICAgICBpZiAoXCJjb2xsYWJvcmF0aW9uXCIgaW4gdGhpcy5zdG9yYWdlICYmIHR5cGVvZiB0aGlzLnN0b3JhZ2UuY29sbGFib3JhdGlvbiA9PT0gXCJvYmplY3RcIiAmJiB0aGlzLnN0b3JhZ2UuY29sbGFib3JhdGlvbikge1xuICAgICAgICAgICAgO1xuICAgICAgICAgICAgdGhpcy5zdG9yYWdlLmNvbGxhYm9yYXRpb24uaXNEaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMub3B0aW9ucy5leHRlbnNpb25zID0gdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMuZmlsdGVyKChleHRlbnNpb24pID0+IGV4dGVuc2lvbi5uYW1lICE9PSBcImNvbGxhYm9yYXRpb25cIik7XG4gICAgICAgICAgdGhpcy5jcmVhdGVFeHRlbnNpb25NYW5hZ2VyKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZG9jID0gY3JlYXRlRG9jdW1lbnQodGhpcy5vcHRpb25zLmNvbnRlbnQsIHRoaXMuc2NoZW1hLCB0aGlzLm9wdGlvbnMucGFyc2VPcHRpb25zLCB7XG4gICAgICAgIGVycm9yT25JbnZhbGlkQ29udGVudDogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZG9jO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgUHJvc2VNaXJyb3Igdmlldy5cbiAgICovXG4gIGNyZWF0ZVZpZXcoZWxlbWVudCkge1xuICAgIHZhciBfYTtcbiAgICB0aGlzLmVkaXRvclZpZXcgPSBuZXcgRWRpdG9yVmlldyhlbGVtZW50LCB7XG4gICAgICAuLi50aGlzLm9wdGlvbnMuZWRpdG9yUHJvcHMsXG4gICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgIC8vIGFkZCBgcm9sZT1cInRleHRib3hcImAgdG8gdGhlIGVkaXRvciBlbGVtZW50XG4gICAgICAgIHJvbGU6IFwidGV4dGJveFwiLFxuICAgICAgICAuLi4oX2EgPSB0aGlzLm9wdGlvbnMuZWRpdG9yUHJvcHMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5hdHRyaWJ1dGVzXG4gICAgICB9LFxuICAgICAgZGlzcGF0Y2hUcmFuc2FjdGlvbjogdGhpcy5kaXNwYXRjaFRyYW5zYWN0aW9uLmJpbmQodGhpcyksXG4gICAgICBzdGF0ZTogdGhpcy5lZGl0b3JTdGF0ZSxcbiAgICAgIG1hcmtWaWV3czogdGhpcy5leHRlbnNpb25NYW5hZ2VyLm1hcmtWaWV3cyxcbiAgICAgIG5vZGVWaWV3czogdGhpcy5leHRlbnNpb25NYW5hZ2VyLm5vZGVWaWV3c1xuICAgIH0pO1xuICAgIGNvbnN0IG5ld1N0YXRlID0gdGhpcy5zdGF0ZS5yZWNvbmZpZ3VyZSh7XG4gICAgICBwbHVnaW5zOiB0aGlzLmV4dGVuc2lvbk1hbmFnZXIucGx1Z2luc1xuICAgIH0pO1xuICAgIHRoaXMudmlldy51cGRhdGVTdGF0ZShuZXdTdGF0ZSk7XG4gICAgdGhpcy5wcmVwZW5kQ2xhc3MoKTtcbiAgICB0aGlzLmluamVjdENTUygpO1xuICAgIGNvbnN0IGRvbSA9IHRoaXMudmlldy5kb207XG4gICAgZG9tLmVkaXRvciA9IHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYWxsIG5vZGUgYW5kIG1hcmsgdmlld3MuXG4gICAqL1xuICBjcmVhdGVOb2RlVmlld3MoKSB7XG4gICAgaWYgKHRoaXMudmlldy5pc0Rlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnZpZXcuc2V0UHJvcHMoe1xuICAgICAgbWFya1ZpZXdzOiB0aGlzLmV4dGVuc2lvbk1hbmFnZXIubWFya1ZpZXdzLFxuICAgICAgbm9kZVZpZXdzOiB0aGlzLmV4dGVuc2lvbk1hbmFnZXIubm9kZVZpZXdzXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFByZXBlbmQgY2xhc3MgbmFtZSB0byBlbGVtZW50LlxuICAgKi9cbiAgcHJlcGVuZENsYXNzKCkge1xuICAgIHRoaXMudmlldy5kb20uY2xhc3NOYW1lID0gYCR7dGhpcy5jbGFzc05hbWV9ICR7dGhpcy52aWV3LmRvbS5jbGFzc05hbWV9YDtcbiAgfVxuICBjYXB0dXJlVHJhbnNhY3Rpb24oZm4pIHtcbiAgICB0aGlzLmlzQ2FwdHVyaW5nVHJhbnNhY3Rpb24gPSB0cnVlO1xuICAgIGZuKCk7XG4gICAgdGhpcy5pc0NhcHR1cmluZ1RyYW5zYWN0aW9uID0gZmFsc2U7XG4gICAgY29uc3QgdHIgPSB0aGlzLmNhcHR1cmVkVHJhbnNhY3Rpb247XG4gICAgdGhpcy5jYXB0dXJlZFRyYW5zYWN0aW9uID0gbnVsbDtcbiAgICByZXR1cm4gdHI7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBjYWxsYmFjayBvdmVyIHdoaWNoIHRvIHNlbmQgdHJhbnNhY3Rpb25zIChzdGF0ZSB1cGRhdGVzKSBwcm9kdWNlZCBieSB0aGUgdmlldy5cbiAgICpcbiAgICogQHBhcmFtIHRyYW5zYWN0aW9uIEFuIGVkaXRvciBzdGF0ZSB0cmFuc2FjdGlvblxuICAgKi9cbiAgZGlzcGF0Y2hUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICAgIGlmICh0aGlzLnZpZXcuaXNEZXN0cm95ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNDYXB0dXJpbmdUcmFuc2FjdGlvbikge1xuICAgICAgaWYgKCF0aGlzLmNhcHR1cmVkVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgdGhpcy5jYXB0dXJlZFRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb247XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRyYW5zYWN0aW9uLnN0ZXBzLmZvckVhY2goKHN0ZXApID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5jYXB0dXJlZFRyYW5zYWN0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2Euc3RlcChzdGVwKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IHN0YXRlLCB0cmFuc2FjdGlvbnMgfSA9IHRoaXMuc3RhdGUuYXBwbHlUcmFuc2FjdGlvbih0cmFuc2FjdGlvbik7XG4gICAgY29uc3Qgc2VsZWN0aW9uSGFzQ2hhbmdlZCA9ICF0aGlzLnN0YXRlLnNlbGVjdGlvbi5lcShzdGF0ZS5zZWxlY3Rpb24pO1xuICAgIGNvbnN0IHJvb3RUcldhc0FwcGxpZWQgPSB0cmFuc2FjdGlvbnMuaW5jbHVkZXModHJhbnNhY3Rpb24pO1xuICAgIGNvbnN0IHByZXZTdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgdGhpcy5lbWl0KFwiYmVmb3JlVHJhbnNhY3Rpb25cIiwge1xuICAgICAgZWRpdG9yOiB0aGlzLFxuICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICBuZXh0U3RhdGU6IHN0YXRlXG4gICAgfSk7XG4gICAgaWYgKCFyb290VHJXYXNBcHBsaWVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMudmlldy51cGRhdGVTdGF0ZShzdGF0ZSk7XG4gICAgdGhpcy5lbWl0KFwidHJhbnNhY3Rpb25cIiwge1xuICAgICAgZWRpdG9yOiB0aGlzLFxuICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICBhcHBlbmRlZFRyYW5zYWN0aW9uczogdHJhbnNhY3Rpb25zLnNsaWNlKDEpXG4gICAgfSk7XG4gICAgaWYgKHNlbGVjdGlvbkhhc0NoYW5nZWQpIHtcbiAgICAgIHRoaXMuZW1pdChcInNlbGVjdGlvblVwZGF0ZVwiLCB7XG4gICAgICAgIGVkaXRvcjogdGhpcyxcbiAgICAgICAgdHJhbnNhY3Rpb25cbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBtb3N0UmVjZW50Rm9jdXNUciA9IHRyYW5zYWN0aW9ucy5maW5kTGFzdCgodHIpID0+IHRyLmdldE1ldGEoXCJmb2N1c1wiKSB8fCB0ci5nZXRNZXRhKFwiYmx1clwiKSk7XG4gICAgY29uc3QgZm9jdXMyID0gbW9zdFJlY2VudEZvY3VzVHIgPT0gbnVsbCA/IHZvaWQgMCA6IG1vc3RSZWNlbnRGb2N1c1RyLmdldE1ldGEoXCJmb2N1c1wiKTtcbiAgICBjb25zdCBibHVyMiA9IG1vc3RSZWNlbnRGb2N1c1RyID09IG51bGwgPyB2b2lkIDAgOiBtb3N0UmVjZW50Rm9jdXNUci5nZXRNZXRhKFwiYmx1clwiKTtcbiAgICBpZiAoZm9jdXMyKSB7XG4gICAgICB0aGlzLmVtaXQoXCJmb2N1c1wiLCB7XG4gICAgICAgIGVkaXRvcjogdGhpcyxcbiAgICAgICAgZXZlbnQ6IGZvY3VzMi5ldmVudCxcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgdHJhbnNhY3Rpb246IG1vc3RSZWNlbnRGb2N1c1RyXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGJsdXIyKSB7XG4gICAgICB0aGlzLmVtaXQoXCJibHVyXCIsIHtcbiAgICAgICAgZWRpdG9yOiB0aGlzLFxuICAgICAgICBldmVudDogYmx1cjIuZXZlbnQsXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgIHRyYW5zYWN0aW9uOiBtb3N0UmVjZW50Rm9jdXNUclxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0cmFuc2FjdGlvbi5nZXRNZXRhKFwicHJldmVudFVwZGF0ZVwiKSB8fCAhdHJhbnNhY3Rpb25zLnNvbWUoKHRyKSA9PiB0ci5kb2NDaGFuZ2VkKSB8fCBwcmV2U3RhdGUuZG9jLmVxKHN0YXRlLmRvYykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5lbWl0KFwidXBkYXRlXCIsIHtcbiAgICAgIGVkaXRvcjogdGhpcyxcbiAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgYXBwZW5kZWRUcmFuc2FjdGlvbnM6IHRyYW5zYWN0aW9ucy5zbGljZSgxKVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYXR0cmlidXRlcyBvZiB0aGUgY3VycmVudGx5IHNlbGVjdGVkIG5vZGUgb3IgbWFyay5cbiAgICovXG4gIGdldEF0dHJpYnV0ZXMobmFtZU9yVHlwZSkge1xuICAgIHJldHVybiBnZXRBdHRyaWJ1dGVzKHRoaXMuc3RhdGUsIG5hbWVPclR5cGUpO1xuICB9XG4gIGlzQWN0aXZlKG5hbWVPckF0dHJpYnV0ZXMsIGF0dHJpYnV0ZXNPclVuZGVmaW5lZCkge1xuICAgIGNvbnN0IG5hbWUgPSB0eXBlb2YgbmFtZU9yQXR0cmlidXRlcyA9PT0gXCJzdHJpbmdcIiA/IG5hbWVPckF0dHJpYnV0ZXMgOiBudWxsO1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB0eXBlb2YgbmFtZU9yQXR0cmlidXRlcyA9PT0gXCJzdHJpbmdcIiA/IGF0dHJpYnV0ZXNPclVuZGVmaW5lZCA6IG5hbWVPckF0dHJpYnV0ZXM7XG4gICAgcmV0dXJuIGlzQWN0aXZlKHRoaXMuc3RhdGUsIG5hbWUsIGF0dHJpYnV0ZXMpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGRvY3VtZW50IGFzIEpTT04uXG4gICAqL1xuICBnZXRKU09OKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmRvYy50b0pTT04oKTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBkb2N1bWVudCBhcyBIVE1MLlxuICAgKi9cbiAgZ2V0SFRNTCgpIHtcbiAgICByZXR1cm4gZ2V0SFRNTEZyb21GcmFnbWVudCh0aGlzLnN0YXRlLmRvYy5jb250ZW50LCB0aGlzLnNjaGVtYSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgZG9jdW1lbnQgYXMgdGV4dC5cbiAgICovXG4gIGdldFRleHQob3B0aW9ucykge1xuICAgIGNvbnN0IHsgYmxvY2tTZXBhcmF0b3IgPSBcIlxcblxcblwiLCB0ZXh0U2VyaWFsaXplcnMgPSB7fSB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgICByZXR1cm4gZ2V0VGV4dCh0aGlzLnN0YXRlLmRvYywge1xuICAgICAgYmxvY2tTZXBhcmF0b3IsXG4gICAgICB0ZXh0U2VyaWFsaXplcnM6IHtcbiAgICAgICAgLi4uZ2V0VGV4dFNlcmlhbGl6ZXJzRnJvbVNjaGVtYSh0aGlzLnNjaGVtYSksXG4gICAgICAgIC4uLnRleHRTZXJpYWxpemVyc1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGVyZSBpcyBubyBjb250ZW50LlxuICAgKi9cbiAgZ2V0IGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIGlzTm9kZUVtcHR5KHRoaXMuc3RhdGUuZG9jKTtcbiAgfVxuICAvKipcbiAgICogRGVzdHJveSB0aGUgZWRpdG9yLlxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmVtaXQoXCJkZXN0cm95XCIpO1xuICAgIHRoaXMudW5tb3VudCgpO1xuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSBlZGl0b3IgaXMgYWxyZWFkeSBkZXN0cm95ZWQuXG4gICAqL1xuICBnZXQgaXNEZXN0cm95ZWQoKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5lZGl0b3JWaWV3KSA9PSBudWxsID8gdm9pZCAwIDogX2EuaXNEZXN0cm95ZWQpICE9IG51bGwgPyBfYiA6IHRydWU7XG4gIH1cbiAgJG5vZGUoc2VsZWN0b3IsIGF0dHJpYnV0ZXMpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuICgoX2EgPSB0aGlzLiRkb2MpID09IG51bGwgPyB2b2lkIDAgOiBfYS5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yLCBhdHRyaWJ1dGVzKSkgfHwgbnVsbDtcbiAgfVxuICAkbm9kZXMoc2VsZWN0b3IsIGF0dHJpYnV0ZXMpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuICgoX2EgPSB0aGlzLiRkb2MpID09IG51bGwgPyB2b2lkIDAgOiBfYS5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yLCBhdHRyaWJ1dGVzKSkgfHwgbnVsbDtcbiAgfVxuICAkcG9zKHBvcykge1xuICAgIGNvbnN0ICRwb3MgPSB0aGlzLnN0YXRlLmRvYy5yZXNvbHZlKHBvcyk7XG4gICAgcmV0dXJuIG5ldyBOb2RlUG9zKCRwb3MsIHRoaXMpO1xuICB9XG4gIGdldCAkZG9jKCkge1xuICAgIHJldHVybiB0aGlzLiRwb3MoMCk7XG4gIH1cbn07XG5cbi8vIHNyYy9pbnB1dFJ1bGVzL21hcmtJbnB1dFJ1bGUudHNcbmZ1bmN0aW9uIG1hcmtJbnB1dFJ1bGUoY29uZmlnKSB7XG4gIHJldHVybiBuZXcgSW5wdXRSdWxlKHtcbiAgICBmaW5kOiBjb25maWcuZmluZCxcbiAgICBoYW5kbGVyOiAoeyBzdGF0ZSwgcmFuZ2UsIG1hdGNoIH0pID0+IHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBjYWxsT3JSZXR1cm4oY29uZmlnLmdldEF0dHJpYnV0ZXMsIHZvaWQgMCwgbWF0Y2gpO1xuICAgICAgaWYgKGF0dHJpYnV0ZXMgPT09IGZhbHNlIHx8IGF0dHJpYnV0ZXMgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBjb25zdCB7IHRyIH0gPSBzdGF0ZTtcbiAgICAgIGNvbnN0IGNhcHR1cmVHcm91cCA9IG1hdGNoW21hdGNoLmxlbmd0aCAtIDFdO1xuICAgICAgY29uc3QgZnVsbE1hdGNoID0gbWF0Y2hbMF07XG4gICAgICBpZiAoY2FwdHVyZUdyb3VwKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0U3BhY2VzID0gZnVsbE1hdGNoLnNlYXJjaCgvXFxTLyk7XG4gICAgICAgIGNvbnN0IHRleHRTdGFydCA9IHJhbmdlLmZyb20gKyBmdWxsTWF0Y2guaW5kZXhPZihjYXB0dXJlR3JvdXApO1xuICAgICAgICBjb25zdCB0ZXh0RW5kID0gdGV4dFN0YXJ0ICsgY2FwdHVyZUdyb3VwLmxlbmd0aDtcbiAgICAgICAgY29uc3QgZXhjbHVkZWRNYXJrcyA9IGdldE1hcmtzQmV0d2VlbihyYW5nZS5mcm9tLCByYW5nZS50bywgc3RhdGUuZG9jKS5maWx0ZXIoKGl0ZW0pID0+IHtcbiAgICAgICAgICBjb25zdCBleGNsdWRlZCA9IGl0ZW0ubWFyay50eXBlLmV4Y2x1ZGVkO1xuICAgICAgICAgIHJldHVybiBleGNsdWRlZC5maW5kKCh0eXBlKSA9PiB0eXBlID09PSBjb25maWcudHlwZSAmJiB0eXBlICE9PSBpdGVtLm1hcmsudHlwZSk7XG4gICAgICAgIH0pLmZpbHRlcigoaXRlbSkgPT4gaXRlbS50byA+IHRleHRTdGFydCk7XG4gICAgICAgIGlmIChleGNsdWRlZE1hcmtzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0ZXh0RW5kIDwgcmFuZ2UudG8pIHtcbiAgICAgICAgICB0ci5kZWxldGUodGV4dEVuZCwgcmFuZ2UudG8pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0ZXh0U3RhcnQgPiByYW5nZS5mcm9tKSB7XG4gICAgICAgICAgdHIuZGVsZXRlKHJhbmdlLmZyb20gKyBzdGFydFNwYWNlcywgdGV4dFN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtYXJrRW5kID0gcmFuZ2UuZnJvbSArIHN0YXJ0U3BhY2VzICsgY2FwdHVyZUdyb3VwLmxlbmd0aDtcbiAgICAgICAgdHIuYWRkTWFyayhyYW5nZS5mcm9tICsgc3RhcnRTcGFjZXMsIG1hcmtFbmQsIGNvbmZpZy50eXBlLmNyZWF0ZShhdHRyaWJ1dGVzIHx8IHt9KSk7XG4gICAgICAgIHRyLnJlbW92ZVN0b3JlZE1hcmsoY29uZmlnLnR5cGUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgdW5kb2FibGU6IGNvbmZpZy51bmRvYWJsZVxuICB9KTtcbn1cblxuLy8gc3JjL2lucHV0UnVsZXMvbm9kZUlucHV0UnVsZS50c1xuZnVuY3Rpb24gbm9kZUlucHV0UnVsZShjb25maWcpIHtcbiAgcmV0dXJuIG5ldyBJbnB1dFJ1bGUoe1xuICAgIGZpbmQ6IGNvbmZpZy5maW5kLFxuICAgIGhhbmRsZXI6ICh7IHN0YXRlLCByYW5nZSwgbWF0Y2ggfSkgPT4ge1xuICAgICAgY29uc3QgYXR0cmlidXRlcyA9IGNhbGxPclJldHVybihjb25maWcuZ2V0QXR0cmlidXRlcywgdm9pZCAwLCBtYXRjaCkgfHwge307XG4gICAgICBjb25zdCB7IHRyIH0gPSBzdGF0ZTtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gcmFuZ2UuZnJvbTtcbiAgICAgIGxldCBlbmQgPSByYW5nZS50bztcbiAgICAgIGNvbnN0IG5ld05vZGUgPSBjb25maWcudHlwZS5jcmVhdGUoYXR0cmlidXRlcyk7XG4gICAgICBpZiAobWF0Y2hbMV0pIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gbWF0Y2hbMF0ubGFzdEluZGV4T2YobWF0Y2hbMV0pO1xuICAgICAgICBsZXQgbWF0Y2hTdGFydCA9IHN0YXJ0ICsgb2Zmc2V0O1xuICAgICAgICBpZiAobWF0Y2hTdGFydCA+IGVuZCkge1xuICAgICAgICAgIG1hdGNoU3RhcnQgPSBlbmQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW5kID0gbWF0Y2hTdGFydCArIG1hdGNoWzFdLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsYXN0Q2hhciA9IG1hdGNoWzBdW21hdGNoWzBdLmxlbmd0aCAtIDFdO1xuICAgICAgICB0ci5pbnNlcnRUZXh0KGxhc3RDaGFyLCBzdGFydCArIG1hdGNoWzBdLmxlbmd0aCAtIDEpO1xuICAgICAgICB0ci5yZXBsYWNlV2l0aChtYXRjaFN0YXJ0LCBlbmQsIG5ld05vZGUpO1xuICAgICAgfSBlbHNlIGlmIChtYXRjaFswXSkge1xuICAgICAgICBjb25zdCBpbnNlcnRpb25TdGFydCA9IGNvbmZpZy50eXBlLmlzSW5saW5lID8gc3RhcnQgOiBzdGFydCAtIDE7XG4gICAgICAgIHRyLmluc2VydChpbnNlcnRpb25TdGFydCwgY29uZmlnLnR5cGUuY3JlYXRlKGF0dHJpYnV0ZXMpKS5kZWxldGUodHIubWFwcGluZy5tYXAoc3RhcnQpLCB0ci5tYXBwaW5nLm1hcChlbmQpKTtcbiAgICAgIH1cbiAgICAgIHRyLnNjcm9sbEludG9WaWV3KCk7XG4gICAgfSxcbiAgICB1bmRvYWJsZTogY29uZmlnLnVuZG9hYmxlXG4gIH0pO1xufVxuXG4vLyBzcmMvaW5wdXRSdWxlcy90ZXh0YmxvY2tUeXBlSW5wdXRSdWxlLnRzXG5mdW5jdGlvbiB0ZXh0YmxvY2tUeXBlSW5wdXRSdWxlKGNvbmZpZykge1xuICByZXR1cm4gbmV3IElucHV0UnVsZSh7XG4gICAgZmluZDogY29uZmlnLmZpbmQsXG4gICAgaGFuZGxlcjogKHsgc3RhdGUsIHJhbmdlLCBtYXRjaCB9KSA9PiB7XG4gICAgICBjb25zdCAkc3RhcnQgPSBzdGF0ZS5kb2MucmVzb2x2ZShyYW5nZS5mcm9tKTtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBjYWxsT3JSZXR1cm4oY29uZmlnLmdldEF0dHJpYnV0ZXMsIHZvaWQgMCwgbWF0Y2gpIHx8IHt9O1xuICAgICAgaWYgKCEkc3RhcnQubm9kZSgtMSkuY2FuUmVwbGFjZVdpdGgoJHN0YXJ0LmluZGV4KC0xKSwgJHN0YXJ0LmluZGV4QWZ0ZXIoLTEpLCBjb25maWcudHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBzdGF0ZS50ci5kZWxldGUocmFuZ2UuZnJvbSwgcmFuZ2UudG8pLnNldEJsb2NrVHlwZShyYW5nZS5mcm9tLCByYW5nZS5mcm9tLCBjb25maWcudHlwZSwgYXR0cmlidXRlcyk7XG4gICAgfSxcbiAgICB1bmRvYWJsZTogY29uZmlnLnVuZG9hYmxlXG4gIH0pO1xufVxuXG4vLyBzcmMvaW5wdXRSdWxlcy90ZXh0SW5wdXRSdWxlLnRzXG5mdW5jdGlvbiB0ZXh0SW5wdXRSdWxlKGNvbmZpZykge1xuICByZXR1cm4gbmV3IElucHV0UnVsZSh7XG4gICAgZmluZDogY29uZmlnLmZpbmQsXG4gICAgaGFuZGxlcjogKHsgc3RhdGUsIHJhbmdlLCBtYXRjaCB9KSA9PiB7XG4gICAgICBsZXQgaW5zZXJ0ID0gY29uZmlnLnJlcGxhY2U7XG4gICAgICBsZXQgc3RhcnQgPSByYW5nZS5mcm9tO1xuICAgICAgY29uc3QgZW5kID0gcmFuZ2UudG87XG4gICAgICBpZiAobWF0Y2hbMV0pIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gbWF0Y2hbMF0ubGFzdEluZGV4T2YobWF0Y2hbMV0pO1xuICAgICAgICBpbnNlcnQgKz0gbWF0Y2hbMF0uc2xpY2Uob2Zmc2V0ICsgbWF0Y2hbMV0ubGVuZ3RoKTtcbiAgICAgICAgc3RhcnQgKz0gb2Zmc2V0O1xuICAgICAgICBjb25zdCBjdXRPZmYgPSBzdGFydCAtIGVuZDtcbiAgICAgICAgaWYgKGN1dE9mZiA+IDApIHtcbiAgICAgICAgICBpbnNlcnQgPSBtYXRjaFswXS5zbGljZShvZmZzZXQgLSBjdXRPZmYsIG9mZnNldCkgKyBpbnNlcnQ7XG4gICAgICAgICAgc3RhcnQgPSBlbmQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN0YXRlLnRyLmluc2VydFRleHQoaW5zZXJ0LCBzdGFydCwgZW5kKTtcbiAgICB9LFxuICAgIHVuZG9hYmxlOiBjb25maWcudW5kb2FibGVcbiAgfSk7XG59XG5cbi8vIHNyYy9pbnB1dFJ1bGVzL3dyYXBwaW5nSW5wdXRSdWxlLnRzXG5pbXBvcnQgeyBjYW5Kb2luIGFzIGNhbkpvaW4yLCBmaW5kV3JhcHBpbmcgfSBmcm9tIFwiQHRpcHRhcC9wbS90cmFuc2Zvcm1cIjtcbmZ1bmN0aW9uIHdyYXBwaW5nSW5wdXRSdWxlKGNvbmZpZykge1xuICByZXR1cm4gbmV3IElucHV0UnVsZSh7XG4gICAgZmluZDogY29uZmlnLmZpbmQsXG4gICAgaGFuZGxlcjogKHsgc3RhdGUsIHJhbmdlLCBtYXRjaCwgY2hhaW4gfSkgPT4ge1xuICAgICAgY29uc3QgYXR0cmlidXRlcyA9IGNhbGxPclJldHVybihjb25maWcuZ2V0QXR0cmlidXRlcywgdm9pZCAwLCBtYXRjaCkgfHwge307XG4gICAgICBjb25zdCB0ciA9IHN0YXRlLnRyLmRlbGV0ZShyYW5nZS5mcm9tLCByYW5nZS50byk7XG4gICAgICBjb25zdCAkc3RhcnQgPSB0ci5kb2MucmVzb2x2ZShyYW5nZS5mcm9tKTtcbiAgICAgIGNvbnN0IGJsb2NrUmFuZ2UgPSAkc3RhcnQuYmxvY2tSYW5nZSgpO1xuICAgICAgY29uc3Qgd3JhcHBpbmcgPSBibG9ja1JhbmdlICYmIGZpbmRXcmFwcGluZyhibG9ja1JhbmdlLCBjb25maWcudHlwZSwgYXR0cmlidXRlcyk7XG4gICAgICBpZiAoIXdyYXBwaW5nKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdHIud3JhcChibG9ja1JhbmdlLCB3cmFwcGluZyk7XG4gICAgICBpZiAoY29uZmlnLmtlZXBNYXJrcyAmJiBjb25maWcuZWRpdG9yKSB7XG4gICAgICAgIGNvbnN0IHsgc2VsZWN0aW9uLCBzdG9yZWRNYXJrcyB9ID0gc3RhdGU7XG4gICAgICAgIGNvbnN0IHsgc3BsaXR0YWJsZU1hcmtzIH0gPSBjb25maWcuZWRpdG9yLmV4dGVuc2lvbk1hbmFnZXI7XG4gICAgICAgIGNvbnN0IG1hcmtzID0gc3RvcmVkTWFya3MgfHwgc2VsZWN0aW9uLiR0by5wYXJlbnRPZmZzZXQgJiYgc2VsZWN0aW9uLiRmcm9tLm1hcmtzKCk7XG4gICAgICAgIGlmIChtYXJrcykge1xuICAgICAgICAgIGNvbnN0IGZpbHRlcmVkTWFya3MgPSBtYXJrcy5maWx0ZXIoKG1hcmspID0+IHNwbGl0dGFibGVNYXJrcy5pbmNsdWRlcyhtYXJrLnR5cGUubmFtZSkpO1xuICAgICAgICAgIHRyLmVuc3VyZU1hcmtzKGZpbHRlcmVkTWFya3MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY29uZmlnLmtlZXBBdHRyaWJ1dGVzKSB7XG4gICAgICAgIGNvbnN0IG5vZGVUeXBlID0gY29uZmlnLnR5cGUubmFtZSA9PT0gXCJidWxsZXRMaXN0XCIgfHwgY29uZmlnLnR5cGUubmFtZSA9PT0gXCJvcmRlcmVkTGlzdFwiID8gXCJsaXN0SXRlbVwiIDogXCJ0YXNrTGlzdFwiO1xuICAgICAgICBjaGFpbigpLnVwZGF0ZUF0dHJpYnV0ZXMobm9kZVR5cGUsIGF0dHJpYnV0ZXMpLnJ1bigpO1xuICAgICAgfVxuICAgICAgY29uc3QgYmVmb3JlID0gdHIuZG9jLnJlc29sdmUocmFuZ2UuZnJvbSAtIDEpLm5vZGVCZWZvcmU7XG4gICAgICBpZiAoYmVmb3JlICYmIGJlZm9yZS50eXBlID09PSBjb25maWcudHlwZSAmJiBjYW5Kb2luMih0ci5kb2MsIHJhbmdlLmZyb20gLSAxKSAmJiAoIWNvbmZpZy5qb2luUHJlZGljYXRlIHx8IGNvbmZpZy5qb2luUHJlZGljYXRlKG1hdGNoLCBiZWZvcmUpKSkge1xuICAgICAgICB0ci5qb2luKHJhbmdlLmZyb20gLSAxKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVuZG9hYmxlOiBjb25maWcudW5kb2FibGVcbiAgfSk7XG59XG5cbi8vIHNyYy9qc3gtcnVudGltZS50c1xuZnVuY3Rpb24gRnJhZ21lbnQ2KHByb3BzKSB7XG4gIHJldHVybiBwcm9wcy5jaGlsZHJlbjtcbn1cbnZhciBoID0gKHRhZywgYXR0cmlidXRlcykgPT4ge1xuICBpZiAodGFnID09PSBcInNsb3RcIikge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGlmICh0YWcgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgIHJldHVybiB0YWcoYXR0cmlidXRlcyk7XG4gIH1cbiAgY29uc3QgeyBjaGlsZHJlbiwgLi4ucmVzdCB9ID0gYXR0cmlidXRlcyAhPSBudWxsID8gYXR0cmlidXRlcyA6IHt9O1xuICBpZiAodGFnID09PSBcInN2Z1wiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU1ZHIGVsZW1lbnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluIHRoZSBKU1ggc3ludGF4LCB1c2UgdGhlIGFycmF5IHN5bnRheCBpbnN0ZWFkXCIpO1xuICB9XG4gIHJldHVybiBbdGFnLCByZXN0LCBjaGlsZHJlbl07XG59O1xuXG4vLyBzcmMvbGliL1Jlc2l6YWJsZU5vZGVWaWV3LnRzXG52YXIgaXNUb3VjaEV2ZW50ID0gKGUpID0+IHtcbiAgcmV0dXJuIFwidG91Y2hlc1wiIGluIGU7XG59O1xudmFyIFJlc2l6YWJsZU5vZGVWaWV3ID0gY2xhc3Mge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBSZXNpemFibGVOb2RlVmlldyBpbnN0YW5jZS5cbiAgICpcbiAgICogVGhlIGNvbnN0cnVjdG9yIHNldHMgdXAgdGhlIHJlc2l6ZSBoYW5kbGVzLCBhcHBsaWVzIGluaXRpYWwgc2l6aW5nIGZyb21cbiAgICogbm9kZSBhdHRyaWJ1dGVzLCBhbmQgY29uZmlndXJlcyBhbGwgcmVzaXplIGJlaGF2aW9yIG9wdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gQ29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgcmVzaXphYmxlIG5vZGUgdmlld1xuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIC8qKiBBY3RpdmUgcmVzaXplIGhhbmRsZSBkaXJlY3Rpb25zICovXG4gICAgdGhpcy5kaXJlY3Rpb25zID0gW1wiYm90dG9tLWxlZnRcIiwgXCJib3R0b20tcmlnaHRcIiwgXCJ0b3AtbGVmdFwiLCBcInRvcC1yaWdodFwiXTtcbiAgICAvKiogTWluaW11bSBhbGxvd2VkIGRpbWVuc2lvbnMgKi9cbiAgICB0aGlzLm1pblNpemUgPSB7XG4gICAgICBoZWlnaHQ6IDgsXG4gICAgICB3aWR0aDogOFxuICAgIH07XG4gICAgLyoqIFdoZXRoZXIgdG8gYWx3YXlzIHByZXNlcnZlIGFzcGVjdCByYXRpbyAqL1xuICAgIHRoaXMucHJlc2VydmVBc3BlY3RSYXRpbyA9IGZhbHNlO1xuICAgIC8qKiBDU1MgY2xhc3MgbmFtZXMgZm9yIGVsZW1lbnRzICovXG4gICAgdGhpcy5jbGFzc05hbWVzID0ge1xuICAgICAgY29udGFpbmVyOiBcIlwiLFxuICAgICAgd3JhcHBlcjogXCJcIixcbiAgICAgIGhhbmRsZTogXCJcIixcbiAgICAgIHJlc2l6aW5nOiBcIlwiXG4gICAgfTtcbiAgICAvKiogSW5pdGlhbCB3aWR0aCBvZiB0aGUgZWxlbWVudCAoZm9yIGFzcGVjdCByYXRpbyBjYWxjdWxhdGlvbikgKi9cbiAgICB0aGlzLmluaXRpYWxXaWR0aCA9IDA7XG4gICAgLyoqIEluaXRpYWwgaGVpZ2h0IG9mIHRoZSBlbGVtZW50IChmb3IgYXNwZWN0IHJhdGlvIGNhbGN1bGF0aW9uKSAqL1xuICAgIHRoaXMuaW5pdGlhbEhlaWdodCA9IDA7XG4gICAgLyoqIENhbGN1bGF0ZWQgYXNwZWN0IHJhdGlvICh3aWR0aCAvIGhlaWdodCkgKi9cbiAgICB0aGlzLmFzcGVjdFJhdGlvID0gMTtcbiAgICAvKiogV2hldGhlciBhIHJlc2l6ZSBvcGVyYXRpb24gaXMgY3VycmVudGx5IGFjdGl2ZSAqL1xuICAgIHRoaXMuaXNSZXNpemluZyA9IGZhbHNlO1xuICAgIC8qKiBUaGUgaGFuZGxlIGN1cnJlbnRseSBiZWluZyBkcmFnZ2VkICovXG4gICAgdGhpcy5hY3RpdmVIYW5kbGUgPSBudWxsO1xuICAgIC8qKiBTdGFydGluZyBtb3VzZSBYIHBvc2l0aW9uIHdoZW4gcmVzaXplIGJlZ2FuICovXG4gICAgdGhpcy5zdGFydFggPSAwO1xuICAgIC8qKiBTdGFydGluZyBtb3VzZSBZIHBvc2l0aW9uIHdoZW4gcmVzaXplIGJlZ2FuICovXG4gICAgdGhpcy5zdGFydFkgPSAwO1xuICAgIC8qKiBFbGVtZW50IHdpZHRoIHdoZW4gcmVzaXplIGJlZ2FuICovXG4gICAgdGhpcy5zdGFydFdpZHRoID0gMDtcbiAgICAvKiogRWxlbWVudCBoZWlnaHQgd2hlbiByZXNpemUgYmVnYW4gKi9cbiAgICB0aGlzLnN0YXJ0SGVpZ2h0ID0gMDtcbiAgICAvKiogV2hldGhlciBTaGlmdCBrZXkgaXMgY3VycmVudGx5IHByZXNzZWQgKGZvciB0ZW1wb3JhcnkgYXNwZWN0IHJhdGlvIGxvY2spICovXG4gICAgdGhpcy5pc1NoaWZ0S2V5UHJlc3NlZCA9IGZhbHNlO1xuICAgIC8qKiBMYXN0IGtub3duIGVkaXRhYmxlIHN0YXRlIG9mIHRoZSBlZGl0b3IgKi9cbiAgICB0aGlzLmxhc3RFZGl0YWJsZVN0YXRlID0gdm9pZCAwO1xuICAgIC8qKiBNYXAgb2YgaGFuZGxlIGVsZW1lbnRzIGJ5IGRpcmVjdGlvbiAqL1xuICAgIHRoaXMuaGFuZGxlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIG1vdXNlIG1vdmVtZW50IGR1cmluZyBhbiBhY3RpdmUgcmVzaXplLlxuICAgICAqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgZGVsdGEgZnJvbSB0aGUgc3RhcnRpbmcgcG9zaXRpb24sIGNvbXB1dGVzIG5ldyBkaW1lbnNpb25zXG4gICAgICogYmFzZWQgb24gdGhlIGFjdGl2ZSBoYW5kbGUgZGlyZWN0aW9uLCBhcHBsaWVzIGNvbnN0cmFpbnRzIGFuZCBhc3BlY3QgcmF0aW8sXG4gICAgICogdGhlbiB1cGRhdGVzIHRoZSBlbGVtZW50J3Mgc3R5bGUgYW5kIGNhbGxzIHRoZSBvblJlc2l6ZSBjYWxsYmFjay5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldmVudCAtIFRoZSBtb3VzZSBtb3ZlIGV2ZW50XG4gICAgICovXG4gICAgdGhpcy5oYW5kbGVNb3VzZU1vdmUgPSAoZXZlbnQpID0+IHtcbiAgICAgIGlmICghdGhpcy5pc1Jlc2l6aW5nIHx8ICF0aGlzLmFjdGl2ZUhhbmRsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBkZWx0YVggPSBldmVudC5jbGllbnRYIC0gdGhpcy5zdGFydFg7XG4gICAgICBjb25zdCBkZWx0YVkgPSBldmVudC5jbGllbnRZIC0gdGhpcy5zdGFydFk7XG4gICAgICB0aGlzLmhhbmRsZVJlc2l6ZShkZWx0YVgsIGRlbHRhWSk7XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZVRvdWNoTW92ZSA9IChldmVudCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLmlzUmVzaXppbmcgfHwgIXRoaXMuYWN0aXZlSGFuZGxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRvdWNoID0gZXZlbnQudG91Y2hlc1swXTtcbiAgICAgIGlmICghdG91Y2gpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZGVsdGFYID0gdG91Y2guY2xpZW50WCAtIHRoaXMuc3RhcnRYO1xuICAgICAgY29uc3QgZGVsdGFZID0gdG91Y2guY2xpZW50WSAtIHRoaXMuc3RhcnRZO1xuICAgICAgdGhpcy5oYW5kbGVSZXNpemUoZGVsdGFYLCBkZWx0YVkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29tcGxldGVzIHRoZSByZXNpemUgb3BlcmF0aW9uIHdoZW4gdGhlIG1vdXNlIGJ1dHRvbiBpcyByZWxlYXNlZC5cbiAgICAgKlxuICAgICAqIENhcHR1cmVzIGZpbmFsIGRpbWVuc2lvbnMsIGNhbGxzIHRoZSBvbkNvbW1pdCBjYWxsYmFjayB0byBwZXJzaXN0IGNoYW5nZXMsXG4gICAgICogcmVtb3ZlcyB0aGUgcmVzaXppbmcgc3RhdGUgYW5kIGNsYXNzLCBhbmQgY2xlYW5zIHVwIGRvY3VtZW50LWxldmVsIGxpc3RlbmVycy5cbiAgICAgKi9cbiAgICB0aGlzLmhhbmRsZU1vdXNlVXAgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuaXNSZXNpemluZykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBmaW5hbFdpZHRoID0gdGhpcy5lbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgICAgY29uc3QgZmluYWxIZWlnaHQgPSB0aGlzLmVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuICAgICAgdGhpcy5vbkNvbW1pdChmaW5hbFdpZHRoLCBmaW5hbEhlaWdodCk7XG4gICAgICB0aGlzLmlzUmVzaXppbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMuYWN0aXZlSGFuZGxlID0gbnVsbDtcbiAgICAgIHRoaXMuY29udGFpbmVyLmRhdGFzZXQucmVzaXplU3RhdGUgPSBcImZhbHNlXCI7XG4gICAgICBpZiAodGhpcy5jbGFzc05hbWVzLnJlc2l6aW5nKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5jbGFzc05hbWVzLnJlc2l6aW5nKTtcbiAgICAgIH1cbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5oYW5kbGVNb3VzZU1vdmUpO1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdGhpcy5oYW5kbGVNb3VzZVVwKTtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuaGFuZGxlS2V5RG93bik7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5dXBcIiwgdGhpcy5oYW5kbGVLZXlVcCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUcmFja3MgU2hpZnQga2V5IHN0YXRlIHRvIGVuYWJsZSB0ZW1wb3JhcnkgYXNwZWN0IHJhdGlvIGxvY2tpbmcuXG4gICAgICpcbiAgICAgKiBXaGVuIFNoaWZ0IGlzIHByZXNzZWQgZHVyaW5nIHJlc2l6ZSwgYXNwZWN0IHJhdGlvIGlzIHByZXNlcnZlZCBldmVuIGlmXG4gICAgICogcHJlc2VydmVBc3BlY3RSYXRpbyBpcyBmYWxzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldmVudCAtIFRoZSBrZXlib2FyZCBldmVudFxuICAgICAqL1xuICAgIHRoaXMuaGFuZGxlS2V5RG93biA9IChldmVudCkgPT4ge1xuICAgICAgaWYgKGV2ZW50LmtleSA9PT0gXCJTaGlmdFwiKSB7XG4gICAgICAgIHRoaXMuaXNTaGlmdEtleVByZXNzZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVHJhY2tzIFNoaWZ0IGtleSByZWxlYXNlIHRvIGRpc2FibGUgdGVtcG9yYXJ5IGFzcGVjdCByYXRpbyBsb2NraW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIGV2ZW50IC0gVGhlIGtleWJvYXJkIGV2ZW50XG4gICAgICovXG4gICAgdGhpcy5oYW5kbGVLZXlVcCA9IChldmVudCkgPT4ge1xuICAgICAgaWYgKGV2ZW50LmtleSA9PT0gXCJTaGlmdFwiKSB7XG4gICAgICAgIHRoaXMuaXNTaGlmdEtleVByZXNzZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgIHRoaXMubm9kZSA9IG9wdGlvbnMubm9kZTtcbiAgICB0aGlzLmVkaXRvciA9IG9wdGlvbnMuZWRpdG9yO1xuICAgIHRoaXMuZWxlbWVudCA9IG9wdGlvbnMuZWxlbWVudDtcbiAgICB0aGlzLmNvbnRlbnRFbGVtZW50ID0gb3B0aW9ucy5jb250ZW50RWxlbWVudDtcbiAgICB0aGlzLmdldFBvcyA9IG9wdGlvbnMuZ2V0UG9zO1xuICAgIHRoaXMub25SZXNpemUgPSBvcHRpb25zLm9uUmVzaXplO1xuICAgIHRoaXMub25Db21taXQgPSBvcHRpb25zLm9uQ29tbWl0O1xuICAgIHRoaXMub25VcGRhdGUgPSBvcHRpb25zLm9uVXBkYXRlO1xuICAgIGlmICgoX2EgPSBvcHRpb25zLm9wdGlvbnMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5taW4pIHtcbiAgICAgIHRoaXMubWluU2l6ZSA9IHtcbiAgICAgICAgLi4udGhpcy5taW5TaXplLFxuICAgICAgICAuLi5vcHRpb25zLm9wdGlvbnMubWluXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoKF9iID0gb3B0aW9ucy5vcHRpb25zKSA9PSBudWxsID8gdm9pZCAwIDogX2IubWF4KSB7XG4gICAgICB0aGlzLm1heFNpemUgPSBvcHRpb25zLm9wdGlvbnMubWF4O1xuICAgIH1cbiAgICBpZiAoKF9jID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5vcHRpb25zKSA9PSBudWxsID8gdm9pZCAwIDogX2MuZGlyZWN0aW9ucykge1xuICAgICAgdGhpcy5kaXJlY3Rpb25zID0gb3B0aW9ucy5vcHRpb25zLmRpcmVjdGlvbnM7XG4gICAgfVxuICAgIGlmICgoX2QgPSBvcHRpb25zLm9wdGlvbnMpID09IG51bGwgPyB2b2lkIDAgOiBfZC5wcmVzZXJ2ZUFzcGVjdFJhdGlvKSB7XG4gICAgICB0aGlzLnByZXNlcnZlQXNwZWN0UmF0aW8gPSBvcHRpb25zLm9wdGlvbnMucHJlc2VydmVBc3BlY3RSYXRpbztcbiAgICB9XG4gICAgaWYgKChfZSA9IG9wdGlvbnMub3B0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9lLmNsYXNzTmFtZSkge1xuICAgICAgdGhpcy5jbGFzc05hbWVzID0ge1xuICAgICAgICBjb250YWluZXI6IG9wdGlvbnMub3B0aW9ucy5jbGFzc05hbWUuY29udGFpbmVyIHx8IFwiXCIsXG4gICAgICAgIHdyYXBwZXI6IG9wdGlvbnMub3B0aW9ucy5jbGFzc05hbWUud3JhcHBlciB8fCBcIlwiLFxuICAgICAgICBoYW5kbGU6IG9wdGlvbnMub3B0aW9ucy5jbGFzc05hbWUuaGFuZGxlIHx8IFwiXCIsXG4gICAgICAgIHJlc2l6aW5nOiBvcHRpb25zLm9wdGlvbnMuY2xhc3NOYW1lLnJlc2l6aW5nIHx8IFwiXCJcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICgoX2YgPSBvcHRpb25zLm9wdGlvbnMpID09IG51bGwgPyB2b2lkIDAgOiBfZi5jcmVhdGVDdXN0b21IYW5kbGUpIHtcbiAgICAgIHRoaXMuY3JlYXRlQ3VzdG9tSGFuZGxlID0gb3B0aW9ucy5vcHRpb25zLmNyZWF0ZUN1c3RvbUhhbmRsZTtcbiAgICB9XG4gICAgdGhpcy53cmFwcGVyID0gdGhpcy5jcmVhdGVXcmFwcGVyKCk7XG4gICAgdGhpcy5jb250YWluZXIgPSB0aGlzLmNyZWF0ZUNvbnRhaW5lcigpO1xuICAgIHRoaXMuYXBwbHlJbml0aWFsU2l6ZSgpO1xuICAgIHRoaXMuYXR0YWNoSGFuZGxlcygpO1xuICAgIHRoaXMuZWRpdG9yLm9uKFwidXBkYXRlXCIsIHRoaXMuaGFuZGxlRWRpdG9yVXBkYXRlLmJpbmQodGhpcykpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0b3AtbGV2ZWwgRE9NIG5vZGUgdGhhdCBzaG91bGQgYmUgcGxhY2VkIGluIHRoZSBlZGl0b3IuXG4gICAqXG4gICAqIFRoaXMgaXMgcmVxdWlyZWQgYnkgdGhlIFByb3NlTWlycm9yIE5vZGVWaWV3IGludGVyZmFjZS4gVGhlIGNvbnRhaW5lclxuICAgKiBpbmNsdWRlcyB0aGUgd3JhcHBlciwgaGFuZGxlcywgYW5kIHRoZSBhY3R1YWwgY29udGVudCBlbGVtZW50LlxuICAgKlxuICAgKiBAcmV0dXJucyBUaGUgY29udGFpbmVyIGVsZW1lbnQgdG8gYmUgaW5zZXJ0ZWQgaW50byB0aGUgZWRpdG9yXG4gICAqL1xuICBnZXQgZG9tKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxuICBnZXQgY29udGVudERPTSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZW50RWxlbWVudDtcbiAgfVxuICBoYW5kbGVFZGl0b3JVcGRhdGUoKSB7XG4gICAgY29uc3QgaXNFZGl0YWJsZSA9IHRoaXMuZWRpdG9yLmlzRWRpdGFibGU7XG4gICAgaWYgKGlzRWRpdGFibGUgPT09IHRoaXMubGFzdEVkaXRhYmxlU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5sYXN0RWRpdGFibGVTdGF0ZSA9IGlzRWRpdGFibGU7XG4gICAgaWYgKCFpc0VkaXRhYmxlKSB7XG4gICAgICB0aGlzLnJlbW92ZUhhbmRsZXMoKTtcbiAgICB9IGVsc2UgaWYgKGlzRWRpdGFibGUgJiYgdGhpcy5oYW5kbGVNYXAuc2l6ZSA9PT0gMCkge1xuICAgICAgdGhpcy5hdHRhY2hIYW5kbGVzKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiB0aGUgbm9kZSdzIGNvbnRlbnQgb3IgYXR0cmlidXRlcyBjaGFuZ2UuXG4gICAqXG4gICAqIFVwZGF0ZXMgdGhlIGludGVybmFsIG5vZGUgcmVmZXJlbmNlLiBJZiBhIGN1c3RvbSBgb25VcGRhdGVgIGNhbGxiYWNrXG4gICAqIHdhcyBwcm92aWRlZCwgaXQgd2lsbCBiZSBjYWxsZWQgdG8gaGFuZGxlIGFkZGl0aW9uYWwgdXBkYXRlIGxvZ2ljLlxuICAgKlxuICAgKiBAcGFyYW0gbm9kZSAtIFRoZSBuZXcvdXBkYXRlZCBub2RlXG4gICAqIEBwYXJhbSBkZWNvcmF0aW9ucyAtIE5vZGUgZGVjb3JhdGlvbnNcbiAgICogQHBhcmFtIGlubmVyRGVjb3JhdGlvbnMgLSBJbm5lciBkZWNvcmF0aW9uc1xuICAgKiBAcmV0dXJucyBgZmFsc2VgIGlmIHRoZSBub2RlIHR5cGUgaGFzIGNoYW5nZWQgKHJlcXVpcmVzIGZ1bGwgcmVidWlsZCksIG90aGVyd2lzZSB0aGUgcmVzdWx0IG9mIGBvblVwZGF0ZWAgb3IgYHRydWVgXG4gICAqL1xuICB1cGRhdGUobm9kZSwgZGVjb3JhdGlvbnMsIGlubmVyRGVjb3JhdGlvbnMpIHtcbiAgICBpZiAobm9kZS50eXBlICE9PSB0aGlzLm5vZGUudHlwZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgIGlmICh0aGlzLm9uVXBkYXRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5vblVwZGF0ZShub2RlLCBkZWNvcmF0aW9ucywgaW5uZXJEZWNvcmF0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBDbGVhbnVwIG1ldGhvZCBjYWxsZWQgd2hlbiB0aGUgbm9kZSB2aWV3IGlzIGJlaW5nIHJlbW92ZWQuXG4gICAqXG4gICAqIFJlbW92ZXMgYWxsIGV2ZW50IGxpc3RlbmVycyB0byBwcmV2ZW50IG1lbW9yeSBsZWFrcy4gVGhpcyBpcyByZXF1aXJlZFxuICAgKiBieSB0aGUgUHJvc2VNaXJyb3IgTm9kZVZpZXcgaW50ZXJmYWNlLiBJZiBhIHJlc2l6ZSBpcyBhY3RpdmUgd2hlblxuICAgKiBkZXN0cm95IGlzIGNhbGxlZCwgaXQgd2lsbCBiZSBwcm9wZXJseSBjYW5jZWxsZWQuXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLmlzUmVzaXppbmcpIHtcbiAgICAgIHRoaXMuY29udGFpbmVyLmRhdGFzZXQucmVzaXplU3RhdGUgPSBcImZhbHNlXCI7XG4gICAgICBpZiAodGhpcy5jbGFzc05hbWVzLnJlc2l6aW5nKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5jbGFzc05hbWVzLnJlc2l6aW5nKTtcbiAgICAgIH1cbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5oYW5kbGVNb3VzZU1vdmUpO1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdGhpcy5oYW5kbGVNb3VzZVVwKTtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuaGFuZGxlS2V5RG93bik7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5dXBcIiwgdGhpcy5oYW5kbGVLZXlVcCk7XG4gICAgICB0aGlzLmlzUmVzaXppbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMuYWN0aXZlSGFuZGxlID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5lZGl0b3Iub2ZmKFwidXBkYXRlXCIsIHRoaXMuaGFuZGxlRWRpdG9yVXBkYXRlLmJpbmQodGhpcykpO1xuICAgIHRoaXMuY29udGFpbmVyLnJlbW92ZSgpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIHRoZSBvdXRlciBjb250YWluZXIgZWxlbWVudC5cbiAgICpcbiAgICogVGhlIGNvbnRhaW5lciBpcyB0aGUgdG9wLWxldmVsIGVsZW1lbnQgcmV0dXJuZWQgYnkgdGhlIE5vZGVWaWV3IGFuZFxuICAgKiB3cmFwcyB0aGUgZW50aXJlIHJlc2l6YWJsZSBub2RlLiBJdCdzIHNldCB1cCB3aXRoIGZsZXhib3ggdG8gaGFuZGxlXG4gICAqIGFsaWdubWVudCBhbmQgaW5jbHVkZXMgZGF0YSBhdHRyaWJ1dGVzIGZvciBzdHlsaW5nIGFuZCBpZGVudGlmaWNhdGlvbi5cbiAgICpcbiAgICogQHJldHVybnMgVGhlIGNvbnRhaW5lciBlbGVtZW50XG4gICAqL1xuICBjcmVhdGVDb250YWluZXIoKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgZWxlbWVudC5kYXRhc2V0LnJlc2l6ZUNvbnRhaW5lciA9IFwiXCI7XG4gICAgZWxlbWVudC5kYXRhc2V0Lm5vZGUgPSB0aGlzLm5vZGUudHlwZS5uYW1lO1xuICAgIGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IFwiZmxleFwiO1xuICAgIGlmICh0aGlzLmNsYXNzTmFtZXMuY29udGFpbmVyKSB7XG4gICAgICBlbGVtZW50LmNsYXNzTmFtZSA9IHRoaXMuY2xhc3NOYW1lcy5jb250YWluZXI7XG4gICAgfVxuICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy53cmFwcGVyKTtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyB0aGUgd3JhcHBlciBlbGVtZW50IHRoYXQgY29udGFpbnMgdGhlIGNvbnRlbnQgYW5kIGhhbmRsZXMuXG4gICAqXG4gICAqIFRoZSB3cmFwcGVyIHVzZXMgcmVsYXRpdmUgcG9zaXRpb25pbmcgc28gdGhhdCByZXNpemUgaGFuZGxlcyBjYW4gYmVcbiAgICogcG9zaXRpb25lZCBhYnNvbHV0ZWx5IHdpdGhpbiBpdC4gVGhpcyBpcyB0aGUgZGlyZWN0IHBhcmVudCBvZiB0aGVcbiAgICogY29udGVudCBlbGVtZW50IGJlaW5nIG1hZGUgcmVzaXphYmxlLlxuICAgKlxuICAgKiBAcmV0dXJucyBUaGUgd3JhcHBlciBlbGVtZW50XG4gICAqL1xuICBjcmVhdGVXcmFwcGVyKCkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG4gICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgIGVsZW1lbnQuZGF0YXNldC5yZXNpemVXcmFwcGVyID0gXCJcIjtcbiAgICBpZiAodGhpcy5jbGFzc05hbWVzLndyYXBwZXIpIHtcbiAgICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gdGhpcy5jbGFzc05hbWVzLndyYXBwZXI7XG4gICAgfVxuICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5lbGVtZW50KTtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIHJlc2l6ZSBoYW5kbGUgZWxlbWVudCBmb3IgYSBzcGVjaWZpYyBkaXJlY3Rpb24uXG4gICAqXG4gICAqIEVhY2ggaGFuZGxlIGlzIGFic29sdXRlbHkgcG9zaXRpb25lZCBhbmQgaW5jbHVkZXMgYSBkYXRhIGF0dHJpYnV0ZVxuICAgKiBpZGVudGlmeWluZyBpdHMgZGlyZWN0aW9uIGZvciBzdHlsaW5nIHB1cnBvc2VzLlxuICAgKlxuICAgKiBAcGFyYW0gZGlyZWN0aW9uIC0gVGhlIHJlc2l6ZSBkaXJlY3Rpb24gZm9yIHRoaXMgaGFuZGxlXG4gICAqIEByZXR1cm5zIFRoZSBoYW5kbGUgZWxlbWVudFxuICAgKi9cbiAgY3JlYXRlSGFuZGxlKGRpcmVjdGlvbikge1xuICAgIGNvbnN0IGhhbmRsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgaGFuZGxlLmRhdGFzZXQucmVzaXplSGFuZGxlID0gZGlyZWN0aW9uO1xuICAgIGhhbmRsZS5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICBpZiAodGhpcy5jbGFzc05hbWVzLmhhbmRsZSkge1xuICAgICAgaGFuZGxlLmNsYXNzTmFtZSA9IHRoaXMuY2xhc3NOYW1lcy5oYW5kbGU7XG4gICAgfVxuICAgIHJldHVybiBoYW5kbGU7XG4gIH1cbiAgLyoqXG4gICAqIFBvc2l0aW9ucyBhIGhhbmRsZSBlbGVtZW50IGFjY29yZGluZyB0byBpdHMgZGlyZWN0aW9uLlxuICAgKlxuICAgKiBDb3JuZXIgaGFuZGxlcyAoZS5nLiwgJ3RvcC1sZWZ0JykgYXJlIHBvc2l0aW9uZWQgYXQgdGhlIGludGVyc2VjdGlvblxuICAgKiBvZiB0d28gZWRnZXMuIEVkZ2UgaGFuZGxlcyAoZS5nLiwgJ3RvcCcpIHNwYW4gdGhlIGZ1bGwgd2lkdGggb3IgaGVpZ2h0LlxuICAgKlxuICAgKiBAcGFyYW0gaGFuZGxlIC0gVGhlIGhhbmRsZSBlbGVtZW50IHRvIHBvc2l0aW9uXG4gICAqIEBwYXJhbSBkaXJlY3Rpb24gLSBUaGUgZGlyZWN0aW9uIGRldGVybWluaW5nIHRoZSBwb3NpdGlvblxuICAgKi9cbiAgcG9zaXRpb25IYW5kbGUoaGFuZGxlLCBkaXJlY3Rpb24pIHtcbiAgICBjb25zdCBpc1RvcCA9IGRpcmVjdGlvbi5pbmNsdWRlcyhcInRvcFwiKTtcbiAgICBjb25zdCBpc0JvdHRvbSA9IGRpcmVjdGlvbi5pbmNsdWRlcyhcImJvdHRvbVwiKTtcbiAgICBjb25zdCBpc0xlZnQgPSBkaXJlY3Rpb24uaW5jbHVkZXMoXCJsZWZ0XCIpO1xuICAgIGNvbnN0IGlzUmlnaHQgPSBkaXJlY3Rpb24uaW5jbHVkZXMoXCJyaWdodFwiKTtcbiAgICBpZiAoaXNUb3ApIHtcbiAgICAgIGhhbmRsZS5zdHlsZS50b3AgPSBcIjBcIjtcbiAgICB9XG4gICAgaWYgKGlzQm90dG9tKSB7XG4gICAgICBoYW5kbGUuc3R5bGUuYm90dG9tID0gXCIwXCI7XG4gICAgfVxuICAgIGlmIChpc0xlZnQpIHtcbiAgICAgIGhhbmRsZS5zdHlsZS5sZWZ0ID0gXCIwXCI7XG4gICAgfVxuICAgIGlmIChpc1JpZ2h0KSB7XG4gICAgICBoYW5kbGUuc3R5bGUucmlnaHQgPSBcIjBcIjtcbiAgICB9XG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gXCJ0b3BcIiB8fCBkaXJlY3Rpb24gPT09IFwiYm90dG9tXCIpIHtcbiAgICAgIGhhbmRsZS5zdHlsZS5sZWZ0ID0gXCIwXCI7XG4gICAgICBoYW5kbGUuc3R5bGUucmlnaHQgPSBcIjBcIjtcbiAgICB9XG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gXCJsZWZ0XCIgfHwgZGlyZWN0aW9uID09PSBcInJpZ2h0XCIpIHtcbiAgICAgIGhhbmRsZS5zdHlsZS50b3AgPSBcIjBcIjtcbiAgICAgIGhhbmRsZS5zdHlsZS5ib3R0b20gPSBcIjBcIjtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW5kIGF0dGFjaGVzIGFsbCByZXNpemUgaGFuZGxlcyB0byB0aGUgd3JhcHBlci5cbiAgICpcbiAgICogSXRlcmF0ZXMgdGhyb3VnaCB0aGUgY29uZmlndXJlZCBkaXJlY3Rpb25zLCBjcmVhdGVzIGEgaGFuZGxlIGZvciBlYWNoLFxuICAgKiBwb3NpdGlvbnMgaXQsIGF0dGFjaGVzIHRoZSBtb3VzZWRvd24gbGlzdGVuZXIsIGFuZCBhcHBlbmRzIGl0IHRvIHRoZSBET00uXG4gICAqL1xuICBhdHRhY2hIYW5kbGVzKCkge1xuICAgIHRoaXMuZGlyZWN0aW9ucy5mb3JFYWNoKChkaXJlY3Rpb24pID0+IHtcbiAgICAgIGxldCBoYW5kbGU7XG4gICAgICBpZiAodGhpcy5jcmVhdGVDdXN0b21IYW5kbGUpIHtcbiAgICAgICAgaGFuZGxlID0gdGhpcy5jcmVhdGVDdXN0b21IYW5kbGUoZGlyZWN0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhbmRsZSA9IHRoaXMuY3JlYXRlSGFuZGxlKGRpcmVjdGlvbik7XG4gICAgICB9XG4gICAgICBpZiAoIShoYW5kbGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIGBbUmVzaXphYmxlTm9kZVZpZXddIGNyZWF0ZUN1c3RvbUhhbmRsZShcIiR7ZGlyZWN0aW9ufVwiKSBkaWQgbm90IHJldHVybiBhbiBIVE1MRWxlbWVudC4gRmFsbGluZyBiYWNrIHRvIGRlZmF1bHQgaGFuZGxlLmBcbiAgICAgICAgKTtcbiAgICAgICAgaGFuZGxlID0gdGhpcy5jcmVhdGVIYW5kbGUoZGlyZWN0aW9uKTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5jcmVhdGVDdXN0b21IYW5kbGUpIHtcbiAgICAgICAgdGhpcy5wb3NpdGlvbkhhbmRsZShoYW5kbGUsIGRpcmVjdGlvbik7XG4gICAgICB9XG4gICAgICBoYW5kbGUuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCAoZXZlbnQpID0+IHRoaXMuaGFuZGxlUmVzaXplU3RhcnQoZXZlbnQsIGRpcmVjdGlvbikpO1xuICAgICAgaGFuZGxlLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIChldmVudCkgPT4gdGhpcy5oYW5kbGVSZXNpemVTdGFydChldmVudCwgZGlyZWN0aW9uKSk7XG4gICAgICB0aGlzLmhhbmRsZU1hcC5zZXQoZGlyZWN0aW9uLCBoYW5kbGUpO1xuICAgICAgdGhpcy53cmFwcGVyLmFwcGVuZENoaWxkKGhhbmRsZSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgYWxsIHJlc2l6ZSBoYW5kbGVzIGZyb20gdGhlIHdyYXBwZXIuXG4gICAqXG4gICAqIENsZWFucyB1cCB0aGUgaGFuZGxlIG1hcCBhbmQgcmVtb3ZlcyBlYWNoIGhhbmRsZSBlbGVtZW50IGZyb20gdGhlIERPTS5cbiAgICovXG4gIHJlbW92ZUhhbmRsZXMoKSB7XG4gICAgdGhpcy5oYW5kbGVNYXAuZm9yRWFjaCgoZWwpID0+IGVsLnJlbW92ZSgpKTtcbiAgICB0aGlzLmhhbmRsZU1hcC5jbGVhcigpO1xuICB9XG4gIC8qKlxuICAgKiBBcHBsaWVzIGluaXRpYWwgc2l6aW5nIGZyb20gbm9kZSBhdHRyaWJ1dGVzIHRvIHRoZSBlbGVtZW50LlxuICAgKlxuICAgKiBJZiB3aWR0aC9oZWlnaHQgYXR0cmlidXRlcyBleGlzdCBvbiB0aGUgbm9kZSwgdGhleSdyZSBhcHBsaWVkIHRvIHRoZSBlbGVtZW50LlxuICAgKiBPdGhlcndpc2UsIHRoZSBlbGVtZW50J3MgbmF0dXJhbC9jdXJyZW50IGRpbWVuc2lvbnMgYXJlIG1lYXN1cmVkLiBUaGUgYXNwZWN0XG4gICAqIHJhdGlvIGlzIGNhbGN1bGF0ZWQgZm9yIGxhdGVyIHVzZSBpbiBhc3BlY3QtcmF0aW8tcHJlc2VydmluZyByZXNpemVzLlxuICAgKi9cbiAgYXBwbHlJbml0aWFsU2l6ZSgpIHtcbiAgICBjb25zdCB3aWR0aCA9IHRoaXMubm9kZS5hdHRycy53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSB0aGlzLm5vZGUuYXR0cnMuaGVpZ2h0O1xuICAgIGlmICh3aWR0aCkge1xuICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLndpZHRoID0gYCR7d2lkdGh9cHhgO1xuICAgICAgdGhpcy5pbml0aWFsV2lkdGggPSB3aWR0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pbml0aWFsV2lkdGggPSB0aGlzLmVsZW1lbnQub2Zmc2V0V2lkdGg7XG4gICAgfVxuICAgIGlmIChoZWlnaHQpIHtcbiAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5oZWlnaHQgPSBgJHtoZWlnaHR9cHhgO1xuICAgICAgdGhpcy5pbml0aWFsSGVpZ2h0ID0gaGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmluaXRpYWxIZWlnaHQgPSB0aGlzLmVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuICAgIH1cbiAgICBpZiAodGhpcy5pbml0aWFsV2lkdGggPiAwICYmIHRoaXMuaW5pdGlhbEhlaWdodCA+IDApIHtcbiAgICAgIHRoaXMuYXNwZWN0UmF0aW8gPSB0aGlzLmluaXRpYWxXaWR0aCAvIHRoaXMuaW5pdGlhbEhlaWdodDtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEluaXRpYXRlcyBhIHJlc2l6ZSBvcGVyYXRpb24gd2hlbiBhIGhhbmRsZSBpcyBjbGlja2VkLlxuICAgKlxuICAgKiBDYXB0dXJlcyB0aGUgc3RhcnRpbmcgbW91c2UgcG9zaXRpb24gYW5kIGVsZW1lbnQgZGltZW5zaW9ucywgc2V0cyB1cFxuICAgKiB0aGUgcmVzaXplIHN0YXRlLCBhZGRzIHRoZSByZXNpemluZyBjbGFzcyBhbmQgc3RhdGUgYXR0cmlidXRlLCBhbmRcbiAgICogYXR0YWNoZXMgZG9jdW1lbnQtbGV2ZWwgbGlzdGVuZXJzIGZvciBtb3VzZSBtb3ZlbWVudCBhbmQga2V5Ym9hcmQgaW5wdXQuXG4gICAqXG4gICAqIEBwYXJhbSBldmVudCAtIFRoZSBtb3VzZSBkb3duIGV2ZW50XG4gICAqIEBwYXJhbSBkaXJlY3Rpb24gLSBUaGUgZGlyZWN0aW9uIG9mIHRoZSBoYW5kbGUgYmVpbmcgZHJhZ2dlZFxuICAgKi9cbiAgaGFuZGxlUmVzaXplU3RhcnQoZXZlbnQsIGRpcmVjdGlvbikge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgdGhpcy5pc1Jlc2l6aW5nID0gdHJ1ZTtcbiAgICB0aGlzLmFjdGl2ZUhhbmRsZSA9IGRpcmVjdGlvbjtcbiAgICBpZiAoaXNUb3VjaEV2ZW50KGV2ZW50KSkge1xuICAgICAgdGhpcy5zdGFydFggPSBldmVudC50b3VjaGVzWzBdLmNsaWVudFg7XG4gICAgICB0aGlzLnN0YXJ0WSA9IGV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdGFydFggPSBldmVudC5jbGllbnRYO1xuICAgICAgdGhpcy5zdGFydFkgPSBldmVudC5jbGllbnRZO1xuICAgIH1cbiAgICB0aGlzLnN0YXJ0V2lkdGggPSB0aGlzLmVsZW1lbnQub2Zmc2V0V2lkdGg7XG4gICAgdGhpcy5zdGFydEhlaWdodCA9IHRoaXMuZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gICAgaWYgKHRoaXMuc3RhcnRXaWR0aCA+IDAgJiYgdGhpcy5zdGFydEhlaWdodCA+IDApIHtcbiAgICAgIHRoaXMuYXNwZWN0UmF0aW8gPSB0aGlzLnN0YXJ0V2lkdGggLyB0aGlzLnN0YXJ0SGVpZ2h0O1xuICAgIH1cbiAgICBjb25zdCBwb3MgPSB0aGlzLmdldFBvcygpO1xuICAgIGlmIChwb3MgIT09IHZvaWQgMCkge1xuICAgIH1cbiAgICB0aGlzLmNvbnRhaW5lci5kYXRhc2V0LnJlc2l6ZVN0YXRlID0gXCJ0cnVlXCI7XG4gICAgaWYgKHRoaXMuY2xhc3NOYW1lcy5yZXNpemluZykge1xuICAgICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZCh0aGlzLmNsYXNzTmFtZXMucmVzaXppbmcpO1xuICAgIH1cbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMuaGFuZGxlTW91c2VNb3ZlKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIHRoaXMuaGFuZGxlVG91Y2hNb3ZlKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLmhhbmRsZU1vdXNlVXApO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuaGFuZGxlS2V5RG93bik7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIHRoaXMuaGFuZGxlS2V5VXApO1xuICB9XG4gIGhhbmRsZVJlc2l6ZShkZWx0YVgsIGRlbHRhWSkge1xuICAgIGlmICghdGhpcy5hY3RpdmVIYW5kbGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2hvdWxkUHJlc2VydmVBc3BlY3RSYXRpbyA9IHRoaXMucHJlc2VydmVBc3BlY3RSYXRpbyB8fCB0aGlzLmlzU2hpZnRLZXlQcmVzc2VkO1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gdGhpcy5jYWxjdWxhdGVOZXdEaW1lbnNpb25zKHRoaXMuYWN0aXZlSGFuZGxlLCBkZWx0YVgsIGRlbHRhWSk7XG4gICAgY29uc3QgY29uc3RyYWluZWQgPSB0aGlzLmFwcGx5Q29uc3RyYWludHMod2lkdGgsIGhlaWdodCwgc2hvdWxkUHJlc2VydmVBc3BlY3RSYXRpbyk7XG4gICAgdGhpcy5lbGVtZW50LnN0eWxlLndpZHRoID0gYCR7Y29uc3RyYWluZWQud2lkdGh9cHhgO1xuICAgIHRoaXMuZWxlbWVudC5zdHlsZS5oZWlnaHQgPSBgJHtjb25zdHJhaW5lZC5oZWlnaHR9cHhgO1xuICAgIGlmICh0aGlzLm9uUmVzaXplKSB7XG4gICAgICB0aGlzLm9uUmVzaXplKGNvbnN0cmFpbmVkLndpZHRoLCBjb25zdHJhaW5lZC5oZWlnaHQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ2FsY3VsYXRlcyBuZXcgZGltZW5zaW9ucyBiYXNlZCBvbiBtb3VzZSBkZWx0YSBhbmQgcmVzaXplIGRpcmVjdGlvbi5cbiAgICpcbiAgICogVGFrZXMgdGhlIHN0YXJ0aW5nIGRpbWVuc2lvbnMgYW5kIGFwcGxpZXMgdGhlIG1vdXNlIG1vdmVtZW50IGRlbHRhXG4gICAqIGFjY29yZGluZyB0byB0aGUgaGFuZGxlIGRpcmVjdGlvbi4gRm9yIGNvcm5lciBoYW5kbGVzLCBib3RoIGRpbWVuc2lvbnNcbiAgICogYXJlIGFmZmVjdGVkLiBGb3IgZWRnZSBoYW5kbGVzLCBvbmx5IG9uZSBkaW1lbnNpb24gY2hhbmdlcy4gSWYgYXNwZWN0XG4gICAqIHJhdGlvIHNob3VsZCBiZSBwcmVzZXJ2ZWQsIGRlbGVnYXRlcyB0byBhcHBseUFzcGVjdFJhdGlvLlxuICAgKlxuICAgKiBAcGFyYW0gZGlyZWN0aW9uIC0gVGhlIGFjdGl2ZSByZXNpemUgaGFuZGxlIGRpcmVjdGlvblxuICAgKiBAcGFyYW0gZGVsdGFYIC0gSG9yaXpvbnRhbCBtb3VzZSBtb3ZlbWVudCBzaW5jZSByZXNpemUgc3RhcnRcbiAgICogQHBhcmFtIGRlbHRhWSAtIFZlcnRpY2FsIG1vdXNlIG1vdmVtZW50IHNpbmNlIHJlc2l6ZSBzdGFydFxuICAgKiBAcmV0dXJucyBUaGUgY2FsY3VsYXRlZCB3aWR0aCBhbmQgaGVpZ2h0XG4gICAqL1xuICBjYWxjdWxhdGVOZXdEaW1lbnNpb25zKGRpcmVjdGlvbiwgZGVsdGFYLCBkZWx0YVkpIHtcbiAgICBsZXQgbmV3V2lkdGggPSB0aGlzLnN0YXJ0V2lkdGg7XG4gICAgbGV0IG5ld0hlaWdodCA9IHRoaXMuc3RhcnRIZWlnaHQ7XG4gICAgY29uc3QgaXNSaWdodCA9IGRpcmVjdGlvbi5pbmNsdWRlcyhcInJpZ2h0XCIpO1xuICAgIGNvbnN0IGlzTGVmdCA9IGRpcmVjdGlvbi5pbmNsdWRlcyhcImxlZnRcIik7XG4gICAgY29uc3QgaXNCb3R0b20gPSBkaXJlY3Rpb24uaW5jbHVkZXMoXCJib3R0b21cIik7XG4gICAgY29uc3QgaXNUb3AgPSBkaXJlY3Rpb24uaW5jbHVkZXMoXCJ0b3BcIik7XG4gICAgaWYgKGlzUmlnaHQpIHtcbiAgICAgIG5ld1dpZHRoID0gdGhpcy5zdGFydFdpZHRoICsgZGVsdGFYO1xuICAgIH0gZWxzZSBpZiAoaXNMZWZ0KSB7XG4gICAgICBuZXdXaWR0aCA9IHRoaXMuc3RhcnRXaWR0aCAtIGRlbHRhWDtcbiAgICB9XG4gICAgaWYgKGlzQm90dG9tKSB7XG4gICAgICBuZXdIZWlnaHQgPSB0aGlzLnN0YXJ0SGVpZ2h0ICsgZGVsdGFZO1xuICAgIH0gZWxzZSBpZiAoaXNUb3ApIHtcbiAgICAgIG5ld0hlaWdodCA9IHRoaXMuc3RhcnRIZWlnaHQgLSBkZWx0YVk7XG4gICAgfVxuICAgIGlmIChkaXJlY3Rpb24gPT09IFwicmlnaHRcIiB8fCBkaXJlY3Rpb24gPT09IFwibGVmdFwiKSB7XG4gICAgICBuZXdXaWR0aCA9IHRoaXMuc3RhcnRXaWR0aCArIChpc1JpZ2h0ID8gZGVsdGFYIDogLWRlbHRhWCk7XG4gICAgfVxuICAgIGlmIChkaXJlY3Rpb24gPT09IFwidG9wXCIgfHwgZGlyZWN0aW9uID09PSBcImJvdHRvbVwiKSB7XG4gICAgICBuZXdIZWlnaHQgPSB0aGlzLnN0YXJ0SGVpZ2h0ICsgKGlzQm90dG9tID8gZGVsdGFZIDogLWRlbHRhWSk7XG4gICAgfVxuICAgIGNvbnN0IHNob3VsZFByZXNlcnZlQXNwZWN0UmF0aW8gPSB0aGlzLnByZXNlcnZlQXNwZWN0UmF0aW8gfHwgdGhpcy5pc1NoaWZ0S2V5UHJlc3NlZDtcbiAgICBpZiAoc2hvdWxkUHJlc2VydmVBc3BlY3RSYXRpbykge1xuICAgICAgcmV0dXJuIHRoaXMuYXBwbHlBc3BlY3RSYXRpbyhuZXdXaWR0aCwgbmV3SGVpZ2h0LCBkaXJlY3Rpb24pO1xuICAgIH1cbiAgICByZXR1cm4geyB3aWR0aDogbmV3V2lkdGgsIGhlaWdodDogbmV3SGVpZ2h0IH07XG4gIH1cbiAgLyoqXG4gICAqIEFwcGxpZXMgbWluL21heCBjb25zdHJhaW50cyB0byBkaW1lbnNpb25zLlxuICAgKlxuICAgKiBXaGVuIGFzcGVjdCByYXRpbyBpcyBOT1QgcHJlc2VydmVkLCBjb25zdHJhaW50cyBhcmUgYXBwbGllZCBpbmRlcGVuZGVudGx5XG4gICAqIHRvIHdpZHRoIGFuZCBoZWlnaHQuIFdoZW4gYXNwZWN0IHJhdGlvIElTIHByZXNlcnZlZCwgY29uc3RyYWludHMgYXJlXG4gICAqIGFwcGxpZWQgd2hpbGUgbWFpbnRhaW5pbmcgdGhlIGFzcGVjdCByYXRpb+KAlGlmIG9uZSBkaW1lbnNpb24gaGl0cyBhIGxpbWl0LFxuICAgKiB0aGUgb3RoZXIgaXMgcmVjYWxjdWxhdGVkIHByb3BvcnRpb25hbGx5LlxuICAgKlxuICAgKiBUaGlzIGVuc3VyZXMgdGhhdCBhc3BlY3QgcmF0aW8gaXMgbmV2ZXIgYnJva2VuIHdoZW4gY29uc3RyYWluZWQuXG4gICAqXG4gICAqIEBwYXJhbSB3aWR0aCAtIFRoZSB1bmNvbnN0cmFpbmVkIHdpZHRoXG4gICAqIEBwYXJhbSBoZWlnaHQgLSBUaGUgdW5jb25zdHJhaW5lZCBoZWlnaHRcbiAgICogQHBhcmFtIHByZXNlcnZlQXNwZWN0UmF0aW8gLSBXaGV0aGVyIHRvIG1haW50YWluIGFzcGVjdCByYXRpbyB3aGlsZSBjb25zdHJhaW5pbmdcbiAgICogQHJldHVybnMgVGhlIGNvbnN0cmFpbmVkIGRpbWVuc2lvbnNcbiAgICovXG4gIGFwcGx5Q29uc3RyYWludHMod2lkdGgsIGhlaWdodCwgcHJlc2VydmVBc3BlY3RSYXRpbykge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICBpZiAoIXByZXNlcnZlQXNwZWN0UmF0aW8pIHtcbiAgICAgIGxldCBjb25zdHJhaW5lZFdpZHRoMiA9IE1hdGgubWF4KHRoaXMubWluU2l6ZS53aWR0aCwgd2lkdGgpO1xuICAgICAgbGV0IGNvbnN0cmFpbmVkSGVpZ2h0MiA9IE1hdGgubWF4KHRoaXMubWluU2l6ZS5oZWlnaHQsIGhlaWdodCk7XG4gICAgICBpZiAoKF9hID0gdGhpcy5tYXhTaXplKSA9PSBudWxsID8gdm9pZCAwIDogX2Eud2lkdGgpIHtcbiAgICAgICAgY29uc3RyYWluZWRXaWR0aDIgPSBNYXRoLm1pbih0aGlzLm1heFNpemUud2lkdGgsIGNvbnN0cmFpbmVkV2lkdGgyKTtcbiAgICAgIH1cbiAgICAgIGlmICgoX2IgPSB0aGlzLm1heFNpemUpID09IG51bGwgPyB2b2lkIDAgOiBfYi5oZWlnaHQpIHtcbiAgICAgICAgY29uc3RyYWluZWRIZWlnaHQyID0gTWF0aC5taW4odGhpcy5tYXhTaXplLmhlaWdodCwgY29uc3RyYWluZWRIZWlnaHQyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHdpZHRoOiBjb25zdHJhaW5lZFdpZHRoMiwgaGVpZ2h0OiBjb25zdHJhaW5lZEhlaWdodDIgfTtcbiAgICB9XG4gICAgbGV0IGNvbnN0cmFpbmVkV2lkdGggPSB3aWR0aDtcbiAgICBsZXQgY29uc3RyYWluZWRIZWlnaHQgPSBoZWlnaHQ7XG4gICAgaWYgKGNvbnN0cmFpbmVkV2lkdGggPCB0aGlzLm1pblNpemUud2lkdGgpIHtcbiAgICAgIGNvbnN0cmFpbmVkV2lkdGggPSB0aGlzLm1pblNpemUud2lkdGg7XG4gICAgICBjb25zdHJhaW5lZEhlaWdodCA9IGNvbnN0cmFpbmVkV2lkdGggLyB0aGlzLmFzcGVjdFJhdGlvO1xuICAgIH1cbiAgICBpZiAoY29uc3RyYWluZWRIZWlnaHQgPCB0aGlzLm1pblNpemUuaGVpZ2h0KSB7XG4gICAgICBjb25zdHJhaW5lZEhlaWdodCA9IHRoaXMubWluU2l6ZS5oZWlnaHQ7XG4gICAgICBjb25zdHJhaW5lZFdpZHRoID0gY29uc3RyYWluZWRIZWlnaHQgKiB0aGlzLmFzcGVjdFJhdGlvO1xuICAgIH1cbiAgICBpZiAoKChfYyA9IHRoaXMubWF4U2l6ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLndpZHRoKSAmJiBjb25zdHJhaW5lZFdpZHRoID4gdGhpcy5tYXhTaXplLndpZHRoKSB7XG4gICAgICBjb25zdHJhaW5lZFdpZHRoID0gdGhpcy5tYXhTaXplLndpZHRoO1xuICAgICAgY29uc3RyYWluZWRIZWlnaHQgPSBjb25zdHJhaW5lZFdpZHRoIC8gdGhpcy5hc3BlY3RSYXRpbztcbiAgICB9XG4gICAgaWYgKCgoX2QgPSB0aGlzLm1heFNpemUpID09IG51bGwgPyB2b2lkIDAgOiBfZC5oZWlnaHQpICYmIGNvbnN0cmFpbmVkSGVpZ2h0ID4gdGhpcy5tYXhTaXplLmhlaWdodCkge1xuICAgICAgY29uc3RyYWluZWRIZWlnaHQgPSB0aGlzLm1heFNpemUuaGVpZ2h0O1xuICAgICAgY29uc3RyYWluZWRXaWR0aCA9IGNvbnN0cmFpbmVkSGVpZ2h0ICogdGhpcy5hc3BlY3RSYXRpbztcbiAgICB9XG4gICAgcmV0dXJuIHsgd2lkdGg6IGNvbnN0cmFpbmVkV2lkdGgsIGhlaWdodDogY29uc3RyYWluZWRIZWlnaHQgfTtcbiAgfVxuICAvKipcbiAgICogQWRqdXN0cyBkaW1lbnNpb25zIHRvIG1haW50YWluIHRoZSBvcmlnaW5hbCBhc3BlY3QgcmF0aW8uXG4gICAqXG4gICAqIEZvciBob3Jpem9udGFsIGhhbmRsZXMgKGxlZnQvcmlnaHQpLCB1c2VzIHdpZHRoIGFzIHRoZSBwcmltYXJ5IGRpbWVuc2lvblxuICAgKiBhbmQgY2FsY3VsYXRlcyBoZWlnaHQgZnJvbSBpdC4gRm9yIHZlcnRpY2FsIGhhbmRsZXMgKHRvcC9ib3R0b20pLCB1c2VzXG4gICAqIGhlaWdodCBhcyBwcmltYXJ5IGFuZCBjYWxjdWxhdGVzIHdpZHRoLiBGb3IgY29ybmVyIGhhbmRsZXMsIHVzZXMgd2lkdGhcbiAgICogYXMgdGhlIHByaW1hcnkgZGltZW5zaW9uLlxuICAgKlxuICAgKiBAcGFyYW0gd2lkdGggLSBUaGUgbmV3IHdpZHRoXG4gICAqIEBwYXJhbSBoZWlnaHQgLSBUaGUgbmV3IGhlaWdodFxuICAgKiBAcGFyYW0gZGlyZWN0aW9uIC0gVGhlIGFjdGl2ZSByZXNpemUgZGlyZWN0aW9uXG4gICAqIEByZXR1cm5zIERpbWVuc2lvbnMgYWRqdXN0ZWQgdG8gcHJlc2VydmUgYXNwZWN0IHJhdGlvXG4gICAqL1xuICBhcHBseUFzcGVjdFJhdGlvKHdpZHRoLCBoZWlnaHQsIGRpcmVjdGlvbikge1xuICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IGRpcmVjdGlvbiA9PT0gXCJsZWZ0XCIgfHwgZGlyZWN0aW9uID09PSBcInJpZ2h0XCI7XG4gICAgY29uc3QgaXNWZXJ0aWNhbCA9IGRpcmVjdGlvbiA9PT0gXCJ0b3BcIiB8fCBkaXJlY3Rpb24gPT09IFwiYm90dG9tXCI7XG4gICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodDogd2lkdGggLyB0aGlzLmFzcGVjdFJhdGlvXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoaXNWZXJ0aWNhbCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IGhlaWdodCAqIHRoaXMuYXNwZWN0UmF0aW8sXG4gICAgICAgIGhlaWdodFxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0OiB3aWR0aCAvIHRoaXMuYXNwZWN0UmF0aW9cbiAgICB9O1xuICB9XG59O1xudmFyIFJlc2l6YWJsZU5vZGV2aWV3ID0gUmVzaXphYmxlTm9kZVZpZXc7XG5cbi8vIHNyYy91dGlsaXRpZXMvY2FuSW5zZXJ0Tm9kZS50c1xuaW1wb3J0IHsgTm9kZVNlbGVjdGlvbiBhcyBOb2RlU2VsZWN0aW9uNCB9IGZyb20gXCJAdGlwdGFwL3BtL3N0YXRlXCI7XG5mdW5jdGlvbiBjYW5JbnNlcnROb2RlKHN0YXRlLCBub2RlVHlwZSkge1xuICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gc3RhdGU7XG4gIGNvbnN0IHsgJGZyb20gfSA9IHNlbGVjdGlvbjtcbiAgaWYgKHNlbGVjdGlvbiBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb240KSB7XG4gICAgY29uc3QgaW5kZXggPSAkZnJvbS5pbmRleCgpO1xuICAgIGNvbnN0IHBhcmVudCA9ICRmcm9tLnBhcmVudDtcbiAgICByZXR1cm4gcGFyZW50LmNhblJlcGxhY2VXaXRoKGluZGV4LCBpbmRleCArIDEsIG5vZGVUeXBlKTtcbiAgfVxuICBsZXQgZGVwdGggPSAkZnJvbS5kZXB0aDtcbiAgd2hpbGUgKGRlcHRoID49IDApIHtcbiAgICBjb25zdCBpbmRleCA9ICRmcm9tLmluZGV4KGRlcHRoKTtcbiAgICBjb25zdCBwYXJlbnQgPSAkZnJvbS5ub2RlKGRlcHRoKTtcbiAgICBjb25zdCBtYXRjaCA9IHBhcmVudC5jb250ZW50TWF0Y2hBdChpbmRleCk7XG4gICAgaWYgKG1hdGNoLm1hdGNoVHlwZShub2RlVHlwZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBkZXB0aCAtPSAxO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8gc3JjL3V0aWxpdGllcy9lc2NhcGVGb3JSZWdFeC50c1xuZnVuY3Rpb24gZXNjYXBlRm9yUmVnRXgoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZSgvWy0vXFxcXF4kKis/LigpfFtcXF17fV0vZywgXCJcXFxcJCZcIik7XG59XG5cbi8vIHNyYy91dGlsaXRpZXMvaXNTdHJpbmcudHNcbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCI7XG59XG5cbi8vIHNyYy91dGlsaXRpZXMvbWFya2Rvd24vaW5kZXgudHNcbnZhciBtYXJrZG93bl9leHBvcnRzID0ge307XG5fX2V4cG9ydChtYXJrZG93bl9leHBvcnRzLCB7XG4gIGNyZWF0ZUF0b21CbG9ja01hcmtkb3duU3BlYzogKCkgPT4gY3JlYXRlQXRvbUJsb2NrTWFya2Rvd25TcGVjLFxuICBjcmVhdGVCbG9ja01hcmtkb3duU3BlYzogKCkgPT4gY3JlYXRlQmxvY2tNYXJrZG93blNwZWMsXG4gIGNyZWF0ZUlubGluZU1hcmtkb3duU3BlYzogKCkgPT4gY3JlYXRlSW5saW5lTWFya2Rvd25TcGVjLFxuICBwYXJzZUF0dHJpYnV0ZXM6ICgpID0+IHBhcnNlQXR0cmlidXRlcyxcbiAgcGFyc2VJbmRlbnRlZEJsb2NrczogKCkgPT4gcGFyc2VJbmRlbnRlZEJsb2NrcyxcbiAgcmVuZGVyTmVzdGVkTWFya2Rvd25Db250ZW50OiAoKSA9PiByZW5kZXJOZXN0ZWRNYXJrZG93bkNvbnRlbnQsXG4gIHNlcmlhbGl6ZUF0dHJpYnV0ZXM6ICgpID0+IHNlcmlhbGl6ZUF0dHJpYnV0ZXNcbn0pO1xuXG4vLyBzcmMvdXRpbGl0aWVzL21hcmtkb3duL2F0dHJpYnV0ZVV0aWxzLnRzXG5mdW5jdGlvbiBwYXJzZUF0dHJpYnV0ZXMoYXR0clN0cmluZykge1xuICBpZiAoIShhdHRyU3RyaW5nID09IG51bGwgPyB2b2lkIDAgOiBhdHRyU3RyaW5nLnRyaW0oKSkpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgY29uc3QgYXR0cmlidXRlcyA9IHt9O1xuICBjb25zdCBxdW90ZWRTdHJpbmdzID0gW107XG4gIGNvbnN0IHRlbXBTdHJpbmcgPSBhdHRyU3RyaW5nLnJlcGxhY2UoL1tcIiddKFteXCInXSopW1wiJ10vZywgKG1hdGNoKSA9PiB7XG4gICAgcXVvdGVkU3RyaW5ncy5wdXNoKG1hdGNoKTtcbiAgICByZXR1cm4gYF9fUVVPVEVEXyR7cXVvdGVkU3RyaW5ncy5sZW5ndGggLSAxfV9fYDtcbiAgfSk7XG4gIGNvbnN0IGNsYXNzTWF0Y2hlcyA9IHRlbXBTdHJpbmcubWF0Y2goLyg/Ol58XFxzKVxcLihbYS16QS1aXVtcXHctXSopL2cpO1xuICBpZiAoY2xhc3NNYXRjaGVzKSB7XG4gICAgY29uc3QgY2xhc3NlcyA9IGNsYXNzTWF0Y2hlcy5tYXAoKG1hdGNoKSA9PiBtYXRjaC50cmltKCkuc2xpY2UoMSkpO1xuICAgIGF0dHJpYnV0ZXMuY2xhc3MgPSBjbGFzc2VzLmpvaW4oXCIgXCIpO1xuICB9XG4gIGNvbnN0IGlkTWF0Y2ggPSB0ZW1wU3RyaW5nLm1hdGNoKC8oPzpefFxccykjKFthLXpBLVpdW1xcdy1dKikvKTtcbiAgaWYgKGlkTWF0Y2gpIHtcbiAgICBhdHRyaWJ1dGVzLmlkID0gaWRNYXRjaFsxXTtcbiAgfVxuICBjb25zdCBrdlJlZ2V4ID0gLyhbYS16QS1aXVtcXHctXSopXFxzKj1cXHMqKF9fUVVPVEVEX1xcZCtfXykvZztcbiAgY29uc3Qga3ZNYXRjaGVzID0gQXJyYXkuZnJvbSh0ZW1wU3RyaW5nLm1hdGNoQWxsKGt2UmVnZXgpKTtcbiAga3ZNYXRjaGVzLmZvckVhY2goKFssIGtleSwgcXVvdGVkUmVmXSkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBxdW90ZWRJbmRleCA9IHBhcnNlSW50KCgoX2EgPSBxdW90ZWRSZWYubWF0Y2goL19fUVVPVEVEXyhcXGQrKV9fLykpID09IG51bGwgPyB2b2lkIDAgOiBfYVsxXSkgfHwgXCIwXCIsIDEwKTtcbiAgICBjb25zdCBxdW90ZWRWYWx1ZSA9IHF1b3RlZFN0cmluZ3NbcXVvdGVkSW5kZXhdO1xuICAgIGlmIChxdW90ZWRWYWx1ZSkge1xuICAgICAgYXR0cmlidXRlc1trZXldID0gcXVvdGVkVmFsdWUuc2xpY2UoMSwgLTEpO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IGNsZWFuU3RyaW5nID0gdGVtcFN0cmluZy5yZXBsYWNlKC8oPzpefFxccylcXC4oW2EtekEtWl1bXFx3LV0qKS9nLCBcIlwiKS5yZXBsYWNlKC8oPzpefFxccykjKFthLXpBLVpdW1xcdy1dKikvZywgXCJcIikucmVwbGFjZSgvKFthLXpBLVpdW1xcdy1dKilcXHMqPVxccypfX1FVT1RFRF9cXGQrX18vZywgXCJcIikudHJpbSgpO1xuICBpZiAoY2xlYW5TdHJpbmcpIHtcbiAgICBjb25zdCBib29sZWFuQXR0cnMgPSBjbGVhblN0cmluZy5zcGxpdCgvXFxzKy8pLmZpbHRlcihCb29sZWFuKTtcbiAgICBib29sZWFuQXR0cnMuZm9yRWFjaCgoYXR0cikgPT4ge1xuICAgICAgaWYgKGF0dHIubWF0Y2goL15bYS16QS1aXVtcXHctXSokLykpIHtcbiAgICAgICAgYXR0cmlidXRlc1thdHRyXSA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGF0dHJpYnV0ZXM7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpIHtcbiAgaWYgKCFhdHRyaWJ1dGVzIHx8IE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG4gIGNvbnN0IHBhcnRzID0gW107XG4gIGlmIChhdHRyaWJ1dGVzLmNsYXNzKSB7XG4gICAgY29uc3QgY2xhc3NlcyA9IFN0cmluZyhhdHRyaWJ1dGVzLmNsYXNzKS5zcGxpdCgvXFxzKy8pLmZpbHRlcihCb29sZWFuKTtcbiAgICBjbGFzc2VzLmZvckVhY2goKGNscykgPT4gcGFydHMucHVzaChgLiR7Y2xzfWApKTtcbiAgfVxuICBpZiAoYXR0cmlidXRlcy5pZCkge1xuICAgIHBhcnRzLnB1c2goYCMke2F0dHJpYnV0ZXMuaWR9YCk7XG4gIH1cbiAgT2JqZWN0LmVudHJpZXMoYXR0cmlidXRlcykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgaWYgKGtleSA9PT0gXCJjbGFzc1wiIHx8IGtleSA9PT0gXCJpZFwiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgcGFydHMucHVzaChrZXkpO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgIT09IGZhbHNlICYmIHZhbHVlICE9IG51bGwpIHtcbiAgICAgIHBhcnRzLnB1c2goYCR7a2V5fT1cIiR7U3RyaW5nKHZhbHVlKX1cImApO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBwYXJ0cy5qb2luKFwiIFwiKTtcbn1cblxuLy8gc3JjL3V0aWxpdGllcy9tYXJrZG93bi9jcmVhdGVBdG9tQmxvY2tNYXJrZG93blNwZWMudHNcbmZ1bmN0aW9uIGNyZWF0ZUF0b21CbG9ja01hcmtkb3duU3BlYyhvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICBub2RlTmFtZSxcbiAgICBuYW1lOiBtYXJrZG93bk5hbWUsXG4gICAgcGFyc2VBdHRyaWJ1dGVzOiBwYXJzZUF0dHJpYnV0ZXMyID0gcGFyc2VBdHRyaWJ1dGVzLFxuICAgIHNlcmlhbGl6ZUF0dHJpYnV0ZXM6IHNlcmlhbGl6ZUF0dHJpYnV0ZXMyID0gc2VyaWFsaXplQXR0cmlidXRlcyxcbiAgICBkZWZhdWx0QXR0cmlidXRlcyA9IHt9LFxuICAgIHJlcXVpcmVkQXR0cmlidXRlcyA9IFtdLFxuICAgIGFsbG93ZWRBdHRyaWJ1dGVzXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBibG9ja05hbWUgPSBtYXJrZG93bk5hbWUgfHwgbm9kZU5hbWU7XG4gIGNvbnN0IGZpbHRlckF0dHJpYnV0ZXMgPSAoYXR0cnMpID0+IHtcbiAgICBpZiAoIWFsbG93ZWRBdHRyaWJ1dGVzKSB7XG4gICAgICByZXR1cm4gYXR0cnM7XG4gICAgfVxuICAgIGNvbnN0IGZpbHRlcmVkID0ge307XG4gICAgYWxsb3dlZEF0dHJpYnV0ZXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBpZiAoa2V5IGluIGF0dHJzKSB7XG4gICAgICAgIGZpbHRlcmVkW2tleV0gPSBhdHRyc1trZXldO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBmaWx0ZXJlZDtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBwYXJzZU1hcmtkb3duOiAodG9rZW4sIGgyKSA9PiB7XG4gICAgICBjb25zdCBhdHRycyA9IHsgLi4uZGVmYXVsdEF0dHJpYnV0ZXMsIC4uLnRva2VuLmF0dHJpYnV0ZXMgfTtcbiAgICAgIHJldHVybiBoMi5jcmVhdGVOb2RlKG5vZGVOYW1lLCBhdHRycywgW10pO1xuICAgIH0sXG4gICAgbWFya2Rvd25Ub2tlbml6ZXI6IHtcbiAgICAgIG5hbWU6IG5vZGVOYW1lLFxuICAgICAgbGV2ZWw6IFwiYmxvY2tcIixcbiAgICAgIHN0YXJ0KHNyYykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cChgXjo6OiR7YmxvY2tOYW1lfSg/OlxcXFxzfCQpYCwgXCJtXCIpO1xuICAgICAgICBjb25zdCBpbmRleCA9IChfYSA9IHNyYy5tYXRjaChyZWdleCkpID09IG51bGwgPyB2b2lkIDAgOiBfYS5pbmRleDtcbiAgICAgICAgcmV0dXJuIGluZGV4ICE9PSB2b2lkIDAgPyBpbmRleCA6IC0xO1xuICAgICAgfSxcbiAgICAgIHRva2VuaXplKHNyYywgX3Rva2VucywgX2xleGVyKSB7XG4gICAgICAgIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cChgXjo6OiR7YmxvY2tOYW1lfSg/OlxcXFxzK1xcXFx7KFtefV0qKVxcXFx9KT9cXFxccyo6OjooPzpcXFxcbnwkKWApO1xuICAgICAgICBjb25zdCBtYXRjaCA9IHNyYy5tYXRjaChyZWdleCk7XG4gICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGF0dHJTdHJpbmcgPSBtYXRjaFsxXSB8fCBcIlwiO1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gcGFyc2VBdHRyaWJ1dGVzMihhdHRyU3RyaW5nKTtcbiAgICAgICAgY29uc3QgbWlzc2luZ1JlcXVpcmVkID0gcmVxdWlyZWRBdHRyaWJ1dGVzLmZpbmQoKHJlcXVpcmVkKSA9PiAhKHJlcXVpcmVkIGluIGF0dHJpYnV0ZXMpKTtcbiAgICAgICAgaWYgKG1pc3NpbmdSZXF1aXJlZCkge1xuICAgICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBub2RlTmFtZSxcbiAgICAgICAgICByYXc6IG1hdGNoWzBdLFxuICAgICAgICAgIGF0dHJpYnV0ZXNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlck1hcmtkb3duOiAobm9kZSkgPT4ge1xuICAgICAgY29uc3QgZmlsdGVyZWRBdHRycyA9IGZpbHRlckF0dHJpYnV0ZXMobm9kZS5hdHRycyB8fCB7fSk7XG4gICAgICBjb25zdCBhdHRycyA9IHNlcmlhbGl6ZUF0dHJpYnV0ZXMyKGZpbHRlcmVkQXR0cnMpO1xuICAgICAgY29uc3QgYXR0clN0cmluZyA9IGF0dHJzID8gYCB7JHthdHRyc319YCA6IFwiXCI7XG4gICAgICByZXR1cm4gYDo6OiR7YmxvY2tOYW1lfSR7YXR0clN0cmluZ30gOjo6YDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy91dGlsaXRpZXMvbWFya2Rvd24vY3JlYXRlQmxvY2tNYXJrZG93blNwZWMudHNcbmZ1bmN0aW9uIGNyZWF0ZUJsb2NrTWFya2Rvd25TcGVjKG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIG5vZGVOYW1lLFxuICAgIG5hbWU6IG1hcmtkb3duTmFtZSxcbiAgICBnZXRDb250ZW50LFxuICAgIHBhcnNlQXR0cmlidXRlczogcGFyc2VBdHRyaWJ1dGVzMiA9IHBhcnNlQXR0cmlidXRlcyxcbiAgICBzZXJpYWxpemVBdHRyaWJ1dGVzOiBzZXJpYWxpemVBdHRyaWJ1dGVzMiA9IHNlcmlhbGl6ZUF0dHJpYnV0ZXMsXG4gICAgZGVmYXVsdEF0dHJpYnV0ZXMgPSB7fSxcbiAgICBjb250ZW50ID0gXCJibG9ja1wiLFxuICAgIGFsbG93ZWRBdHRyaWJ1dGVzXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBibG9ja05hbWUgPSBtYXJrZG93bk5hbWUgfHwgbm9kZU5hbWU7XG4gIGNvbnN0IGZpbHRlckF0dHJpYnV0ZXMgPSAoYXR0cnMpID0+IHtcbiAgICBpZiAoIWFsbG93ZWRBdHRyaWJ1dGVzKSB7XG4gICAgICByZXR1cm4gYXR0cnM7XG4gICAgfVxuICAgIGNvbnN0IGZpbHRlcmVkID0ge307XG4gICAgYWxsb3dlZEF0dHJpYnV0ZXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBpZiAoa2V5IGluIGF0dHJzKSB7XG4gICAgICAgIGZpbHRlcmVkW2tleV0gPSBhdHRyc1trZXldO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBmaWx0ZXJlZDtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBwYXJzZU1hcmtkb3duOiAodG9rZW4sIGgyKSA9PiB7XG4gICAgICBsZXQgbm9kZUNvbnRlbnQ7XG4gICAgICBpZiAoZ2V0Q29udGVudCkge1xuICAgICAgICBjb25zdCBjb250ZW50UmVzdWx0ID0gZ2V0Q29udGVudCh0b2tlbik7XG4gICAgICAgIG5vZGVDb250ZW50ID0gdHlwZW9mIGNvbnRlbnRSZXN1bHQgPT09IFwic3RyaW5nXCIgPyBbeyB0eXBlOiBcInRleHRcIiwgdGV4dDogY29udGVudFJlc3VsdCB9XSA6IGNvbnRlbnRSZXN1bHQ7XG4gICAgICB9IGVsc2UgaWYgKGNvbnRlbnQgPT09IFwiYmxvY2tcIikge1xuICAgICAgICBub2RlQ29udGVudCA9IGgyLnBhcnNlQ2hpbGRyZW4odG9rZW4udG9rZW5zIHx8IFtdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVDb250ZW50ID0gaDIucGFyc2VJbmxpbmUodG9rZW4udG9rZW5zIHx8IFtdKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGF0dHJzID0geyAuLi5kZWZhdWx0QXR0cmlidXRlcywgLi4udG9rZW4uYXR0cmlidXRlcyB9O1xuICAgICAgcmV0dXJuIGgyLmNyZWF0ZU5vZGUobm9kZU5hbWUsIGF0dHJzLCBub2RlQ29udGVudCk7XG4gICAgfSxcbiAgICBtYXJrZG93blRva2VuaXplcjoge1xuICAgICAgbmFtZTogbm9kZU5hbWUsXG4gICAgICBsZXZlbDogXCJibG9ja1wiLFxuICAgICAgc3RhcnQoc3JjKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKGBeOjo6JHtibG9ja05hbWV9YCwgXCJtXCIpO1xuICAgICAgICBjb25zdCBpbmRleCA9IChfYSA9IHNyYy5tYXRjaChyZWdleCkpID09IG51bGwgPyB2b2lkIDAgOiBfYS5pbmRleDtcbiAgICAgICAgcmV0dXJuIGluZGV4ICE9PSB2b2lkIDAgPyBpbmRleCA6IC0xO1xuICAgICAgfSxcbiAgICAgIHRva2VuaXplKHNyYywgX3Rva2VucywgbGV4ZXIpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBvcGVuaW5nUmVnZXggPSBuZXcgUmVnRXhwKGBeOjo6JHtibG9ja05hbWV9KD86XFxcXHMrXFxcXHsoW159XSopXFxcXH0pP1xcXFxzKlxcXFxuYCk7XG4gICAgICAgIGNvbnN0IG9wZW5pbmdNYXRjaCA9IHNyYy5tYXRjaChvcGVuaW5nUmVnZXgpO1xuICAgICAgICBpZiAoIW9wZW5pbmdNYXRjaCkge1xuICAgICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW29wZW5pbmdUYWcsIGF0dHJTdHJpbmcgPSBcIlwiXSA9IG9wZW5pbmdNYXRjaDtcbiAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IHBhcnNlQXR0cmlidXRlczIoYXR0clN0cmluZyk7XG4gICAgICAgIGxldCBsZXZlbCA9IDE7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gb3BlbmluZ1RhZy5sZW5ndGg7XG4gICAgICAgIGxldCBtYXRjaGVkQ29udGVudCA9IFwiXCI7XG4gICAgICAgIGNvbnN0IGJsb2NrUGF0dGVybiA9IC9eOjo6KFtcXHctXSopKFxccy4qKT8vZ207XG4gICAgICAgIGNvbnN0IHJlbWFpbmluZyA9IHNyYy5zbGljZShwb3NpdGlvbik7XG4gICAgICAgIGJsb2NrUGF0dGVybi5sYXN0SW5kZXggPSAwO1xuICAgICAgICBmb3IgKDsgOyApIHtcbiAgICAgICAgICBjb25zdCBtYXRjaCA9IGJsb2NrUGF0dGVybi5leGVjKHJlbWFpbmluZyk7XG4gICAgICAgICAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgbWF0Y2hQb3MgPSBtYXRjaC5pbmRleDtcbiAgICAgICAgICBjb25zdCBibG9ja1R5cGUgPSBtYXRjaFsxXTtcbiAgICAgICAgICBpZiAoKF9hID0gbWF0Y2hbMl0pID09IG51bGwgPyB2b2lkIDAgOiBfYS5lbmRzV2l0aChcIjo6OlwiKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChibG9ja1R5cGUpIHtcbiAgICAgICAgICAgIGxldmVsICs9IDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldmVsIC09IDE7XG4gICAgICAgICAgICBpZiAobGV2ZWwgPT09IDApIHtcbiAgICAgICAgICAgICAgY29uc3QgcmF3Q29udGVudCA9IHJlbWFpbmluZy5zbGljZSgwLCBtYXRjaFBvcyk7XG4gICAgICAgICAgICAgIG1hdGNoZWRDb250ZW50ID0gcmF3Q29udGVudC50cmltKCk7XG4gICAgICAgICAgICAgIGNvbnN0IGZ1bGxNYXRjaCA9IHNyYy5zbGljZSgwLCBwb3NpdGlvbiArIG1hdGNoUG9zICsgbWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgbGV0IGNvbnRlbnRUb2tlbnMgPSBbXTtcbiAgICAgICAgICAgICAgaWYgKG1hdGNoZWRDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRlbnQgPT09IFwiYmxvY2tcIikge1xuICAgICAgICAgICAgICAgICAgY29udGVudFRva2VucyA9IGxleGVyLmJsb2NrVG9rZW5zKHJhd0NvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgY29udGVudFRva2Vucy5mb3JFYWNoKCh0b2tlbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4udGV4dCAmJiAoIXRva2VuLnRva2VucyB8fCB0b2tlbi50b2tlbnMubGVuZ3RoID09PSAwKSkge1xuICAgICAgICAgICAgICAgICAgICAgIHRva2VuLnRva2VucyA9IGxleGVyLmlubGluZVRva2Vucyh0b2tlbi50ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoY29udGVudFRva2Vucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RUb2tlbiA9IGNvbnRlbnRUb2tlbnNbY29udGVudFRva2Vucy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RUb2tlbi50eXBlID09PSBcInBhcmFncmFwaFwiICYmICghbGFzdFRva2VuLnRleHQgfHwgbGFzdFRva2VuLnRleHQudHJpbSgpID09PSBcIlwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUb2tlbnMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgY29udGVudFRva2VucyA9IGxleGVyLmlubGluZVRva2VucyhtYXRjaGVkQ29udGVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogbm9kZU5hbWUsXG4gICAgICAgICAgICAgICAgcmF3OiBmdWxsTWF0Y2gsXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICBjb250ZW50OiBtYXRjaGVkQ29udGVudCxcbiAgICAgICAgICAgICAgICB0b2tlbnM6IGNvbnRlbnRUb2tlbnNcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlck1hcmtkb3duOiAobm9kZSwgaDIpID0+IHtcbiAgICAgIGNvbnN0IGZpbHRlcmVkQXR0cnMgPSBmaWx0ZXJBdHRyaWJ1dGVzKG5vZGUuYXR0cnMgfHwge30pO1xuICAgICAgY29uc3QgYXR0cnMgPSBzZXJpYWxpemVBdHRyaWJ1dGVzMihmaWx0ZXJlZEF0dHJzKTtcbiAgICAgIGNvbnN0IGF0dHJTdHJpbmcgPSBhdHRycyA/IGAgeyR7YXR0cnN9fWAgOiBcIlwiO1xuICAgICAgY29uc3QgcmVuZGVyZWRDb250ZW50ID0gaDIucmVuZGVyQ2hpbGRyZW4obm9kZS5jb250ZW50IHx8IFtdLCBcIlxcblxcblwiKTtcbiAgICAgIHJldHVybiBgOjo6JHtibG9ja05hbWV9JHthdHRyU3RyaW5nfVxuXG4ke3JlbmRlcmVkQ29udGVudH1cblxuOjo6YDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy91dGlsaXRpZXMvbWFya2Rvd24vY3JlYXRlSW5saW5lTWFya2Rvd25TcGVjLnRzXG5mdW5jdGlvbiBwYXJzZVNob3J0Y29kZUF0dHJpYnV0ZXMoYXR0clN0cmluZykge1xuICBpZiAoIWF0dHJTdHJpbmcudHJpbSgpKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIGNvbnN0IGF0dHJpYnV0ZXMgPSB7fTtcbiAgY29uc3QgcmVnZXggPSAvKFxcdyspPSg/OlwiKFteXCJdKilcInwnKFteJ10qKScpL2c7XG4gIGxldCBtYXRjaCA9IHJlZ2V4LmV4ZWMoYXR0clN0cmluZyk7XG4gIHdoaWxlIChtYXRjaCAhPT0gbnVsbCkge1xuICAgIGNvbnN0IFssIGtleSwgZG91YmxlUXVvdGVkLCBzaW5nbGVRdW90ZWRdID0gbWF0Y2g7XG4gICAgYXR0cmlidXRlc1trZXldID0gZG91YmxlUXVvdGVkIHx8IHNpbmdsZVF1b3RlZDtcbiAgICBtYXRjaCA9IHJlZ2V4LmV4ZWMoYXR0clN0cmluZyk7XG4gIH1cbiAgcmV0dXJuIGF0dHJpYnV0ZXM7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVTaG9ydGNvZGVBdHRyaWJ1dGVzKGF0dHJzKSB7XG4gIHJldHVybiBPYmplY3QuZW50cmllcyhhdHRycykuZmlsdGVyKChbLCB2YWx1ZV0pID0+IHZhbHVlICE9PSB2b2lkIDAgJiYgdmFsdWUgIT09IG51bGwpLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBgJHtrZXl9PVwiJHt2YWx1ZX1cImApLmpvaW4oXCIgXCIpO1xufVxuZnVuY3Rpb24gY3JlYXRlSW5saW5lTWFya2Rvd25TcGVjKG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIG5vZGVOYW1lLFxuICAgIG5hbWU6IHNob3J0Y29kZU5hbWUsXG4gICAgZ2V0Q29udGVudCxcbiAgICBwYXJzZUF0dHJpYnV0ZXM6IHBhcnNlQXR0cmlidXRlczIgPSBwYXJzZVNob3J0Y29kZUF0dHJpYnV0ZXMsXG4gICAgc2VyaWFsaXplQXR0cmlidXRlczogc2VyaWFsaXplQXR0cmlidXRlczIgPSBzZXJpYWxpemVTaG9ydGNvZGVBdHRyaWJ1dGVzLFxuICAgIGRlZmF1bHRBdHRyaWJ1dGVzID0ge30sXG4gICAgc2VsZkNsb3NpbmcgPSBmYWxzZSxcbiAgICBhbGxvd2VkQXR0cmlidXRlc1xuICB9ID0gb3B0aW9ucztcbiAgY29uc3Qgc2hvcnRjb2RlID0gc2hvcnRjb2RlTmFtZSB8fCBub2RlTmFtZTtcbiAgY29uc3QgZmlsdGVyQXR0cmlidXRlcyA9IChhdHRycykgPT4ge1xuICAgIGlmICghYWxsb3dlZEF0dHJpYnV0ZXMpIHtcbiAgICAgIHJldHVybiBhdHRycztcbiAgICB9XG4gICAgY29uc3QgZmlsdGVyZWQgPSB7fTtcbiAgICBhbGxvd2VkQXR0cmlidXRlcy5mb3JFYWNoKChhdHRyKSA9PiB7XG4gICAgICBjb25zdCBhdHRyTmFtZSA9IHR5cGVvZiBhdHRyID09PSBcInN0cmluZ1wiID8gYXR0ciA6IGF0dHIubmFtZTtcbiAgICAgIGNvbnN0IHNraXBJZkRlZmF1bHQgPSB0eXBlb2YgYXR0ciA9PT0gXCJzdHJpbmdcIiA/IHZvaWQgMCA6IGF0dHIuc2tpcElmRGVmYXVsdDtcbiAgICAgIGlmIChhdHRyTmFtZSBpbiBhdHRycykge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGF0dHJzW2F0dHJOYW1lXTtcbiAgICAgICAgaWYgKHNraXBJZkRlZmF1bHQgIT09IHZvaWQgMCAmJiB2YWx1ZSA9PT0gc2tpcElmRGVmYXVsdCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmaWx0ZXJlZFthdHRyTmFtZV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZmlsdGVyZWQ7XG4gIH07XG4gIGNvbnN0IGVzY2FwZWRTaG9ydGNvZGUgPSBzaG9ydGNvZGUucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csIFwiXFxcXCQmXCIpO1xuICByZXR1cm4ge1xuICAgIHBhcnNlTWFya2Rvd246ICh0b2tlbiwgaDIpID0+IHtcbiAgICAgIGNvbnN0IGF0dHJzID0geyAuLi5kZWZhdWx0QXR0cmlidXRlcywgLi4udG9rZW4uYXR0cmlidXRlcyB9O1xuICAgICAgaWYgKHNlbGZDbG9zaW5nKSB7XG4gICAgICAgIHJldHVybiBoMi5jcmVhdGVOb2RlKG5vZGVOYW1lLCBhdHRycyk7XG4gICAgICB9XG4gICAgICBjb25zdCBjb250ZW50ID0gZ2V0Q29udGVudCA/IGdldENvbnRlbnQodG9rZW4pIDogdG9rZW4uY29udGVudCB8fCBcIlwiO1xuICAgICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIGgyLmNyZWF0ZU5vZGUobm9kZU5hbWUsIGF0dHJzLCBbaDIuY3JlYXRlVGV4dE5vZGUoY29udGVudCldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoMi5jcmVhdGVOb2RlKG5vZGVOYW1lLCBhdHRycywgW10pO1xuICAgIH0sXG4gICAgbWFya2Rvd25Ub2tlbml6ZXI6IHtcbiAgICAgIG5hbWU6IG5vZGVOYW1lLFxuICAgICAgbGV2ZWw6IFwiaW5saW5lXCIsXG4gICAgICBzdGFydChzcmMpIHtcbiAgICAgICAgY29uc3Qgc3RhcnRQYXR0ZXJuID0gc2VsZkNsb3NpbmcgPyBuZXcgUmVnRXhwKGBcXFxcWyR7ZXNjYXBlZFNob3J0Y29kZX1cXFxccypbXlxcXFxdXSpcXFxcXWApIDogbmV3IFJlZ0V4cChgXFxcXFske2VzY2FwZWRTaG9ydGNvZGV9XFxcXHMqW15cXFxcXV0qXFxcXF1bXFxcXHNcXFxcU10qP1xcXFxbXFxcXC8ke2VzY2FwZWRTaG9ydGNvZGV9XFxcXF1gKTtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBzcmMubWF0Y2goc3RhcnRQYXR0ZXJuKTtcbiAgICAgICAgY29uc3QgaW5kZXggPSBtYXRjaCA9PSBudWxsID8gdm9pZCAwIDogbWF0Y2guaW5kZXg7XG4gICAgICAgIHJldHVybiBpbmRleCAhPT0gdm9pZCAwID8gaW5kZXggOiAtMTtcbiAgICAgIH0sXG4gICAgICB0b2tlbml6ZShzcmMsIF90b2tlbnMsIF9sZXhlcikge1xuICAgICAgICBjb25zdCB0b2tlblBhdHRlcm4gPSBzZWxmQ2xvc2luZyA/IG5ldyBSZWdFeHAoYF5cXFxcWyR7ZXNjYXBlZFNob3J0Y29kZX1cXFxccyooW15cXFxcXV0qKVxcXFxdYCkgOiBuZXcgUmVnRXhwKGBeXFxcXFske2VzY2FwZWRTaG9ydGNvZGV9XFxcXHMqKFteXFxcXF1dKilcXFxcXShbXFxcXHNcXFxcU10qPylcXFxcW1xcXFwvJHtlc2NhcGVkU2hvcnRjb2RlfVxcXFxdYCk7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gc3JjLm1hdGNoKHRva2VuUGF0dGVybik7XG4gICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb250ZW50ID0gXCJcIjtcbiAgICAgICAgbGV0IGF0dHJTdHJpbmcgPSBcIlwiO1xuICAgICAgICBpZiAoc2VsZkNsb3NpbmcpIHtcbiAgICAgICAgICBjb25zdCBbLCBhdHRyc10gPSBtYXRjaDtcbiAgICAgICAgICBhdHRyU3RyaW5nID0gYXR0cnM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgWywgYXR0cnMsIGNvbnRlbnRNYXRjaF0gPSBtYXRjaDtcbiAgICAgICAgICBhdHRyU3RyaW5nID0gYXR0cnM7XG4gICAgICAgICAgY29udGVudCA9IGNvbnRlbnRNYXRjaCB8fCBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBwYXJzZUF0dHJpYnV0ZXMyKGF0dHJTdHJpbmcudHJpbSgpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBub2RlTmFtZSxcbiAgICAgICAgICByYXc6IG1hdGNoWzBdLFxuICAgICAgICAgIGNvbnRlbnQ6IGNvbnRlbnQudHJpbSgpLFxuICAgICAgICAgIGF0dHJpYnV0ZXNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlck1hcmtkb3duOiAobm9kZSkgPT4ge1xuICAgICAgbGV0IGNvbnRlbnQgPSBcIlwiO1xuICAgICAgaWYgKGdldENvbnRlbnQpIHtcbiAgICAgICAgY29udGVudCA9IGdldENvbnRlbnQobm9kZSk7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUuY29udGVudCAmJiBub2RlLmNvbnRlbnQubGVuZ3RoID4gMCkge1xuICAgICAgICBjb250ZW50ID0gbm9kZS5jb250ZW50LmZpbHRlcigoY2hpbGQpID0+IGNoaWxkLnR5cGUgPT09IFwidGV4dFwiKS5tYXAoKGNoaWxkKSA9PiBjaGlsZC50ZXh0KS5qb2luKFwiXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgZmlsdGVyZWRBdHRycyA9IGZpbHRlckF0dHJpYnV0ZXMobm9kZS5hdHRycyB8fCB7fSk7XG4gICAgICBjb25zdCBhdHRycyA9IHNlcmlhbGl6ZUF0dHJpYnV0ZXMyKGZpbHRlcmVkQXR0cnMpO1xuICAgICAgY29uc3QgYXR0clN0cmluZyA9IGF0dHJzID8gYCAke2F0dHJzfWAgOiBcIlwiO1xuICAgICAgaWYgKHNlbGZDbG9zaW5nKSB7XG4gICAgICAgIHJldHVybiBgWyR7c2hvcnRjb2RlfSR7YXR0clN0cmluZ31dYDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBgWyR7c2hvcnRjb2RlfSR7YXR0clN0cmluZ31dJHtjb250ZW50fVsvJHtzaG9ydGNvZGV9XWA7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvdXRpbGl0aWVzL21hcmtkb3duL3BhcnNlSW5kZW50ZWRCbG9ja3MudHNcbmZ1bmN0aW9uIHBhcnNlSW5kZW50ZWRCbG9ja3Moc3JjLCBjb25maWcsIGxleGVyKSB7XG4gIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgY29uc3QgbGluZXMgPSBzcmMuc3BsaXQoXCJcXG5cIik7XG4gIGNvbnN0IGl0ZW1zID0gW107XG4gIGxldCB0b3RhbFJhdyA9IFwiXCI7XG4gIGxldCBpID0gMDtcbiAgY29uc3QgYmFzZUluZGVudFNpemUgPSBjb25maWcuYmFzZUluZGVudFNpemUgfHwgMjtcbiAgd2hpbGUgKGkgPCBsaW5lcy5sZW5ndGgpIHtcbiAgICBjb25zdCBjdXJyZW50TGluZSA9IGxpbmVzW2ldO1xuICAgIGNvbnN0IGl0ZW1NYXRjaCA9IGN1cnJlbnRMaW5lLm1hdGNoKGNvbmZpZy5pdGVtUGF0dGVybik7XG4gICAgaWYgKCFpdGVtTWF0Y2gpIHtcbiAgICAgIGlmIChpdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIGlmIChjdXJyZW50TGluZS50cmltKCkgPT09IFwiXCIpIHtcbiAgICAgICAgaSArPSAxO1xuICAgICAgICB0b3RhbFJhdyA9IGAke3RvdGFsUmF3fSR7Y3VycmVudExpbmV9XG5gO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGl0ZW1EYXRhID0gY29uZmlnLmV4dHJhY3RJdGVtRGF0YShpdGVtTWF0Y2gpO1xuICAgIGNvbnN0IHsgaW5kZW50TGV2ZWwsIG1haW5Db250ZW50IH0gPSBpdGVtRGF0YTtcbiAgICB0b3RhbFJhdyA9IGAke3RvdGFsUmF3fSR7Y3VycmVudExpbmV9XG5gO1xuICAgIGNvbnN0IGl0ZW1Db250ZW50ID0gW21haW5Db250ZW50XTtcbiAgICBpICs9IDE7XG4gICAgd2hpbGUgKGkgPCBsaW5lcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IG5leHRMaW5lID0gbGluZXNbaV07XG4gICAgICBpZiAobmV4dExpbmUudHJpbSgpID09PSBcIlwiKSB7XG4gICAgICAgIGNvbnN0IG5leHROb25FbXB0eUluZGV4ID0gbGluZXMuc2xpY2UoaSArIDEpLmZpbmRJbmRleCgobCkgPT4gbC50cmltKCkgIT09IFwiXCIpO1xuICAgICAgICBpZiAobmV4dE5vbkVtcHR5SW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV4dE5vbkVtcHR5ID0gbGluZXNbaSArIDEgKyBuZXh0Tm9uRW1wdHlJbmRleF07XG4gICAgICAgIGNvbnN0IG5leHRJbmRlbnQyID0gKChfYiA9IChfYSA9IG5leHROb25FbXB0eS5tYXRjaCgvXihcXHMqKS8pKSA9PSBudWxsID8gdm9pZCAwIDogX2FbMV0pID09IG51bGwgPyB2b2lkIDAgOiBfYi5sZW5ndGgpIHx8IDA7XG4gICAgICAgIGlmIChuZXh0SW5kZW50MiA+IGluZGVudExldmVsKSB7XG4gICAgICAgICAgaXRlbUNvbnRlbnQucHVzaChuZXh0TGluZSk7XG4gICAgICAgICAgdG90YWxSYXcgPSBgJHt0b3RhbFJhd30ke25leHRMaW5lfVxuYDtcbiAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IG5leHRJbmRlbnQgPSAoKF9kID0gKF9jID0gbmV4dExpbmUubWF0Y2goL14oXFxzKikvKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jWzFdKSA9PSBudWxsID8gdm9pZCAwIDogX2QubGVuZ3RoKSB8fCAwO1xuICAgICAgaWYgKG5leHRJbmRlbnQgPiBpbmRlbnRMZXZlbCkge1xuICAgICAgICBpdGVtQ29udGVudC5wdXNoKG5leHRMaW5lKTtcbiAgICAgICAgdG90YWxSYXcgPSBgJHt0b3RhbFJhd30ke25leHRMaW5lfVxuYDtcbiAgICAgICAgaSArPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBuZXN0ZWRUb2tlbnM7XG4gICAgY29uc3QgbmVzdGVkQ29udGVudCA9IGl0ZW1Db250ZW50LnNsaWNlKDEpO1xuICAgIGlmIChuZXN0ZWRDb250ZW50Lmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGRlZGVudGVkTmVzdGVkID0gbmVzdGVkQ29udGVudC5tYXAoKG5lc3RlZExpbmUpID0+IG5lc3RlZExpbmUuc2xpY2UoaW5kZW50TGV2ZWwgKyBiYXNlSW5kZW50U2l6ZSkpLmpvaW4oXCJcXG5cIik7XG4gICAgICBpZiAoZGVkZW50ZWROZXN0ZWQudHJpbSgpKSB7XG4gICAgICAgIGlmIChjb25maWcuY3VzdG9tTmVzdGVkUGFyc2VyKSB7XG4gICAgICAgICAgbmVzdGVkVG9rZW5zID0gY29uZmlnLmN1c3RvbU5lc3RlZFBhcnNlcihkZWRlbnRlZE5lc3RlZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmVzdGVkVG9rZW5zID0gbGV4ZXIuYmxvY2tUb2tlbnMoZGVkZW50ZWROZXN0ZWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHRva2VuID0gY29uZmlnLmNyZWF0ZVRva2VuKGl0ZW1EYXRhLCBuZXN0ZWRUb2tlbnMpO1xuICAgIGl0ZW1zLnB1c2godG9rZW4pO1xuICB9XG4gIGlmIChpdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHJldHVybiB7XG4gICAgaXRlbXMsXG4gICAgcmF3OiB0b3RhbFJhd1xuICB9O1xufVxuXG4vLyBzcmMvdXRpbGl0aWVzL21hcmtkb3duL3JlbmRlck5lc3RlZE1hcmtkb3duQ29udGVudC50c1xuZnVuY3Rpb24gcmVuZGVyTmVzdGVkTWFya2Rvd25Db250ZW50KG5vZGUsIGgyLCBwcmVmaXhPckdlbmVyYXRvciwgY3R4KSB7XG4gIGlmICghbm9kZSB8fCAhQXJyYXkuaXNBcnJheShub2RlLmNvbnRlbnQpKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgY29uc3QgcHJlZml4ID0gdHlwZW9mIHByZWZpeE9yR2VuZXJhdG9yID09PSBcImZ1bmN0aW9uXCIgPyBwcmVmaXhPckdlbmVyYXRvcihjdHgpIDogcHJlZml4T3JHZW5lcmF0b3I7XG4gIGNvbnN0IFtjb250ZW50LCAuLi5jaGlsZHJlbl0gPSBub2RlLmNvbnRlbnQ7XG4gIGNvbnN0IG1haW5Db250ZW50ID0gaDIucmVuZGVyQ2hpbGRyZW4oW2NvbnRlbnRdKTtcbiAgY29uc3Qgb3V0cHV0ID0gW2Ake3ByZWZpeH0ke21haW5Db250ZW50fWBdO1xuICBpZiAoY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgIGNoaWxkcmVuLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICBjb25zdCBjaGlsZENvbnRlbnQgPSBoMi5yZW5kZXJDaGlsZHJlbihbY2hpbGRdKTtcbiAgICAgIGlmIChjaGlsZENvbnRlbnQpIHtcbiAgICAgICAgY29uc3QgaW5kZW50ZWRDaGlsZCA9IGNoaWxkQ29udGVudC5zcGxpdChcIlxcblwiKS5tYXAoKGxpbmUpID0+IGxpbmUgPyBoMi5pbmRlbnQobGluZSkgOiBcIlwiKS5qb2luKFwiXFxuXCIpO1xuICAgICAgICBvdXRwdXQucHVzaChpbmRlbnRlZENoaWxkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oXCJcXG5cIik7XG59XG5cbi8vIHNyYy9NYXJrVmlldy50c1xuZnVuY3Rpb24gdXBkYXRlTWFya1ZpZXdBdHRyaWJ1dGVzKGNoZWNrTWFyaywgZWRpdG9yLCBhdHRycyA9IHt9KSB7XG4gIGNvbnN0IHsgc3RhdGUgfSA9IGVkaXRvcjtcbiAgY29uc3QgeyBkb2MsIHRyIH0gPSBzdGF0ZTtcbiAgY29uc3QgdGhpc01hcmsgPSBjaGVja01hcms7XG4gIGRvYy5kZXNjZW5kYW50cygobm9kZSwgcG9zKSA9PiB7XG4gICAgY29uc3QgZnJvbSA9IHRyLm1hcHBpbmcubWFwKHBvcyk7XG4gICAgY29uc3QgdG8gPSB0ci5tYXBwaW5nLm1hcChwb3MpICsgbm9kZS5ub2RlU2l6ZTtcbiAgICBsZXQgZm91bmRNYXJrID0gbnVsbDtcbiAgICBub2RlLm1hcmtzLmZvckVhY2goKG1hcmspID0+IHtcbiAgICAgIGlmIChtYXJrICE9PSB0aGlzTWFyaykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBmb3VuZE1hcmsgPSBtYXJrO1xuICAgIH0pO1xuICAgIGlmICghZm91bmRNYXJrKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBuZWVkc1VwZGF0ZSA9IGZhbHNlO1xuICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKChrKSA9PiB7XG4gICAgICBpZiAoYXR0cnNba10gIT09IGZvdW5kTWFyay5hdHRyc1trXSkge1xuICAgICAgICBuZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKG5lZWRzVXBkYXRlKSB7XG4gICAgICBjb25zdCB1cGRhdGVkTWFyayA9IGNoZWNrTWFyay50eXBlLmNyZWF0ZSh7XG4gICAgICAgIC4uLmNoZWNrTWFyay5hdHRycyxcbiAgICAgICAgLi4uYXR0cnNcbiAgICAgIH0pO1xuICAgICAgdHIucmVtb3ZlTWFyayhmcm9tLCB0bywgY2hlY2tNYXJrLnR5cGUpO1xuICAgICAgdHIuYWRkTWFyayhmcm9tLCB0bywgdXBkYXRlZE1hcmspO1xuICAgIH1cbiAgfSk7XG4gIGlmICh0ci5kb2NDaGFuZ2VkKSB7XG4gICAgZWRpdG9yLnZpZXcuZGlzcGF0Y2godHIpO1xuICB9XG59XG52YXIgTWFya1ZpZXcgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNvbXBvbmVudCwgcHJvcHMsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcbiAgICB0aGlzLmVkaXRvciA9IHByb3BzLmVkaXRvcjtcbiAgICB0aGlzLm9wdGlvbnMgPSB7IC4uLm9wdGlvbnMgfTtcbiAgICB0aGlzLm1hcmsgPSBwcm9wcy5tYXJrO1xuICAgIHRoaXMuSFRNTEF0dHJpYnV0ZXMgPSBwcm9wcy5IVE1MQXR0cmlidXRlcztcbiAgfVxuICBnZXQgZG9tKCkge1xuICAgIHJldHVybiB0aGlzLmVkaXRvci52aWV3LmRvbTtcbiAgfVxuICBnZXQgY29udGVudERPTSgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlIHRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBtYXJrIGluIHRoZSBkb2N1bWVudC5cbiAgICogQHBhcmFtIGF0dHJzIFRoZSBhdHRyaWJ1dGVzIHRvIHVwZGF0ZS5cbiAgICovXG4gIHVwZGF0ZUF0dHJpYnV0ZXMoYXR0cnMsIGNoZWNrTWFyaykge1xuICAgIHVwZGF0ZU1hcmtWaWV3QXR0cmlidXRlcyhjaGVja01hcmsgfHwgdGhpcy5tYXJrLCB0aGlzLmVkaXRvciwgYXR0cnMpO1xuICB9XG4gIGlnbm9yZU11dGF0aW9uKG11dGF0aW9uKSB7XG4gICAgaWYgKCF0aGlzLmRvbSB8fCAhdGhpcy5jb250ZW50RE9NKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuaWdub3JlTXV0YXRpb24gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5pZ25vcmVNdXRhdGlvbih7IG11dGF0aW9uIH0pO1xuICAgIH1cbiAgICBpZiAobXV0YXRpb24udHlwZSA9PT0gXCJzZWxlY3Rpb25cIikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodGhpcy5kb20uY29udGFpbnMobXV0YXRpb24udGFyZ2V0KSAmJiBtdXRhdGlvbi50eXBlID09PSBcImNoaWxkTGlzdFwiICYmIChpc2lPUygpIHx8IGlzQW5kcm9pZCgpKSAmJiB0aGlzLmVkaXRvci5pc0ZvY3VzZWQpIHtcbiAgICAgIGNvbnN0IGNoYW5nZWROb2RlcyA9IFsuLi5BcnJheS5mcm9tKG11dGF0aW9uLmFkZGVkTm9kZXMpLCAuLi5BcnJheS5mcm9tKG11dGF0aW9uLnJlbW92ZWROb2RlcyldO1xuICAgICAgaWYgKGNoYW5nZWROb2Rlcy5ldmVyeSgobm9kZSkgPT4gbm9kZS5pc0NvbnRlbnRFZGl0YWJsZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5jb250ZW50RE9NID09PSBtdXRhdGlvbi50YXJnZXQgJiYgbXV0YXRpb24udHlwZSA9PT0gXCJhdHRyaWJ1dGVzXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcy5jb250ZW50RE9NLmNvbnRhaW5zKG11dGF0aW9uLnRhcmdldCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cbi8vIHNyYy9Ob2RlLnRzXG52YXIgTm9kZTMgPSBjbGFzcyBfTm9kZSBleHRlbmRzIEV4dGVuZGFibGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMudHlwZSA9IFwibm9kZVwiO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgTm9kZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0gY29uZmlnIC0gTm9kZSBjb25maWd1cmF0aW9uIG9iamVjdCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAqL1xuICBzdGF0aWMgY3JlYXRlKGNvbmZpZyA9IHt9KSB7XG4gICAgY29uc3QgcmVzb2x2ZWRDb25maWcgPSB0eXBlb2YgY29uZmlnID09PSBcImZ1bmN0aW9uXCIgPyBjb25maWcoKSA6IGNvbmZpZztcbiAgICByZXR1cm4gbmV3IF9Ob2RlKHJlc29sdmVkQ29uZmlnKTtcbiAgfVxuICBjb25maWd1cmUob3B0aW9ucykge1xuICAgIHJldHVybiBzdXBlci5jb25maWd1cmUob3B0aW9ucyk7XG4gIH1cbiAgZXh0ZW5kKGV4dGVuZGVkQ29uZmlnKSB7XG4gICAgY29uc3QgcmVzb2x2ZWRDb25maWcgPSB0eXBlb2YgZXh0ZW5kZWRDb25maWcgPT09IFwiZnVuY3Rpb25cIiA/IGV4dGVuZGVkQ29uZmlnKCkgOiBleHRlbmRlZENvbmZpZztcbiAgICByZXR1cm4gc3VwZXIuZXh0ZW5kKHJlc29sdmVkQ29uZmlnKTtcbiAgfVxufTtcblxuLy8gc3JjL05vZGVWaWV3LnRzXG5pbXBvcnQgeyBOb2RlU2VsZWN0aW9uIGFzIE5vZGVTZWxlY3Rpb241IH0gZnJvbSBcIkB0aXB0YXAvcG0vc3RhdGVcIjtcbnZhciBOb2RlVmlldyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY29tcG9uZW50LCBwcm9wcywgb3B0aW9ucykge1xuICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xuICAgIHRoaXMuZWRpdG9yID0gcHJvcHMuZWRpdG9yO1xuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIHN0b3BFdmVudDogbnVsbCxcbiAgICAgIGlnbm9yZU11dGF0aW9uOiBudWxsLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH07XG4gICAgdGhpcy5leHRlbnNpb24gPSBwcm9wcy5leHRlbnNpb247XG4gICAgdGhpcy5ub2RlID0gcHJvcHMubm9kZTtcbiAgICB0aGlzLmRlY29yYXRpb25zID0gcHJvcHMuZGVjb3JhdGlvbnM7XG4gICAgdGhpcy5pbm5lckRlY29yYXRpb25zID0gcHJvcHMuaW5uZXJEZWNvcmF0aW9ucztcbiAgICB0aGlzLnZpZXcgPSBwcm9wcy52aWV3O1xuICAgIHRoaXMuSFRNTEF0dHJpYnV0ZXMgPSBwcm9wcy5IVE1MQXR0cmlidXRlcztcbiAgICB0aGlzLmdldFBvcyA9IHByb3BzLmdldFBvcztcbiAgICB0aGlzLm1vdW50KCk7XG4gIH1cbiAgbW91bnQoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGdldCBkb20oKSB7XG4gICAgcmV0dXJuIHRoaXMuZWRpdG9yLnZpZXcuZG9tO1xuICB9XG4gIGdldCBjb250ZW50RE9NKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIG9uRHJhZ1N0YXJ0KGV2ZW50KSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nO1xuICAgIGNvbnN0IHsgdmlldyB9ID0gdGhpcy5lZGl0b3I7XG4gICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgIGNvbnN0IGRyYWdIYW5kbGUgPSB0YXJnZXQubm9kZVR5cGUgPT09IDMgPyAoX2EgPSB0YXJnZXQucGFyZW50RWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNsb3Nlc3QoXCJbZGF0YS1kcmFnLWhhbmRsZV1cIikgOiB0YXJnZXQuY2xvc2VzdChcIltkYXRhLWRyYWctaGFuZGxlXVwiKTtcbiAgICBpZiAoIXRoaXMuZG9tIHx8ICgoX2IgPSB0aGlzLmNvbnRlbnRET00pID09IG51bGwgPyB2b2lkIDAgOiBfYi5jb250YWlucyh0YXJnZXQpKSB8fCAhZHJhZ0hhbmRsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgeCA9IDA7XG4gICAgbGV0IHkgPSAwO1xuICAgIGlmICh0aGlzLmRvbSAhPT0gZHJhZ0hhbmRsZSkge1xuICAgICAgY29uc3QgZG9tQm94ID0gdGhpcy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCBoYW5kbGVCb3ggPSBkcmFnSGFuZGxlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY29uc3Qgb2Zmc2V0WCA9IChfZCA9IGV2ZW50Lm9mZnNldFgpICE9IG51bGwgPyBfZCA6IChfYyA9IGV2ZW50Lm5hdGl2ZUV2ZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2Mub2Zmc2V0WDtcbiAgICAgIGNvbnN0IG9mZnNldFkgPSAoX2YgPSBldmVudC5vZmZzZXRZKSAhPSBudWxsID8gX2YgOiAoX2UgPSBldmVudC5uYXRpdmVFdmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lLm9mZnNldFk7XG4gICAgICB4ID0gaGFuZGxlQm94LnggLSBkb21Cb3gueCArIG9mZnNldFg7XG4gICAgICB5ID0gaGFuZGxlQm94LnkgLSBkb21Cb3gueSArIG9mZnNldFk7XG4gICAgfVxuICAgIGNvbnN0IGNsb25lZE5vZGUgPSB0aGlzLmRvbS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRvbUJveCA9IHRoaXMuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY2xvbmVkTm9kZS5zdHlsZS53aWR0aCA9IGAke01hdGgucm91bmQoZG9tQm94LndpZHRoKX1weGA7XG4gICAgICBjbG9uZWROb2RlLnN0eWxlLmhlaWdodCA9IGAke01hdGgucm91bmQoZG9tQm94LmhlaWdodCl9cHhgO1xuICAgICAgY2xvbmVkTm9kZS5zdHlsZS5ib3hTaXppbmcgPSBcImJvcmRlci1ib3hcIjtcbiAgICAgIGNsb25lZE5vZGUuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwibm9uZVwiO1xuICAgIH0gY2F0Y2gge1xuICAgIH1cbiAgICBsZXQgZHJhZ0ltYWdlV3JhcHBlciA9IG51bGw7XG4gICAgdHJ5IHtcbiAgICAgIGRyYWdJbWFnZVdyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgZHJhZ0ltYWdlV3JhcHBlci5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICAgIGRyYWdJbWFnZVdyYXBwZXIuc3R5bGUudG9wID0gXCItOTk5OXB4XCI7XG4gICAgICBkcmFnSW1hZ2VXcmFwcGVyLnN0eWxlLmxlZnQgPSBcIi05OTk5cHhcIjtcbiAgICAgIGRyYWdJbWFnZVdyYXBwZXIuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwibm9uZVwiO1xuICAgICAgZHJhZ0ltYWdlV3JhcHBlci5hcHBlbmRDaGlsZChjbG9uZWROb2RlKTtcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZHJhZ0ltYWdlV3JhcHBlcik7XG4gICAgICAoX2cgPSBldmVudC5kYXRhVHJhbnNmZXIpID09IG51bGwgPyB2b2lkIDAgOiBfZy5zZXREcmFnSW1hZ2UoY2xvbmVkTm9kZSwgeCwgeSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChkcmFnSW1hZ2VXcmFwcGVyKSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkcmFnSW1hZ2VXcmFwcGVyID09IG51bGwgPyB2b2lkIDAgOiBkcmFnSW1hZ2VXcmFwcGVyLnJlbW92ZSgpO1xuICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgMCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHBvcyA9IHRoaXMuZ2V0UG9zKCk7XG4gICAgaWYgKHR5cGVvZiBwb3MgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gTm9kZVNlbGVjdGlvbjUuY3JlYXRlKHZpZXcuc3RhdGUuZG9jLCBwb3MpO1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdmlldy5zdGF0ZS50ci5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgICB2aWV3LmRpc3BhdGNoKHRyYW5zYWN0aW9uKTtcbiAgfVxuICBzdG9wRXZlbnQoZXZlbnQpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKCF0aGlzLmRvbSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5zdG9wRXZlbnQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5zdG9wRXZlbnQoeyBldmVudCB9KTtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgIGNvbnN0IGlzSW5FbGVtZW50ID0gdGhpcy5kb20uY29udGFpbnModGFyZ2V0KSAmJiAhKChfYSA9IHRoaXMuY29udGVudERPTSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNvbnRhaW5zKHRhcmdldCkpO1xuICAgIGlmICghaXNJbkVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgaXNEcmFnRXZlbnQgPSBldmVudC50eXBlLnN0YXJ0c1dpdGgoXCJkcmFnXCIpO1xuICAgIGNvbnN0IGlzRHJvcEV2ZW50ID0gZXZlbnQudHlwZSA9PT0gXCJkcm9wXCI7XG4gICAgY29uc3QgaXNJbnB1dCA9IFtcIklOUFVUXCIsIFwiQlVUVE9OXCIsIFwiU0VMRUNUXCIsIFwiVEVYVEFSRUFcIl0uaW5jbHVkZXModGFyZ2V0LnRhZ05hbWUpIHx8IHRhcmdldC5pc0NvbnRlbnRFZGl0YWJsZTtcbiAgICBpZiAoaXNJbnB1dCAmJiAhaXNEcm9wRXZlbnQgJiYgIWlzRHJhZ0V2ZW50KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgeyBpc0VkaXRhYmxlIH0gPSB0aGlzLmVkaXRvcjtcbiAgICBjb25zdCB7IGlzRHJhZ2dpbmcgfSA9IHRoaXM7XG4gICAgY29uc3QgaXNEcmFnZ2FibGUgPSAhIXRoaXMubm9kZS50eXBlLnNwZWMuZHJhZ2dhYmxlO1xuICAgIGNvbnN0IGlzU2VsZWN0YWJsZSA9IE5vZGVTZWxlY3Rpb241LmlzU2VsZWN0YWJsZSh0aGlzLm5vZGUpO1xuICAgIGNvbnN0IGlzQ29weUV2ZW50ID0gZXZlbnQudHlwZSA9PT0gXCJjb3B5XCI7XG4gICAgY29uc3QgaXNQYXN0ZUV2ZW50ID0gZXZlbnQudHlwZSA9PT0gXCJwYXN0ZVwiO1xuICAgIGNvbnN0IGlzQ3V0RXZlbnQgPSBldmVudC50eXBlID09PSBcImN1dFwiO1xuICAgIGNvbnN0IGlzQ2xpY2tFdmVudCA9IGV2ZW50LnR5cGUgPT09IFwibW91c2Vkb3duXCI7XG4gICAgaWYgKCFpc0RyYWdnYWJsZSAmJiBpc1NlbGVjdGFibGUgJiYgaXNEcmFnRXZlbnQgJiYgZXZlbnQudGFyZ2V0ID09PSB0aGlzLmRvbSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gICAgaWYgKGlzRHJhZ2dhYmxlICYmIGlzRHJhZ0V2ZW50ICYmICFpc0RyYWdnaW5nICYmIGV2ZW50LnRhcmdldCA9PT0gdGhpcy5kb20pIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChpc0RyYWdnYWJsZSAmJiBpc0VkaXRhYmxlICYmICFpc0RyYWdnaW5nICYmIGlzQ2xpY2tFdmVudCkge1xuICAgICAgY29uc3QgZHJhZ0hhbmRsZSA9IHRhcmdldC5jbG9zZXN0KFwiW2RhdGEtZHJhZy1oYW5kbGVdXCIpO1xuICAgICAgY29uc3QgaXNWYWxpZERyYWdIYW5kbGUgPSBkcmFnSGFuZGxlICYmICh0aGlzLmRvbSA9PT0gZHJhZ0hhbmRsZSB8fCB0aGlzLmRvbS5jb250YWlucyhkcmFnSGFuZGxlKSk7XG4gICAgICBpZiAoaXNWYWxpZERyYWdIYW5kbGUpIHtcbiAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICBcImRyYWdlbmRcIixcbiAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHsgb25jZTogdHJ1ZSB9XG4gICAgICAgICk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgXCJkcm9wXCIsXG4gICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB7IG9uY2U6IHRydWUgfVxuICAgICAgICApO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICAgIFwibW91c2V1cFwiLFxuICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgeyBvbmNlOiB0cnVlIH1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzRHJhZ2dpbmcgfHwgaXNEcm9wRXZlbnQgfHwgaXNDb3B5RXZlbnQgfHwgaXNQYXN0ZUV2ZW50IHx8IGlzQ3V0RXZlbnQgfHwgaXNDbGlja0V2ZW50ICYmIGlzU2VsZWN0YWJsZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gYSBET00gW211dGF0aW9uXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTXV0YXRpb25PYnNlcnZlcikgb3IgYSBzZWxlY3Rpb24gY2hhbmdlIGhhcHBlbnMgd2l0aGluIHRoZSB2aWV3LlxuICAgKiBAcmV0dXJuIGBmYWxzZWAgaWYgdGhlIGVkaXRvciBzaG91bGQgcmUtcmVhZCB0aGUgc2VsZWN0aW9uIG9yIHJlLXBhcnNlIHRoZSByYW5nZSBhcm91bmQgdGhlIG11dGF0aW9uXG4gICAqIEByZXR1cm4gYHRydWVgIGlmIGl0IGNhbiBzYWZlbHkgYmUgaWdub3JlZC5cbiAgICovXG4gIGlnbm9yZU11dGF0aW9uKG11dGF0aW9uKSB7XG4gICAgaWYgKCF0aGlzLmRvbSB8fCAhdGhpcy5jb250ZW50RE9NKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuaWdub3JlTXV0YXRpb24gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5pZ25vcmVNdXRhdGlvbih7IG11dGF0aW9uIH0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5ub2RlLmlzTGVhZiB8fCB0aGlzLm5vZGUuaXNBdG9tKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG11dGF0aW9uLnR5cGUgPT09IFwic2VsZWN0aW9uXCIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZG9tLmNvbnRhaW5zKG11dGF0aW9uLnRhcmdldCkgJiYgbXV0YXRpb24udHlwZSA9PT0gXCJjaGlsZExpc3RcIiAmJiAoaXNpT1MoKSB8fCBpc0FuZHJvaWQoKSkgJiYgdGhpcy5lZGl0b3IuaXNGb2N1c2VkKSB7XG4gICAgICBjb25zdCBjaGFuZ2VkTm9kZXMgPSBbLi4uQXJyYXkuZnJvbShtdXRhdGlvbi5hZGRlZE5vZGVzKSwgLi4uQXJyYXkuZnJvbShtdXRhdGlvbi5yZW1vdmVkTm9kZXMpXTtcbiAgICAgIGlmIChjaGFuZ2VkTm9kZXMuZXZlcnkoKG5vZGUpID0+IG5vZGUuaXNDb250ZW50RWRpdGFibGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuY29udGVudERPTSA9PT0gbXV0YXRpb24udGFyZ2V0ICYmIG11dGF0aW9uLnR5cGUgPT09IFwiYXR0cmlidXRlc1wiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuY29udGVudERPTS5jb250YWlucyhtdXRhdGlvbi50YXJnZXQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGF0dHJpYnV0ZXMgb2YgdGhlIHByb3NlbWlycm9yIG5vZGUuXG4gICAqL1xuICB1cGRhdGVBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpIHtcbiAgICB0aGlzLmVkaXRvci5jb21tYW5kcy5jb21tYW5kKCh7IHRyIH0pID0+IHtcbiAgICAgIGNvbnN0IHBvcyA9IHRoaXMuZ2V0UG9zKCk7XG4gICAgICBpZiAodHlwZW9mIHBvcyAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB0ci5zZXROb2RlTWFya3VwKHBvcywgdm9pZCAwLCB7XG4gICAgICAgIC4uLnRoaXMubm9kZS5hdHRycyxcbiAgICAgICAgLi4uYXR0cmlidXRlc1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogRGVsZXRlIHRoZSBub2RlLlxuICAgKi9cbiAgZGVsZXRlTm9kZSgpIHtcbiAgICBjb25zdCBmcm9tID0gdGhpcy5nZXRQb3MoKTtcbiAgICBpZiAodHlwZW9mIGZyb20gIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdG8gPSBmcm9tICsgdGhpcy5ub2RlLm5vZGVTaXplO1xuICAgIHRoaXMuZWRpdG9yLmNvbW1hbmRzLmRlbGV0ZVJhbmdlKHsgZnJvbSwgdG8gfSk7XG4gIH1cbn07XG5cbi8vIHNyYy9wYXN0ZVJ1bGVzL21hcmtQYXN0ZVJ1bGUudHNcbmZ1bmN0aW9uIG1hcmtQYXN0ZVJ1bGUoY29uZmlnKSB7XG4gIHJldHVybiBuZXcgUGFzdGVSdWxlKHtcbiAgICBmaW5kOiBjb25maWcuZmluZCxcbiAgICBoYW5kbGVyOiAoeyBzdGF0ZSwgcmFuZ2UsIG1hdGNoLCBwYXN0ZUV2ZW50IH0pID0+IHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBjYWxsT3JSZXR1cm4oY29uZmlnLmdldEF0dHJpYnV0ZXMsIHZvaWQgMCwgbWF0Y2gsIHBhc3RlRXZlbnQpO1xuICAgICAgaWYgKGF0dHJpYnV0ZXMgPT09IGZhbHNlIHx8IGF0dHJpYnV0ZXMgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBjb25zdCB7IHRyIH0gPSBzdGF0ZTtcbiAgICAgIGNvbnN0IGNhcHR1cmVHcm91cCA9IG1hdGNoW21hdGNoLmxlbmd0aCAtIDFdO1xuICAgICAgY29uc3QgZnVsbE1hdGNoID0gbWF0Y2hbMF07XG4gICAgICBsZXQgbWFya0VuZCA9IHJhbmdlLnRvO1xuICAgICAgaWYgKGNhcHR1cmVHcm91cCkge1xuICAgICAgICBjb25zdCBzdGFydFNwYWNlcyA9IGZ1bGxNYXRjaC5zZWFyY2goL1xcUy8pO1xuICAgICAgICBjb25zdCB0ZXh0U3RhcnQgPSByYW5nZS5mcm9tICsgZnVsbE1hdGNoLmluZGV4T2YoY2FwdHVyZUdyb3VwKTtcbiAgICAgICAgY29uc3QgdGV4dEVuZCA9IHRleHRTdGFydCArIGNhcHR1cmVHcm91cC5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGV4Y2x1ZGVkTWFya3MgPSBnZXRNYXJrc0JldHdlZW4ocmFuZ2UuZnJvbSwgcmFuZ2UudG8sIHN0YXRlLmRvYykuZmlsdGVyKChpdGVtKSA9PiB7XG4gICAgICAgICAgY29uc3QgZXhjbHVkZWQgPSBpdGVtLm1hcmsudHlwZS5leGNsdWRlZDtcbiAgICAgICAgICByZXR1cm4gZXhjbHVkZWQuZmluZCgodHlwZSkgPT4gdHlwZSA9PT0gY29uZmlnLnR5cGUgJiYgdHlwZSAhPT0gaXRlbS5tYXJrLnR5cGUpO1xuICAgICAgICB9KS5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0udG8gPiB0ZXh0U3RhcnQpO1xuICAgICAgICBpZiAoZXhjbHVkZWRNYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGV4dEVuZCA8IHJhbmdlLnRvKSB7XG4gICAgICAgICAgdHIuZGVsZXRlKHRleHRFbmQsIHJhbmdlLnRvKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGV4dFN0YXJ0ID4gcmFuZ2UuZnJvbSkge1xuICAgICAgICAgIHRyLmRlbGV0ZShyYW5nZS5mcm9tICsgc3RhcnRTcGFjZXMsIHRleHRTdGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgbWFya0VuZCA9IHJhbmdlLmZyb20gKyBzdGFydFNwYWNlcyArIGNhcHR1cmVHcm91cC5sZW5ndGg7XG4gICAgICAgIHRyLmFkZE1hcmsocmFuZ2UuZnJvbSArIHN0YXJ0U3BhY2VzLCBtYXJrRW5kLCBjb25maWcudHlwZS5jcmVhdGUoYXR0cmlidXRlcyB8fCB7fSkpO1xuICAgICAgICB0ci5yZW1vdmVTdG9yZWRNYXJrKGNvbmZpZy50eXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzcmMvcGFzdGVSdWxlcy9ub2RlUGFzdGVSdWxlLnRzXG5mdW5jdGlvbiBub2RlUGFzdGVSdWxlKGNvbmZpZykge1xuICByZXR1cm4gbmV3IFBhc3RlUnVsZSh7XG4gICAgZmluZDogY29uZmlnLmZpbmQsXG4gICAgaGFuZGxlcih7IG1hdGNoLCBjaGFpbiwgcmFuZ2UsIHBhc3RlRXZlbnQgfSkge1xuICAgICAgY29uc3QgYXR0cmlidXRlcyA9IGNhbGxPclJldHVybihjb25maWcuZ2V0QXR0cmlidXRlcywgdm9pZCAwLCBtYXRjaCwgcGFzdGVFdmVudCk7XG4gICAgICBjb25zdCBjb250ZW50ID0gY2FsbE9yUmV0dXJuKGNvbmZpZy5nZXRDb250ZW50LCB2b2lkIDAsIGF0dHJpYnV0ZXMpO1xuICAgICAgaWYgKGF0dHJpYnV0ZXMgPT09IGZhbHNlIHx8IGF0dHJpYnV0ZXMgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBjb25zdCBub2RlID0geyB0eXBlOiBjb25maWcudHlwZS5uYW1lLCBhdHRyczogYXR0cmlidXRlcyB9O1xuICAgICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgICAgbm9kZS5jb250ZW50ID0gY29udGVudDtcbiAgICAgIH1cbiAgICAgIGlmIChtYXRjaC5pbnB1dCkge1xuICAgICAgICBjaGFpbigpLmRlbGV0ZVJhbmdlKHJhbmdlKS5pbnNlcnRDb250ZW50QXQocmFuZ2UuZnJvbSwgbm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3JjL3Bhc3RlUnVsZXMvdGV4dFBhc3RlUnVsZS50c1xuZnVuY3Rpb24gdGV4dFBhc3RlUnVsZShjb25maWcpIHtcbiAgcmV0dXJuIG5ldyBQYXN0ZVJ1bGUoe1xuICAgIGZpbmQ6IGNvbmZpZy5maW5kLFxuICAgIGhhbmRsZXI6ICh7IHN0YXRlLCByYW5nZSwgbWF0Y2ggfSkgPT4ge1xuICAgICAgbGV0IGluc2VydCA9IGNvbmZpZy5yZXBsYWNlO1xuICAgICAgbGV0IHN0YXJ0ID0gcmFuZ2UuZnJvbTtcbiAgICAgIGNvbnN0IGVuZCA9IHJhbmdlLnRvO1xuICAgICAgaWYgKG1hdGNoWzFdKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IG1hdGNoWzBdLmxhc3RJbmRleE9mKG1hdGNoWzFdKTtcbiAgICAgICAgaW5zZXJ0ICs9IG1hdGNoWzBdLnNsaWNlKG9mZnNldCArIG1hdGNoWzFdLmxlbmd0aCk7XG4gICAgICAgIHN0YXJ0ICs9IG9mZnNldDtcbiAgICAgICAgY29uc3QgY3V0T2ZmID0gc3RhcnQgLSBlbmQ7XG4gICAgICAgIGlmIChjdXRPZmYgPiAwKSB7XG4gICAgICAgICAgaW5zZXJ0ID0gbWF0Y2hbMF0uc2xpY2Uob2Zmc2V0IC0gY3V0T2ZmLCBvZmZzZXQpICsgaW5zZXJ0O1xuICAgICAgICAgIHN0YXJ0ID0gZW5kO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdGF0ZS50ci5pbnNlcnRUZXh0KGluc2VydCwgc3RhcnQsIGVuZCk7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3JjL1RyYWNrZXIudHNcbnZhciBUcmFja2VyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih0cmFuc2FjdGlvbikge1xuICAgIHRoaXMudHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbjtcbiAgICB0aGlzLmN1cnJlbnRTdGVwID0gdGhpcy50cmFuc2FjdGlvbi5zdGVwcy5sZW5ndGg7XG4gIH1cbiAgbWFwKHBvc2l0aW9uKSB7XG4gICAgbGV0IGRlbGV0ZWQgPSBmYWxzZTtcbiAgICBjb25zdCBtYXBwZWRQb3NpdGlvbiA9IHRoaXMudHJhbnNhY3Rpb24uc3RlcHMuc2xpY2UodGhpcy5jdXJyZW50U3RlcCkucmVkdWNlKChuZXdQb3NpdGlvbiwgc3RlcCkgPT4ge1xuICAgICAgY29uc3QgbWFwUmVzdWx0ID0gc3RlcC5nZXRNYXAoKS5tYXBSZXN1bHQobmV3UG9zaXRpb24pO1xuICAgICAgaWYgKG1hcFJlc3VsdC5kZWxldGVkKSB7XG4gICAgICAgIGRlbGV0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hcFJlc3VsdC5wb3M7XG4gICAgfSwgcG9zaXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICBwb3NpdGlvbjogbWFwcGVkUG9zaXRpb24sXG4gICAgICBkZWxldGVkXG4gICAgfTtcbiAgfVxufTtcbmV4cG9ydCB7XG4gIENvbW1hbmRNYW5hZ2VyLFxuICBFZGl0b3IsXG4gIEV4dGVuZGFibGUsXG4gIEV4dGVuc2lvbixcbiAgRnJhZ21lbnQ2IGFzIEZyYWdtZW50LFxuICBJbnB1dFJ1bGUsXG4gIE1hcHBhYmxlUG9zaXRpb24sXG4gIE1hcmssXG4gIE1hcmtWaWV3LFxuICBOb2RlMyBhcyBOb2RlLFxuICBOb2RlUG9zLFxuICBOb2RlVmlldyxcbiAgUGFzdGVSdWxlLFxuICBSZXNpemFibGVOb2RlVmlldyxcbiAgUmVzaXphYmxlTm9kZXZpZXcsXG4gIFRyYWNrZXIsXG4gIGNhbGxPclJldHVybixcbiAgY2FuSW5zZXJ0Tm9kZSxcbiAgY29tYmluZVRyYW5zYWN0aW9uU3RlcHMsXG4gIGNvbW1hbmRzX2V4cG9ydHMgYXMgY29tbWFuZHMsXG4gIGNyZWF0ZUF0b21CbG9ja01hcmtkb3duU3BlYyxcbiAgY3JlYXRlQmxvY2tNYXJrZG93blNwZWMsXG4gIGNyZWF0ZUNoYWluYWJsZVN0YXRlLFxuICBjcmVhdGVEb2N1bWVudCxcbiAgaCBhcyBjcmVhdGVFbGVtZW50LFxuICBjcmVhdGVJbmxpbmVNYXJrZG93blNwZWMsXG4gIGNyZWF0ZU1hcHBhYmxlUG9zaXRpb24sXG4gIGNyZWF0ZU5vZGVGcm9tQ29udGVudCxcbiAgY3JlYXRlU3R5bGVUYWcsXG4gIGRlZmF1bHRCbG9ja0F0LFxuICBkZWxldGVQcm9wcyxcbiAgZWxlbWVudEZyb21TdHJpbmcsXG4gIGVzY2FwZUZvclJlZ0V4LFxuICBleHRlbnNpb25zX2V4cG9ydHMgYXMgZXh0ZW5zaW9ucyxcbiAgZmluZENoaWxkcmVuLFxuICBmaW5kQ2hpbGRyZW5JblJhbmdlLFxuICBmaW5kRHVwbGljYXRlcyxcbiAgZmluZFBhcmVudE5vZGUsXG4gIGZpbmRQYXJlbnROb2RlQ2xvc2VzdFRvUG9zLFxuICBmbGF0dGVuRXh0ZW5zaW9ucyxcbiAgZnJvbVN0cmluZyxcbiAgZ2VuZXJhdGVIVE1MLFxuICBnZW5lcmF0ZUpTT04sXG4gIGdlbmVyYXRlVGV4dCxcbiAgZ2V0QXR0cmlidXRlcyxcbiAgZ2V0QXR0cmlidXRlc0Zyb21FeHRlbnNpb25zLFxuICBnZXRDaGFuZ2VkUmFuZ2VzLFxuICBnZXREZWJ1Z0pTT04sXG4gIGdldEV4dGVuc2lvbkZpZWxkLFxuICBnZXRIVE1MRnJvbUZyYWdtZW50LFxuICBnZXRNYXJrQXR0cmlidXRlcyxcbiAgZ2V0TWFya1JhbmdlLFxuICBnZXRNYXJrVHlwZSxcbiAgZ2V0TWFya3NCZXR3ZWVuLFxuICBnZXROb2RlQXRQb3NpdGlvbixcbiAgZ2V0Tm9kZUF0dHJpYnV0ZXMsXG4gIGdldE5vZGVUeXBlLFxuICBnZXRSZW5kZXJlZEF0dHJpYnV0ZXMsXG4gIGdldFNjaGVtYSxcbiAgZ2V0U2NoZW1hQnlSZXNvbHZlZEV4dGVuc2lvbnMsXG4gIGdldFNjaGVtYVR5cGVCeU5hbWUsXG4gIGdldFNjaGVtYVR5cGVOYW1lQnlOYW1lLFxuICBnZXRTcGxpdHRlZEF0dHJpYnV0ZXMsXG4gIGdldFRleHQsXG4gIGdldFRleHRCZXR3ZWVuLFxuICBnZXRUZXh0Q29udGVudEZyb21Ob2RlcyxcbiAgZ2V0VGV4dFNlcmlhbGl6ZXJzRnJvbVNjaGVtYSxcbiAgZ2V0VXBkYXRlZFBvc2l0aW9uLFxuICBoLFxuICBpbmplY3RFeHRlbnNpb25BdHRyaWJ1dGVzVG9QYXJzZVJ1bGUsXG4gIGlucHV0UnVsZXNQbHVnaW4sXG4gIGlzQWN0aXZlLFxuICBpc0FuZHJvaWQsXG4gIGlzQXRFbmRPZk5vZGUsXG4gIGlzQXRTdGFydE9mTm9kZSxcbiAgaXNFbXB0eU9iamVjdCxcbiAgaXNFeHRlbnNpb25SdWxlc0VuYWJsZWQsXG4gIGlzRnVuY3Rpb24sXG4gIGlzTGlzdCxcbiAgaXNNYWNPUyxcbiAgaXNNYXJrQWN0aXZlLFxuICBpc05vZGVBY3RpdmUsXG4gIGlzTm9kZUVtcHR5LFxuICBpc05vZGVTZWxlY3Rpb24sXG4gIGlzTnVtYmVyLFxuICBpc1BsYWluT2JqZWN0LFxuICBpc1JlZ0V4cCxcbiAgaXNTdHJpbmcsXG4gIGlzVGV4dFNlbGVjdGlvbixcbiAgaXNpT1MsXG4gIG1hcmtJbnB1dFJ1bGUsXG4gIG1hcmtQYXN0ZVJ1bGUsXG4gIG1hcmtkb3duX2V4cG9ydHMgYXMgbWFya2Rvd24sXG4gIG1lcmdlQXR0cmlidXRlcyxcbiAgbWVyZ2VEZWVwLFxuICBtaW5NYXgsXG4gIG5vZGVJbnB1dFJ1bGUsXG4gIG5vZGVQYXN0ZVJ1bGUsXG4gIG9iamVjdEluY2x1ZGVzLFxuICBwYXJzZUF0dHJpYnV0ZXMsXG4gIHBhcnNlSW5kZW50ZWRCbG9ja3MsXG4gIHBhc3RlUnVsZXNQbHVnaW4sXG4gIHBvc1RvRE9NUmVjdCxcbiAgcmVtb3ZlRHVwbGljYXRlcyxcbiAgcmVuZGVyTmVzdGVkTWFya2Rvd25Db250ZW50LFxuICByZXNvbHZlRXh0ZW5zaW9ucyxcbiAgcmVzb2x2ZUZvY3VzUG9zaXRpb24sXG4gIHJld3JpdGVVbmtub3duQ29udGVudCxcbiAgc2VsZWN0aW9uVG9JbnNlcnRpb25FbmQsXG4gIHNlcmlhbGl6ZUF0dHJpYnV0ZXMsXG4gIHNvcnRFeHRlbnNpb25zLFxuICBzcGxpdEV4dGVuc2lvbnMsXG4gIHRleHRJbnB1dFJ1bGUsXG4gIHRleHRQYXN0ZVJ1bGUsXG4gIHRleHRibG9ja1R5cGVJbnB1dFJ1bGUsXG4gIHVwZGF0ZU1hcmtWaWV3QXR0cmlidXRlcyxcbiAgd3JhcHBpbmdJbnB1dFJ1bGVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsiX19kZWZQcm9wIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJfX2V4cG9ydCIsInRhcmdldCIsImFsbCIsIm5hbWUiLCJnZXQiLCJlbnVtZXJhYmxlIiwiY3JlYXRlQ2hhaW5hYmxlU3RhdGUiLCJjb25maWciLCJzdGF0ZSIsInRyYW5zYWN0aW9uIiwic2VsZWN0aW9uIiwiZG9jIiwic3RvcmVkTWFya3MiLCJhcHBseSIsImJpbmQiLCJhcHBseVRyYW5zYWN0aW9uIiwicGx1Z2lucyIsInNjaGVtYSIsInJlY29uZmlndXJlIiwidG9KU09OIiwidHIiLCJDb21tYW5kTWFuYWdlciIsImNvbnN0cnVjdG9yIiwicHJvcHMiLCJlZGl0b3IiLCJyYXdDb21tYW5kcyIsImV4dGVuc2lvbk1hbmFnZXIiLCJjb21tYW5kcyIsImN1c3RvbVN0YXRlIiwiaGFzQ3VzdG9tU3RhdGUiLCJ2aWV3IiwiYnVpbGRQcm9wcyIsImZyb21FbnRyaWVzIiwiZW50cmllcyIsIm1hcCIsImNvbW1hbmQyIiwibWV0aG9kIiwiYXJncyIsImNhbGxiYWNrIiwiZ2V0TWV0YSIsImRpc3BhdGNoIiwiY2hhaW4iLCJjcmVhdGVDaGFpbiIsImNhbiIsImNyZWF0ZUNhbiIsInN0YXJ0VHIiLCJzaG91bGREaXNwYXRjaCIsImNhbGxiYWNrcyIsImhhc1N0YXJ0VHJhbnNhY3Rpb24iLCJydW4zIiwiZXZlcnkiLCJjaGFpbmVkQ29tbWFuZCIsInB1c2giLCJydW4iLCJmb3JtYXR0ZWRDb21tYW5kcyIsImNvbW1hbmRzX2V4cG9ydHMiLCJibHVyIiwiY2xlYXJDb250ZW50IiwiY2xlYXJOb2RlcyIsImNvbW1hbmQiLCJjcmVhdGVQYXJhZ3JhcGhOZWFyIiwiY3V0IiwiZGVsZXRlQ3VycmVudE5vZGUiLCJkZWxldGVOb2RlIiwiZGVsZXRlUmFuZ2UiLCJkZWxldGVTZWxlY3Rpb24iLCJlbnRlciIsImV4aXRDb2RlIiwiZXh0ZW5kTWFya1JhbmdlIiwiZmlyc3QiLCJmb2N1cyIsImZvckVhY2giLCJpbnNlcnRDb250ZW50IiwiaW5zZXJ0Q29udGVudEF0Iiwiam9pbkJhY2t3YXJkIiwiam9pbkRvd24iLCJqb2luRm9yd2FyZCIsImpvaW5JdGVtQmFja3dhcmQiLCJqb2luSXRlbUZvcndhcmQiLCJqb2luVGV4dGJsb2NrQmFja3dhcmQiLCJqb2luVGV4dGJsb2NrRm9yd2FyZCIsImpvaW5VcCIsImtleWJvYXJkU2hvcnRjdXQiLCJsaWZ0IiwibGlmdEVtcHR5QmxvY2siLCJsaWZ0TGlzdEl0ZW0iLCJuZXdsaW5lSW5Db2RlIiwicmVzZXRBdHRyaWJ1dGVzIiwic2Nyb2xsSW50b1ZpZXciLCJzZWxlY3RBbGwiLCJzZWxlY3ROb2RlQmFja3dhcmQiLCJzZWxlY3ROb2RlRm9yd2FyZCIsInNlbGVjdFBhcmVudE5vZGUiLCJzZWxlY3RUZXh0YmxvY2tFbmQiLCJzZWxlY3RUZXh0YmxvY2tTdGFydCIsInNldENvbnRlbnQiLCJzZXRNYXJrIiwic2V0TWV0YSIsInNldE5vZGUiLCJzZXROb2RlU2VsZWN0aW9uIiwic2V0VGV4dERpcmVjdGlvbiIsInNldFRleHRTZWxlY3Rpb24iLCJzaW5rTGlzdEl0ZW0iLCJzcGxpdEJsb2NrIiwic3BsaXRMaXN0SXRlbSIsInRvZ2dsZUxpc3QiLCJ0b2dnbGVNYXJrIiwidG9nZ2xlTm9kZSIsInRvZ2dsZVdyYXAiLCJ1bmRvSW5wdXRSdWxlIiwidW5zZXRBbGxNYXJrcyIsInVuc2V0TWFyayIsInVuc2V0VGV4dERpcmVjdGlvbiIsInVwZGF0ZUF0dHJpYnV0ZXMiLCJ3cmFwSW4iLCJ3cmFwSW5MaXN0IiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiX2EiLCJpc0Rlc3Ryb3llZCIsImRvbSIsIndpbmRvdyIsImdldFNlbGVjdGlvbiIsInJlbW92ZUFsbFJhbmdlcyIsImVtaXRVcGRhdGUiLCJsaWZ0VGFyZ2V0IiwicmFuZ2VzIiwiJGZyb20iLCIkdG8iLCJub2Rlc0JldHdlZW4iLCJwb3MiLCJub2RlIiwidHlwZSIsImlzVGV4dCIsIm1hcHBpbmciLCIkbWFwcGVkRnJvbSIsInJlc29sdmUiLCIkbWFwcGVkVG8iLCJub2RlU2l6ZSIsIm5vZGVSYW5nZSIsImJsb2NrUmFuZ2UiLCJ0YXJnZXRMaWZ0RGVwdGgiLCJpc1RleHRibG9jayIsImRlZmF1bHRUeXBlIiwicGFyZW50IiwiY29udGVudE1hdGNoQXQiLCJpbmRleCIsInNldE5vZGVNYXJrdXAiLCJzdGFydCIsImZuIiwib3JpZ2luYWxDcmVhdGVQYXJhZ3JhcGhOZWFyIiwiVGV4dFNlbGVjdGlvbiIsIm9yaWdpblJhbmdlIiwidGFyZ2V0UG9zIiwiY29udGVudFNsaWNlIiwic2xpY2UiLCJmcm9tIiwidG8iLCJuZXdQb3MiLCJpbnNlcnQiLCJjb250ZW50Iiwic2V0U2VsZWN0aW9uIiwiTWF0aCIsIm1heCIsImN1cnJlbnROb2RlIiwiJGFuY2hvciIsInNpemUiLCIkcG9zIiwiZGVwdGgiLCJiZWZvcmUiLCJhZnRlciIsImRlbGV0ZSIsImdldE5vZGVUeXBlIiwibmFtZU9yVHlwZSIsIm5vZGVzIiwiRXJyb3IiLCJ0eXBlT3JOYW1lIiwicmFuZ2UiLCJvcmlnaW5hbERlbGV0ZVNlbGVjdGlvbiIsIm9yaWdpbmFsRXhpdENvZGUiLCJUZXh0U2VsZWN0aW9uMiIsImlzUmVnRXhwIiwidmFsdWUiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJvYmplY3RJbmNsdWRlcyIsIm9iamVjdDEiLCJvYmplY3QyIiwib3B0aW9ucyIsInN0cmljdCIsImtleXMiLCJsZW5ndGgiLCJrZXkiLCJ0ZXN0IiwiZmluZE1hcmtJblNldCIsIm1hcmtzIiwiYXR0cmlidXRlcyIsImZpbmQiLCJpdGVtIiwiayIsImF0dHJzIiwiaXNNYXJrSW5TZXQiLCJnZXRNYXJrUmFuZ2UiLCJjaGlsZEFmdGVyIiwicGFyZW50T2Zmc2V0Iiwic29tZSIsIm1hcmsyIiwiY2hpbGRCZWZvcmUiLCJtYXJrIiwic3RhcnRJbmRleCIsInN0YXJ0UG9zIiwib2Zmc2V0IiwiZW5kSW5kZXgiLCJlbmRQb3MiLCJjaGlsZCIsImNoaWxkQ291bnQiLCJnZXRNYXJrVHlwZSIsIm5ld1NlbGVjdGlvbiIsImNyZWF0ZSIsIml0ZW1zIiwiaSIsIlRleHRTZWxlY3Rpb24zIiwiaXNUZXh0U2VsZWN0aW9uIiwiU2VsZWN0aW9uIiwiVGV4dFNlbGVjdGlvbjQiLCJtaW5NYXgiLCJtaW4iLCJyZXNvbHZlRm9jdXNQb3NpdGlvbiIsInBvc2l0aW9uIiwic2VsZWN0aW9uQXRTdGFydCIsImF0U3RhcnQiLCJzZWxlY3Rpb25BdEVuZCIsImF0RW5kIiwibWluUG9zIiwibWF4UG9zIiwiaXNBbmRyb2lkIiwibmF2aWdhdG9yIiwicGxhdGZvcm0iLCJ1c2VyQWdlbnQiLCJpc2lPUyIsImluY2x1ZGVzIiwiZG9jdW1lbnQiLCJkZWxheWVkRm9jdXMiLCJoYXNGb2N1cyIsImlzU2FtZVNlbGVjdGlvbiIsImVxIiwic2V0U3RvcmVkTWFya3MiLCJGcmFnbWVudCIsIkZyYWdtZW50MiIsIkRPTVBhcnNlciIsIk5vZGUiLCJQcm9zZU1pcnJvck5vZGUiLCJTY2hlbWEiLCJyZW1vdmVXaGl0ZXNwYWNlcyIsImNoaWxkcmVuIiwiY2hpbGROb2RlcyIsIm5vZGVUeXBlIiwibm9kZVZhbHVlIiwicmVtb3ZlQ2hpbGQiLCJlbGVtZW50RnJvbVN0cmluZyIsIndyYXBwZWRWYWx1ZSIsImh0bWwiLCJwYXJzZUZyb21TdHJpbmciLCJib2R5IiwiY3JlYXRlTm9kZUZyb21Db250ZW50IiwicGFyc2VPcHRpb25zIiwiaXNKU09OQ29udGVudCIsImlzVGV4dENvbnRlbnQiLCJpc0FycmF5Q29udGVudCIsIkFycmF5IiwiaXNBcnJheSIsImZyb21BcnJheSIsIm5vZGVGcm9tSlNPTiIsImVycm9yT25JbnZhbGlkQ29udGVudCIsImNoZWNrIiwiZXJyb3IiLCJjYXVzZSIsImNvbnNvbGUiLCJ3YXJuIiwiaGFzSW52YWxpZENvbnRlbnQiLCJpbnZhbGlkQ29udGVudCIsImNvbnRlbnRDaGVja1NjaGVtYSIsInRvcE5vZGUiLCJzcGVjIiwiYXBwZW5kIiwiX190aXB0YXBfX3ByaXZhdGVfX3Vua25vd25fX2NhdGNoX19hbGxfX25vZGUiLCJncm91cCIsInBhcnNlRE9NIiwidGFnIiwiZ2V0QXR0cnMiLCJlIiwib3V0ZXJIVE1MIiwiZnJvbVNjaGVtYSIsInBhcnNlU2xpY2UiLCJwYXJzZSIsInBhcnNlciIsIlNlbGVjdGlvbjIiLCJSZXBsYWNlQXJvdW5kU3RlcCIsIlJlcGxhY2VTdGVwIiwic2VsZWN0aW9uVG9JbnNlcnRpb25FbmQiLCJzdGFydExlbiIsImJpYXMiLCJsYXN0Iiwic3RlcHMiLCJzdGVwIiwibWFwcyIsImVuZCIsIl9mcm9tIiwiX3RvIiwiX25ld0Zyb20iLCJuZXdUbyIsIm5lYXIiLCJpc0ZyYWdtZW50Iiwibm9kZU9yRnJhZ21lbnQiLCJ1cGRhdGVTZWxlY3Rpb24iLCJhcHBseUlucHV0UnVsZXMiLCJhcHBseVBhc3RlUnVsZXMiLCJlbWl0Q29udGVudEVycm9yIiwiZW1pdCIsImRpc2FibGVDb2xsYWJvcmF0aW9uIiwic3RvcmFnZSIsImNvbGxhYm9yYXRpb24iLCJpc0Rpc2FibGVkIiwicHJlc2VydmVXaGl0ZXNwYWNlIiwiZW5hYmxlQ29udGVudENoZWNrIiwiaXNPbmx5VGV4dENvbnRlbnQiLCJpc09ubHlCbG9ja0NvbnRlbnQiLCJpc0Jsb2NrIiwiaXNFbXB0eVRleHRCbG9jayIsImNvZGUiLCJuZXdDb250ZW50IiwidiIsInRleHQiLCJqb2luIiwiaW5zZXJ0VGV4dCIsIiRmcm9tTm9kZSIsImZyb21TZWxlY3Rpb25BdFN0YXJ0IiwiaXNUZXh0U2VsZWN0aW9uMiIsImhhc0NvbnRlbnQiLCJyZXBsYWNlV2l0aCIsIm9yaWdpbmFsSm9pbkJhY2t3YXJkIiwib3JpZ2luYWxKb2luRG93biIsIm9yaWdpbmFsSm9pbkZvcndhcmQiLCJvcmlnaW5hbEpvaW5VcCIsImpvaW5Qb2ludCIsInBvaW50Iiwiam9pblBvaW50MiIsIm9yaWdpbmFsQ29tbWFuZCIsIm9yaWdpbmFsQ29tbWFuZDIiLCJpc01hY09TIiwibm9ybWFsaXplS2V5TmFtZSIsInBhcnRzIiwic3BsaXQiLCJyZXN1bHQiLCJhbHQiLCJjdHJsIiwic2hpZnQiLCJtZXRhIiwibW9kIiwiZXZlbnQiLCJLZXlib2FyZEV2ZW50IiwiYWx0S2V5IiwiY3RybEtleSIsIm1ldGFLZXkiLCJzaGlmdEtleSIsImJ1YmJsZXMiLCJjYW5jZWxhYmxlIiwiY2FwdHVyZWRUcmFuc2FjdGlvbiIsImNhcHR1cmVUcmFuc2FjdGlvbiIsInNvbWVQcm9wIiwiZiIsIm5ld1N0ZXAiLCJtYXliZVN0ZXAiLCJvcmlnaW5hbExpZnQiLCJpc05vZGVBY3RpdmUiLCJlbXB0eSIsIm5vZGVSYW5nZXMiLCJyZWxhdGl2ZUZyb20iLCJyZWxhdGl2ZVRvIiwic2VsZWN0aW9uUmFuZ2UiLCJtYXRjaGVkTm9kZVJhbmdlcyIsImZpbHRlciIsInJlZHVjZSIsInN1bSIsImlzQWN0aXZlMiIsIm9yaWdpbmFsTGlmdEVtcHR5QmxvY2siLCJvcmlnaW5hbExpZnRMaXN0SXRlbSIsIm9yaWdpbmFsTmV3bGluZUluQ29kZSIsImdldFNjaGVtYVR5cGVOYW1lQnlOYW1lIiwiZGVsZXRlUHJvcHMiLCJvYmoiLCJwcm9wT3JQcm9wcyIsIm5ld09iaiIsInByb3AiLCJtYXJrVHlwZSIsInNjaGVtYVR5cGUiLCJjYW5SZXNldCIsImFkZE1hcmsiLCJBbGxTZWxlY3Rpb24iLCJvcmlnaW5hbFNlbGVjdE5vZGVCYWNrd2FyZCIsIm9yaWdpbmFsU2VsZWN0Tm9kZUZvcndhcmQiLCJvcmlnaW5hbFNlbGVjdFBhcmVudE5vZGUiLCJvcmlnaW5hbFNlbGVjdFRleHRibG9ja0VuZCIsIm9yaWdpbmFsU2VsZWN0VGV4dGJsb2NrU3RhcnQiLCJjcmVhdGVEb2N1bWVudCIsImRvY3VtZW50MiIsImdldE1hcmtBdHRyaWJ1dGVzIiwiJGhlYWQiLCJtYXJrSXRlbSIsIlRyYW5zZm9ybSIsImNvbWJpbmVUcmFuc2FjdGlvblN0ZXBzIiwib2xkRG9jIiwidHJhbnNhY3Rpb25zIiwidHJhbnNmb3JtIiwiZGVmYXVsdEJsb2NrQXQiLCJtYXRjaCIsImVkZ2VDb3VudCIsImVkZ2UiLCJoYXNSZXF1aXJlZEF0dHJzIiwiZmluZENoaWxkcmVuIiwicHJlZGljYXRlIiwibm9kZXNXaXRoUG9zIiwiZGVzY2VuZGFudHMiLCJmaW5kQ2hpbGRyZW5JblJhbmdlIiwiZmluZFBhcmVudE5vZGVDbG9zZXN0VG9Qb3MiLCJmaW5kUGFyZW50Tm9kZSIsImdldEV4dGVuc2lvbkZpZWxkIiwiZXh0ZW5zaW9uIiwiZmllbGQiLCJjb250ZXh0IiwiZmxhdHRlbkV4dGVuc2lvbnMiLCJleHRlbnNpb25zIiwiYWRkRXh0ZW5zaW9ucyIsImZsYXQiLCJET01TZXJpYWxpemVyIiwiZ2V0SFRNTEZyb21GcmFnbWVudCIsImZyYWdtZW50IiwiZG9jdW1lbnRGcmFnbWVudCIsInNlcmlhbGl6ZUZyYWdtZW50IiwidGVtcG9yYXJ5RG9jdW1lbnQiLCJpbXBsZW1lbnRhdGlvbiIsImNyZWF0ZUhUTUxEb2N1bWVudCIsImNvbnRhaW5lciIsImNyZWF0ZUVsZW1lbnQiLCJhcHBlbmRDaGlsZCIsImlubmVySFRNTCIsIlNjaGVtYTIiLCJpc0Z1bmN0aW9uIiwiY2FsbE9yUmV0dXJuIiwiaXNFbXB0eU9iamVjdCIsInNwbGl0RXh0ZW5zaW9ucyIsImJhc2VFeHRlbnNpb25zIiwibm9kZUV4dGVuc2lvbnMiLCJtYXJrRXh0ZW5zaW9ucyIsImdldEF0dHJpYnV0ZXNGcm9tRXh0ZW5zaW9ucyIsImV4dGVuc2lvbkF0dHJpYnV0ZXMiLCJub2RlQW5kTWFya0V4dGVuc2lvbnMiLCJkZWZhdWx0QXR0cmlidXRlIiwiZGVmYXVsdCIsInZhbGlkYXRlIiwicmVuZGVyZWQiLCJyZW5kZXJIVE1MIiwicGFyc2VIVE1MIiwia2VlcE9uU3BsaXQiLCJpc1JlcXVpcmVkIiwiYWRkR2xvYmFsQXR0cmlidXRlcyIsImdsb2JhbEF0dHJpYnV0ZXMiLCJnbG9iYWxBdHRyaWJ1dGUiLCJ0eXBlcyIsImF0dHJpYnV0ZSIsImFkZEF0dHJpYnV0ZXMiLCJtZXJnZWRBdHRyIiwibWVyZ2VBdHRyaWJ1dGVzIiwib2JqZWN0cyIsIm1lcmdlZEF0dHJpYnV0ZXMiLCJleGlzdHMiLCJ2YWx1ZUNsYXNzZXMiLCJTdHJpbmciLCJleGlzdGluZ0NsYXNzZXMiLCJpbnNlcnRDbGFzc2VzIiwidmFsdWVDbGFzcyIsIm5ld1N0eWxlcyIsInN0eWxlMiIsInRyaW0iLCJCb29sZWFuIiwiZXhpc3RpbmdTdHlsZXMiLCJzdHlsZU1hcCIsIk1hcCIsInByb3BlcnR5IiwidmFsIiwicGFydCIsInNldCIsImdldFJlbmRlcmVkQXR0cmlidXRlcyIsIm5vZGVPck1hcmsiLCJmcm9tU3RyaW5nIiwiTnVtYmVyIiwiaW5qZWN0RXh0ZW5zaW9uQXR0cmlidXRlc1RvUGFyc2VSdWxlIiwicGFyc2VSdWxlIiwib2xkQXR0cmlidXRlcyIsIm5ld0F0dHJpYnV0ZXMiLCJnZXRBdHRyaWJ1dGUiLCJjbGVhblVwU2NoZW1hSXRlbSIsImRhdGEiLCJidWlsZEF0dHJpYnV0ZVNwZWMiLCJleHRlbnNpb25BdHRyaWJ1dGUiLCJfYiIsImdldFNjaGVtYUJ5UmVzb2x2ZWRFeHRlbnNpb25zIiwiYWxsQXR0cmlidXRlcyIsImV4dHJhTm9kZUZpZWxkcyIsImZpZWxkcyIsImV4dGVuZE5vZGVTY2hlbWEiLCJpbmxpbmUiLCJhdG9tIiwic2VsZWN0YWJsZSIsImRyYWdnYWJsZSIsIndoaXRlc3BhY2UiLCJsaW5lYnJlYWtSZXBsYWNlbWVudCIsImRlZmluaW5nIiwiaXNvbGF0aW5nIiwidG9ET00iLCJIVE1MQXR0cmlidXRlcyIsInJlbmRlclRleHQiLCJ0b1RleHQiLCJleHRyYU1hcmtGaWVsZHMiLCJleHRlbmRNYXJrU2NoZW1hIiwiaW5jbHVzaXZlIiwiZXhjbHVkZXMiLCJzcGFubmluZyIsImZpbmREdXBsaWNhdGVzIiwiZmlsdGVyZWQiLCJlbCIsImluZGV4T2YiLCJTZXQiLCJzb3J0RXh0ZW5zaW9ucyIsImRlZmF1bHRQcmlvcml0eSIsInNvcnQiLCJhIiwiYiIsInByaW9yaXR5QSIsInByaW9yaXR5QiIsInJlc29sdmVFeHRlbnNpb25zIiwicmVzb2x2ZWRFeHRlbnNpb25zIiwiZHVwbGljYXRlZE5hbWVzIiwiZ2V0U2NoZW1hIiwiZ2VuZXJhdGVIVE1MIiwiY29udGVudE5vZGUiLCJmcm9tSlNPTiIsIkRPTVBhcnNlcjIiLCJnZW5lcmF0ZUpTT04iLCJOb2RlMiIsImdldFRleHRCZXR3ZWVuIiwic3RhcnROb2RlIiwiYmxvY2tTZXBhcmF0b3IiLCJ0ZXh0U2VyaWFsaXplcnMiLCJ0ZXh0U2VyaWFsaXplciIsImdldFRleHQiLCJnZXRUZXh0U2VyaWFsaXplcnNGcm9tU2NoZW1hIiwiZ2VuZXJhdGVUZXh0IiwiZ2V0Tm9kZUF0dHJpYnV0ZXMiLCJub2RlMiIsInJldmVyc2UiLCJub2RlSXRlbSIsImdldEF0dHJpYnV0ZXMiLCJyZW1vdmVEdXBsaWNhdGVzIiwiYXJyYXkiLCJieSIsIkpTT04iLCJzdHJpbmdpZnkiLCJzZWVuIiwiaGFzT3duUHJvcGVydHkiLCJzaW1wbGlmeUNoYW5nZWRSYW5nZXMiLCJjaGFuZ2VzIiwidW5pcXVlQ2hhbmdlcyIsImNoYW5nZSIsInJlc3QiLCJfIiwib3RoZXJDaGFuZ2UiLCJvbGRSYW5nZSIsIm5ld1JhbmdlIiwiZ2V0Q2hhbmdlZFJhbmdlcyIsInN0ZXBNYXAiLCJuZXdTdGFydCIsIm5ld0VuZCIsIm9sZFN0YXJ0IiwiaW52ZXJ0Iiwib2xkRW5kIiwiZ2V0RGVidWdKU09OIiwic3RhcnRPZmZzZXQiLCJpc1RvcE5vZGUiLCJ0b3BOb2RlVHlwZSIsImluY3JlbWVudCIsIm91dHB1dDIiLCJvdXRwdXQiLCJnZXRNYXJrc0JldHdlZW4iLCJnZXROb2RlQXRQb3NpdGlvbiIsIm1heERlcHRoIiwiY3VycmVudERlcHRoIiwiZ2V0U2NoZW1hVHlwZUJ5TmFtZSIsImdldFNwbGl0dGVkQXR0cmlidXRlcyIsInR5cGVOYW1lIiwiZ2V0VGV4dENvbnRlbnRGcm9tTm9kZXMiLCJtYXhNYXRjaCIsInRleHRCZWZvcmUiLCJzbGljZUVuZFBvcyIsImNodW5rIiwidGV4dENvbnRlbnQiLCJpc0F0b20iLCJpc01hcmtBY3RpdmUiLCJtYXJrUmFuZ2VzIiwicmFuZ2UyIiwibWF0Y2hlZFJhbmdlIiwibWFya1JhbmdlIiwiZXhjbHVkZWRSYW5nZSIsImlzQWN0aXZlIiwiaXNBdEVuZE9mTm9kZSIsInBhcmVudE5vZGUiLCIkcGFyZW50UG9zIiwiaXNBdFN0YXJ0T2ZOb2RlIiwiaXNFeHRlbnNpb25SdWxlc0VuYWJsZWQiLCJlbmFibGVkIiwiZW5hYmxlZEV4dGVuc2lvbiIsImlzTGlzdCIsImlzTm9kZUVtcHR5IiwiY2hlY2tDaGlsZHJlbiIsImlnbm9yZVdoaXRlc3BhY2UiLCJpc0xlYWYiLCJpc0NvbnRlbnRFbXB0eSIsImNoaWxkTm9kZSIsIk5vZGVTZWxlY3Rpb24iLCJpc05vZGVTZWxlY3Rpb24iLCJNYXBwYWJsZVBvc2l0aW9uIiwiX01hcHBhYmxlUG9zaXRpb24iLCJqc29uIiwiZ2V0VXBkYXRlZFBvc2l0aW9uIiwibWFwUmVzdWx0IiwiY3JlYXRlTWFwcGFibGVQb3NpdGlvbiIsInBvc1RvRE9NUmVjdCIsInJlc29sdmVkRnJvbSIsInJlc29sdmVkRW5kIiwiY29vcmRzQXRQb3MiLCJ0b3AiLCJib3R0b20iLCJsZWZ0IiwicmlnaHQiLCJ3aWR0aCIsImhlaWdodCIsIngiLCJ5IiwicmV3cml0ZVVua25vd25Db250ZW50SW5uZXIiLCJ2YWxpZE1hcmtzIiwidmFsaWROb2RlcyIsInJld3JpdHRlbkNvbnRlbnQiLCJoYXMiLCJvcmlnaW5hbCIsInVuc3VwcG9ydGVkIiwiZmFsbGJhY2tUb1BhcmFncmFwaCIsInJld3JpdGVVbmtub3duQ29udGVudCIsImNhblNldE1hcmsiLCJuZXdNYXJrVHlwZSIsImN1cnNvciIsIiRjdXJzb3IiLCJjdXJyZW50TWFya3MiLCJwYXJlbnRBbGxvd3NNYXJrVHlwZSIsImFsbG93c01hcmtUeXBlIiwiaXNJblNldCIsInNvbWVOb2RlU3VwcG9ydHNNYXJrIiwiaW5saW5lQ29udGVudCIsIl9wb3MiLCJpc0lubGluZSIsImN1cnJlbnRNYXJrc0FsbG93TWFya1R5cGUiLCJvdGhlck1hcmsiLCJhZGRTdG9yZWRNYXJrIiwidHJpbW1lZEZyb20iLCJ0cmltbWVkVG8iLCJzb21lSGFzTWFyayIsInNldEJsb2NrVHlwZSIsImF0dHJpYnV0ZXNUb0NvcHkiLCJzYW1lUGFyZW50IiwiY2FuU2V0QmxvY2siLCJ1cGRhdGVkU3RhdGUiLCJOb2RlU2VsZWN0aW9uMiIsImRpcmVjdGlvbiIsImRpciIsIlRleHRTZWxlY3Rpb241Iiwib3JpZ2luYWxTaW5rTGlzdEl0ZW0iLCJOb2RlU2VsZWN0aW9uMyIsIlRleHRTZWxlY3Rpb242IiwiY2FuU3BsaXQiLCJlbnN1cmVNYXJrcyIsInNwbGl0dGFibGVNYXJrcyIsImZpbHRlcmVkTWFya3MiLCJrZWVwTWFya3MiLCJkZWZsdCIsImluZGV4QWZ0ZXIiLCJmaXJzdDIiLCIkZmlyc3QiLCJjYW5SZXBsYWNlV2l0aCIsIkZyYWdtZW50MyIsIlNsaWNlIiwiVGV4dFNlbGVjdGlvbjciLCJjYW5TcGxpdDIiLCJvdmVycmlkZUF0dHJzIiwiZ3JhbmRQYXJlbnQiLCJ3cmFwIiwiZGVwdGhCZWZvcmUiLCJkIiwiY29weSIsImRlcHRoQWZ0ZXIiLCJuZXdOZXh0VHlwZUF0dHJpYnV0ZXMyIiwibmV4dFR5cGUyIiwiY29udGVudE1hdGNoIiwiY3JlYXRlQW5kRmlsbCIsInJlcGxhY2UiLCJzZWwiLCJuIiwibmV4dFR5cGUiLCJuZXdUeXBlQXR0cmlidXRlcyIsIm5ld05leHRUeXBlQXR0cmlidXRlcyIsImNhbkpvaW4iLCJqb2luTGlzdEJhY2t3YXJkcyIsImxpc3RUeXBlIiwibGlzdCIsIm5vZGVCZWZvcmUiLCJub2RlQXQiLCJjYW5Kb2luQmFja3dhcmRzIiwiam9pbkxpc3RGb3J3YXJkcyIsIm5vZGVBZnRlciIsImNhbkpvaW5Gb3J3YXJkcyIsImxpc3RUeXBlT3JOYW1lIiwiaXRlbVR5cGVPck5hbWUiLCJpdGVtVHlwZSIsInBhcmVudExpc3QiLCJ2YWxpZENvbnRlbnQiLCJjYW5XcmFwSW5MaXN0IiwiZXh0ZW5kRW1wdHlNYXJrUmFuZ2UiLCJ0b2dnbGVUeXBlT3JOYW1lIiwidG9nZ2xlVHlwZSIsInBsdWdpbiIsInVuZG9hYmxlIiwiaXNJbnB1dFJ1bGVzIiwiZ2V0U3RhdGUiLCJ0b1VuZG8iLCJqIiwiZG9jcyIsInJlbW92ZU1hcmsiLCJyZW1vdmVTdG9yZWRNYXJrIiwibmV3QXR0cnMiLCJjYW5VcGRhdGUiLCJsYXN0UG9zIiwibGFzdE5vZGUiLCJ0cmltbWVkRnJvbTIiLCJ0cmltbWVkVG8yIiwib3JpZ2luYWxXcmFwSW4iLCJvcmlnaW5hbFdyYXBJbkxpc3QiLCJFZGl0b3JTdGF0ZSIsIkVkaXRvclZpZXciLCJFdmVudEVtaXR0ZXIiLCJvbiIsIm9mZiIsIm9uY2UiLCJvbmNlRm4iLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJrZXltYXAiLCJGcmFnbWVudDQiLCJQbHVnaW4iLCJJbnB1dFJ1bGUiLCJoYW5kbGVyIiwiaW5wdXRSdWxlTWF0Y2hlckhhbmRsZXIiLCJleGVjIiwiaW5wdXRSdWxlTWF0Y2giLCJpbnB1dCIsInJ1bGVzIiwiY29tcG9zaW5nIiwibWF0Y2hlZCIsInJ1bGUiLCJpbnB1dFJ1bGVzUGx1Z2luIiwiaW5pdCIsInByZXYiLCJzdG9yZWQiLCJzaW11bGF0ZWRJbnB1dE1ldGEiLCJpc1NpbXVsYXRlZElucHV0Iiwic2V0VGltZW91dCIsInNlbGVjdGlvblNldCIsImRvY0NoYW5nZWQiLCJoYW5kbGVUZXh0SW5wdXQiLCJoYW5kbGVET01FdmVudHMiLCJjb21wb3NpdGlvbmVuZCIsImhhbmRsZUtleURvd24iLCJnZXRUeXBlIiwiaXNQbGFpbk9iamVjdCIsImdldFByb3RvdHlwZU9mIiwibWVyZ2VEZWVwIiwic291cmNlIiwiRXh0ZW5kYWJsZSIsImNvbmZpZ3VyZSIsImV4dGVuZCIsImFkZE9wdGlvbnMiLCJleHRlbmRlZENvbmZpZyIsIk1hcmsiLCJfTWFyayIsImFyZ3VtZW50cyIsInJlc29sdmVkQ29uZmlnIiwiaGFuZGxlRXhpdCIsImN1cnJlbnRQb3MiLCJpc0F0RW5kIiwiaXNJbk1hcmsiLCJtIiwiRnJhZ21lbnQ1IiwiUGx1Z2luMiIsImlzTnVtYmVyIiwiUGFzdGVSdWxlIiwicGFzdGVSdWxlTWF0Y2hlckhhbmRsZXIiLCJtYXRjaEFsbCIsIm1hdGNoZXMiLCJwYXN0ZVJ1bGVNYXRjaCIsInJ1bjIiLCJwYXN0ZUV2ZW50IiwiZHJvcEV2ZW50IiwiaGFuZGxlcnMiLCJfYyIsIl9kIiwiX2UiLCJjb250ZW50U2l6ZSIsInJlc29sdmVkVG8iLCJ0ZXh0VG9NYXRjaCIsInRleHRCZXR3ZWVuIiwic3VjY2VzcyIsInRpcHRhcERyYWdGcm9tT3RoZXJFZGl0b3IiLCJjcmVhdGVDbGlwYm9hcmRQYXN0ZUV2ZW50IiwiQ2xpcGJvYXJkRXZlbnQiLCJjbGlwYm9hcmREYXRhIiwiRGF0YVRyYW5zZmVyIiwic2V0RGF0YSIsInBhc3RlUnVsZXNQbHVnaW4iLCJkcmFnU291cmNlRWxlbWVudCIsImlzUGFzdGVkRnJvbVByb3NlTWlycm9yIiwiaXNEcm9wcGVkRnJvbVByb3NlTWlycm9yIiwiRHJhZ0V2ZW50IiwicHJvY2Vzc0V2ZW50IiwicGFzdGVFdnQiLCJjaGFpbmFibGVTdGF0ZSIsImhhbmRsZURyYWdzdGFydCIsInBhcmVudEVsZW1lbnQiLCJjb250YWlucyIsImhhbmRsZURyYWdlbmQiLCJhZGRFdmVudExpc3RlbmVyIiwiZGVzdHJveSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJkcm9wIiwiZHJhZ0Zyb21PdGhlckVkaXRvciIsImlzRWRpdGFibGUiLCJwYXN0ZSIsIl92aWV3IiwiZ2V0RGF0YSIsImFwcGVuZFRyYW5zYWN0aW9uIiwib2xkU3RhdGUiLCJpc1Bhc3RlIiwiaXNEcm9wIiwic2ltdWxhdGVkUGFzdGVNZXRhIiwiaXNTaW11bGF0ZWRQYXN0ZSIsImZyb20yIiwidG8yIiwiZmluZERpZmZTdGFydCIsImZpbmREaWZmRW5kIiwiRXh0ZW5zaW9uTWFuYWdlciIsInNldHVwRXh0ZW5zaW9ucyIsImV4dGVuc2lvblN0b3JhZ2UiLCJhZGRDb21tYW5kcyIsImFsbFBsdWdpbnMiLCJmbGF0TWFwIiwiYWRkS2V5Ym9hcmRTaG9ydGN1dHMiLCJkZWZhdWx0QmluZGluZ3MiLCJBcnJvd1JpZ2h0IiwiYmluZGluZ3MiLCJzaG9ydGN1dCIsImtleU1hcFBsdWdpbiIsImFkZElucHV0UnVsZXMiLCJlbmFibGVJbnB1dFJ1bGVzIiwiaW5wdXRSZXN1bHQiLCJpbnB1dFBsdWdpbnMiLCJhZGRQYXN0ZVJ1bGVzIiwiZW5hYmxlUGFzdGVSdWxlcyIsInBhc3RlUnVsZXMiLCJhZGRQcm9zZU1pcnJvclBsdWdpbnMiLCJwcm9zZU1pcnJvclBsdWdpbnMiLCJub2RlVmlld3MiLCJhZGROb2RlVmlldyIsIm5vZGVWaWV3UmVzdWx0Iiwibm9kZXZpZXciLCJnZXRQb3MiLCJkZWNvcmF0aW9ucyIsImlubmVyRGVjb3JhdGlvbnMiLCJtYXJrVmlld3MiLCJhZGRNYXJrVmlldyIsIm1hcmtWaWV3IiwidXBkYXRlTWFya1ZpZXdBdHRyaWJ1dGVzIiwib25CZWZvcmVDcmVhdGUiLCJvbkNyZWF0ZSIsIm9uVXBkYXRlIiwib25TZWxlY3Rpb25VcGRhdGUiLCJvblRyYW5zYWN0aW9uIiwib25Gb2N1cyIsIm9uQmx1ciIsIm9uRGVzdHJveSIsImZsYXR0ZW4iLCJleHRlbnNpb25zX2V4cG9ydHMiLCJDbGlwYm9hcmRUZXh0U2VyaWFsaXplciIsIkNvbW1hbmRzIiwiRGVsZXRlIiwiRHJvcCIsIkVkaXRhYmxlIiwiRm9jdXNFdmVudHMiLCJLZXltYXAiLCJQYXN0ZSIsIlRhYmluZGV4IiwiVGV4dERpcmVjdGlvbiIsImZvY3VzRXZlbnRzUGx1Z2luS2V5IiwiUGx1Z2luMyIsIlBsdWdpbktleSIsIkV4dGVuc2lvbiIsIl9FeHRlbnNpb24iLCJjbGlwYm9hcmRUZXh0U2VyaWFsaXplciIsIlJlbW92ZU1hcmtTdGVwIiwiYXBwZW5kZWRUcmFuc2FjdGlvbnMiLCJfYTIiLCJfYjIiLCJfYzIiLCJjb3JlRXh0ZW5zaW9uT3B0aW9ucyIsImZpbHRlclRyYW5zYWN0aW9uIiwibmV4dFRyYW5zYWN0aW9uIiwiZGVsZXRlZEFmdGVyIiwiZGVsZXRlZEJlZm9yZSIsImlzRnVsbHlXaXRoaW5SYW5nZSIsIm5ld0Zyb20iLCJkZWxldGVkUmFuZ2UiLCJwYXJ0aWFsIiwiY29tYmluZWRUcmFuc2Zvcm0iLCJfYTMiLCJfYjMiLCJmb3VuZEJlZm9yZU1hcmsiLCJmb3VuZEFmdGVyTWFyayIsImFzeW5jIiwiUGx1Z2luNCIsIlBsdWdpbktleTIiLCJoYW5kbGVEcm9wIiwibW92ZWQiLCJQbHVnaW41IiwiUGx1Z2luS2V5MyIsImVkaXRhYmxlIiwiUGx1Z2luNiIsIlBsdWdpbktleTQiLCJpc0ZvY3VzZWQiLCJQbHVnaW43IiwiUGx1Z2luS2V5NSIsIlNlbGVjdGlvbjMiLCJoYW5kbGVCYWNrc3BhY2UiLCJwYXJlbnRJc0lzb2xhdGluZyIsInBhcmVudFBvcyIsImlzQXRTdGFydCIsImhhbmRsZURlbGV0ZSIsImhhbmRsZUVudGVyIiwiYmFzZUtleW1hcCIsIkVudGVyIiwiQmFja3NwYWNlIiwicGNLZXltYXAiLCJtYWNLZXltYXAiLCJuZXdTdGF0ZSIsInRyMiIsImRvY0NoYW5nZXMiLCJpZ25vcmVUciIsImFsbEZyb20iLCJhbGxFbmQiLCJhbGxXYXNTZWxlY3RlZCIsImlzRW1wdHkiLCJQbHVnaW44IiwiUGx1Z2luS2V5NiIsImhhbmRsZVBhc3RlIiwiUGx1Z2luOSIsIlBsdWdpbktleTciLCJ0YWJpbmRleCIsIlBsdWdpbjEwIiwiUGx1Z2luS2V5OCIsImVsZW1lbnQiLCJOb2RlUG9zIiwiX05vZGVQb3MiLCJhY3R1YWxEZXB0aCIsInJlc29sdmVkUG9zIiwiZG9tQXRQb3MiLCJpc05vblRleHRBdG9tIiwiY2hpbGROb2RlUG9zIiwiZmlyc3RDaGlsZCIsImxhc3RDaGlsZCIsImNsb3Nlc3QiLCJzZWxlY3RvciIsIm5vZGVBdHRyaWJ1dGVzIiwiYXR0cktleXMiLCJxdWVyeVNlbGVjdG9yIiwicXVlcnlTZWxlY3RvckFsbCIsImZpcnN0SXRlbU9ubHkiLCJjaGlsZFBvcyIsImRvZXNBbGxBdHRyaWJ1dGVzTWF0Y2giLCJjb25jYXQiLCJzZXRBdHRyaWJ1dGUiLCJzdHlsZSIsImNyZWF0ZVN0eWxlVGFnIiwibm9uY2UiLCJzdWZmaXgiLCJ0aXB0YXBTdHlsZVRhZyIsInN0eWxlTm9kZSIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwiRWRpdG9yIiwiY3NzIiwiY2xhc3NOYW1lIiwiZWRpdG9yVmlldyIsImlzSW5pdGlhbGl6ZWQiLCJpbnN0YW5jZUlkIiwicmFuZG9tIiwiaW5qZWN0Q1NTIiwiaW5qZWN0Tm9uY2UiLCJhdXRvZm9jdXMiLCJ0ZXh0RGlyZWN0aW9uIiwiZWRpdG9yUHJvcHMiLCJlbmFibGVDb3JlRXh0ZW5zaW9ucyIsIm9uTW91bnQiLCJvblVubW91bnQiLCJvbkNvbnRlbnRFcnJvciIsIm9uUGFzdGUiLCJvbkRyb3AiLCJvbkRlbGV0ZSIsImlzQ2FwdHVyaW5nVHJhbnNhY3Rpb24iLCJ1dGlscyIsInNldE9wdGlvbnMiLCJjcmVhdGVFeHRlbnNpb25NYW5hZ2VyIiwiY3JlYXRlQ29tbWFuZE1hbmFnZXIiLCJjcmVhdGVTY2hlbWEiLCJpbml0aWFsRG9jIiwiY3JlYXRlRG9jIiwiZWRpdG9yU3RhdGUiLCJtb3VudCIsImNyZWF0ZVZpZXciLCJoZWFkIiwidW5tb3VudCIsInJlbW92ZSIsImNvbW1hbmRNYW5hZ2VyIiwic2V0UHJvcHMiLCJ1cGRhdGVTdGF0ZSIsInNldEVkaXRhYmxlIiwiUHJveHkiLCJkaXNwYXRjaFRyYW5zYWN0aW9uIiwiZHJhZ2dpbmciLCJSZWZsZWN0IiwicmVnaXN0ZXJQbHVnaW4iLCJoYW5kbGVQbHVnaW5zIiwidW5yZWdpc3RlclBsdWdpbiIsIm5hbWVPclBsdWdpbktleVRvUmVtb3ZlIiwicHJldlBsdWdpbnMiLCJuYW1lT3JQbHVnaW5LZXkiLCJzdGFydHNXaXRoIiwiY29yZUV4dGVuc2lvbnMiLCJleHQiLCJhbGxFeHRlbnNpb25zIiwibWVzc2FnZSIsInJvbGUiLCJwcmVwZW5kQ2xhc3MiLCJjcmVhdGVOb2RlVmlld3MiLCJzZWxlY3Rpb25IYXNDaGFuZ2VkIiwicm9vdFRyV2FzQXBwbGllZCIsInByZXZTdGF0ZSIsIm5leHRTdGF0ZSIsIm1vc3RSZWNlbnRGb2N1c1RyIiwiZmluZExhc3QiLCJmb2N1czIiLCJibHVyMiIsIm5hbWVPckF0dHJpYnV0ZXMiLCJhdHRyaWJ1dGVzT3JVbmRlZmluZWQiLCJnZXRKU09OIiwiZ2V0SFRNTCIsIiRub2RlIiwiJGRvYyIsIiRub2RlcyIsIm1hcmtJbnB1dFJ1bGUiLCJjYXB0dXJlR3JvdXAiLCJmdWxsTWF0Y2giLCJzdGFydFNwYWNlcyIsInNlYXJjaCIsInRleHRTdGFydCIsInRleHRFbmQiLCJleGNsdWRlZE1hcmtzIiwiZXhjbHVkZWQiLCJtYXJrRW5kIiwibm9kZUlucHV0UnVsZSIsIm5ld05vZGUiLCJsYXN0SW5kZXhPZiIsIm1hdGNoU3RhcnQiLCJsYXN0Q2hhciIsImluc2VydGlvblN0YXJ0IiwidGV4dGJsb2NrVHlwZUlucHV0UnVsZSIsIiRzdGFydCIsInRleHRJbnB1dFJ1bGUiLCJjdXRPZmYiLCJjYW5Kb2luMiIsImZpbmRXcmFwcGluZyIsIndyYXBwaW5nSW5wdXRSdWxlIiwid3JhcHBpbmciLCJrZWVwQXR0cmlidXRlcyIsImpvaW5QcmVkaWNhdGUiLCJGcmFnbWVudDYiLCJoIiwiRnVuY3Rpb24iLCJpc1RvdWNoRXZlbnQiLCJSZXNpemFibGVOb2RlVmlldyIsImRpcmVjdGlvbnMiLCJtaW5TaXplIiwicHJlc2VydmVBc3BlY3RSYXRpbyIsImNsYXNzTmFtZXMiLCJ3cmFwcGVyIiwiaGFuZGxlIiwicmVzaXppbmciLCJpbml0aWFsV2lkdGgiLCJpbml0aWFsSGVpZ2h0IiwiYXNwZWN0UmF0aW8iLCJpc1Jlc2l6aW5nIiwiYWN0aXZlSGFuZGxlIiwic3RhcnRYIiwic3RhcnRZIiwic3RhcnRXaWR0aCIsInN0YXJ0SGVpZ2h0IiwiaXNTaGlmdEtleVByZXNzZWQiLCJsYXN0RWRpdGFibGVTdGF0ZSIsImhhbmRsZU1hcCIsImhhbmRsZU1vdXNlTW92ZSIsImRlbHRhWCIsImNsaWVudFgiLCJkZWx0YVkiLCJjbGllbnRZIiwiaGFuZGxlUmVzaXplIiwiaGFuZGxlVG91Y2hNb3ZlIiwidG91Y2giLCJ0b3VjaGVzIiwiaGFuZGxlTW91c2VVcCIsImZpbmFsV2lkdGgiLCJvZmZzZXRXaWR0aCIsImZpbmFsSGVpZ2h0Iiwib2Zmc2V0SGVpZ2h0Iiwib25Db21taXQiLCJkYXRhc2V0IiwicmVzaXplU3RhdGUiLCJjbGFzc0xpc3QiLCJoYW5kbGVLZXlVcCIsIl9mIiwiY29udGVudEVsZW1lbnQiLCJvblJlc2l6ZSIsIm1heFNpemUiLCJjcmVhdGVDdXN0b21IYW5kbGUiLCJjcmVhdGVXcmFwcGVyIiwiY3JlYXRlQ29udGFpbmVyIiwiYXBwbHlJbml0aWFsU2l6ZSIsImF0dGFjaEhhbmRsZXMiLCJoYW5kbGVFZGl0b3JVcGRhdGUiLCJjb250ZW50RE9NIiwicmVtb3ZlSGFuZGxlcyIsInVwZGF0ZSIsInJlc2l6ZUNvbnRhaW5lciIsImRpc3BsYXkiLCJyZXNpemVXcmFwcGVyIiwiY3JlYXRlSGFuZGxlIiwicmVzaXplSGFuZGxlIiwicG9zaXRpb25IYW5kbGUiLCJpc1RvcCIsImlzQm90dG9tIiwiaXNMZWZ0IiwiaXNSaWdodCIsIkhUTUxFbGVtZW50IiwiaGFuZGxlUmVzaXplU3RhcnQiLCJjbGVhciIsInByZXZlbnREZWZhdWx0Iiwic3RvcFByb3BhZ2F0aW9uIiwiYWRkIiwic2hvdWxkUHJlc2VydmVBc3BlY3RSYXRpbyIsImNhbGN1bGF0ZU5ld0RpbWVuc2lvbnMiLCJjb25zdHJhaW5lZCIsImFwcGx5Q29uc3RyYWludHMiLCJuZXdXaWR0aCIsIm5ld0hlaWdodCIsImFwcGx5QXNwZWN0UmF0aW8iLCJjb25zdHJhaW5lZFdpZHRoMiIsImNvbnN0cmFpbmVkSGVpZ2h0MiIsImNvbnN0cmFpbmVkV2lkdGgiLCJjb25zdHJhaW5lZEhlaWdodCIsImlzSG9yaXpvbnRhbCIsImlzVmVydGljYWwiLCJSZXNpemFibGVOb2RldmlldyIsIk5vZGVTZWxlY3Rpb240IiwiY2FuSW5zZXJ0Tm9kZSIsIm1hdGNoVHlwZSIsImVzY2FwZUZvclJlZ0V4Iiwic3RyaW5nIiwiaXNTdHJpbmciLCJtYXJrZG93bl9leHBvcnRzIiwiY3JlYXRlQXRvbUJsb2NrTWFya2Rvd25TcGVjIiwiY3JlYXRlQmxvY2tNYXJrZG93blNwZWMiLCJjcmVhdGVJbmxpbmVNYXJrZG93blNwZWMiLCJwYXJzZUF0dHJpYnV0ZXMiLCJwYXJzZUluZGVudGVkQmxvY2tzIiwicmVuZGVyTmVzdGVkTWFya2Rvd25Db250ZW50Iiwic2VyaWFsaXplQXR0cmlidXRlcyIsImF0dHJTdHJpbmciLCJxdW90ZWRTdHJpbmdzIiwidGVtcFN0cmluZyIsImNsYXNzTWF0Y2hlcyIsImNsYXNzZXMiLCJjbGFzcyIsImlkTWF0Y2giLCJpZCIsImt2UmVnZXgiLCJrdk1hdGNoZXMiLCJxdW90ZWRSZWYiLCJxdW90ZWRJbmRleCIsInBhcnNlSW50IiwicXVvdGVkVmFsdWUiLCJjbGVhblN0cmluZyIsImJvb2xlYW5BdHRycyIsImF0dHIiLCJjbHMiLCJub2RlTmFtZSIsIm1hcmtkb3duTmFtZSIsInBhcnNlQXR0cmlidXRlczIiLCJzZXJpYWxpemVBdHRyaWJ1dGVzMiIsImRlZmF1bHRBdHRyaWJ1dGVzIiwicmVxdWlyZWRBdHRyaWJ1dGVzIiwiYWxsb3dlZEF0dHJpYnV0ZXMiLCJibG9ja05hbWUiLCJmaWx0ZXJBdHRyaWJ1dGVzIiwicGFyc2VNYXJrZG93biIsInRva2VuIiwiaDIiLCJjcmVhdGVOb2RlIiwibWFya2Rvd25Ub2tlbml6ZXIiLCJsZXZlbCIsInNyYyIsInJlZ2V4IiwiUmVnRXhwIiwidG9rZW5pemUiLCJfdG9rZW5zIiwiX2xleGVyIiwibWlzc2luZ1JlcXVpcmVkIiwicmVxdWlyZWQiLCJyYXciLCJyZW5kZXJNYXJrZG93biIsImZpbHRlcmVkQXR0cnMiLCJnZXRDb250ZW50Iiwibm9kZUNvbnRlbnQiLCJjb250ZW50UmVzdWx0IiwicGFyc2VDaGlsZHJlbiIsInRva2VucyIsInBhcnNlSW5saW5lIiwibGV4ZXIiLCJvcGVuaW5nUmVnZXgiLCJvcGVuaW5nTWF0Y2giLCJvcGVuaW5nVGFnIiwibWF0Y2hlZENvbnRlbnQiLCJibG9ja1BhdHRlcm4iLCJyZW1haW5pbmciLCJsYXN0SW5kZXgiLCJtYXRjaFBvcyIsImJsb2NrVHlwZSIsImVuZHNXaXRoIiwicmF3Q29udGVudCIsImNvbnRlbnRUb2tlbnMiLCJibG9ja1Rva2VucyIsImlubGluZVRva2VucyIsImxhc3RUb2tlbiIsInBvcCIsInJlbmRlcmVkQ29udGVudCIsInJlbmRlckNoaWxkcmVuIiwicGFyc2VTaG9ydGNvZGVBdHRyaWJ1dGVzIiwiZG91YmxlUXVvdGVkIiwic2luZ2xlUXVvdGVkIiwic2VyaWFsaXplU2hvcnRjb2RlQXR0cmlidXRlcyIsInNob3J0Y29kZU5hbWUiLCJzZWxmQ2xvc2luZyIsInNob3J0Y29kZSIsImF0dHJOYW1lIiwic2tpcElmRGVmYXVsdCIsImVzY2FwZWRTaG9ydGNvZGUiLCJjcmVhdGVUZXh0Tm9kZSIsInN0YXJ0UGF0dGVybiIsInRva2VuUGF0dGVybiIsImxpbmVzIiwidG90YWxSYXciLCJiYXNlSW5kZW50U2l6ZSIsImN1cnJlbnRMaW5lIiwiaXRlbU1hdGNoIiwiaXRlbVBhdHRlcm4iLCJpdGVtRGF0YSIsImV4dHJhY3RJdGVtRGF0YSIsImluZGVudExldmVsIiwibWFpbkNvbnRlbnQiLCJpdGVtQ29udGVudCIsIm5leHRMaW5lIiwibmV4dE5vbkVtcHR5SW5kZXgiLCJmaW5kSW5kZXgiLCJsIiwibmV4dE5vbkVtcHR5IiwibmV4dEluZGVudDIiLCJuZXh0SW5kZW50IiwibmVzdGVkVG9rZW5zIiwibmVzdGVkQ29udGVudCIsImRlZGVudGVkTmVzdGVkIiwibmVzdGVkTGluZSIsImN1c3RvbU5lc3RlZFBhcnNlciIsImNyZWF0ZVRva2VuIiwicHJlZml4T3JHZW5lcmF0b3IiLCJjdHgiLCJwcmVmaXgiLCJjaGlsZENvbnRlbnQiLCJpbmRlbnRlZENoaWxkIiwibGluZSIsImluZGVudCIsImNoZWNrTWFyayIsInRoaXNNYXJrIiwiZm91bmRNYXJrIiwibmVlZHNVcGRhdGUiLCJ1cGRhdGVkTWFyayIsIk1hcmtWaWV3IiwiY29tcG9uZW50IiwiaWdub3JlTXV0YXRpb24iLCJtdXRhdGlvbiIsImNoYW5nZWROb2RlcyIsImFkZGVkTm9kZXMiLCJyZW1vdmVkTm9kZXMiLCJpc0NvbnRlbnRFZGl0YWJsZSIsIk5vZGUzIiwiX05vZGUiLCJOb2RlU2VsZWN0aW9uNSIsIk5vZGVWaWV3IiwiaXNEcmFnZ2luZyIsInN0b3BFdmVudCIsIm9uRHJhZ1N0YXJ0IiwiX2ciLCJkcmFnSGFuZGxlIiwiZG9tQm94IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiaGFuZGxlQm94Iiwib2Zmc2V0WCIsIm5hdGl2ZUV2ZW50Iiwib2Zmc2V0WSIsImNsb25lZE5vZGUiLCJjbG9uZU5vZGUiLCJyb3VuZCIsImJveFNpemluZyIsInBvaW50ZXJFdmVudHMiLCJkcmFnSW1hZ2VXcmFwcGVyIiwiZGF0YVRyYW5zZmVyIiwic2V0RHJhZ0ltYWdlIiwiaXNJbkVsZW1lbnQiLCJpc0RyYWdFdmVudCIsImlzRHJvcEV2ZW50IiwiaXNJbnB1dCIsInRhZ05hbWUiLCJpc0RyYWdnYWJsZSIsImlzU2VsZWN0YWJsZSIsImlzQ29weUV2ZW50IiwiaXNQYXN0ZUV2ZW50IiwiaXNDdXRFdmVudCIsImlzQ2xpY2tFdmVudCIsImlzVmFsaWREcmFnSGFuZGxlIiwibWFya1Bhc3RlUnVsZSIsIm5vZGVQYXN0ZVJ1bGUiLCJ0ZXh0UGFzdGVSdWxlIiwiVHJhY2tlciIsImN1cnJlbnRTdGVwIiwiZGVsZXRlZCIsIm1hcHBlZFBvc2l0aW9uIiwibmV3UG9zaXRpb24iLCJnZXRNYXAiLCJtYXJrZG93biJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/core/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/core/dist/jsx-runtime/jsx-runtime.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@tiptap/core/dist/jsx-runtime/jsx-runtime.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Fragment: () => (/* binding */ Fragment),\n/* harmony export */   createElement: () => (/* binding */ h),\n/* harmony export */   h: () => (/* binding */ h),\n/* harmony export */   jsx: () => (/* binding */ h),\n/* harmony export */   jsxDEV: () => (/* binding */ h),\n/* harmony export */   jsxs: () => (/* binding */ h)\n/* harmony export */ });\n// src/jsx-runtime.ts\nfunction Fragment(props) {\n    return props.children;\n}\nvar h = (tag, attributes)=>{\n    if (tag === \"slot\") {\n        return 0;\n    }\n    if (tag instanceof Function) {\n        return tag(attributes);\n    }\n    const { children, ...rest } = attributes != null ? attributes : {};\n    if (tag === \"svg\") {\n        throw new Error(\"SVG elements are not supported in the JSX syntax, use the array syntax instead\");\n    }\n    return [\n        tag,\n        rest,\n        children\n    ];\n};\n //# sourceMappingURL=jsx-runtime.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL2Rpc3QvanN4LXJ1bnRpbWUvanN4LXJ1bnRpbWUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEscUJBQXFCO0FBQ3JCLFNBQVNBLFNBQVNDLEtBQUs7SUFDckIsT0FBT0EsTUFBTUMsUUFBUTtBQUN2QjtBQUNBLElBQUlDLElBQUksQ0FBQ0MsS0FBS0M7SUFDWixJQUFJRCxRQUFRLFFBQVE7UUFDbEIsT0FBTztJQUNUO0lBQ0EsSUFBSUEsZUFBZUUsVUFBVTtRQUMzQixPQUFPRixJQUFJQztJQUNiO0lBQ0EsTUFBTSxFQUFFSCxRQUFRLEVBQUUsR0FBR0ssTUFBTSxHQUFHRixjQUFjLE9BQU9BLGFBQWEsQ0FBQztJQUNqRSxJQUFJRCxRQUFRLE9BQU87UUFDakIsTUFBTSxJQUFJSSxNQUFNO0lBQ2xCO0lBQ0EsT0FBTztRQUFDSjtRQUFLRztRQUFNTDtLQUFTO0FBQzlCO0FBUUUsQ0FDRix1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcmFzb2JwYWktd2ViLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9kaXN0L2pzeC1ydW50aW1lL2pzeC1ydW50aW1lLmpzPzIyNmQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2pzeC1ydW50aW1lLnRzXG5mdW5jdGlvbiBGcmFnbWVudChwcm9wcykge1xuICByZXR1cm4gcHJvcHMuY2hpbGRyZW47XG59XG52YXIgaCA9ICh0YWcsIGF0dHJpYnV0ZXMpID0+IHtcbiAgaWYgKHRhZyA9PT0gXCJzbG90XCIpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBpZiAodGFnIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICByZXR1cm4gdGFnKGF0dHJpYnV0ZXMpO1xuICB9XG4gIGNvbnN0IHsgY2hpbGRyZW4sIC4uLnJlc3QgfSA9IGF0dHJpYnV0ZXMgIT0gbnVsbCA/IGF0dHJpYnV0ZXMgOiB7fTtcbiAgaWYgKHRhZyA9PT0gXCJzdmdcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlNWRyBlbGVtZW50cyBhcmUgbm90IHN1cHBvcnRlZCBpbiB0aGUgSlNYIHN5bnRheCwgdXNlIHRoZSBhcnJheSBzeW50YXggaW5zdGVhZFwiKTtcbiAgfVxuICByZXR1cm4gW3RhZywgcmVzdCwgY2hpbGRyZW5dO1xufTtcbmV4cG9ydCB7XG4gIEZyYWdtZW50LFxuICBoIGFzIGNyZWF0ZUVsZW1lbnQsXG4gIGgsXG4gIGggYXMganN4LFxuICBoIGFzIGpzeERFVixcbiAgaCBhcyBqc3hzXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9anN4LXJ1bnRpbWUuanMubWFwIl0sIm5hbWVzIjpbIkZyYWdtZW50IiwicHJvcHMiLCJjaGlsZHJlbiIsImgiLCJ0YWciLCJhdHRyaWJ1dGVzIiwiRnVuY3Rpb24iLCJyZXN0IiwiRXJyb3IiLCJjcmVhdGVFbGVtZW50IiwianN4IiwianN4REVWIiwianN4cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/core/dist/jsx-runtime/jsx-runtime.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-blockquote/dist/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-blockquote/dist/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Blockquote: () => (/* binding */ Blockquote),\n/* harmony export */   \"default\": () => (/* binding */ index_default),\n/* harmony export */   inputRegex: () => (/* binding */ inputRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_core_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/core/jsx-runtime */ \"(ssr)/./node_modules/@tiptap/core/dist/jsx-runtime/jsx-runtime.js\");\n// src/blockquote.tsx\n\n\nvar inputRegex = /^\\s*>\\s$/;\nvar Blockquote = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n    name: \"blockquote\",\n    addOptions () {\n        return {\n            HTMLAttributes: {}\n        };\n    },\n    content: \"block+\",\n    group: \"block\",\n    defining: true,\n    parseHTML () {\n        return [\n            {\n                tag: \"blockquote\"\n            }\n        ];\n    },\n    renderHTML ({ HTMLAttributes }) {\n        return /* @__PURE__ */ (0,_tiptap_core_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"blockquote\", {\n            ...(0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes),\n            children: /* @__PURE__ */ (0,_tiptap_core_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"slot\", {})\n        });\n    },\n    parseMarkdown: (token, helpers)=>{\n        return helpers.createNode(\"blockquote\", void 0, helpers.parseChildren(token.tokens || []));\n    },\n    renderMarkdown: (node, h)=>{\n        if (!node.content) {\n            return \"\";\n        }\n        const prefix = \">\";\n        const result = [];\n        node.content.forEach((child)=>{\n            const childContent = h.renderChildren([\n                child\n            ]);\n            const lines = childContent.split(\"\\n\");\n            const linesWithPrefix = lines.map((line)=>{\n                if (line.trim() === \"\") {\n                    return prefix;\n                }\n                return `${prefix} ${line}`;\n            });\n            result.push(linesWithPrefix.join(\"\\n\"));\n        });\n        return result.join(`\n${prefix}\n`);\n    },\n    addCommands () {\n        return {\n            setBlockquote: ()=>({ commands })=>{\n                    return commands.wrapIn(this.name);\n                },\n            toggleBlockquote: ()=>({ commands })=>{\n                    return commands.toggleWrap(this.name);\n                },\n            unsetBlockquote: ()=>({ commands })=>{\n                    return commands.lift(this.name);\n                }\n        };\n    },\n    addKeyboardShortcuts () {\n        return {\n            \"Mod-Shift-b\": ()=>this.editor.commands.toggleBlockquote()\n        };\n    },\n    addInputRules () {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.wrappingInputRule)({\n                find: inputRegex,\n                type: this.type\n            })\n        ];\n    }\n});\n// src/index.ts\nvar index_default = Blockquote;\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tYmxvY2txdW90ZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUEscUJBQXFCO0FBQ21EO0FBQ3pCO0FBQy9DLElBQUlJLGFBQWE7QUFDakIsSUFBSUMsYUFBYUosOENBQUlBLENBQUNLLE1BQU0sQ0FBQztJQUMzQkMsTUFBTTtJQUNOQztRQUNFLE9BQU87WUFDTEMsZ0JBQWdCLENBQUM7UUFDbkI7SUFDRjtJQUNBQyxTQUFTO0lBQ1RDLE9BQU87SUFDUEMsVUFBVTtJQUNWQztRQUNFLE9BQU87WUFBQztnQkFBRUMsS0FBSztZQUFhO1NBQUU7SUFDaEM7SUFDQUMsWUFBVyxFQUFFTixjQUFjLEVBQUU7UUFDM0IsT0FBTyxhQUFhLEdBQUdOLDZEQUFHQSxDQUFDLGNBQWM7WUFBRSxHQUFHSCw2REFBZUEsQ0FBQyxJQUFJLENBQUNnQixPQUFPLENBQUNQLGNBQWMsRUFBRUEsZUFBZTtZQUFFUSxVQUFVLGFBQWEsR0FBR2QsNkRBQUdBLENBQUMsUUFBUSxDQUFDO1FBQUc7SUFDeEo7SUFDQWUsZUFBZSxDQUFDQyxPQUFPQztRQUNyQixPQUFPQSxRQUFRQyxVQUFVLENBQUMsY0FBYyxLQUFLLEdBQUdELFFBQVFFLGFBQWEsQ0FBQ0gsTUFBTUksTUFBTSxJQUFJLEVBQUU7SUFDMUY7SUFDQUMsZ0JBQWdCLENBQUNDLE1BQU1DO1FBQ3JCLElBQUksQ0FBQ0QsS0FBS2YsT0FBTyxFQUFFO1lBQ2pCLE9BQU87UUFDVDtRQUNBLE1BQU1pQixTQUFTO1FBQ2YsTUFBTUMsU0FBUyxFQUFFO1FBQ2pCSCxLQUFLZixPQUFPLENBQUNtQixPQUFPLENBQUMsQ0FBQ0M7WUFDcEIsTUFBTUMsZUFBZUwsRUFBRU0sY0FBYyxDQUFDO2dCQUFDRjthQUFNO1lBQzdDLE1BQU1HLFFBQVFGLGFBQWFHLEtBQUssQ0FBQztZQUNqQyxNQUFNQyxrQkFBa0JGLE1BQU1HLEdBQUcsQ0FBQyxDQUFDQztnQkFDakMsSUFBSUEsS0FBS0MsSUFBSSxPQUFPLElBQUk7b0JBQ3RCLE9BQU9YO2dCQUNUO2dCQUNBLE9BQU8sQ0FBQyxFQUFFQSxPQUFPLENBQUMsRUFBRVUsS0FBSyxDQUFDO1lBQzVCO1lBQ0FULE9BQU9XLElBQUksQ0FBQ0osZ0JBQWdCSyxJQUFJLENBQUM7UUFDbkM7UUFDQSxPQUFPWixPQUFPWSxJQUFJLENBQUMsQ0FBQztBQUN4QixFQUFFYixPQUFPO0FBQ1QsQ0FBQztJQUNDO0lBQ0FjO1FBQ0UsT0FBTztZQUNMQyxlQUFlLElBQU0sQ0FBQyxFQUFFQyxRQUFRLEVBQUU7b0JBQ2hDLE9BQU9BLFNBQVNDLE1BQU0sQ0FBQyxJQUFJLENBQUNyQyxJQUFJO2dCQUNsQztZQUNBc0Msa0JBQWtCLElBQU0sQ0FBQyxFQUFFRixRQUFRLEVBQUU7b0JBQ25DLE9BQU9BLFNBQVNHLFVBQVUsQ0FBQyxJQUFJLENBQUN2QyxJQUFJO2dCQUN0QztZQUNBd0MsaUJBQWlCLElBQU0sQ0FBQyxFQUFFSixRQUFRLEVBQUU7b0JBQ2xDLE9BQU9BLFNBQVNLLElBQUksQ0FBQyxJQUFJLENBQUN6QyxJQUFJO2dCQUNoQztRQUNGO0lBQ0Y7SUFDQTBDO1FBQ0UsT0FBTztZQUNMLGVBQWUsSUFBTSxJQUFJLENBQUNDLE1BQU0sQ0FBQ1AsUUFBUSxDQUFDRSxnQkFBZ0I7UUFDNUQ7SUFDRjtJQUNBTTtRQUNFLE9BQU87WUFDTGpELCtEQUFpQkEsQ0FBQztnQkFDaEJrRCxNQUFNaEQ7Z0JBQ05pRCxNQUFNLElBQUksQ0FBQ0EsSUFBSTtZQUNqQjtTQUNEO0lBQ0g7QUFDRjtBQUVBLGVBQWU7QUFDZixJQUFJQyxnQkFBZ0JqRDtBQUtsQixDQUNGLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3ByYXNvYnBhaS13ZWIvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tYmxvY2txdW90ZS9kaXN0L2luZGV4LmpzP2UxYTIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2Jsb2NrcXVvdGUudHN4XG5pbXBvcnQgeyBtZXJnZUF0dHJpYnV0ZXMsIE5vZGUsIHdyYXBwaW5nSW5wdXRSdWxlIH0gZnJvbSBcIkB0aXB0YXAvY29yZVwiO1xuaW1wb3J0IHsganN4IH0gZnJvbSBcIkB0aXB0YXAvY29yZS9qc3gtcnVudGltZVwiO1xudmFyIGlucHV0UmVnZXggPSAvXlxccyo+XFxzJC87XG52YXIgQmxvY2txdW90ZSA9IE5vZGUuY3JlYXRlKHtcbiAgbmFtZTogXCJibG9ja3F1b3RlXCIsXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fVxuICAgIH07XG4gIH0sXG4gIGNvbnRlbnQ6IFwiYmxvY2srXCIsXG4gIGdyb3VwOiBcImJsb2NrXCIsXG4gIGRlZmluaW5nOiB0cnVlLFxuICBwYXJzZUhUTUwoKSB7XG4gICAgcmV0dXJuIFt7IHRhZzogXCJibG9ja3F1b3RlXCIgfV07XG4gIH0sXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goXCJibG9ja3F1b3RlXCIsIHsgLi4ubWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChcInNsb3RcIiwge30pIH0pO1xuICB9LFxuICBwYXJzZU1hcmtkb3duOiAodG9rZW4sIGhlbHBlcnMpID0+IHtcbiAgICByZXR1cm4gaGVscGVycy5jcmVhdGVOb2RlKFwiYmxvY2txdW90ZVwiLCB2b2lkIDAsIGhlbHBlcnMucGFyc2VDaGlsZHJlbih0b2tlbi50b2tlbnMgfHwgW10pKTtcbiAgfSxcbiAgcmVuZGVyTWFya2Rvd246IChub2RlLCBoKSA9PiB7XG4gICAgaWYgKCFub2RlLmNvbnRlbnQpIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICBjb25zdCBwcmVmaXggPSBcIj5cIjtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBub2RlLmNvbnRlbnQuZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICAgIGNvbnN0IGNoaWxkQ29udGVudCA9IGgucmVuZGVyQ2hpbGRyZW4oW2NoaWxkXSk7XG4gICAgICBjb25zdCBsaW5lcyA9IGNoaWxkQ29udGVudC5zcGxpdChcIlxcblwiKTtcbiAgICAgIGNvbnN0IGxpbmVzV2l0aFByZWZpeCA9IGxpbmVzLm1hcCgobGluZSkgPT4ge1xuICAgICAgICBpZiAobGluZS50cmltKCkgPT09IFwiXCIpIHtcbiAgICAgICAgICByZXR1cm4gcHJlZml4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHtwcmVmaXh9ICR7bGluZX1gO1xuICAgICAgfSk7XG4gICAgICByZXN1bHQucHVzaChsaW5lc1dpdGhQcmVmaXguam9pbihcIlxcblwiKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdC5qb2luKGBcbiR7cHJlZml4fVxuYCk7XG4gIH0sXG4gIGFkZENvbW1hbmRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzZXRCbG9ja3F1b3RlOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy53cmFwSW4odGhpcy5uYW1lKTtcbiAgICAgIH0sXG4gICAgICB0b2dnbGVCbG9ja3F1b3RlOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy50b2dnbGVXcmFwKHRoaXMubmFtZSk7XG4gICAgICB9LFxuICAgICAgdW5zZXRCbG9ja3F1b3RlOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy5saWZ0KHRoaXMubmFtZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFwiTW9kLVNoaWZ0LWJcIjogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlQmxvY2txdW90ZSgpXG4gICAgfTtcbiAgfSxcbiAgYWRkSW5wdXRSdWxlcygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgd3JhcHBpbmdJbnB1dFJ1bGUoe1xuICAgICAgICBmaW5kOiBpbnB1dFJlZ2V4LFxuICAgICAgICB0eXBlOiB0aGlzLnR5cGVcbiAgICAgIH0pXG4gICAgXTtcbiAgfVxufSk7XG5cbi8vIHNyYy9pbmRleC50c1xudmFyIGluZGV4X2RlZmF1bHQgPSBCbG9ja3F1b3RlO1xuZXhwb3J0IHtcbiAgQmxvY2txdW90ZSxcbiAgaW5kZXhfZGVmYXVsdCBhcyBkZWZhdWx0LFxuICBpbnB1dFJlZ2V4XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIm1lcmdlQXR0cmlidXRlcyIsIk5vZGUiLCJ3cmFwcGluZ0lucHV0UnVsZSIsImpzeCIsImlucHV0UmVnZXgiLCJCbG9ja3F1b3RlIiwiY3JlYXRlIiwibmFtZSIsImFkZE9wdGlvbnMiLCJIVE1MQXR0cmlidXRlcyIsImNvbnRlbnQiLCJncm91cCIsImRlZmluaW5nIiwicGFyc2VIVE1MIiwidGFnIiwicmVuZGVySFRNTCIsIm9wdGlvbnMiLCJjaGlsZHJlbiIsInBhcnNlTWFya2Rvd24iLCJ0b2tlbiIsImhlbHBlcnMiLCJjcmVhdGVOb2RlIiwicGFyc2VDaGlsZHJlbiIsInRva2VucyIsInJlbmRlck1hcmtkb3duIiwibm9kZSIsImgiLCJwcmVmaXgiLCJyZXN1bHQiLCJmb3JFYWNoIiwiY2hpbGQiLCJjaGlsZENvbnRlbnQiLCJyZW5kZXJDaGlsZHJlbiIsImxpbmVzIiwic3BsaXQiLCJsaW5lc1dpdGhQcmVmaXgiLCJtYXAiLCJsaW5lIiwidHJpbSIsInB1c2giLCJqb2luIiwiYWRkQ29tbWFuZHMiLCJzZXRCbG9ja3F1b3RlIiwiY29tbWFuZHMiLCJ3cmFwSW4iLCJ0b2dnbGVCbG9ja3F1b3RlIiwidG9nZ2xlV3JhcCIsInVuc2V0QmxvY2txdW90ZSIsImxpZnQiLCJhZGRLZXlib2FyZFNob3J0Y3V0cyIsImVkaXRvciIsImFkZElucHV0UnVsZXMiLCJmaW5kIiwidHlwZSIsImluZGV4X2RlZmF1bHQiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-blockquote/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-bold/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@tiptap/extension-bold/dist/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Bold: () => (/* binding */ Bold),\n/* harmony export */   \"default\": () => (/* binding */ index_default),\n/* harmony export */   starInputRegex: () => (/* binding */ starInputRegex),\n/* harmony export */   starPasteRegex: () => (/* binding */ starPasteRegex),\n/* harmony export */   underscoreInputRegex: () => (/* binding */ underscoreInputRegex),\n/* harmony export */   underscorePasteRegex: () => (/* binding */ underscorePasteRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_core_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/core/jsx-runtime */ \"(ssr)/./node_modules/@tiptap/core/dist/jsx-runtime/jsx-runtime.js\");\n// src/bold.tsx\n\n\nvar starInputRegex = /(?:^|\\s)(\\*\\*(?!\\s+\\*\\*)((?:[^*]+))\\*\\*(?!\\s+\\*\\*))$/;\nvar starPasteRegex = /(?:^|\\s)(\\*\\*(?!\\s+\\*\\*)((?:[^*]+))\\*\\*(?!\\s+\\*\\*))/g;\nvar underscoreInputRegex = /(?:^|\\s)(__(?!\\s+__)((?:[^_]+))__(?!\\s+__))$/;\nvar underscorePasteRegex = /(?:^|\\s)(__(?!\\s+__)((?:[^_]+))__(?!\\s+__))/g;\nvar Bold = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Mark.create({\n    name: \"bold\",\n    addOptions () {\n        return {\n            HTMLAttributes: {}\n        };\n    },\n    parseHTML () {\n        return [\n            {\n                tag: \"strong\"\n            },\n            {\n                tag: \"b\",\n                getAttrs: (node)=>node.style.fontWeight !== \"normal\" && null\n            },\n            {\n                style: \"font-weight=400\",\n                clearMark: (mark)=>mark.type.name === this.name\n            },\n            {\n                style: \"font-weight\",\n                getAttrs: (value)=>/^(bold(er)?|[5-9]\\d{2,})$/.test(value) && null\n            }\n        ];\n    },\n    renderHTML ({ HTMLAttributes }) {\n        return /* @__PURE__ */ (0,_tiptap_core_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"strong\", {\n            ...(0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes),\n            children: /* @__PURE__ */ (0,_tiptap_core_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"slot\", {})\n        });\n    },\n    markdownTokenName: \"strong\",\n    parseMarkdown: (token, helpers)=>{\n        return helpers.applyMark(\"bold\", helpers.parseInline(token.tokens || []));\n    },\n    renderMarkdown: (node, h)=>{\n        return `**${h.renderChildren(node)}**`;\n    },\n    addCommands () {\n        return {\n            setBold: ()=>({ commands })=>{\n                    return commands.setMark(this.name);\n                },\n            toggleBold: ()=>({ commands })=>{\n                    return commands.toggleMark(this.name);\n                },\n            unsetBold: ()=>({ commands })=>{\n                    return commands.unsetMark(this.name);\n                }\n        };\n    },\n    addKeyboardShortcuts () {\n        return {\n            \"Mod-b\": ()=>this.editor.commands.toggleBold(),\n            \"Mod-B\": ()=>this.editor.commands.toggleBold()\n        };\n    },\n    addInputRules () {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({\n                find: starInputRegex,\n                type: this.type\n            }),\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({\n                find: underscoreInputRegex,\n                type: this.type\n            })\n        ];\n    },\n    addPasteRules () {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({\n                find: starPasteRegex,\n                type: this.type\n            }),\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({\n                find: underscorePasteRegex,\n                type: this.type\n            })\n        ];\n    }\n});\n// src/index.ts\nvar index_default = Bold;\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tYm9sZC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUEsZUFBZTtBQUNvRTtBQUNwQztBQUMvQyxJQUFJSyxpQkFBaUI7QUFDckIsSUFBSUMsaUJBQWlCO0FBQ3JCLElBQUlDLHVCQUF1QjtBQUMzQixJQUFJQyx1QkFBdUI7QUFDM0IsSUFBSUMsT0FBT1QsOENBQUlBLENBQUNVLE1BQU0sQ0FBQztJQUNyQkMsTUFBTTtJQUNOQztRQUNFLE9BQU87WUFDTEMsZ0JBQWdCLENBQUM7UUFDbkI7SUFDRjtJQUNBQztRQUNFLE9BQU87WUFDTDtnQkFDRUMsS0FBSztZQUNQO1lBQ0E7Z0JBQ0VBLEtBQUs7Z0JBQ0xDLFVBQVUsQ0FBQ0MsT0FBU0EsS0FBS0MsS0FBSyxDQUFDQyxVQUFVLEtBQUssWUFBWTtZQUM1RDtZQUNBO2dCQUNFRCxPQUFPO2dCQUNQRSxXQUFXLENBQUNDLE9BQVNBLEtBQUtDLElBQUksQ0FBQ1gsSUFBSSxLQUFLLElBQUksQ0FBQ0EsSUFBSTtZQUNuRDtZQUNBO2dCQUNFTyxPQUFPO2dCQUNQRixVQUFVLENBQUNPLFFBQVUsNEJBQTRCQyxJQUFJLENBQUNELFVBQVU7WUFDbEU7U0FDRDtJQUNIO0lBQ0FFLFlBQVcsRUFBRVosY0FBYyxFQUFFO1FBQzNCLE9BQU8sYUFBYSxHQUFHVCw2REFBR0EsQ0FBQyxVQUFVO1lBQUUsR0FBR0QsNkRBQWVBLENBQUMsSUFBSSxDQUFDdUIsT0FBTyxDQUFDYixjQUFjLEVBQUVBLGVBQWU7WUFBRWMsVUFBVSxhQUFhLEdBQUd2Qiw2REFBR0EsQ0FBQyxRQUFRLENBQUM7UUFBRztJQUNwSjtJQUNBd0IsbUJBQW1CO0lBQ25CQyxlQUFlLENBQUNDLE9BQU9DO1FBQ3JCLE9BQU9BLFFBQVFDLFNBQVMsQ0FBQyxRQUFRRCxRQUFRRSxXQUFXLENBQUNILE1BQU1JLE1BQU0sSUFBSSxFQUFFO0lBQ3pFO0lBQ0FDLGdCQUFnQixDQUFDbEIsTUFBTW1CO1FBQ3JCLE9BQU8sQ0FBQyxFQUFFLEVBQUVBLEVBQUVDLGNBQWMsQ0FBQ3BCLE1BQU0sRUFBRSxDQUFDO0lBQ3hDO0lBQ0FxQjtRQUNFLE9BQU87WUFDTEMsU0FBUyxJQUFNLENBQUMsRUFBRUMsUUFBUSxFQUFFO29CQUMxQixPQUFPQSxTQUFTQyxPQUFPLENBQUMsSUFBSSxDQUFDOUIsSUFBSTtnQkFDbkM7WUFDQStCLFlBQVksSUFBTSxDQUFDLEVBQUVGLFFBQVEsRUFBRTtvQkFDN0IsT0FBT0EsU0FBU0csVUFBVSxDQUFDLElBQUksQ0FBQ2hDLElBQUk7Z0JBQ3RDO1lBQ0FpQyxXQUFXLElBQU0sQ0FBQyxFQUFFSixRQUFRLEVBQUU7b0JBQzVCLE9BQU9BLFNBQVNLLFNBQVMsQ0FBQyxJQUFJLENBQUNsQyxJQUFJO2dCQUNyQztRQUNGO0lBQ0Y7SUFDQW1DO1FBQ0UsT0FBTztZQUNMLFNBQVMsSUFBTSxJQUFJLENBQUNDLE1BQU0sQ0FBQ1AsUUFBUSxDQUFDRSxVQUFVO1lBQzlDLFNBQVMsSUFBTSxJQUFJLENBQUNLLE1BQU0sQ0FBQ1AsUUFBUSxDQUFDRSxVQUFVO1FBQ2hEO0lBQ0Y7SUFDQU07UUFDRSxPQUFPO1lBQ0wvQywyREFBYUEsQ0FBQztnQkFDWmdELE1BQU01QztnQkFDTmlCLE1BQU0sSUFBSSxDQUFDQSxJQUFJO1lBQ2pCO1lBQ0FyQiwyREFBYUEsQ0FBQztnQkFDWmdELE1BQU0xQztnQkFDTmUsTUFBTSxJQUFJLENBQUNBLElBQUk7WUFDakI7U0FDRDtJQUNIO0lBQ0E0QjtRQUNFLE9BQU87WUFDTGhELDJEQUFhQSxDQUFDO2dCQUNaK0MsTUFBTTNDO2dCQUNOZ0IsTUFBTSxJQUFJLENBQUNBLElBQUk7WUFDakI7WUFDQXBCLDJEQUFhQSxDQUFDO2dCQUNaK0MsTUFBTXpDO2dCQUNOYyxNQUFNLElBQUksQ0FBQ0EsSUFBSTtZQUNqQjtTQUNEO0lBQ0g7QUFDRjtBQUVBLGVBQWU7QUFDZixJQUFJNkIsZ0JBQWdCMUM7QUFRbEIsQ0FDRixpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcmFzb2JwYWktd2ViLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWJvbGQvZGlzdC9pbmRleC5qcz9kZjY1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9ib2xkLnRzeFxuaW1wb3J0IHsgTWFyaywgbWFya0lucHV0UnVsZSwgbWFya1Bhc3RlUnVsZSwgbWVyZ2VBdHRyaWJ1dGVzIH0gZnJvbSBcIkB0aXB0YXAvY29yZVwiO1xuaW1wb3J0IHsganN4IH0gZnJvbSBcIkB0aXB0YXAvY29yZS9qc3gtcnVudGltZVwiO1xudmFyIHN0YXJJbnB1dFJlZ2V4ID0gLyg/Ol58XFxzKShcXCpcXCooPyFcXHMrXFwqXFwqKSgoPzpbXipdKykpXFwqXFwqKD8hXFxzK1xcKlxcKikpJC87XG52YXIgc3RhclBhc3RlUmVnZXggPSAvKD86XnxcXHMpKFxcKlxcKig/IVxccytcXCpcXCopKCg/OlteKl0rKSlcXCpcXCooPyFcXHMrXFwqXFwqKSkvZztcbnZhciB1bmRlcnNjb3JlSW5wdXRSZWdleCA9IC8oPzpefFxccykoX18oPyFcXHMrX18pKCg/OlteX10rKSlfXyg/IVxccytfXykpJC87XG52YXIgdW5kZXJzY29yZVBhc3RlUmVnZXggPSAvKD86XnxcXHMpKF9fKD8hXFxzK19fKSgoPzpbXl9dKykpX18oPyFcXHMrX18pKS9nO1xudmFyIEJvbGQgPSBNYXJrLmNyZWF0ZSh7XG4gIG5hbWU6IFwiYm9sZFwiLFxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBIVE1MQXR0cmlidXRlczoge31cbiAgICB9O1xuICB9LFxuICBwYXJzZUhUTUwoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgdGFnOiBcInN0cm9uZ1wiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB0YWc6IFwiYlwiLFxuICAgICAgICBnZXRBdHRyczogKG5vZGUpID0+IG5vZGUuc3R5bGUuZm9udFdlaWdodCAhPT0gXCJub3JtYWxcIiAmJiBudWxsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzdHlsZTogXCJmb250LXdlaWdodD00MDBcIixcbiAgICAgICAgY2xlYXJNYXJrOiAobWFyaykgPT4gbWFyay50eXBlLm5hbWUgPT09IHRoaXMubmFtZVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgc3R5bGU6IFwiZm9udC13ZWlnaHRcIixcbiAgICAgICAgZ2V0QXR0cnM6ICh2YWx1ZSkgPT4gL14oYm9sZChlcik/fFs1LTldXFxkezIsfSkkLy50ZXN0KHZhbHVlKSAmJiBudWxsXG4gICAgICB9XG4gICAgXTtcbiAgfSxcbiAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChcInN0cm9uZ1wiLCB7IC4uLm1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJzbG90XCIsIHt9KSB9KTtcbiAgfSxcbiAgbWFya2Rvd25Ub2tlbk5hbWU6IFwic3Ryb25nXCIsXG4gIHBhcnNlTWFya2Rvd246ICh0b2tlbiwgaGVscGVycykgPT4ge1xuICAgIHJldHVybiBoZWxwZXJzLmFwcGx5TWFyayhcImJvbGRcIiwgaGVscGVycy5wYXJzZUlubGluZSh0b2tlbi50b2tlbnMgfHwgW10pKTtcbiAgfSxcbiAgcmVuZGVyTWFya2Rvd246IChub2RlLCBoKSA9PiB7XG4gICAgcmV0dXJuIGAqKiR7aC5yZW5kZXJDaGlsZHJlbihub2RlKX0qKmA7XG4gIH0sXG4gIGFkZENvbW1hbmRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzZXRCb2xkOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy5zZXRNYXJrKHRoaXMubmFtZSk7XG4gICAgICB9LFxuICAgICAgdG9nZ2xlQm9sZDogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICByZXR1cm4gY29tbWFuZHMudG9nZ2xlTWFyayh0aGlzLm5hbWUpO1xuICAgICAgfSxcbiAgICAgIHVuc2V0Qm9sZDogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICByZXR1cm4gY29tbWFuZHMudW5zZXRNYXJrKHRoaXMubmFtZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFwiTW9kLWJcIjogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlQm9sZCgpLFxuICAgICAgXCJNb2QtQlwiOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVCb2xkKClcbiAgICB9O1xuICB9LFxuICBhZGRJbnB1dFJ1bGVzKCkge1xuICAgIHJldHVybiBbXG4gICAgICBtYXJrSW5wdXRSdWxlKHtcbiAgICAgICAgZmluZDogc3RhcklucHV0UmVnZXgsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZVxuICAgICAgfSksXG4gICAgICBtYXJrSW5wdXRSdWxlKHtcbiAgICAgICAgZmluZDogdW5kZXJzY29yZUlucHV0UmVnZXgsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZVxuICAgICAgfSlcbiAgICBdO1xuICB9LFxuICBhZGRQYXN0ZVJ1bGVzKCkge1xuICAgIHJldHVybiBbXG4gICAgICBtYXJrUGFzdGVSdWxlKHtcbiAgICAgICAgZmluZDogc3RhclBhc3RlUmVnZXgsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZVxuICAgICAgfSksXG4gICAgICBtYXJrUGFzdGVSdWxlKHtcbiAgICAgICAgZmluZDogdW5kZXJzY29yZVBhc3RlUmVnZXgsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZVxuICAgICAgfSlcbiAgICBdO1xuICB9XG59KTtcblxuLy8gc3JjL2luZGV4LnRzXG52YXIgaW5kZXhfZGVmYXVsdCA9IEJvbGQ7XG5leHBvcnQge1xuICBCb2xkLFxuICBpbmRleF9kZWZhdWx0IGFzIGRlZmF1bHQsXG4gIHN0YXJJbnB1dFJlZ2V4LFxuICBzdGFyUGFzdGVSZWdleCxcbiAgdW5kZXJzY29yZUlucHV0UmVnZXgsXG4gIHVuZGVyc2NvcmVQYXN0ZVJlZ2V4XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIk1hcmsiLCJtYXJrSW5wdXRSdWxlIiwibWFya1Bhc3RlUnVsZSIsIm1lcmdlQXR0cmlidXRlcyIsImpzeCIsInN0YXJJbnB1dFJlZ2V4Iiwic3RhclBhc3RlUmVnZXgiLCJ1bmRlcnNjb3JlSW5wdXRSZWdleCIsInVuZGVyc2NvcmVQYXN0ZVJlZ2V4IiwiQm9sZCIsImNyZWF0ZSIsIm5hbWUiLCJhZGRPcHRpb25zIiwiSFRNTEF0dHJpYnV0ZXMiLCJwYXJzZUhUTUwiLCJ0YWciLCJnZXRBdHRycyIsIm5vZGUiLCJzdHlsZSIsImZvbnRXZWlnaHQiLCJjbGVhck1hcmsiLCJtYXJrIiwidHlwZSIsInZhbHVlIiwidGVzdCIsInJlbmRlckhUTUwiLCJvcHRpb25zIiwiY2hpbGRyZW4iLCJtYXJrZG93blRva2VuTmFtZSIsInBhcnNlTWFya2Rvd24iLCJ0b2tlbiIsImhlbHBlcnMiLCJhcHBseU1hcmsiLCJwYXJzZUlubGluZSIsInRva2VucyIsInJlbmRlck1hcmtkb3duIiwiaCIsInJlbmRlckNoaWxkcmVuIiwiYWRkQ29tbWFuZHMiLCJzZXRCb2xkIiwiY29tbWFuZHMiLCJzZXRNYXJrIiwidG9nZ2xlQm9sZCIsInRvZ2dsZU1hcmsiLCJ1bnNldEJvbGQiLCJ1bnNldE1hcmsiLCJhZGRLZXlib2FyZFNob3J0Y3V0cyIsImVkaXRvciIsImFkZElucHV0UnVsZXMiLCJmaW5kIiwiYWRkUGFzdGVSdWxlcyIsImluZGV4X2RlZmF1bHQiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-bold/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-character-count/dist/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@tiptap/extension-character-count/dist/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CharacterCount: () => (/* reexport safe */ _tiptap_extensions__WEBPACK_IMPORTED_MODULE_0__.CharacterCount),\n/* harmony export */   \"default\": () => (/* binding */ index_default)\n/* harmony export */ });\n/* harmony import */ var _tiptap_extensions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/extensions */ \"(ssr)/./node_modules/@tiptap/extensions/dist/index.js\");\n// src/index.ts\n\n\nvar index_default = _tiptap_extensions__WEBPACK_IMPORTED_MODULE_0__.CharacterCount;\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tY2hhcmFjdGVyLWNvdW50L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsZUFBZTtBQUNxQztBQUNtQjtBQUN2RSxJQUFJRSxnQkFBZ0JGLDhEQUFjQTtBQUloQyxDQUNGLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3ByYXNvYnBhaS13ZWIvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tY2hhcmFjdGVyLWNvdW50L2Rpc3QvaW5kZXguanM/MGI5NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvaW5kZXgudHNcbmltcG9ydCB7IENoYXJhY3RlckNvdW50IH0gZnJvbSBcIkB0aXB0YXAvZXh0ZW5zaW9uc1wiO1xuaW1wb3J0IHsgQ2hhcmFjdGVyQ291bnQgYXMgQ2hhcmFjdGVyQ291bnQyIH0gZnJvbSBcIkB0aXB0YXAvZXh0ZW5zaW9uc1wiO1xudmFyIGluZGV4X2RlZmF1bHQgPSBDaGFyYWN0ZXJDb3VudDtcbmV4cG9ydCB7XG4gIENoYXJhY3RlckNvdW50MiBhcyBDaGFyYWN0ZXJDb3VudCxcbiAgaW5kZXhfZGVmYXVsdCBhcyBkZWZhdWx0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIkNoYXJhY3RlckNvdW50IiwiQ2hhcmFjdGVyQ291bnQyIiwiaW5kZXhfZGVmYXVsdCIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-character-count/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-code-block/dist/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-code-block/dist/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CodeBlock: () => (/* binding */ CodeBlock),\n/* harmony export */   backtickInputRegex: () => (/* binding */ backtickInputRegex),\n/* harmony export */   \"default\": () => (/* binding */ index_default),\n/* harmony export */   tildeInputRegex: () => (/* binding */ tildeInputRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/state */ \"(ssr)/./node_modules/@tiptap/pm/dist/state/index.js\");\n// src/code-block.ts\n\n\nvar DEFAULT_TAB_SIZE = 4;\nvar backtickInputRegex = /^```([a-z]+)?[\\s\\n]$/;\nvar tildeInputRegex = /^~~~([a-z]+)?[\\s\\n]$/;\nvar CodeBlock = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Node.create({\n    name: \"codeBlock\",\n    addOptions () {\n        return {\n            languageClassPrefix: \"language-\",\n            exitOnTripleEnter: true,\n            exitOnArrowDown: true,\n            defaultLanguage: null,\n            enableTabIndentation: false,\n            tabSize: DEFAULT_TAB_SIZE,\n            HTMLAttributes: {}\n        };\n    },\n    content: \"text*\",\n    marks: \"\",\n    group: \"block\",\n    code: true,\n    defining: true,\n    addAttributes () {\n        return {\n            language: {\n                default: this.options.defaultLanguage,\n                parseHTML: (element)=>{\n                    var _a;\n                    const { languageClassPrefix } = this.options;\n                    if (!languageClassPrefix) {\n                        return null;\n                    }\n                    const classNames = [\n                        ...((_a = element.firstElementChild) == null ? void 0 : _a.classList) || []\n                    ];\n                    const languages = classNames.filter((className)=>className.startsWith(languageClassPrefix)).map((className)=>className.replace(languageClassPrefix, \"\"));\n                    const language = languages[0];\n                    if (!language) {\n                        return null;\n                    }\n                    return language;\n                },\n                rendered: false\n            }\n        };\n    },\n    parseHTML () {\n        return [\n            {\n                tag: \"pre\",\n                preserveWhitespace: \"full\"\n            }\n        ];\n    },\n    renderHTML ({ node, HTMLAttributes }) {\n        return [\n            \"pre\",\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes),\n            [\n                \"code\",\n                {\n                    class: node.attrs.language ? this.options.languageClassPrefix + node.attrs.language : null\n                },\n                0\n            ]\n        ];\n    },\n    markdownTokenName: \"code\",\n    parseMarkdown: (token, helpers)=>{\n        var _a;\n        if (((_a = token.raw) == null ? void 0 : _a.startsWith(\"```\")) === false && token.codeBlockStyle !== \"indented\") {\n            return [];\n        }\n        return helpers.createNode(\"codeBlock\", {\n            language: token.lang || null\n        }, token.text ? [\n            helpers.createTextNode(token.text)\n        ] : []);\n    },\n    renderMarkdown: (node, h)=>{\n        var _a;\n        let output = \"\";\n        const language = ((_a = node.attrs) == null ? void 0 : _a.language) || \"\";\n        if (!node.content) {\n            output = `\\`\\`\\`${language}\n\n\\`\\`\\``;\n        } else {\n            const lines = [\n                `\\`\\`\\`${language}`,\n                h.renderChildren(node.content),\n                \"```\"\n            ];\n            output = lines.join(\"\\n\");\n        }\n        return output;\n    },\n    addCommands () {\n        return {\n            setCodeBlock: (attributes)=>({ commands })=>{\n                    return commands.setNode(this.name, attributes);\n                },\n            toggleCodeBlock: (attributes)=>({ commands })=>{\n                    return commands.toggleNode(this.name, \"paragraph\", attributes);\n                }\n        };\n    },\n    addKeyboardShortcuts () {\n        return {\n            \"Mod-Alt-c\": ()=>this.editor.commands.toggleCodeBlock(),\n            // remove code block when at start of document or code block is empty\n            Backspace: ()=>{\n                const { empty, $anchor } = this.editor.state.selection;\n                const isAtStart = $anchor.pos === 1;\n                if (!empty || $anchor.parent.type.name !== this.name) {\n                    return false;\n                }\n                if (isAtStart || !$anchor.parent.textContent.length) {\n                    return this.editor.commands.clearNodes();\n                }\n                return false;\n            },\n            // handle tab indentation\n            Tab: ({ editor })=>{\n                var _a;\n                if (!this.options.enableTabIndentation) {\n                    return false;\n                }\n                const tabSize = (_a = this.options.tabSize) != null ? _a : DEFAULT_TAB_SIZE;\n                const { state } = editor;\n                const { selection } = state;\n                const { $from, empty } = selection;\n                if ($from.parent.type !== this.type) {\n                    return false;\n                }\n                const indent = \" \".repeat(tabSize);\n                if (empty) {\n                    return editor.commands.insertContent(indent);\n                }\n                return editor.commands.command(({ tr })=>{\n                    const { from, to } = selection;\n                    const text = state.doc.textBetween(from, to, \"\\n\", \"\\n\");\n                    const lines = text.split(\"\\n\");\n                    const indentedText = lines.map((line)=>indent + line).join(\"\\n\");\n                    tr.replaceWith(from, to, state.schema.text(indentedText));\n                    return true;\n                });\n            },\n            // handle shift+tab reverse indentation\n            \"Shift-Tab\": ({ editor })=>{\n                var _a;\n                if (!this.options.enableTabIndentation) {\n                    return false;\n                }\n                const tabSize = (_a = this.options.tabSize) != null ? _a : DEFAULT_TAB_SIZE;\n                const { state } = editor;\n                const { selection } = state;\n                const { $from, empty } = selection;\n                if ($from.parent.type !== this.type) {\n                    return false;\n                }\n                if (empty) {\n                    return editor.commands.command(({ tr })=>{\n                        var _a2;\n                        const { pos } = $from;\n                        const codeBlockStart = $from.start();\n                        const codeBlockEnd = $from.end();\n                        const allText = state.doc.textBetween(codeBlockStart, codeBlockEnd, \"\\n\", \"\\n\");\n                        const lines = allText.split(\"\\n\");\n                        let currentLineIndex = 0;\n                        let charCount = 0;\n                        const relativeCursorPos = pos - codeBlockStart;\n                        for(let i = 0; i < lines.length; i += 1){\n                            if (charCount + lines[i].length >= relativeCursorPos) {\n                                currentLineIndex = i;\n                                break;\n                            }\n                            charCount += lines[i].length + 1;\n                        }\n                        const currentLine = lines[currentLineIndex];\n                        const leadingSpaces = ((_a2 = currentLine.match(/^ */)) == null ? void 0 : _a2[0]) || \"\";\n                        const spacesToRemove = Math.min(leadingSpaces.length, tabSize);\n                        if (spacesToRemove === 0) {\n                            return true;\n                        }\n                        let lineStartPos = codeBlockStart;\n                        for(let i = 0; i < currentLineIndex; i += 1){\n                            lineStartPos += lines[i].length + 1;\n                        }\n                        tr.delete(lineStartPos, lineStartPos + spacesToRemove);\n                        const cursorPosInLine = pos - lineStartPos;\n                        if (cursorPosInLine <= spacesToRemove) {\n                            tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(tr.doc, lineStartPos));\n                        }\n                        return true;\n                    });\n                }\n                return editor.commands.command(({ tr })=>{\n                    const { from, to } = selection;\n                    const text = state.doc.textBetween(from, to, \"\\n\", \"\\n\");\n                    const lines = text.split(\"\\n\");\n                    const reverseIndentText = lines.map((line)=>{\n                        var _a2;\n                        const leadingSpaces = ((_a2 = line.match(/^ */)) == null ? void 0 : _a2[0]) || \"\";\n                        const spacesToRemove = Math.min(leadingSpaces.length, tabSize);\n                        return line.slice(spacesToRemove);\n                    }).join(\"\\n\");\n                    tr.replaceWith(from, to, state.schema.text(reverseIndentText));\n                    return true;\n                });\n            },\n            // exit node on triple enter\n            Enter: ({ editor })=>{\n                if (!this.options.exitOnTripleEnter) {\n                    return false;\n                }\n                const { state } = editor;\n                const { selection } = state;\n                const { $from, empty } = selection;\n                if (!empty || $from.parent.type !== this.type) {\n                    return false;\n                }\n                const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;\n                const endsWithDoubleNewline = $from.parent.textContent.endsWith(\"\\n\\n\");\n                if (!isAtEnd || !endsWithDoubleNewline) {\n                    return false;\n                }\n                return editor.chain().command(({ tr })=>{\n                    tr.delete($from.pos - 2, $from.pos);\n                    return true;\n                }).exitCode().run();\n            },\n            // exit node on arrow down\n            ArrowDown: ({ editor })=>{\n                if (!this.options.exitOnArrowDown) {\n                    return false;\n                }\n                const { state } = editor;\n                const { selection, doc } = state;\n                const { $from, empty } = selection;\n                if (!empty || $from.parent.type !== this.type) {\n                    return false;\n                }\n                const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;\n                if (!isAtEnd) {\n                    return false;\n                }\n                const after = $from.after();\n                if (after === void 0) {\n                    return false;\n                }\n                const nodeAfter = doc.nodeAt(after);\n                if (nodeAfter) {\n                    return editor.commands.command(({ tr })=>{\n                        tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near(doc.resolve(after)));\n                        return true;\n                    });\n                }\n                return editor.commands.exitCode();\n            }\n        };\n    },\n    addInputRules () {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.textblockTypeInputRule)({\n                find: backtickInputRegex,\n                type: this.type,\n                getAttributes: (match)=>({\n                        language: match[1]\n                    })\n            }),\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.textblockTypeInputRule)({\n                find: tildeInputRegex,\n                type: this.type,\n                getAttributes: (match)=>({\n                        language: match[1]\n                    })\n            })\n        ];\n    },\n    addProseMirrorPlugins () {\n        return [\n            // this plugin creates a code block for pasted content from VS Code\n            // we can also detect the copied code language\n            new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n                key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\"codeBlockVSCodeHandler\"),\n                props: {\n                    handlePaste: (view, event)=>{\n                        if (!event.clipboardData) {\n                            return false;\n                        }\n                        if (this.editor.isActive(this.type.name)) {\n                            return false;\n                        }\n                        const text = event.clipboardData.getData(\"text/plain\");\n                        const vscode = event.clipboardData.getData(\"vscode-editor-data\");\n                        const vscodeData = vscode ? JSON.parse(vscode) : void 0;\n                        const language = vscodeData == null ? void 0 : vscodeData.mode;\n                        if (!text || !language) {\n                            return false;\n                        }\n                        const { tr, schema } = view.state;\n                        const textNode = schema.text(text.replace(/\\r\\n?/g, \"\\n\"));\n                        tr.replaceSelectionWith(this.type.create({\n                            language\n                        }, textNode));\n                        if (tr.selection.$from.parent.type !== this.type) {\n                            tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.near(tr.doc.resolve(Math.max(0, tr.selection.from - 2))));\n                        }\n                        tr.setMeta(\"paste\", true);\n                        view.dispatch(tr);\n                        return true;\n                    }\n                }\n            })\n        ];\n    }\n});\n// src/index.ts\nvar index_default = CodeBlock;\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tY29kZS1ibG9jay9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBLG9CQUFvQjtBQUN5RDtBQUNFO0FBQy9FLElBQUlPLG1CQUFtQjtBQUN2QixJQUFJQyxxQkFBcUI7QUFDekIsSUFBSUMsa0JBQWtCO0FBQ3RCLElBQUlDLFlBQVlULDhDQUFJQSxDQUFDVSxNQUFNLENBQUM7SUFDMUJDLE1BQU07SUFDTkM7UUFDRSxPQUFPO1lBQ0xDLHFCQUFxQjtZQUNyQkMsbUJBQW1CO1lBQ25CQyxpQkFBaUI7WUFDakJDLGlCQUFpQjtZQUNqQkMsc0JBQXNCO1lBQ3RCQyxTQUFTWjtZQUNUYSxnQkFBZ0IsQ0FBQztRQUNuQjtJQUNGO0lBQ0FDLFNBQVM7SUFDVEMsT0FBTztJQUNQQyxPQUFPO0lBQ1BDLE1BQU07SUFDTkMsVUFBVTtJQUNWQztRQUNFLE9BQU87WUFDTEMsVUFBVTtnQkFDUkMsU0FBUyxJQUFJLENBQUNDLE9BQU8sQ0FBQ1osZUFBZTtnQkFDckNhLFdBQVcsQ0FBQ0M7b0JBQ1YsSUFBSUM7b0JBQ0osTUFBTSxFQUFFbEIsbUJBQW1CLEVBQUUsR0FBRyxJQUFJLENBQUNlLE9BQU87b0JBQzVDLElBQUksQ0FBQ2YscUJBQXFCO3dCQUN4QixPQUFPO29CQUNUO29CQUNBLE1BQU1tQixhQUFhOzJCQUFJLENBQUMsQ0FBQ0QsS0FBS0QsUUFBUUcsaUJBQWlCLEtBQUssT0FBTyxLQUFLLElBQUlGLEdBQUdHLFNBQVMsS0FBSyxFQUFFO3FCQUFDO29CQUNoRyxNQUFNQyxZQUFZSCxXQUFXSSxNQUFNLENBQUMsQ0FBQ0MsWUFBY0EsVUFBVUMsVUFBVSxDQUFDekIsc0JBQXNCMEIsR0FBRyxDQUFDLENBQUNGLFlBQWNBLFVBQVVHLE9BQU8sQ0FBQzNCLHFCQUFxQjtvQkFDeEosTUFBTWEsV0FBV1MsU0FBUyxDQUFDLEVBQUU7b0JBQzdCLElBQUksQ0FBQ1QsVUFBVTt3QkFDYixP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dkUsTUFBTSxDQUFDOzRCQUFFZ0I7d0JBQVMsR0FBR2lJO3dCQUN2RCxJQUFJaEUsR0FBR2QsU0FBUyxDQUFDUyxLQUFLLENBQUNOLE1BQU0sQ0FBQ0MsSUFBSSxLQUFLLElBQUksQ0FBQ0EsSUFBSSxFQUFFOzRCQUNoRFUsR0FBRzZCLFlBQVksQ0FBQ25ILDJEQUFhQSxDQUFDbUksSUFBSSxDQUFDN0MsR0FBR0csR0FBRyxDQUFDMkMsT0FBTyxDQUFDdEIsS0FBSzBDLEdBQUcsQ0FBQyxHQUFHbEUsR0FBR2QsU0FBUyxDQUFDZSxJQUFJLEdBQUc7d0JBQ3BGO3dCQUNBRCxHQUFHbUUsT0FBTyxDQUFDLFNBQVM7d0JBQ3BCYixLQUFLYyxRQUFRLENBQUNwRTt3QkFDZCxPQUFPO29CQUNUO2dCQUNGO1lBQ0Y7U0FDRDtJQUNIO0FBQ0Y7QUFFQSxlQUFlO0FBQ2YsSUFBSXFFLGdCQUFnQnZKO0FBTWxCLENBQ0YsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJhc29icGFpLXdlYi8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1jb2RlLWJsb2NrL2Rpc3QvaW5kZXguanM/Y2JhNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvY29kZS1ibG9jay50c1xuaW1wb3J0IHsgbWVyZ2VBdHRyaWJ1dGVzLCBOb2RlLCB0ZXh0YmxvY2tUeXBlSW5wdXRSdWxlIH0gZnJvbSBcIkB0aXB0YXAvY29yZVwiO1xuaW1wb3J0IHsgUGx1Z2luLCBQbHVnaW5LZXksIFNlbGVjdGlvbiwgVGV4dFNlbGVjdGlvbiB9IGZyb20gXCJAdGlwdGFwL3BtL3N0YXRlXCI7XG52YXIgREVGQVVMVF9UQUJfU0laRSA9IDQ7XG52YXIgYmFja3RpY2tJbnB1dFJlZ2V4ID0gL15gYGAoW2Etel0rKT9bXFxzXFxuXSQvO1xudmFyIHRpbGRlSW5wdXRSZWdleCA9IC9efn5+KFthLXpdKyk/W1xcc1xcbl0kLztcbnZhciBDb2RlQmxvY2sgPSBOb2RlLmNyZWF0ZSh7XG4gIG5hbWU6IFwiY29kZUJsb2NrXCIsXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxhbmd1YWdlQ2xhc3NQcmVmaXg6IFwibGFuZ3VhZ2UtXCIsXG4gICAgICBleGl0T25UcmlwbGVFbnRlcjogdHJ1ZSxcbiAgICAgIGV4aXRPbkFycm93RG93bjogdHJ1ZSxcbiAgICAgIGRlZmF1bHRMYW5ndWFnZTogbnVsbCxcbiAgICAgIGVuYWJsZVRhYkluZGVudGF0aW9uOiBmYWxzZSxcbiAgICAgIHRhYlNpemU6IERFRkFVTFRfVEFCX1NJWkUsXG4gICAgICBIVE1MQXR0cmlidXRlczoge31cbiAgICB9O1xuICB9LFxuICBjb250ZW50OiBcInRleHQqXCIsXG4gIG1hcmtzOiBcIlwiLFxuICBncm91cDogXCJibG9ja1wiLFxuICBjb2RlOiB0cnVlLFxuICBkZWZpbmluZzogdHJ1ZSxcbiAgYWRkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGFuZ3VhZ2U6IHtcbiAgICAgICAgZGVmYXVsdDogdGhpcy5vcHRpb25zLmRlZmF1bHRMYW5ndWFnZSxcbiAgICAgICAgcGFyc2VIVE1MOiAoZWxlbWVudCkgPT4ge1xuICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICBjb25zdCB7IGxhbmd1YWdlQ2xhc3NQcmVmaXggfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgICBpZiAoIWxhbmd1YWdlQ2xhc3NQcmVmaXgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBjbGFzc05hbWVzID0gWy4uLigoX2EgPSBlbGVtZW50LmZpcnN0RWxlbWVudENoaWxkKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2xhc3NMaXN0KSB8fCBbXV07XG4gICAgICAgICAgY29uc3QgbGFuZ3VhZ2VzID0gY2xhc3NOYW1lcy5maWx0ZXIoKGNsYXNzTmFtZSkgPT4gY2xhc3NOYW1lLnN0YXJ0c1dpdGgobGFuZ3VhZ2VDbGFzc1ByZWZpeCkpLm1hcCgoY2xhc3NOYW1lKSA9PiBjbGFzc05hbWUucmVwbGFjZShsYW5ndWFnZUNsYXNzUHJlZml4LCBcIlwiKSk7XG4gICAgICAgICAgY29uc3QgbGFuZ3VhZ2UgPSBsYW5ndWFnZXNbMF07XG4gICAgICAgICAgaWYgKCFsYW5ndWFnZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBsYW5ndWFnZTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVuZGVyZWQ6IGZhbHNlXG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIHRhZzogXCJwcmVcIixcbiAgICAgICAgcHJlc2VydmVXaGl0ZXNwYWNlOiBcImZ1bGxcIlxuICAgICAgfVxuICAgIF07XG4gIH0sXG4gIHJlbmRlckhUTUwoeyBub2RlLCBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIFwicHJlXCIsXG4gICAgICBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksXG4gICAgICBbXG4gICAgICAgIFwiY29kZVwiLFxuICAgICAgICB7XG4gICAgICAgICAgY2xhc3M6IG5vZGUuYXR0cnMubGFuZ3VhZ2UgPyB0aGlzLm9wdGlvbnMubGFuZ3VhZ2VDbGFzc1ByZWZpeCArIG5vZGUuYXR0cnMubGFuZ3VhZ2UgOiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIDBcbiAgICAgIF1cbiAgICBdO1xuICB9LFxuICBtYXJrZG93blRva2VuTmFtZTogXCJjb2RlXCIsXG4gIHBhcnNlTWFya2Rvd246ICh0b2tlbiwgaGVscGVycykgPT4ge1xuICAgIHZhciBfYTtcbiAgICBpZiAoKChfYSA9IHRva2VuLnJhdykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnN0YXJ0c1dpdGgoXCJgYGBcIikpID09PSBmYWxzZSAmJiB0b2tlbi5jb2RlQmxvY2tTdHlsZSAhPT0gXCJpbmRlbnRlZFwiKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHJldHVybiBoZWxwZXJzLmNyZWF0ZU5vZGUoXG4gICAgICBcImNvZGVCbG9ja1wiLFxuICAgICAgeyBsYW5ndWFnZTogdG9rZW4ubGFuZyB8fCBudWxsIH0sXG4gICAgICB0b2tlbi50ZXh0ID8gW2hlbHBlcnMuY3JlYXRlVGV4dE5vZGUodG9rZW4udGV4dCldIDogW11cbiAgICApO1xuICB9LFxuICByZW5kZXJNYXJrZG93bjogKG5vZGUsIGgpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IG91dHB1dCA9IFwiXCI7XG4gICAgY29uc3QgbGFuZ3VhZ2UgPSAoKF9hID0gbm9kZS5hdHRycykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmxhbmd1YWdlKSB8fCBcIlwiO1xuICAgIGlmICghbm9kZS5jb250ZW50KSB7XG4gICAgICBvdXRwdXQgPSBgXFxgXFxgXFxgJHtsYW5ndWFnZX1cblxuXFxgXFxgXFxgYDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbGluZXMgPSBbYFxcYFxcYFxcYCR7bGFuZ3VhZ2V9YCwgaC5yZW5kZXJDaGlsZHJlbihub2RlLmNvbnRlbnQpLCBcImBgYFwiXTtcbiAgICAgIG91dHB1dCA9IGxpbmVzLmpvaW4oXCJcXG5cIik7XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH0sXG4gIGFkZENvbW1hbmRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzZXRDb2RlQmxvY2s6IChhdHRyaWJ1dGVzKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy5zZXROb2RlKHRoaXMubmFtZSwgYXR0cmlidXRlcyk7XG4gICAgICB9LFxuICAgICAgdG9nZ2xlQ29kZUJsb2NrOiAoYXR0cmlidXRlcykgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICByZXR1cm4gY29tbWFuZHMudG9nZ2xlTm9kZSh0aGlzLm5hbWUsIFwicGFyYWdyYXBoXCIsIGF0dHJpYnV0ZXMpO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBcIk1vZC1BbHQtY1wiOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVDb2RlQmxvY2soKSxcbiAgICAgIC8vIHJlbW92ZSBjb2RlIGJsb2NrIHdoZW4gYXQgc3RhcnQgb2YgZG9jdW1lbnQgb3IgY29kZSBibG9jayBpcyBlbXB0eVxuICAgICAgQmFja3NwYWNlOiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZW1wdHksICRhbmNob3IgfSA9IHRoaXMuZWRpdG9yLnN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgY29uc3QgaXNBdFN0YXJ0ID0gJGFuY2hvci5wb3MgPT09IDE7XG4gICAgICAgIGlmICghZW1wdHkgfHwgJGFuY2hvci5wYXJlbnQudHlwZS5uYW1lICE9PSB0aGlzLm5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQXRTdGFydCB8fCAhJGFuY2hvci5wYXJlbnQudGV4dENvbnRlbnQubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZWRpdG9yLmNvbW1hbmRzLmNsZWFyTm9kZXMoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9LFxuICAgICAgLy8gaGFuZGxlIHRhYiBpbmRlbnRhdGlvblxuICAgICAgVGFiOiAoeyBlZGl0b3IgfSkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmVuYWJsZVRhYkluZGVudGF0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhYlNpemUgPSAoX2EgPSB0aGlzLm9wdGlvbnMudGFiU2l6ZSkgIT0gbnVsbCA/IF9hIDogREVGQVVMVF9UQUJfU0laRTtcbiAgICAgICAgY29uc3QgeyBzdGF0ZSB9ID0gZWRpdG9yO1xuICAgICAgICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gc3RhdGU7XG4gICAgICAgIGNvbnN0IHsgJGZyb20sIGVtcHR5IH0gPSBzZWxlY3Rpb247XG4gICAgICAgIGlmICgkZnJvbS5wYXJlbnQudHlwZSAhPT0gdGhpcy50eXBlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluZGVudCA9IFwiIFwiLnJlcGVhdCh0YWJTaXplKTtcbiAgICAgICAgaWYgKGVtcHR5KSB7XG4gICAgICAgICAgcmV0dXJuIGVkaXRvci5jb21tYW5kcy5pbnNlcnRDb250ZW50KGluZGVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVkaXRvci5jb21tYW5kcy5jb21tYW5kKCh7IHRyIH0pID0+IHtcbiAgICAgICAgICBjb25zdCB7IGZyb20sIHRvIH0gPSBzZWxlY3Rpb247XG4gICAgICAgICAgY29uc3QgdGV4dCA9IHN0YXRlLmRvYy50ZXh0QmV0d2Vlbihmcm9tLCB0bywgXCJcXG5cIiwgXCJcXG5cIik7XG4gICAgICAgICAgY29uc3QgbGluZXMgPSB0ZXh0LnNwbGl0KFwiXFxuXCIpO1xuICAgICAgICAgIGNvbnN0IGluZGVudGVkVGV4dCA9IGxpbmVzLm1hcCgobGluZSkgPT4gaW5kZW50ICsgbGluZSkuam9pbihcIlxcblwiKTtcbiAgICAgICAgICB0ci5yZXBsYWNlV2l0aChmcm9tLCB0bywgc3RhdGUuc2NoZW1hLnRleHQoaW5kZW50ZWRUZXh0KSk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIC8vIGhhbmRsZSBzaGlmdCt0YWIgcmV2ZXJzZSBpbmRlbnRhdGlvblxuICAgICAgXCJTaGlmdC1UYWJcIjogKHsgZWRpdG9yIH0pID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5lbmFibGVUYWJJbmRlbnRhdGlvbikge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YWJTaXplID0gKF9hID0gdGhpcy5vcHRpb25zLnRhYlNpemUpICE9IG51bGwgPyBfYSA6IERFRkFVTFRfVEFCX1NJWkU7XG4gICAgICAgIGNvbnN0IHsgc3RhdGUgfSA9IGVkaXRvcjtcbiAgICAgICAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHN0YXRlO1xuICAgICAgICBjb25zdCB7ICRmcm9tLCBlbXB0eSB9ID0gc2VsZWN0aW9uO1xuICAgICAgICBpZiAoJGZyb20ucGFyZW50LnR5cGUgIT09IHRoaXMudHlwZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW1wdHkpIHtcbiAgICAgICAgICByZXR1cm4gZWRpdG9yLmNvbW1hbmRzLmNvbW1hbmQoKHsgdHIgfSkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hMjtcbiAgICAgICAgICAgIGNvbnN0IHsgcG9zIH0gPSAkZnJvbTtcbiAgICAgICAgICAgIGNvbnN0IGNvZGVCbG9ja1N0YXJ0ID0gJGZyb20uc3RhcnQoKTtcbiAgICAgICAgICAgIGNvbnN0IGNvZGVCbG9ja0VuZCA9ICRmcm9tLmVuZCgpO1xuICAgICAgICAgICAgY29uc3QgYWxsVGV4dCA9IHN0YXRlLmRvYy50ZXh0QmV0d2Vlbihjb2RlQmxvY2tTdGFydCwgY29kZUJsb2NrRW5kLCBcIlxcblwiLCBcIlxcblwiKTtcbiAgICAgICAgICAgIGNvbnN0IGxpbmVzID0gYWxsVGV4dC5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgICAgIGxldCBjdXJyZW50TGluZUluZGV4ID0gMDtcbiAgICAgICAgICAgIGxldCBjaGFyQ291bnQgPSAwO1xuICAgICAgICAgICAgY29uc3QgcmVsYXRpdmVDdXJzb3JQb3MgPSBwb3MgLSBjb2RlQmxvY2tTdGFydDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgaWYgKGNoYXJDb3VudCArIGxpbmVzW2ldLmxlbmd0aCA+PSByZWxhdGl2ZUN1cnNvclBvcykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRMaW5lSW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNoYXJDb3VudCArPSBsaW5lc1tpXS5sZW5ndGggKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY3VycmVudExpbmUgPSBsaW5lc1tjdXJyZW50TGluZUluZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IGxlYWRpbmdTcGFjZXMgPSAoKF9hMiA9IGN1cnJlbnRMaW5lLm1hdGNoKC9eICovKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMlswXSkgfHwgXCJcIjtcbiAgICAgICAgICAgIGNvbnN0IHNwYWNlc1RvUmVtb3ZlID0gTWF0aC5taW4obGVhZGluZ1NwYWNlcy5sZW5ndGgsIHRhYlNpemUpO1xuICAgICAgICAgICAgaWYgKHNwYWNlc1RvUmVtb3ZlID09PSAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGxpbmVTdGFydFBvcyA9IGNvZGVCbG9ja1N0YXJ0O1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJyZW50TGluZUluZGV4OyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgbGluZVN0YXJ0UG9zICs9IGxpbmVzW2ldLmxlbmd0aCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ci5kZWxldGUobGluZVN0YXJ0UG9zLCBsaW5lU3RhcnRQb3MgKyBzcGFjZXNUb1JlbW92ZSk7XG4gICAgICAgICAgICBjb25zdCBjdXJzb3JQb3NJbkxpbmUgPSBwb3MgLSBsaW5lU3RhcnRQb3M7XG4gICAgICAgICAgICBpZiAoY3Vyc29yUG9zSW5MaW5lIDw9IHNwYWNlc1RvUmVtb3ZlKSB7XG4gICAgICAgICAgICAgIHRyLnNldFNlbGVjdGlvbihUZXh0U2VsZWN0aW9uLmNyZWF0ZSh0ci5kb2MsIGxpbmVTdGFydFBvcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVkaXRvci5jb21tYW5kcy5jb21tYW5kKCh7IHRyIH0pID0+IHtcbiAgICAgICAgICBjb25zdCB7IGZyb20sIHRvIH0gPSBzZWxlY3Rpb247XG4gICAgICAgICAgY29uc3QgdGV4dCA9IHN0YXRlLmRvYy50ZXh0QmV0d2Vlbihmcm9tLCB0bywgXCJcXG5cIiwgXCJcXG5cIik7XG4gICAgICAgICAgY29uc3QgbGluZXMgPSB0ZXh0LnNwbGl0KFwiXFxuXCIpO1xuICAgICAgICAgIGNvbnN0IHJldmVyc2VJbmRlbnRUZXh0ID0gbGluZXMubWFwKChsaW5lKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EyO1xuICAgICAgICAgICAgY29uc3QgbGVhZGluZ1NwYWNlcyA9ICgoX2EyID0gbGluZS5tYXRjaCgvXiAqLykpID09IG51bGwgPyB2b2lkIDAgOiBfYTJbMF0pIHx8IFwiXCI7XG4gICAgICAgICAgICBjb25zdCBzcGFjZXNUb1JlbW92ZSA9IE1hdGgubWluKGxlYWRpbmdTcGFjZXMubGVuZ3RoLCB0YWJTaXplKTtcbiAgICAgICAgICAgIHJldHVybiBsaW5lLnNsaWNlKHNwYWNlc1RvUmVtb3ZlKTtcbiAgICAgICAgICB9KS5qb2luKFwiXFxuXCIpO1xuICAgICAgICAgIHRyLnJlcGxhY2VXaXRoKGZyb20sIHRvLCBzdGF0ZS5zY2hlbWEudGV4dChyZXZlcnNlSW5kZW50VGV4dCkpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICAvLyBleGl0IG5vZGUgb24gdHJpcGxlIGVudGVyXG4gICAgICBFbnRlcjogKHsgZWRpdG9yIH0pID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZXhpdE9uVHJpcGxlRW50ZXIpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBzdGF0ZSB9ID0gZWRpdG9yO1xuICAgICAgICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gc3RhdGU7XG4gICAgICAgIGNvbnN0IHsgJGZyb20sIGVtcHR5IH0gPSBzZWxlY3Rpb247XG4gICAgICAgIGlmICghZW1wdHkgfHwgJGZyb20ucGFyZW50LnR5cGUgIT09IHRoaXMudHlwZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc0F0RW5kID0gJGZyb20ucGFyZW50T2Zmc2V0ID09PSAkZnJvbS5wYXJlbnQubm9kZVNpemUgLSAyO1xuICAgICAgICBjb25zdCBlbmRzV2l0aERvdWJsZU5ld2xpbmUgPSAkZnJvbS5wYXJlbnQudGV4dENvbnRlbnQuZW5kc1dpdGgoXCJcXG5cXG5cIik7XG4gICAgICAgIGlmICghaXNBdEVuZCB8fCAhZW5kc1dpdGhEb3VibGVOZXdsaW5lKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlZGl0b3IuY2hhaW4oKS5jb21tYW5kKCh7IHRyIH0pID0+IHtcbiAgICAgICAgICB0ci5kZWxldGUoJGZyb20ucG9zIC0gMiwgJGZyb20ucG9zKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSkuZXhpdENvZGUoKS5ydW4oKTtcbiAgICAgIH0sXG4gICAgICAvLyBleGl0IG5vZGUgb24gYXJyb3cgZG93blxuICAgICAgQXJyb3dEb3duOiAoeyBlZGl0b3IgfSkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5leGl0T25BcnJvd0Rvd24pIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBzdGF0ZSB9ID0gZWRpdG9yO1xuICAgICAgICBjb25zdCB7IHNlbGVjdGlvbiwgZG9jIH0gPSBzdGF0ZTtcbiAgICAgICAgY29uc3QgeyAkZnJvbSwgZW1wdHkgfSA9IHNlbGVjdGlvbjtcbiAgICAgICAgaWYgKCFlbXB0eSB8fCAkZnJvbS5wYXJlbnQudHlwZSAhPT0gdGhpcy50eXBlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzQXRFbmQgPSAkZnJvbS5wYXJlbnRPZmZzZXQgPT09ICRmcm9tLnBhcmVudC5ub2RlU2l6ZSAtIDI7XG4gICAgICAgIGlmICghaXNBdEVuZCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhZnRlciA9ICRmcm9tLmFmdGVyKCk7XG4gICAgICAgIGlmIChhZnRlciA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5vZGVBZnRlciA9IGRvYy5ub2RlQXQoYWZ0ZXIpO1xuICAgICAgICBpZiAobm9kZUFmdGVyKSB7XG4gICAgICAgICAgcmV0dXJuIGVkaXRvci5jb21tYW5kcy5jb21tYW5kKCh7IHRyIH0pID0+IHtcbiAgICAgICAgICAgIHRyLnNldFNlbGVjdGlvbihTZWxlY3Rpb24ubmVhcihkb2MucmVzb2x2ZShhZnRlcikpKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlZGl0b3IuY29tbWFuZHMuZXhpdENvZGUoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBhZGRJbnB1dFJ1bGVzKCkge1xuICAgIHJldHVybiBbXG4gICAgICB0ZXh0YmxvY2tUeXBlSW5wdXRSdWxlKHtcbiAgICAgICAgZmluZDogYmFja3RpY2tJbnB1dFJlZ2V4LFxuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgIGdldEF0dHJpYnV0ZXM6IChtYXRjaCkgPT4gKHtcbiAgICAgICAgICBsYW5ndWFnZTogbWF0Y2hbMV1cbiAgICAgICAgfSlcbiAgICAgIH0pLFxuICAgICAgdGV4dGJsb2NrVHlwZUlucHV0UnVsZSh7XG4gICAgICAgIGZpbmQ6IHRpbGRlSW5wdXRSZWdleCxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICBnZXRBdHRyaWJ1dGVzOiAobWF0Y2gpID0+ICh7XG4gICAgICAgICAgbGFuZ3VhZ2U6IG1hdGNoWzFdXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIF07XG4gIH0sXG4gIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgLy8gdGhpcyBwbHVnaW4gY3JlYXRlcyBhIGNvZGUgYmxvY2sgZm9yIHBhc3RlZCBjb250ZW50IGZyb20gVlMgQ29kZVxuICAgICAgLy8gd2UgY2FuIGFsc28gZGV0ZWN0IHRoZSBjb3BpZWQgY29kZSBsYW5ndWFnZVxuICAgICAgbmV3IFBsdWdpbih7XG4gICAgICAgIGtleTogbmV3IFBsdWdpbktleShcImNvZGVCbG9ja1ZTQ29kZUhhbmRsZXJcIiksXG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgaGFuZGxlUGFzdGU6ICh2aWV3LCBldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFldmVudC5jbGlwYm9hcmREYXRhKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmVkaXRvci5pc0FjdGl2ZSh0aGlzLnR5cGUubmFtZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdGV4dCA9IGV2ZW50LmNsaXBib2FyZERhdGEuZ2V0RGF0YShcInRleHQvcGxhaW5cIik7XG4gICAgICAgICAgICBjb25zdCB2c2NvZGUgPSBldmVudC5jbGlwYm9hcmREYXRhLmdldERhdGEoXCJ2c2NvZGUtZWRpdG9yLWRhdGFcIik7XG4gICAgICAgICAgICBjb25zdCB2c2NvZGVEYXRhID0gdnNjb2RlID8gSlNPTi5wYXJzZSh2c2NvZGUpIDogdm9pZCAwO1xuICAgICAgICAgICAgY29uc3QgbGFuZ3VhZ2UgPSB2c2NvZGVEYXRhID09IG51bGwgPyB2b2lkIDAgOiB2c2NvZGVEYXRhLm1vZGU7XG4gICAgICAgICAgICBpZiAoIXRleHQgfHwgIWxhbmd1YWdlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgdHIsIHNjaGVtYSB9ID0gdmlldy5zdGF0ZTtcbiAgICAgICAgICAgIGNvbnN0IHRleHROb2RlID0gc2NoZW1hLnRleHQodGV4dC5yZXBsYWNlKC9cXHJcXG4/L2csIFwiXFxuXCIpKTtcbiAgICAgICAgICAgIHRyLnJlcGxhY2VTZWxlY3Rpb25XaXRoKHRoaXMudHlwZS5jcmVhdGUoeyBsYW5ndWFnZSB9LCB0ZXh0Tm9kZSkpO1xuICAgICAgICAgICAgaWYgKHRyLnNlbGVjdGlvbi4kZnJvbS5wYXJlbnQudHlwZSAhPT0gdGhpcy50eXBlKSB7XG4gICAgICAgICAgICAgIHRyLnNldFNlbGVjdGlvbihUZXh0U2VsZWN0aW9uLm5lYXIodHIuZG9jLnJlc29sdmUoTWF0aC5tYXgoMCwgdHIuc2VsZWN0aW9uLmZyb20gLSAyKSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyLnNldE1ldGEoXCJwYXN0ZVwiLCB0cnVlKTtcbiAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2godHIpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIF07XG4gIH1cbn0pO1xuXG4vLyBzcmMvaW5kZXgudHNcbnZhciBpbmRleF9kZWZhdWx0ID0gQ29kZUJsb2NrO1xuZXhwb3J0IHtcbiAgQ29kZUJsb2NrLFxuICBiYWNrdGlja0lucHV0UmVnZXgsXG4gIGluZGV4X2RlZmF1bHQgYXMgZGVmYXVsdCxcbiAgdGlsZGVJbnB1dFJlZ2V4XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIm1lcmdlQXR0cmlidXRlcyIsIk5vZGUiLCJ0ZXh0YmxvY2tUeXBlSW5wdXRSdWxlIiwiUGx1Z2luIiwiUGx1Z2luS2V5IiwiU2VsZWN0aW9uIiwiVGV4dFNlbGVjdGlvbiIsIkRFRkFVTFRfVEFCX1NJWkUiLCJiYWNrdGlja0lucHV0UmVnZXgiLCJ0aWxkZUlucHV0UmVnZXgiLCJDb2RlQmxvY2siLCJjcmVhdGUiLCJuYW1lIiwiYWRkT3B0aW9ucyIsImxhbmd1YWdlQ2xhc3NQcmVmaXgiLCJleGl0T25UcmlwbGVFbnRlciIsImV4aXRPbkFycm93RG93biIsImRlZmF1bHRMYW5ndWFnZSIsImVuYWJsZVRhYkluZGVudGF0aW9uIiwidGFiU2l6ZSIsIkhUTUxBdHRyaWJ1dGVzIiwiY29udGVudCIsIm1hcmtzIiwiZ3JvdXAiLCJjb2RlIiwiZGVmaW5pbmciLCJhZGRBdHRyaWJ1dGVzIiwibGFuZ3VhZ2UiLCJkZWZhdWx0Iiwib3B0aW9ucyIsInBhcnNlSFRNTCIsImVsZW1lbnQiLCJfYSIsImNsYXNzTmFtZXMiLCJmaXJzdEVsZW1lbnRDaGlsZCIsImNsYXNzTGlzdCIsImxhbmd1YWdlcyIsImZpbHRlciIsImNsYXNzTmFtZSIsInN0YXJ0c1dpdGgiLCJtYXAiLCJyZXBsYWNlIiwicmVuZGVyZWQiLCJ0YWciLCJwcmVzZXJ2ZVdoaXRlc3BhY2UiLCJyZW5kZXJIVE1MIiwibm9kZSIsImNsYXNzIiwiYXR0cnMiLCJtYXJrZG93blRva2VuTmFtZSIsInBhcnNlTWFya2Rvd24iLCJ0b2tlbiIsImhlbHBlcnMiLCJyYXciLCJjb2RlQmxvY2tTdHlsZSIsImNyZWF0ZU5vZGUiLCJsYW5nIiwidGV4dCIsImNyZWF0ZVRleHROb2RlIiwicmVuZGVyTWFya2Rvd24iLCJoIiwib3V0cHV0IiwibGluZXMiLCJyZW5kZXJDaGlsZHJlbiIsImpvaW4iLCJhZGRDb21tYW5kcyIsInNldENvZGVCbG9jayIsImF0dHJpYnV0ZXMiLCJjb21tYW5kcyIsInNldE5vZGUiLCJ0b2dnbGVDb2RlQmxvY2siLCJ0b2dnbGVOb2RlIiwiYWRkS2V5Ym9hcmRTaG9ydGN1dHMiLCJlZGl0b3IiLCJCYWNrc3BhY2UiLCJlbXB0eSIsIiRhbmNob3IiLCJzdGF0ZSIsInNlbGVjdGlvbiIsImlzQXRTdGFydCIsInBvcyIsInBhcmVudCIsInR5cGUiLCJ0ZXh0Q29udGVudCIsImxlbmd0aCIsImNsZWFyTm9kZXMiLCJUYWIiLCIkZnJvbSIsImluZGVudCIsInJlcGVhdCIsImluc2VydENvbnRlbnQiLCJjb21tYW5kIiwidHIiLCJmcm9tIiwidG8iLCJkb2MiLCJ0ZXh0QmV0d2VlbiIsInNwbGl0IiwiaW5kZW50ZWRUZXh0IiwibGluZSIsInJlcGxhY2VXaXRoIiwic2NoZW1hIiwiX2EyIiwiY29kZUJsb2NrU3RhcnQiLCJzdGFydCIsImNvZGVCbG9ja0VuZCIsImVuZCIsImFsbFRleHQiLCJjdXJyZW50TGluZUluZGV4IiwiY2hhckNvdW50IiwicmVsYXRpdmVDdXJzb3JQb3MiLCJpIiwiY3VycmVudExpbmUiLCJsZWFkaW5nU3BhY2VzIiwibWF0Y2giLCJzcGFjZXNUb1JlbW92ZSIsIk1hdGgiLCJtaW4iLCJsaW5lU3RhcnRQb3MiLCJkZWxldGUiLCJjdXJzb3JQb3NJbkxpbmUiLCJzZXRTZWxlY3Rpb24iLCJyZXZlcnNlSW5kZW50VGV4dCIsInNsaWNlIiwiRW50ZXIiLCJpc0F0RW5kIiwicGFyZW50T2Zmc2V0Iiwibm9kZVNpemUiLCJlbmRzV2l0aERvdWJsZU5ld2xpbmUiLCJlbmRzV2l0aCIsImNoYWluIiwiZXhpdENvZGUiLCJydW4iLCJBcnJvd0Rvd24iLCJhZnRlciIsIm5vZGVBZnRlciIsIm5vZGVBdCIsIm5lYXIiLCJyZXNvbHZlIiwiYWRkSW5wdXRSdWxlcyIsImZpbmQiLCJnZXRBdHRyaWJ1dGVzIiwiYWRkUHJvc2VNaXJyb3JQbHVnaW5zIiwia2V5IiwicHJvcHMiLCJoYW5kbGVQYXN0ZSIsInZpZXciLCJldmVudCIsImNsaXBib2FyZERhdGEiLCJpc0FjdGl2ZSIsImdldERhdGEiLCJ2c2NvZGUiLCJ2c2NvZGVEYXRhIiwiSlNPTiIsInBhcnNlIiwibW9kZSIsInRleHROb2RlIiwicmVwbGFjZVNlbGVjdGlvbldpdGgiLCJtYXgiLCJzZXRNZXRhIiwiZGlzcGF0Y2giLCJpbmRleF9kZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-code-block/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-code/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@tiptap/extension-code/dist/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Code: () => (/* binding */ Code),\n/* harmony export */   \"default\": () => (/* binding */ index_default),\n/* harmony export */   inputRegex: () => (/* binding */ inputRegex),\n/* harmony export */   pasteRegex: () => (/* binding */ pasteRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n// src/code.ts\n\nvar inputRegex = /(^|[^`])`([^`]+)`(?!`)$/;\nvar pasteRegex = /(^|[^`])`([^`]+)`(?!`)/g;\nvar Code = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Mark.create({\n    name: \"code\",\n    addOptions () {\n        return {\n            HTMLAttributes: {}\n        };\n    },\n    excludes: \"_\",\n    code: true,\n    exitable: true,\n    parseHTML () {\n        return [\n            {\n                tag: \"code\"\n            }\n        ];\n    },\n    renderHTML ({ HTMLAttributes }) {\n        return [\n            \"code\",\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes),\n            0\n        ];\n    },\n    markdownTokenName: \"codespan\",\n    parseMarkdown: (token, helpers)=>{\n        return helpers.applyMark(\"code\", [\n            {\n                type: \"text\",\n                text: token.text || \"\"\n            }\n        ]);\n    },\n    renderMarkdown: (node, h)=>{\n        if (!node.content) {\n            return \"\";\n        }\n        return `\\`${h.renderChildren(node.content)}\\``;\n    },\n    addCommands () {\n        return {\n            setCode: ()=>({ commands })=>{\n                    return commands.setMark(this.name);\n                },\n            toggleCode: ()=>({ commands })=>{\n                    return commands.toggleMark(this.name);\n                },\n            unsetCode: ()=>({ commands })=>{\n                    return commands.unsetMark(this.name);\n                }\n        };\n    },\n    addKeyboardShortcuts () {\n        return {\n            \"Mod-e\": ()=>this.editor.commands.toggleCode()\n        };\n    },\n    addInputRules () {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({\n                find: inputRegex,\n                type: this.type\n            })\n        ];\n    },\n    addPasteRules () {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({\n                find: pasteRegex,\n                type: this.type\n            })\n        ];\n    }\n});\n// src/index.ts\nvar index_default = Code;\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tY29kZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUEsY0FBYztBQUNxRTtBQUNuRixJQUFJSSxhQUFhO0FBQ2pCLElBQUlDLGFBQWE7QUFDakIsSUFBSUMsT0FBT04sOENBQUlBLENBQUNPLE1BQU0sQ0FBQztJQUNyQkMsTUFBTTtJQUNOQztRQUNFLE9BQU87WUFDTEMsZ0JBQWdCLENBQUM7UUFDbkI7SUFDRjtJQUNBQyxVQUFVO0lBQ1ZDLE1BQU07SUFDTkMsVUFBVTtJQUNWQztRQUNFLE9BQU87WUFBQztnQkFBRUMsS0FBSztZQUFPO1NBQUU7SUFDMUI7SUFDQUMsWUFBVyxFQUFFTixjQUFjLEVBQUU7UUFDM0IsT0FBTztZQUFDO1lBQVFQLDZEQUFlQSxDQUFDLElBQUksQ0FBQ2MsT0FBTyxDQUFDUCxjQUFjLEVBQUVBO1lBQWlCO1NBQUU7SUFDbEY7SUFDQVEsbUJBQW1CO0lBQ25CQyxlQUFlLENBQUNDLE9BQU9DO1FBQ3JCLE9BQU9BLFFBQVFDLFNBQVMsQ0FBQyxRQUFRO1lBQUM7Z0JBQUVDLE1BQU07Z0JBQVFDLE1BQU1KLE1BQU1JLElBQUksSUFBSTtZQUFHO1NBQUU7SUFDN0U7SUFDQUMsZ0JBQWdCLENBQUNDLE1BQU1DO1FBQ3JCLElBQUksQ0FBQ0QsS0FBS0UsT0FBTyxFQUFFO1lBQ2pCLE9BQU87UUFDVDtRQUNBLE9BQU8sQ0FBQyxFQUFFLEVBQUVELEVBQUVFLGNBQWMsQ0FBQ0gsS0FBS0UsT0FBTyxFQUFFLEVBQUUsQ0FBQztJQUNoRDtJQUNBRTtRQUNFLE9BQU87WUFDTEMsU0FBUyxJQUFNLENBQUMsRUFBRUMsUUFBUSxFQUFFO29CQUMxQixPQUFPQSxTQUFTQyxPQUFPLENBQUMsSUFBSSxDQUFDekIsSUFBSTtnQkFDbkM7WUFDQTBCLFlBQVksSUFBTSxDQUFDLEVBQUVGLFFBQVEsRUFBRTtvQkFDN0IsT0FBT0EsU0FBU0csVUFBVSxDQUFDLElBQUksQ0FBQzNCLElBQUk7Z0JBQ3RDO1lBQ0E0QixXQUFXLElBQU0sQ0FBQyxFQUFFSixRQUFRLEVBQUU7b0JBQzVCLE9BQU9BLFNBQVNLLFNBQVMsQ0FBQyxJQUFJLENBQUM3QixJQUFJO2dCQUNyQztRQUNGO0lBQ0Y7SUFDQThCO1FBQ0UsT0FBTztZQUNMLFNBQVMsSUFBTSxJQUFJLENBQUNDLE1BQU0sQ0FBQ1AsUUFBUSxDQUFDRSxVQUFVO1FBQ2hEO0lBQ0Y7SUFDQU07UUFDRSxPQUFPO1lBQ0x2QywyREFBYUEsQ0FBQztnQkFDWndDLE1BQU1yQztnQkFDTm1CLE1BQU0sSUFBSSxDQUFDQSxJQUFJO1lBQ2pCO1NBQ0Q7SUFDSDtJQUNBbUI7UUFDRSxPQUFPO1lBQ0x4QywyREFBYUEsQ0FBQztnQkFDWnVDLE1BQU1wQztnQkFDTmtCLE1BQU0sSUFBSSxDQUFDQSxJQUFJO1lBQ2pCO1NBQ0Q7SUFDSDtBQUNGO0FBRUEsZUFBZTtBQUNmLElBQUlvQixnQkFBZ0JyQztBQU1sQixDQUNGLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3ByYXNvYnBhaS13ZWIvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tY29kZS9kaXN0L2luZGV4LmpzPzM2NjAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2NvZGUudHNcbmltcG9ydCB7IE1hcmssIG1hcmtJbnB1dFJ1bGUsIG1hcmtQYXN0ZVJ1bGUsIG1lcmdlQXR0cmlidXRlcyB9IGZyb20gXCJAdGlwdGFwL2NvcmVcIjtcbnZhciBpbnB1dFJlZ2V4ID0gLyhefFteYF0pYChbXmBdKylgKD8hYCkkLztcbnZhciBwYXN0ZVJlZ2V4ID0gLyhefFteYF0pYChbXmBdKylgKD8hYCkvZztcbnZhciBDb2RlID0gTWFyay5jcmVhdGUoe1xuICBuYW1lOiBcImNvZGVcIixcbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9XG4gICAgfTtcbiAgfSxcbiAgZXhjbHVkZXM6IFwiX1wiLFxuICBjb2RlOiB0cnVlLFxuICBleGl0YWJsZTogdHJ1ZSxcbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbeyB0YWc6IFwiY29kZVwiIH1dO1xuICB9LFxuICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgIHJldHVybiBbXCJjb2RlXCIsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgMF07XG4gIH0sXG4gIG1hcmtkb3duVG9rZW5OYW1lOiBcImNvZGVzcGFuXCIsXG4gIHBhcnNlTWFya2Rvd246ICh0b2tlbiwgaGVscGVycykgPT4ge1xuICAgIHJldHVybiBoZWxwZXJzLmFwcGx5TWFyayhcImNvZGVcIiwgW3sgdHlwZTogXCJ0ZXh0XCIsIHRleHQ6IHRva2VuLnRleHQgfHwgXCJcIiB9XSk7XG4gIH0sXG4gIHJlbmRlck1hcmtkb3duOiAobm9kZSwgaCkgPT4ge1xuICAgIGlmICghbm9kZS5jb250ZW50KSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgcmV0dXJuIGBcXGAke2gucmVuZGVyQ2hpbGRyZW4obm9kZS5jb250ZW50KX1cXGBgO1xuICB9LFxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2V0Q29kZTogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICByZXR1cm4gY29tbWFuZHMuc2V0TWFyayh0aGlzLm5hbWUpO1xuICAgICAgfSxcbiAgICAgIHRvZ2dsZUNvZGU6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnRvZ2dsZU1hcmsodGhpcy5uYW1lKTtcbiAgICAgIH0sXG4gICAgICB1bnNldENvZGU6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnVuc2V0TWFyayh0aGlzLm5hbWUpO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBcIk1vZC1lXCI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZUNvZGUoKVxuICAgIH07XG4gIH0sXG4gIGFkZElucHV0UnVsZXMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG1hcmtJbnB1dFJ1bGUoe1xuICAgICAgICBmaW5kOiBpbnB1dFJlZ2V4LFxuICAgICAgICB0eXBlOiB0aGlzLnR5cGVcbiAgICAgIH0pXG4gICAgXTtcbiAgfSxcbiAgYWRkUGFzdGVSdWxlcygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgbWFya1Bhc3RlUnVsZSh7XG4gICAgICAgIGZpbmQ6IHBhc3RlUmVnZXgsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZVxuICAgICAgfSlcbiAgICBdO1xuICB9XG59KTtcblxuLy8gc3JjL2luZGV4LnRzXG52YXIgaW5kZXhfZGVmYXVsdCA9IENvZGU7XG5leHBvcnQge1xuICBDb2RlLFxuICBpbmRleF9kZWZhdWx0IGFzIGRlZmF1bHQsXG4gIGlucHV0UmVnZXgsXG4gIHBhc3RlUmVnZXhcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsiTWFyayIsIm1hcmtJbnB1dFJ1bGUiLCJtYXJrUGFzdGVSdWxlIiwibWVyZ2VBdHRyaWJ1dGVzIiwiaW5wdXRSZWdleCIsInBhc3RlUmVnZXgiLCJDb2RlIiwiY3JlYXRlIiwibmFtZSIsImFkZE9wdGlvbnMiLCJIVE1MQXR0cmlidXRlcyIsImV4Y2x1ZGVzIiwiY29kZSIsImV4aXRhYmxlIiwicGFyc2VIVE1MIiwidGFnIiwicmVuZGVySFRNTCIsIm9wdGlvbnMiLCJtYXJrZG93blRva2VuTmFtZSIsInBhcnNlTWFya2Rvd24iLCJ0b2tlbiIsImhlbHBlcnMiLCJhcHBseU1hcmsiLCJ0eXBlIiwidGV4dCIsInJlbmRlck1hcmtkb3duIiwibm9kZSIsImgiLCJjb250ZW50IiwicmVuZGVyQ2hpbGRyZW4iLCJhZGRDb21tYW5kcyIsInNldENvZGUiLCJjb21tYW5kcyIsInNldE1hcmsiLCJ0b2dnbGVDb2RlIiwidG9nZ2xlTWFyayIsInVuc2V0Q29kZSIsInVuc2V0TWFyayIsImFkZEtleWJvYXJkU2hvcnRjdXRzIiwiZWRpdG9yIiwiYWRkSW5wdXRSdWxlcyIsImZpbmQiLCJhZGRQYXN0ZVJ1bGVzIiwiaW5kZXhfZGVmYXVsdCIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-code/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-document/dist/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@tiptap/extension-document/dist/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Document: () => (/* binding */ Document),\n/* harmony export */   \"default\": () => (/* binding */ index_default)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n// src/document.ts\n\nvar Document = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n    name: \"doc\",\n    topNode: true,\n    content: \"block+\",\n    renderMarkdown: (node, h)=>{\n        if (!node.content) {\n            return \"\";\n        }\n        return h.renderChildren(node.content, \"\\n\\n\");\n    }\n});\n// src/index.ts\nvar index_default = Document;\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tZG9jdW1lbnQvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxrQkFBa0I7QUFDa0I7QUFDcEMsSUFBSUMsV0FBV0QsOENBQUlBLENBQUNFLE1BQU0sQ0FBQztJQUN6QkMsTUFBTTtJQUNOQyxTQUFTO0lBQ1RDLFNBQVM7SUFDVEMsZ0JBQWdCLENBQUNDLE1BQU1DO1FBQ3JCLElBQUksQ0FBQ0QsS0FBS0YsT0FBTyxFQUFFO1lBQ2pCLE9BQU87UUFDVDtRQUNBLE9BQU9HLEVBQUVDLGNBQWMsQ0FBQ0YsS0FBS0YsT0FBTyxFQUFFO0lBQ3hDO0FBQ0Y7QUFFQSxlQUFlO0FBQ2YsSUFBSUssZ0JBQWdCVDtBQUlsQixDQUNGLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3ByYXNvYnBhaS13ZWIvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tZG9jdW1lbnQvZGlzdC9pbmRleC5qcz9jY2ZkIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9kb2N1bWVudC50c1xuaW1wb3J0IHsgTm9kZSB9IGZyb20gXCJAdGlwdGFwL2NvcmVcIjtcbnZhciBEb2N1bWVudCA9IE5vZGUuY3JlYXRlKHtcbiAgbmFtZTogXCJkb2NcIixcbiAgdG9wTm9kZTogdHJ1ZSxcbiAgY29udGVudDogXCJibG9jaytcIixcbiAgcmVuZGVyTWFya2Rvd246IChub2RlLCBoKSA9PiB7XG4gICAgaWYgKCFub2RlLmNvbnRlbnQpIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICByZXR1cm4gaC5yZW5kZXJDaGlsZHJlbihub2RlLmNvbnRlbnQsIFwiXFxuXFxuXCIpO1xuICB9XG59KTtcblxuLy8gc3JjL2luZGV4LnRzXG52YXIgaW5kZXhfZGVmYXVsdCA9IERvY3VtZW50O1xuZXhwb3J0IHtcbiAgRG9jdW1lbnQsXG4gIGluZGV4X2RlZmF1bHQgYXMgZGVmYXVsdFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJOb2RlIiwiRG9jdW1lbnQiLCJjcmVhdGUiLCJuYW1lIiwidG9wTm9kZSIsImNvbnRlbnQiLCJyZW5kZXJNYXJrZG93biIsIm5vZGUiLCJoIiwicmVuZGVyQ2hpbGRyZW4iLCJpbmRleF9kZWZhdWx0IiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-document/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-hard-break/dist/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-hard-break/dist/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HardBreak: () => (/* binding */ HardBreak),\n/* harmony export */   \"default\": () => (/* binding */ index_default)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n// src/hard-break.ts\n\nvar HardBreak = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n    name: \"hardBreak\",\n    markdownTokenName: \"br\",\n    addOptions () {\n        return {\n            keepMarks: true,\n            HTMLAttributes: {}\n        };\n    },\n    inline: true,\n    group: \"inline\",\n    selectable: false,\n    linebreakReplacement: true,\n    parseHTML () {\n        return [\n            {\n                tag: \"br\"\n            }\n        ];\n    },\n    renderHTML ({ HTMLAttributes }) {\n        return [\n            \"br\",\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes)\n        ];\n    },\n    renderText () {\n        return \"\\n\";\n    },\n    renderMarkdown: ()=>`  \n`,\n    parseMarkdown: ()=>{\n        return {\n            type: \"hardBreak\"\n        };\n    },\n    addCommands () {\n        return {\n            setHardBreak: ()=>({ commands, chain, state, editor })=>{\n                    return commands.first([\n                        ()=>commands.exitCode(),\n                        ()=>commands.command(()=>{\n                                const { selection, storedMarks } = state;\n                                if (selection.$from.parent.type.spec.isolating) {\n                                    return false;\n                                }\n                                const { keepMarks } = this.options;\n                                const { splittableMarks } = editor.extensionManager;\n                                const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();\n                                return chain().insertContent({\n                                    type: this.name\n                                }).command(({ tr, dispatch })=>{\n                                    if (dispatch && marks && keepMarks) {\n                                        const filteredMarks = marks.filter((mark)=>splittableMarks.includes(mark.type.name));\n                                        tr.ensureMarks(filteredMarks);\n                                    }\n                                    return true;\n                                }).run();\n                            })\n                    ]);\n                }\n        };\n    },\n    addKeyboardShortcuts () {\n        return {\n            \"Mod-Enter\": ()=>this.editor.commands.setHardBreak(),\n            \"Shift-Enter\": ()=>this.editor.commands.setHardBreak()\n        };\n    }\n});\n// src/index.ts\nvar index_default = HardBreak;\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24taGFyZC1icmVhay9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLG9CQUFvQjtBQUNpQztBQUNyRCxJQUFJRSxZQUFZRCw4Q0FBSUEsQ0FBQ0UsTUFBTSxDQUFDO0lBQzFCQyxNQUFNO0lBQ05DLG1CQUFtQjtJQUNuQkM7UUFDRSxPQUFPO1lBQ0xDLFdBQVc7WUFDWEMsZ0JBQWdCLENBQUM7UUFDbkI7SUFDRjtJQUNBQyxRQUFRO0lBQ1JDLE9BQU87SUFDUEMsWUFBWTtJQUNaQyxzQkFBc0I7SUFDdEJDO1FBQ0UsT0FBTztZQUFDO2dCQUFFQyxLQUFLO1lBQUs7U0FBRTtJQUN4QjtJQUNBQyxZQUFXLEVBQUVQLGNBQWMsRUFBRTtRQUMzQixPQUFPO1lBQUM7WUFBTVIsNkRBQWVBLENBQUMsSUFBSSxDQUFDZ0IsT0FBTyxDQUFDUixjQUFjLEVBQUVBO1NBQWdCO0lBQzdFO0lBQ0FTO1FBQ0UsT0FBTztJQUNUO0lBQ0FDLGdCQUFnQixJQUFNLENBQUM7QUFDekIsQ0FBQztJQUNDQyxlQUFlO1FBQ2IsT0FBTztZQUNMQyxNQUFNO1FBQ1I7SUFDRjtJQUNBQztRQUNFLE9BQU87WUFDTEMsY0FBYyxJQUFNLENBQUMsRUFBRUMsUUFBUSxFQUFFQyxLQUFLLEVBQUVDLEtBQUssRUFBRUMsTUFBTSxFQUFFO29CQUNyRCxPQUFPSCxTQUFTSSxLQUFLLENBQUM7d0JBQ3BCLElBQU1KLFNBQVNLLFFBQVE7d0JBQ3ZCLElBQU1MLFNBQVNNLE9BQU8sQ0FBQztnQ0FDckIsTUFBTSxFQUFFQyxTQUFTLEVBQUVDLFdBQVcsRUFBRSxHQUFHTjtnQ0FDbkMsSUFBSUssVUFBVUUsS0FBSyxDQUFDQyxNQUFNLENBQUNiLElBQUksQ0FBQ2MsSUFBSSxDQUFDQyxTQUFTLEVBQUU7b0NBQzlDLE9BQU87Z0NBQ1Q7Z0NBQ0EsTUFBTSxFQUFFNUIsU0FBUyxFQUFFLEdBQUcsSUFBSSxDQUFDUyxPQUFPO2dDQUNsQyxNQUFNLEVBQUVvQixlQUFlLEVBQUUsR0FBR1YsT0FBT1csZ0JBQWdCO2dDQUNuRCxNQUFNQyxRQUFRUCxlQUFlRCxVQUFVUyxHQUFHLENBQUNDLFlBQVksSUFBSVYsVUFBVUUsS0FBSyxDQUFDTSxLQUFLO2dDQUNoRixPQUFPZCxRQUFRaUIsYUFBYSxDQUFDO29DQUFFckIsTUFBTSxJQUFJLENBQUNoQixJQUFJO2dDQUFDLEdBQUd5QixPQUFPLENBQUMsQ0FBQyxFQUFFYSxFQUFFLEVBQUVDLFFBQVEsRUFBRTtvQ0FDekUsSUFBSUEsWUFBWUwsU0FBUy9CLFdBQVc7d0NBQ2xDLE1BQU1xQyxnQkFBZ0JOLE1BQU1PLE1BQU0sQ0FBQyxDQUFDQyxPQUFTVixnQkFBZ0JXLFFBQVEsQ0FBQ0QsS0FBSzFCLElBQUksQ0FBQ2hCLElBQUk7d0NBQ3BGc0MsR0FBR00sV0FBVyxDQUFDSjtvQ0FDakI7b0NBQ0EsT0FBTztnQ0FDVCxHQUFHSyxHQUFHOzRCQUNSO3FCQUNEO2dCQUNIO1FBQ0Y7SUFDRjtJQUNBQztRQUNFLE9BQU87WUFDTCxhQUFhLElBQU0sSUFBSSxDQUFDeEIsTUFBTSxDQUFDSCxRQUFRLENBQUNELFlBQVk7WUFDcEQsZUFBZSxJQUFNLElBQUksQ0FBQ0ksTUFBTSxDQUFDSCxRQUFRLENBQUNELFlBQVk7UUFDeEQ7SUFDRjtBQUNGO0FBRUEsZUFBZTtBQUNmLElBQUk2QixnQkFBZ0JqRDtBQUlsQixDQUNGLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3ByYXNvYnBhaS13ZWIvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24taGFyZC1icmVhay9kaXN0L2luZGV4LmpzPzAxNTkiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2hhcmQtYnJlYWsudHNcbmltcG9ydCB7IG1lcmdlQXR0cmlidXRlcywgTm9kZSB9IGZyb20gXCJAdGlwdGFwL2NvcmVcIjtcbnZhciBIYXJkQnJlYWsgPSBOb2RlLmNyZWF0ZSh7XG4gIG5hbWU6IFwiaGFyZEJyZWFrXCIsXG4gIG1hcmtkb3duVG9rZW5OYW1lOiBcImJyXCIsXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtlZXBNYXJrczogdHJ1ZSxcbiAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fVxuICAgIH07XG4gIH0sXG4gIGlubGluZTogdHJ1ZSxcbiAgZ3JvdXA6IFwiaW5saW5lXCIsXG4gIHNlbGVjdGFibGU6IGZhbHNlLFxuICBsaW5lYnJlYWtSZXBsYWNlbWVudDogdHJ1ZSxcbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbeyB0YWc6IFwiYnJcIiB9XTtcbiAgfSxcbiAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICByZXR1cm4gW1wiYnJcIiwgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpXTtcbiAgfSxcbiAgcmVuZGVyVGV4dCgpIHtcbiAgICByZXR1cm4gXCJcXG5cIjtcbiAgfSxcbiAgcmVuZGVyTWFya2Rvd246ICgpID0+IGAgIFxuYCxcbiAgcGFyc2VNYXJrZG93bjogKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImhhcmRCcmVha1wiXG4gICAgfTtcbiAgfSxcbiAgYWRkQ29tbWFuZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNldEhhcmRCcmVhazogKCkgPT4gKHsgY29tbWFuZHMsIGNoYWluLCBzdGF0ZSwgZWRpdG9yIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLmZpcnN0KFtcbiAgICAgICAgICAoKSA9PiBjb21tYW5kcy5leGl0Q29kZSgpLFxuICAgICAgICAgICgpID0+IGNvbW1hbmRzLmNvbW1hbmQoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBzZWxlY3Rpb24sIHN0b3JlZE1hcmtzIH0gPSBzdGF0ZTtcbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb24uJGZyb20ucGFyZW50LnR5cGUuc3BlYy5pc29sYXRpbmcpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBrZWVwTWFya3MgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgICAgIGNvbnN0IHsgc3BsaXR0YWJsZU1hcmtzIH0gPSBlZGl0b3IuZXh0ZW5zaW9uTWFuYWdlcjtcbiAgICAgICAgICAgIGNvbnN0IG1hcmtzID0gc3RvcmVkTWFya3MgfHwgc2VsZWN0aW9uLiR0by5wYXJlbnRPZmZzZXQgJiYgc2VsZWN0aW9uLiRmcm9tLm1hcmtzKCk7XG4gICAgICAgICAgICByZXR1cm4gY2hhaW4oKS5pbnNlcnRDb250ZW50KHsgdHlwZTogdGhpcy5uYW1lIH0pLmNvbW1hbmQoKHsgdHIsIGRpc3BhdGNoIH0pID0+IHtcbiAgICAgICAgICAgICAgaWYgKGRpc3BhdGNoICYmIG1hcmtzICYmIGtlZXBNYXJrcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlcmVkTWFya3MgPSBtYXJrcy5maWx0ZXIoKG1hcmspID0+IHNwbGl0dGFibGVNYXJrcy5pbmNsdWRlcyhtYXJrLnR5cGUubmFtZSkpO1xuICAgICAgICAgICAgICAgIHRyLmVuc3VyZU1hcmtzKGZpbHRlcmVkTWFya3MpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSkucnVuKCk7XG4gICAgICAgICAgfSlcbiAgICAgICAgXSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFwiTW9kLUVudGVyXCI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnNldEhhcmRCcmVhaygpLFxuICAgICAgXCJTaGlmdC1FbnRlclwiOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5zZXRIYXJkQnJlYWsoKVxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBzcmMvaW5kZXgudHNcbnZhciBpbmRleF9kZWZhdWx0ID0gSGFyZEJyZWFrO1xuZXhwb3J0IHtcbiAgSGFyZEJyZWFrLFxuICBpbmRleF9kZWZhdWx0IGFzIGRlZmF1bHRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsibWVyZ2VBdHRyaWJ1dGVzIiwiTm9kZSIsIkhhcmRCcmVhayIsImNyZWF0ZSIsIm5hbWUiLCJtYXJrZG93blRva2VuTmFtZSIsImFkZE9wdGlvbnMiLCJrZWVwTWFya3MiLCJIVE1MQXR0cmlidXRlcyIsImlubGluZSIsImdyb3VwIiwic2VsZWN0YWJsZSIsImxpbmVicmVha1JlcGxhY2VtZW50IiwicGFyc2VIVE1MIiwidGFnIiwicmVuZGVySFRNTCIsIm9wdGlvbnMiLCJyZW5kZXJUZXh0IiwicmVuZGVyTWFya2Rvd24iLCJwYXJzZU1hcmtkb3duIiwidHlwZSIsImFkZENvbW1hbmRzIiwic2V0SGFyZEJyZWFrIiwiY29tbWFuZHMiLCJjaGFpbiIsInN0YXRlIiwiZWRpdG9yIiwiZmlyc3QiLCJleGl0Q29kZSIsImNvbW1hbmQiLCJzZWxlY3Rpb24iLCJzdG9yZWRNYXJrcyIsIiRmcm9tIiwicGFyZW50Iiwic3BlYyIsImlzb2xhdGluZyIsInNwbGl0dGFibGVNYXJrcyIsImV4dGVuc2lvbk1hbmFnZXIiLCJtYXJrcyIsIiR0byIsInBhcmVudE9mZnNldCIsImluc2VydENvbnRlbnQiLCJ0ciIsImRpc3BhdGNoIiwiZmlsdGVyZWRNYXJrcyIsImZpbHRlciIsIm1hcmsiLCJpbmNsdWRlcyIsImVuc3VyZU1hcmtzIiwicnVuIiwiYWRkS2V5Ym9hcmRTaG9ydGN1dHMiLCJpbmRleF9kZWZhdWx0IiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-hard-break/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-heading/dist/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@tiptap/extension-heading/dist/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Heading: () => (/* binding */ Heading),\n/* harmony export */   \"default\": () => (/* binding */ index_default)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n// src/heading.ts\n\nvar Heading = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n    name: \"heading\",\n    addOptions () {\n        return {\n            levels: [\n                1,\n                2,\n                3,\n                4,\n                5,\n                6\n            ],\n            HTMLAttributes: {}\n        };\n    },\n    content: \"inline*\",\n    group: \"block\",\n    defining: true,\n    addAttributes () {\n        return {\n            level: {\n                default: 1,\n                rendered: false\n            }\n        };\n    },\n    parseHTML () {\n        return this.options.levels.map((level)=>({\n                tag: `h${level}`,\n                attrs: {\n                    level\n                }\n            }));\n    },\n    renderHTML ({ node, HTMLAttributes }) {\n        const hasLevel = this.options.levels.includes(node.attrs.level);\n        const level = hasLevel ? node.attrs.level : this.options.levels[0];\n        return [\n            `h${level}`,\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes),\n            0\n        ];\n    },\n    parseMarkdown: (token, helpers)=>{\n        return helpers.createNode(\"heading\", {\n            level: token.depth || 1\n        }, helpers.parseInline(token.tokens || []));\n    },\n    renderMarkdown: (node, h)=>{\n        var _a;\n        const level = ((_a = node.attrs) == null ? void 0 : _a.level) ? parseInt(node.attrs.level, 10) : 1;\n        const headingChars = \"#\".repeat(level);\n        if (!node.content) {\n            return \"\";\n        }\n        return `${headingChars} ${h.renderChildren(node.content)}`;\n    },\n    addCommands () {\n        return {\n            setHeading: (attributes)=>({ commands })=>{\n                    if (!this.options.levels.includes(attributes.level)) {\n                        return false;\n                    }\n                    return commands.setNode(this.name, attributes);\n                },\n            toggleHeading: (attributes)=>({ commands })=>{\n                    if (!this.options.levels.includes(attributes.level)) {\n                        return false;\n                    }\n                    return commands.toggleNode(this.name, \"paragraph\", attributes);\n                }\n        };\n    },\n    addKeyboardShortcuts () {\n        return this.options.levels.reduce((items, level)=>({\n                ...items,\n                ...{\n                    [`Mod-Alt-${level}`]: ()=>this.editor.commands.toggleHeading({\n                            level\n                        })\n                }\n            }), {});\n    },\n    addInputRules () {\n        return this.options.levels.map((level)=>{\n            return (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.textblockTypeInputRule)({\n                find: new RegExp(`^(#{${Math.min(...this.options.levels)},${level}})\\\\s$`),\n                type: this.type,\n                getAttributes: {\n                    level\n                }\n            });\n        });\n    }\n});\n// src/index.ts\nvar index_default = Heading;\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24taGVhZGluZy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLGlCQUFpQjtBQUM0RDtBQUM3RSxJQUFJRyxVQUFVRiw4Q0FBSUEsQ0FBQ0csTUFBTSxDQUFDO0lBQ3hCQyxNQUFNO0lBQ05DO1FBQ0UsT0FBTztZQUNMQyxRQUFRO2dCQUFDO2dCQUFHO2dCQUFHO2dCQUFHO2dCQUFHO2dCQUFHO2FBQUU7WUFDMUJDLGdCQUFnQixDQUFDO1FBQ25CO0lBQ0Y7SUFDQUMsU0FBUztJQUNUQyxPQUFPO0lBQ1BDLFVBQVU7SUFDVkM7UUFDRSxPQUFPO1lBQ0xDLE9BQU87Z0JBQ0xDLFNBQVM7Z0JBQ1RDLFVBQVU7WUFDWjtRQUNGO0lBQ0Y7SUFDQUM7UUFDRSxPQUFPLElBQUksQ0FBQ0MsT0FBTyxDQUFDVixNQUFNLENBQUNXLEdBQUcsQ0FBQyxDQUFDTCxRQUFXO2dCQUN6Q00sS0FBSyxDQUFDLENBQUMsRUFBRU4sTUFBTSxDQUFDO2dCQUNoQk8sT0FBTztvQkFBRVA7Z0JBQU07WUFDakI7SUFDRjtJQUNBUSxZQUFXLEVBQUVDLElBQUksRUFBRWQsY0FBYyxFQUFFO1FBQ2pDLE1BQU1lLFdBQVcsSUFBSSxDQUFDTixPQUFPLENBQUNWLE1BQU0sQ0FBQ2lCLFFBQVEsQ0FBQ0YsS0FBS0YsS0FBSyxDQUFDUCxLQUFLO1FBQzlELE1BQU1BLFFBQVFVLFdBQVdELEtBQUtGLEtBQUssQ0FBQ1AsS0FBSyxHQUFHLElBQUksQ0FBQ0ksT0FBTyxDQUFDVixNQUFNLENBQUMsRUFBRTtRQUNsRSxPQUFPO1lBQUMsQ0FBQyxDQUFDLEVBQUVNLE1BQU0sQ0FBQztZQUFFYiw2REFBZUEsQ0FBQyxJQUFJLENBQUNpQixPQUFPLENBQUNULGNBQWMsRUFBRUE7WUFBaUI7U0FBRTtJQUN2RjtJQUNBaUIsZUFBZSxDQUFDQyxPQUFPQztRQUNyQixPQUFPQSxRQUFRQyxVQUFVLENBQUMsV0FBVztZQUFFZixPQUFPYSxNQUFNRyxLQUFLLElBQUk7UUFBRSxHQUFHRixRQUFRRyxXQUFXLENBQUNKLE1BQU1LLE1BQU0sSUFBSSxFQUFFO0lBQzFHO0lBQ0FDLGdCQUFnQixDQUFDVixNQUFNVztRQUNyQixJQUFJQztRQUNKLE1BQU1yQixRQUFRLENBQUMsQ0FBQ3FCLEtBQUtaLEtBQUtGLEtBQUssS0FBSyxPQUFPLEtBQUssSUFBSWMsR0FBR3JCLEtBQUssSUFBSXNCLFNBQVNiLEtBQUtGLEtBQUssQ0FBQ1AsS0FBSyxFQUFFLE1BQU07UUFDakcsTUFBTXVCLGVBQWUsSUFBSUMsTUFBTSxDQUFDeEI7UUFDaEMsSUFBSSxDQUFDUyxLQUFLYixPQUFPLEVBQUU7WUFDakIsT0FBTztRQUNUO1FBQ0EsT0FBTyxDQUFDLEVBQUUyQixhQUFhLENBQUMsRUFBRUgsRUFBRUssY0FBYyxDQUFDaEIsS0FBS2IsT0FBTyxFQUFFLENBQUM7SUFDNUQ7SUFDQThCO1FBQ0UsT0FBTztZQUNMQyxZQUFZLENBQUNDLGFBQWUsQ0FBQyxFQUFFQyxRQUFRLEVBQUU7b0JBQ3ZDLElBQUksQ0FBQyxJQUFJLENBQUN6QixPQUFPLENBQUNWLE1BQU0sQ0FBQ2lCLFFBQVEsQ0FBQ2lCLFdBQVc1QixLQUFLLEdBQUc7d0JBQ25ELE9BQU87b0JBQ1Q7b0JBQ0EsT0FBTzZCLFNBQVNDLE9BQU8sQ0FBQyxJQUFJLENBQUN0QyxJQUFJLEVBQUVvQztnQkFDckM7WUFDQUcsZUFBZSxDQUFDSCxhQUFlLENBQUMsRUFBRUMsUUFBUSxFQUFFO29CQUMxQyxJQUFJLENBQUMsSUFBSSxDQUFDekIsT0FBTyxDQUFDVixNQUFNLENBQUNpQixRQUFRLENBQUNpQixXQUFXNUIsS0FBSyxHQUFHO3dCQUNuRCxPQUFPO29CQUNUO29CQUNBLE9BQU82QixTQUFTRyxVQUFVLENBQUMsSUFBSSxDQUFDeEMsSUFBSSxFQUFFLGFBQWFvQztnQkFDckQ7UUFDRjtJQUNGO0lBQ0FLO1FBQ0UsT0FBTyxJQUFJLENBQUM3QixPQUFPLENBQUNWLE1BQU0sQ0FBQ3dDLE1BQU0sQ0FDL0IsQ0FBQ0MsT0FBT25DLFFBQVc7Z0JBQ2pCLEdBQUdtQyxLQUFLO2dCQUNSLEdBQUc7b0JBQ0QsQ0FBQyxDQUFDLFFBQVEsRUFBRW5DLE1BQU0sQ0FBQyxDQUFDLEVBQUUsSUFBTSxJQUFJLENBQUNvQyxNQUFNLENBQUNQLFFBQVEsQ0FBQ0UsYUFBYSxDQUFDOzRCQUFFL0I7d0JBQU07Z0JBQ3pFLENBQUM7WUFDSCxJQUNBLENBQUM7SUFFTDtJQUNBcUM7UUFDRSxPQUFPLElBQUksQ0FBQ2pDLE9BQU8sQ0FBQ1YsTUFBTSxDQUFDVyxHQUFHLENBQUMsQ0FBQ0w7WUFDOUIsT0FBT1gsb0VBQXNCQSxDQUFDO2dCQUM1QmlELE1BQU0sSUFBSUMsT0FBTyxDQUFDLElBQUksRUFBRUMsS0FBS0MsR0FBRyxJQUFJLElBQUksQ0FBQ3JDLE9BQU8sQ0FBQ1YsTUFBTSxFQUFFLENBQUMsRUFBRU0sTUFBTSxNQUFNLENBQUM7Z0JBQ3pFMEMsTUFBTSxJQUFJLENBQUNBLElBQUk7Z0JBQ2ZDLGVBQWU7b0JBQ2IzQztnQkFDRjtZQUNGO1FBQ0Y7SUFDRjtBQUNGO0FBRUEsZUFBZTtBQUNmLElBQUk0QyxnQkFBZ0J0RDtBQUlsQixDQUNGLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3ByYXNvYnBhaS13ZWIvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24taGVhZGluZy9kaXN0L2luZGV4LmpzP2QzMDYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2hlYWRpbmcudHNcbmltcG9ydCB7IG1lcmdlQXR0cmlidXRlcywgTm9kZSwgdGV4dGJsb2NrVHlwZUlucHV0UnVsZSB9IGZyb20gXCJAdGlwdGFwL2NvcmVcIjtcbnZhciBIZWFkaW5nID0gTm9kZS5jcmVhdGUoe1xuICBuYW1lOiBcImhlYWRpbmdcIixcbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGV2ZWxzOiBbMSwgMiwgMywgNCwgNSwgNl0sXG4gICAgICBIVE1MQXR0cmlidXRlczoge31cbiAgICB9O1xuICB9LFxuICBjb250ZW50OiBcImlubGluZSpcIixcbiAgZ3JvdXA6IFwiYmxvY2tcIixcbiAgZGVmaW5pbmc6IHRydWUsXG4gIGFkZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxldmVsOiB7XG4gICAgICAgIGRlZmF1bHQ6IDEsXG4gICAgICAgIHJlbmRlcmVkOiBmYWxzZVxuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmxldmVscy5tYXAoKGxldmVsKSA9PiAoe1xuICAgICAgdGFnOiBgaCR7bGV2ZWx9YCxcbiAgICAgIGF0dHJzOiB7IGxldmVsIH1cbiAgICB9KSk7XG4gIH0sXG4gIHJlbmRlckhUTUwoeyBub2RlLCBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgY29uc3QgaGFzTGV2ZWwgPSB0aGlzLm9wdGlvbnMubGV2ZWxzLmluY2x1ZGVzKG5vZGUuYXR0cnMubGV2ZWwpO1xuICAgIGNvbnN0IGxldmVsID0gaGFzTGV2ZWwgPyBub2RlLmF0dHJzLmxldmVsIDogdGhpcy5vcHRpb25zLmxldmVsc1swXTtcbiAgICByZXR1cm4gW2BoJHtsZXZlbH1gLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdO1xuICB9LFxuICBwYXJzZU1hcmtkb3duOiAodG9rZW4sIGhlbHBlcnMpID0+IHtcbiAgICByZXR1cm4gaGVscGVycy5jcmVhdGVOb2RlKFwiaGVhZGluZ1wiLCB7IGxldmVsOiB0b2tlbi5kZXB0aCB8fCAxIH0sIGhlbHBlcnMucGFyc2VJbmxpbmUodG9rZW4udG9rZW5zIHx8IFtdKSk7XG4gIH0sXG4gIHJlbmRlck1hcmtkb3duOiAobm9kZSwgaCkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBsZXZlbCA9ICgoX2EgPSBub2RlLmF0dHJzKSA9PSBudWxsID8gdm9pZCAwIDogX2EubGV2ZWwpID8gcGFyc2VJbnQobm9kZS5hdHRycy5sZXZlbCwgMTApIDogMTtcbiAgICBjb25zdCBoZWFkaW5nQ2hhcnMgPSBcIiNcIi5yZXBlYXQobGV2ZWwpO1xuICAgIGlmICghbm9kZS5jb250ZW50KSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgcmV0dXJuIGAke2hlYWRpbmdDaGFyc30gJHtoLnJlbmRlckNoaWxkcmVuKG5vZGUuY29udGVudCl9YDtcbiAgfSxcbiAgYWRkQ29tbWFuZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNldEhlYWRpbmc6IChhdHRyaWJ1dGVzKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmxldmVscy5pbmNsdWRlcyhhdHRyaWJ1dGVzLmxldmVsKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tbWFuZHMuc2V0Tm9kZSh0aGlzLm5hbWUsIGF0dHJpYnV0ZXMpO1xuICAgICAgfSxcbiAgICAgIHRvZ2dsZUhlYWRpbmc6IChhdHRyaWJ1dGVzKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmxldmVscy5pbmNsdWRlcyhhdHRyaWJ1dGVzLmxldmVsKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tbWFuZHMudG9nZ2xlTm9kZSh0aGlzLm5hbWUsIFwicGFyYWdyYXBoXCIsIGF0dHJpYnV0ZXMpO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMubGV2ZWxzLnJlZHVjZShcbiAgICAgIChpdGVtcywgbGV2ZWwpID0+ICh7XG4gICAgICAgIC4uLml0ZW1zLFxuICAgICAgICAuLi57XG4gICAgICAgICAgW2BNb2QtQWx0LSR7bGV2ZWx9YF06ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZUhlYWRpbmcoeyBsZXZlbCB9KVxuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIHt9XG4gICAgKTtcbiAgfSxcbiAgYWRkSW5wdXRSdWxlcygpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmxldmVscy5tYXAoKGxldmVsKSA9PiB7XG4gICAgICByZXR1cm4gdGV4dGJsb2NrVHlwZUlucHV0UnVsZSh7XG4gICAgICAgIGZpbmQ6IG5ldyBSZWdFeHAoYF4oI3ske01hdGgubWluKC4uLnRoaXMub3B0aW9ucy5sZXZlbHMpfSwke2xldmVsfX0pXFxcXHMkYCksXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgZ2V0QXR0cmlidXRlczoge1xuICAgICAgICAgIGxldmVsXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59KTtcblxuLy8gc3JjL2luZGV4LnRzXG52YXIgaW5kZXhfZGVmYXVsdCA9IEhlYWRpbmc7XG5leHBvcnQge1xuICBIZWFkaW5nLFxuICBpbmRleF9kZWZhdWx0IGFzIGRlZmF1bHRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsibWVyZ2VBdHRyaWJ1dGVzIiwiTm9kZSIsInRleHRibG9ja1R5cGVJbnB1dFJ1bGUiLCJIZWFkaW5nIiwiY3JlYXRlIiwibmFtZSIsImFkZE9wdGlvbnMiLCJsZXZlbHMiLCJIVE1MQXR0cmlidXRlcyIsImNvbnRlbnQiLCJncm91cCIsImRlZmluaW5nIiwiYWRkQXR0cmlidXRlcyIsImxldmVsIiwiZGVmYXVsdCIsInJlbmRlcmVkIiwicGFyc2VIVE1MIiwib3B0aW9ucyIsIm1hcCIsInRhZyIsImF0dHJzIiwicmVuZGVySFRNTCIsIm5vZGUiLCJoYXNMZXZlbCIsImluY2x1ZGVzIiwicGFyc2VNYXJrZG93biIsInRva2VuIiwiaGVscGVycyIsImNyZWF0ZU5vZGUiLCJkZXB0aCIsInBhcnNlSW5saW5lIiwidG9rZW5zIiwicmVuZGVyTWFya2Rvd24iLCJoIiwiX2EiLCJwYXJzZUludCIsImhlYWRpbmdDaGFycyIsInJlcGVhdCIsInJlbmRlckNoaWxkcmVuIiwiYWRkQ29tbWFuZHMiLCJzZXRIZWFkaW5nIiwiYXR0cmlidXRlcyIsImNvbW1hbmRzIiwic2V0Tm9kZSIsInRvZ2dsZUhlYWRpbmciLCJ0b2dnbGVOb2RlIiwiYWRkS2V5Ym9hcmRTaG9ydGN1dHMiLCJyZWR1Y2UiLCJpdGVtcyIsImVkaXRvciIsImFkZElucHV0UnVsZXMiLCJmaW5kIiwiUmVnRXhwIiwiTWF0aCIsIm1pbiIsInR5cGUiLCJnZXRBdHRyaWJ1dGVzIiwiaW5kZXhfZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-heading/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-horizontal-rule/dist/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@tiptap/extension-horizontal-rule/dist/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HorizontalRule: () => (/* binding */ HorizontalRule),\n/* harmony export */   \"default\": () => (/* binding */ index_default)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/state */ \"(ssr)/./node_modules/@tiptap/pm/dist/state/index.js\");\n// src/horizontal-rule.ts\n\n\nvar HorizontalRule = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Node.create({\n    name: \"horizontalRule\",\n    addOptions () {\n        return {\n            HTMLAttributes: {},\n            nextNodeType: \"paragraph\"\n        };\n    },\n    group: \"block\",\n    parseHTML () {\n        return [\n            {\n                tag: \"hr\"\n            }\n        ];\n    },\n    renderHTML ({ HTMLAttributes }) {\n        return [\n            \"hr\",\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes)\n        ];\n    },\n    markdownTokenName: \"hr\",\n    parseMarkdown: (token, helpers)=>{\n        return helpers.createNode(\"horizontalRule\");\n    },\n    renderMarkdown: ()=>{\n        return \"---\";\n    },\n    addCommands () {\n        return {\n            setHorizontalRule: ()=>({ chain, state })=>{\n                    if (!(0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.canInsertNode)(state, state.schema.nodes[this.name])) {\n                        return false;\n                    }\n                    const { selection } = state;\n                    const { $to: $originTo } = selection;\n                    const currentChain = chain();\n                    if ((0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.isNodeSelection)(selection)) {\n                        currentChain.insertContentAt($originTo.pos, {\n                            type: this.name\n                        });\n                    } else {\n                        currentChain.insertContent({\n                            type: this.name\n                        });\n                    }\n                    return currentChain.command(({ state: chainState, tr, dispatch })=>{\n                        if (dispatch) {\n                            const { $to } = tr.selection;\n                            const posAfter = $to.end();\n                            if ($to.nodeAfter) {\n                                if ($to.nodeAfter.isTextblock) {\n                                    tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(tr.doc, $to.pos + 1));\n                                } else if ($to.nodeAfter.isBlock) {\n                                    tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.create(tr.doc, $to.pos));\n                                } else {\n                                    tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(tr.doc, $to.pos));\n                                }\n                            } else {\n                                const nodeType = chainState.schema.nodes[this.options.nextNodeType] || $to.parent.type.contentMatch.defaultType;\n                                const node = nodeType == null ? void 0 : nodeType.create();\n                                if (node) {\n                                    tr.insert(posAfter, node);\n                                    tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(tr.doc, posAfter + 1));\n                                }\n                            }\n                            tr.scrollIntoView();\n                        }\n                        return true;\n                    }).run();\n                }\n        };\n    },\n    addInputRules () {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.nodeInputRule)({\n                find: /^(?:---|-|___\\s|\\*\\*\\*\\s)$/,\n                type: this.type\n            })\n        ];\n    }\n});\n// src/index.ts\nvar index_default = HorizontalRule;\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24taG9yaXpvbnRhbC1ydWxlL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLHlCQUF5QjtBQUMyRTtBQUNwQztBQUNoRSxJQUFJTyxpQkFBaUJKLDhDQUFJQSxDQUFDSyxNQUFNLENBQUM7SUFDL0JDLE1BQU07SUFDTkM7UUFDRSxPQUFPO1lBQ0xDLGdCQUFnQixDQUFDO1lBQ2pCQyxjQUFjO1FBQ2hCO0lBQ0Y7SUFDQUMsT0FBTztJQUNQQztRQUNFLE9BQU87WUFBQztnQkFBRUMsS0FBSztZQUFLO1NBQUU7SUFDeEI7SUFDQUMsWUFBVyxFQUFFTCxjQUFjLEVBQUU7UUFDM0IsT0FBTztZQUFDO1lBQU1ULDZEQUFlQSxDQUFDLElBQUksQ0FBQ2UsT0FBTyxDQUFDTixjQUFjLEVBQUVBO1NBQWdCO0lBQzdFO0lBQ0FPLG1CQUFtQjtJQUNuQkMsZUFBZSxDQUFDQyxPQUFPQztRQUNyQixPQUFPQSxRQUFRQyxVQUFVLENBQUM7SUFDNUI7SUFDQUMsZ0JBQWdCO1FBQ2QsT0FBTztJQUNUO0lBQ0FDO1FBQ0UsT0FBTztZQUNMQyxtQkFBbUIsSUFBTSxDQUFDLEVBQUVDLEtBQUssRUFBRUMsS0FBSyxFQUFFO29CQUN4QyxJQUFJLENBQUMzQiwyREFBYUEsQ0FBQzJCLE9BQU9BLE1BQU1DLE1BQU0sQ0FBQ0MsS0FBSyxDQUFDLElBQUksQ0FBQ3BCLElBQUksQ0FBQyxHQUFHO3dCQUN4RCxPQUFPO29CQUNUO29CQUNBLE1BQU0sRUFBRXFCLFNBQVMsRUFBRSxHQUFHSDtvQkFDdEIsTUFBTSxFQUFFSSxLQUFLQyxTQUFTLEVBQUUsR0FBR0Y7b0JBQzNCLE1BQU1HLGVBQWVQO29CQUNyQixJQUFJekIsNkRBQWVBLENBQUM2QixZQUFZO3dCQUM5QkcsYUFBYUMsZUFBZSxDQUFDRixVQUFVRyxHQUFHLEVBQUU7NEJBQzFDQyxNQUFNLElBQUksQ0FBQzNCLElBQUk7d0JBQ2pCO29CQUNGLE9BQU87d0JBQ0x3QixhQUFhSSxhQUFhLENBQUM7NEJBQUVELE1BQU0sSUFBSSxDQUFDM0IsSUFBSTt3QkFBQztvQkFDL0M7b0JBQ0EsT0FBT3dCLGFBQWFLLE9BQU8sQ0FBQyxDQUFDLEVBQUVYLE9BQU9ZLFVBQVUsRUFBRUMsRUFBRSxFQUFFQyxRQUFRLEVBQUU7d0JBQzlELElBQUlBLFVBQVU7NEJBQ1osTUFBTSxFQUFFVixHQUFHLEVBQUUsR0FBR1MsR0FBR1YsU0FBUzs0QkFDNUIsTUFBTVksV0FBV1gsSUFBSVksR0FBRzs0QkFDeEIsSUFBSVosSUFBSWEsU0FBUyxFQUFFO2dDQUNqQixJQUFJYixJQUFJYSxTQUFTLENBQUNDLFdBQVcsRUFBRTtvQ0FDN0JMLEdBQUdNLFlBQVksQ0FBQ3hDLDJEQUFhQSxDQUFDRSxNQUFNLENBQUNnQyxHQUFHTyxHQUFHLEVBQUVoQixJQUFJSSxHQUFHLEdBQUc7Z0NBQ3pELE9BQU8sSUFBSUosSUFBSWEsU0FBUyxDQUFDSSxPQUFPLEVBQUU7b0NBQ2hDUixHQUFHTSxZQUFZLENBQUN6QywyREFBYUEsQ0FBQ0csTUFBTSxDQUFDZ0MsR0FBR08sR0FBRyxFQUFFaEIsSUFBSUksR0FBRztnQ0FDdEQsT0FBTztvQ0FDTEssR0FBR00sWUFBWSxDQUFDeEMsMkRBQWFBLENBQUNFLE1BQU0sQ0FBQ2dDLEdBQUdPLEdBQUcsRUFBRWhCLElBQUlJLEdBQUc7Z0NBQ3REOzRCQUNGLE9BQU87Z0NBQ0wsTUFBTWMsV0FBV1YsV0FBV1gsTUFBTSxDQUFDQyxLQUFLLENBQUMsSUFBSSxDQUFDWixPQUFPLENBQUNMLFlBQVksQ0FBQyxJQUFJbUIsSUFBSW1CLE1BQU0sQ0FBQ2QsSUFBSSxDQUFDZSxZQUFZLENBQUNDLFdBQVc7Z0NBQy9HLE1BQU1DLE9BQU9KLFlBQVksT0FBTyxLQUFLLElBQUlBLFNBQVN6QyxNQUFNO2dDQUN4RCxJQUFJNkMsTUFBTTtvQ0FDUmIsR0FBR2MsTUFBTSxDQUFDWixVQUFVVztvQ0FDcEJiLEdBQUdNLFlBQVksQ0FBQ3hDLDJEQUFhQSxDQUFDRSxNQUFNLENBQUNnQyxHQUFHTyxHQUFHLEVBQUVMLFdBQVc7Z0NBQzFEOzRCQUNGOzRCQUNBRixHQUFHZSxjQUFjO3dCQUNuQjt3QkFDQSxPQUFPO29CQUNULEdBQUdDLEdBQUc7Z0JBQ1I7UUFDRjtJQUNGO0lBQ0FDO1FBQ0UsT0FBTztZQUNMckQsMkRBQWFBLENBQUM7Z0JBQ1pzRCxNQUFNO2dCQUNOdEIsTUFBTSxJQUFJLENBQUNBLElBQUk7WUFDakI7U0FDRDtJQUNIO0FBQ0Y7QUFFQSxlQUFlO0FBQ2YsSUFBSXVCLGdCQUFnQnBEO0FBSWxCLENBQ0YsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJhc29icGFpLXdlYi8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1ob3Jpem9udGFsLXJ1bGUvZGlzdC9pbmRleC5qcz8yNzAxIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9ob3Jpem9udGFsLXJ1bGUudHNcbmltcG9ydCB7IGNhbkluc2VydE5vZGUsIGlzTm9kZVNlbGVjdGlvbiwgbWVyZ2VBdHRyaWJ1dGVzLCBOb2RlLCBub2RlSW5wdXRSdWxlIH0gZnJvbSBcIkB0aXB0YXAvY29yZVwiO1xuaW1wb3J0IHsgTm9kZVNlbGVjdGlvbiwgVGV4dFNlbGVjdGlvbiB9IGZyb20gXCJAdGlwdGFwL3BtL3N0YXRlXCI7XG52YXIgSG9yaXpvbnRhbFJ1bGUgPSBOb2RlLmNyZWF0ZSh7XG4gIG5hbWU6IFwiaG9yaXpvbnRhbFJ1bGVcIixcbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgICAgbmV4dE5vZGVUeXBlOiBcInBhcmFncmFwaFwiXG4gICAgfTtcbiAgfSxcbiAgZ3JvdXA6IFwiYmxvY2tcIixcbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbeyB0YWc6IFwiaHJcIiB9XTtcbiAgfSxcbiAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICByZXR1cm4gW1wiaHJcIiwgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpXTtcbiAgfSxcbiAgbWFya2Rvd25Ub2tlbk5hbWU6IFwiaHJcIixcbiAgcGFyc2VNYXJrZG93bjogKHRva2VuLCBoZWxwZXJzKSA9PiB7XG4gICAgcmV0dXJuIGhlbHBlcnMuY3JlYXRlTm9kZShcImhvcml6b250YWxSdWxlXCIpO1xuICB9LFxuICByZW5kZXJNYXJrZG93bjogKCkgPT4ge1xuICAgIHJldHVybiBcIi0tLVwiO1xuICB9LFxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2V0SG9yaXpvbnRhbFJ1bGU6ICgpID0+ICh7IGNoYWluLCBzdGF0ZSB9KSA9PiB7XG4gICAgICAgIGlmICghY2FuSW5zZXJ0Tm9kZShzdGF0ZSwgc3RhdGUuc2NoZW1hLm5vZGVzW3RoaXMubmFtZV0pKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSBzdGF0ZTtcbiAgICAgICAgY29uc3QgeyAkdG86ICRvcmlnaW5UbyB9ID0gc2VsZWN0aW9uO1xuICAgICAgICBjb25zdCBjdXJyZW50Q2hhaW4gPSBjaGFpbigpO1xuICAgICAgICBpZiAoaXNOb2RlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICBjdXJyZW50Q2hhaW4uaW5zZXJ0Q29udGVudEF0KCRvcmlnaW5Uby5wb3MsIHtcbiAgICAgICAgICAgIHR5cGU6IHRoaXMubmFtZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1cnJlbnRDaGFpbi5pbnNlcnRDb250ZW50KHsgdHlwZTogdGhpcy5uYW1lIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdXJyZW50Q2hhaW4uY29tbWFuZCgoeyBzdGF0ZTogY2hhaW5TdGF0ZSwgdHIsIGRpc3BhdGNoIH0pID0+IHtcbiAgICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgJHRvIH0gPSB0ci5zZWxlY3Rpb247XG4gICAgICAgICAgICBjb25zdCBwb3NBZnRlciA9ICR0by5lbmQoKTtcbiAgICAgICAgICAgIGlmICgkdG8ubm9kZUFmdGVyKSB7XG4gICAgICAgICAgICAgIGlmICgkdG8ubm9kZUFmdGVyLmlzVGV4dGJsb2NrKSB7XG4gICAgICAgICAgICAgICAgdHIuc2V0U2VsZWN0aW9uKFRleHRTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgJHRvLnBvcyArIDEpKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICgkdG8ubm9kZUFmdGVyLmlzQmxvY2spIHtcbiAgICAgICAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24oTm9kZVNlbGVjdGlvbi5jcmVhdGUodHIuZG9jLCAkdG8ucG9zKSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdHIuc2V0U2VsZWN0aW9uKFRleHRTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgJHRvLnBvcykpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zdCBub2RlVHlwZSA9IGNoYWluU3RhdGUuc2NoZW1hLm5vZGVzW3RoaXMub3B0aW9ucy5uZXh0Tm9kZVR5cGVdIHx8ICR0by5wYXJlbnQudHlwZS5jb250ZW50TWF0Y2guZGVmYXVsdFR5cGU7XG4gICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBub2RlVHlwZSA9PSBudWxsID8gdm9pZCAwIDogbm9kZVR5cGUuY3JlYXRlKCk7XG4gICAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgdHIuaW5zZXJ0KHBvc0FmdGVyLCBub2RlKTtcbiAgICAgICAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24oVGV4dFNlbGVjdGlvbi5jcmVhdGUodHIuZG9jLCBwb3NBZnRlciArIDEpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHIuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pLnJ1bigpO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIGFkZElucHV0UnVsZXMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG5vZGVJbnB1dFJ1bGUoe1xuICAgICAgICBmaW5kOiAvXig/Oi0tLXzigJQtfF9fX1xcc3xcXCpcXCpcXCpcXHMpJC8sXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZVxuICAgICAgfSlcbiAgICBdO1xuICB9XG59KTtcblxuLy8gc3JjL2luZGV4LnRzXG52YXIgaW5kZXhfZGVmYXVsdCA9IEhvcml6b250YWxSdWxlO1xuZXhwb3J0IHtcbiAgSG9yaXpvbnRhbFJ1bGUsXG4gIGluZGV4X2RlZmF1bHQgYXMgZGVmYXVsdFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJjYW5JbnNlcnROb2RlIiwiaXNOb2RlU2VsZWN0aW9uIiwibWVyZ2VBdHRyaWJ1dGVzIiwiTm9kZSIsIm5vZGVJbnB1dFJ1bGUiLCJOb2RlU2VsZWN0aW9uIiwiVGV4dFNlbGVjdGlvbiIsIkhvcml6b250YWxSdWxlIiwiY3JlYXRlIiwibmFtZSIsImFkZE9wdGlvbnMiLCJIVE1MQXR0cmlidXRlcyIsIm5leHROb2RlVHlwZSIsImdyb3VwIiwicGFyc2VIVE1MIiwidGFnIiwicmVuZGVySFRNTCIsIm9wdGlvbnMiLCJtYXJrZG93blRva2VuTmFtZSIsInBhcnNlTWFya2Rvd24iLCJ0b2tlbiIsImhlbHBlcnMiLCJjcmVhdGVOb2RlIiwicmVuZGVyTWFya2Rvd24iLCJhZGRDb21tYW5kcyIsInNldEhvcml6b250YWxSdWxlIiwiY2hhaW4iLCJzdGF0ZSIsInNjaGVtYSIsIm5vZGVzIiwic2VsZWN0aW9uIiwiJHRvIiwiJG9yaWdpblRvIiwiY3VycmVudENoYWluIiwiaW5zZXJ0Q29udGVudEF0IiwicG9zIiwidHlwZSIsImluc2VydENvbnRlbnQiLCJjb21tYW5kIiwiY2hhaW5TdGF0ZSIsInRyIiwiZGlzcGF0Y2giLCJwb3NBZnRlciIsImVuZCIsIm5vZGVBZnRlciIsImlzVGV4dGJsb2NrIiwic2V0U2VsZWN0aW9uIiwiZG9jIiwiaXNCbG9jayIsIm5vZGVUeXBlIiwicGFyZW50IiwiY29udGVudE1hdGNoIiwiZGVmYXVsdFR5cGUiLCJub2RlIiwiaW5zZXJ0Iiwic2Nyb2xsSW50b1ZpZXciLCJydW4iLCJhZGRJbnB1dFJ1bGVzIiwiZmluZCIsImluZGV4X2RlZmF1bHQiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-horizontal-rule/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-image/dist/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@tiptap/extension-image/dist/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Image: () => (/* binding */ Image),\n/* harmony export */   \"default\": () => (/* binding */ index_default),\n/* harmony export */   inputRegex: () => (/* binding */ inputRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n// src/image.ts\n\nvar inputRegex = /(?:^|\\s)(!\\[(.+|:?)]\\((\\S+)(?:(?:\\s+)[\"'](\\S+)[\"'])?\\))$/;\nvar Image = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n    name: \"image\",\n    addOptions () {\n        return {\n            inline: false,\n            allowBase64: false,\n            HTMLAttributes: {},\n            resize: false\n        };\n    },\n    inline () {\n        return this.options.inline;\n    },\n    group () {\n        return this.options.inline ? \"inline\" : \"block\";\n    },\n    draggable: true,\n    addAttributes () {\n        return {\n            src: {\n                default: null\n            },\n            alt: {\n                default: null\n            },\n            title: {\n                default: null\n            },\n            width: {\n                default: null\n            },\n            height: {\n                default: null\n            }\n        };\n    },\n    parseHTML () {\n        return [\n            {\n                tag: this.options.allowBase64 ? \"img[src]\" : 'img[src]:not([src^=\"data:\"])'\n            }\n        ];\n    },\n    renderHTML ({ HTMLAttributes }) {\n        return [\n            \"img\",\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes)\n        ];\n    },\n    parseMarkdown: (token, helpers)=>{\n        return helpers.createNode(\"image\", {\n            src: token.href,\n            title: token.title,\n            alt: token.text\n        });\n    },\n    renderMarkdown: (node)=>{\n        var _a, _b, _c, _d, _e, _f;\n        const src = (_b = (_a = node.attrs) == null ? void 0 : _a.src) != null ? _b : \"\";\n        const alt = (_d = (_c = node.attrs) == null ? void 0 : _c.alt) != null ? _d : \"\";\n        const title = (_f = (_e = node.attrs) == null ? void 0 : _e.title) != null ? _f : \"\";\n        return title ? `![${alt}](${src} \"${title}\")` : `![${alt}](${src})`;\n    },\n    addNodeView () {\n        if (!this.options.resize || !this.options.resize.enabled || typeof document === \"undefined\") {\n            return null;\n        }\n        const { directions, minWidth, minHeight, alwaysPreserveAspectRatio } = this.options.resize;\n        return ({ node, getPos, HTMLAttributes, editor })=>{\n            const el = document.createElement(\"img\");\n            Object.entries(HTMLAttributes).forEach(([key, value])=>{\n                if (value != null) {\n                    switch(key){\n                        case \"width\":\n                        case \"height\":\n                            break;\n                        default:\n                            el.setAttribute(key, value);\n                            break;\n                    }\n                }\n            });\n            el.src = HTMLAttributes.src;\n            const nodeView = new _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.ResizableNodeView({\n                element: el,\n                editor,\n                node,\n                getPos,\n                onResize: (width, height)=>{\n                    el.style.width = `${width}px`;\n                    el.style.height = `${height}px`;\n                },\n                onCommit: (width, height)=>{\n                    const pos = getPos();\n                    if (pos === void 0) {\n                        return;\n                    }\n                    this.editor.chain().setNodeSelection(pos).updateAttributes(this.name, {\n                        width,\n                        height\n                    }).run();\n                },\n                onUpdate: (updatedNode, _decorations, _innerDecorations)=>{\n                    if (updatedNode.type !== node.type) {\n                        return false;\n                    }\n                    return true;\n                },\n                options: {\n                    directions,\n                    min: {\n                        width: minWidth,\n                        height: minHeight\n                    },\n                    preserveAspectRatio: alwaysPreserveAspectRatio === true\n                }\n            });\n            const dom = nodeView.dom;\n            dom.style.visibility = \"hidden\";\n            dom.style.pointerEvents = \"none\";\n            el.onload = ()=>{\n                dom.style.visibility = \"\";\n                dom.style.pointerEvents = \"\";\n            };\n            return nodeView;\n        };\n    },\n    addCommands () {\n        return {\n            setImage: (options)=>({ commands })=>{\n                    return commands.insertContent({\n                        type: this.name,\n                        attrs: options\n                    });\n                }\n        };\n    },\n    addInputRules () {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.nodeInputRule)({\n                find: inputRegex,\n                type: this.type,\n                getAttributes: (match)=>{\n                    const [, , alt, src, title] = match;\n                    return {\n                        src,\n                        alt,\n                        title\n                    };\n                }\n            })\n        ];\n    }\n});\n// src/index.ts\nvar index_default = Image;\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24taW1hZ2UvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUEsZUFBZTtBQUN3RTtBQUN2RixJQUFJSSxhQUFhO0FBQ2pCLElBQUlDLFFBQVFKLDhDQUFJQSxDQUFDSyxNQUFNLENBQUM7SUFDdEJDLE1BQU07SUFDTkM7UUFDRSxPQUFPO1lBQ0xDLFFBQVE7WUFDUkMsYUFBYTtZQUNiQyxnQkFBZ0IsQ0FBQztZQUNqQkMsUUFBUTtRQUNWO0lBQ0Y7SUFDQUg7UUFDRSxPQUFPLElBQUksQ0FBQ0ksT0FBTyxDQUFDSixNQUFNO0lBQzVCO0lBQ0FLO1FBQ0UsT0FBTyxJQUFJLENBQUNELE9BQU8sQ0FBQ0osTUFBTSxHQUFHLFdBQVc7SUFDMUM7SUFDQU0sV0FBVztJQUNYQztRQUNFLE9BQU87WUFDTEMsS0FBSztnQkFDSEMsU0FBUztZQUNYO1lBQ0FDLEtBQUs7Z0JBQ0hELFNBQVM7WUFDWDtZQUNBRSxPQUFPO2dCQUNMRixTQUFTO1lBQ1g7WUFDQUcsT0FBTztnQkFDTEgsU0FBUztZQUNYO1lBQ0FJLFFBQVE7Z0JBQ05KLFNBQVM7WUFDWDtRQUNGO0lBQ0Y7SUFDQUs7UUFDRSxPQUFPO1lBQ0w7Z0JBQ0VDLEtBQUssSUFBSSxDQUFDWCxPQUFPLENBQUNILFdBQVcsR0FBRyxhQUFhO1lBQy9DO1NBQ0Q7SUFDSDtJQUNBZSxZQUFXLEVBQUVkLGNBQWMsRUFBRTtRQUMzQixPQUFPO1lBQUM7WUFBT1gsNkRBQWVBLENBQUMsSUFBSSxDQUFDYSxPQUFPLENBQUNGLGNBQWMsRUFBRUE7U0FBZ0I7SUFDOUU7SUFDQWUsZUFBZSxDQUFDQyxPQUFPQztRQUNyQixPQUFPQSxRQUFRQyxVQUFVLENBQUMsU0FBUztZQUNqQ1osS0FBS1UsTUFBTUcsSUFBSTtZQUNmVixPQUFPTyxNQUFNUCxLQUFLO1lBQ2xCRCxLQUFLUSxNQUFNSSxJQUFJO1FBQ2pCO0lBQ0Y7SUFDQUMsZ0JBQWdCLENBQUNDO1FB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Z0IsYUFBYSxHQUFHO1lBQzFCM0IsR0FBRzRCLE1BQU0sR0FBRztnQkFDVkgsSUFBSWQsS0FBSyxDQUFDZSxVQUFVLEdBQUc7Z0JBQ3ZCRCxJQUFJZCxLQUFLLENBQUNnQixhQUFhLEdBQUc7WUFDNUI7WUFDQSxPQUFPbkI7UUFDVDtJQUNGO0lBQ0FxQjtRQUNFLE9BQU87WUFDTEMsVUFBVSxDQUFDbkUsVUFBWSxDQUFDLEVBQUVvRSxRQUFRLEVBQUU7b0JBQ2xDLE9BQU9BLFNBQVNDLGFBQWEsQ0FBQzt3QkFDNUJWLE1BQU0sSUFBSSxDQUFDakUsSUFBSTt3QkFDZmlDLE9BQU8zQjtvQkFDVDtnQkFDRjtRQUNGO0lBQ0Y7SUFDQXNFO1FBQ0UsT0FBTztZQUNMakYsMkRBQWFBLENBQUM7Z0JBQ1prRixNQUFNaEY7Z0JBQ05vRSxNQUFNLElBQUksQ0FBQ0EsSUFBSTtnQkFDZmEsZUFBZSxDQUFDQztvQkFDZCxNQUFNLEtBQUtuRSxLQUFLRixLQUFLRyxNQUFNLEdBQUdrRTtvQkFDOUIsT0FBTzt3QkFBRXJFO3dCQUFLRTt3QkFBS0M7b0JBQU07Z0JBQzNCO1lBQ0Y7U0FDRDtJQUNIO0FBQ0Y7QUFFQSxlQUFlO0FBQ2YsSUFBSW1FLGdCQUFnQmxGO0FBS2xCLENBQ0YsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJhc29icGFpLXdlYi8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1pbWFnZS9kaXN0L2luZGV4LmpzPzY3NmYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2ltYWdlLnRzXG5pbXBvcnQgeyBtZXJnZUF0dHJpYnV0ZXMsIE5vZGUsIG5vZGVJbnB1dFJ1bGUsIFJlc2l6YWJsZU5vZGVWaWV3IH0gZnJvbSBcIkB0aXB0YXAvY29yZVwiO1xudmFyIGlucHV0UmVnZXggPSAvKD86XnxcXHMpKCFcXFsoLit8Oj8pXVxcKChcXFMrKSg/Oig/OlxccyspW1wiJ10oXFxTKylbXCInXSk/XFwpKSQvO1xudmFyIEltYWdlID0gTm9kZS5jcmVhdGUoe1xuICBuYW1lOiBcImltYWdlXCIsXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlubGluZTogZmFsc2UsXG4gICAgICBhbGxvd0Jhc2U2NDogZmFsc2UsXG4gICAgICBIVE1MQXR0cmlidXRlczoge30sXG4gICAgICByZXNpemU6IGZhbHNlXG4gICAgfTtcbiAgfSxcbiAgaW5saW5lKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuaW5saW5lO1xuICB9LFxuICBncm91cCgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmlubGluZSA/IFwiaW5saW5lXCIgOiBcImJsb2NrXCI7XG4gIH0sXG4gIGRyYWdnYWJsZTogdHJ1ZSxcbiAgYWRkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3JjOiB7XG4gICAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICAgIH0sXG4gICAgICBhbHQ6IHtcbiAgICAgICAgZGVmYXVsdDogbnVsbFxuICAgICAgfSxcbiAgICAgIHRpdGxlOiB7XG4gICAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICAgIH0sXG4gICAgICB3aWR0aDoge1xuICAgICAgICBkZWZhdWx0OiBudWxsXG4gICAgICB9LFxuICAgICAgaGVpZ2h0OiB7XG4gICAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBwYXJzZUhUTUwoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgdGFnOiB0aGlzLm9wdGlvbnMuYWxsb3dCYXNlNjQgPyBcImltZ1tzcmNdXCIgOiAnaW1nW3NyY106bm90KFtzcmNePVwiZGF0YTpcIl0pJ1xuICAgICAgfVxuICAgIF07XG4gIH0sXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgcmV0dXJuIFtcImltZ1wiLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyldO1xuICB9LFxuICBwYXJzZU1hcmtkb3duOiAodG9rZW4sIGhlbHBlcnMpID0+IHtcbiAgICByZXR1cm4gaGVscGVycy5jcmVhdGVOb2RlKFwiaW1hZ2VcIiwge1xuICAgICAgc3JjOiB0b2tlbi5ocmVmLFxuICAgICAgdGl0bGU6IHRva2VuLnRpdGxlLFxuICAgICAgYWx0OiB0b2tlbi50ZXh0XG4gICAgfSk7XG4gIH0sXG4gIHJlbmRlck1hcmtkb3duOiAobm9kZSkgPT4ge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgIGNvbnN0IHNyYyA9IChfYiA9IChfYSA9IG5vZGUuYXR0cnMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5zcmMpICE9IG51bGwgPyBfYiA6IFwiXCI7XG4gICAgY29uc3QgYWx0ID0gKF9kID0gKF9jID0gbm9kZS5hdHRycykgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLmFsdCkgIT0gbnVsbCA/IF9kIDogXCJcIjtcbiAgICBjb25zdCB0aXRsZSA9IChfZiA9IChfZSA9IG5vZGUuYXR0cnMpID09IG51bGwgPyB2b2lkIDAgOiBfZS50aXRsZSkgIT0gbnVsbCA/IF9mIDogXCJcIjtcbiAgICByZXR1cm4gdGl0bGUgPyBgIVske2FsdH1dKCR7c3JjfSBcIiR7dGl0bGV9XCIpYCA6IGAhWyR7YWx0fV0oJHtzcmN9KWA7XG4gIH0sXG4gIGFkZE5vZGVWaWV3KCkge1xuICAgIGlmICghdGhpcy5vcHRpb25zLnJlc2l6ZSB8fCAhdGhpcy5vcHRpb25zLnJlc2l6ZS5lbmFibGVkIHx8IHR5cGVvZiBkb2N1bWVudCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHsgZGlyZWN0aW9ucywgbWluV2lkdGgsIG1pbkhlaWdodCwgYWx3YXlzUHJlc2VydmVBc3BlY3RSYXRpbyB9ID0gdGhpcy5vcHRpb25zLnJlc2l6ZTtcbiAgICByZXR1cm4gKHsgbm9kZSwgZ2V0UG9zLCBIVE1MQXR0cmlidXRlcywgZWRpdG9yIH0pID0+IHtcbiAgICAgIGNvbnN0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcbiAgICAgIE9iamVjdC5lbnRyaWVzKEhUTUxBdHRyaWJ1dGVzKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgICAgY2FzZSBcIndpZHRoXCI6XG4gICAgICAgICAgICBjYXNlIFwiaGVpZ2h0XCI6XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZWwuc3JjID0gSFRNTEF0dHJpYnV0ZXMuc3JjO1xuICAgICAgY29uc3Qgbm9kZVZpZXcgPSBuZXcgUmVzaXphYmxlTm9kZVZpZXcoe1xuICAgICAgICBlbGVtZW50OiBlbCxcbiAgICAgICAgZWRpdG9yLFxuICAgICAgICBub2RlLFxuICAgICAgICBnZXRQb3MsXG4gICAgICAgIG9uUmVzaXplOiAod2lkdGgsIGhlaWdodCkgPT4ge1xuICAgICAgICAgIGVsLnN0eWxlLndpZHRoID0gYCR7d2lkdGh9cHhgO1xuICAgICAgICAgIGVsLnN0eWxlLmhlaWdodCA9IGAke2hlaWdodH1weGA7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQ29tbWl0OiAod2lkdGgsIGhlaWdodCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHBvcyA9IGdldFBvcygpO1xuICAgICAgICAgIGlmIChwb3MgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmVkaXRvci5jaGFpbigpLnNldE5vZGVTZWxlY3Rpb24ocG9zKS51cGRhdGVBdHRyaWJ1dGVzKHRoaXMubmFtZSwge1xuICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHRcbiAgICAgICAgICB9KS5ydW4oKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25VcGRhdGU6ICh1cGRhdGVkTm9kZSwgX2RlY29yYXRpb25zLCBfaW5uZXJEZWNvcmF0aW9ucykgPT4ge1xuICAgICAgICAgIGlmICh1cGRhdGVkTm9kZS50eXBlICE9PSBub2RlLnR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICBkaXJlY3Rpb25zLFxuICAgICAgICAgIG1pbjoge1xuICAgICAgICAgICAgd2lkdGg6IG1pbldpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBtaW5IZWlnaHRcbiAgICAgICAgICB9LFxuICAgICAgICAgIHByZXNlcnZlQXNwZWN0UmF0aW86IGFsd2F5c1ByZXNlcnZlQXNwZWN0UmF0aW8gPT09IHRydWVcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjb25zdCBkb20gPSBub2RlVmlldy5kb207XG4gICAgICBkb20uc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XG4gICAgICBkb20uc3R5bGUucG9pbnRlckV2ZW50cyA9IFwibm9uZVwiO1xuICAgICAgZWwub25sb2FkID0gKCkgPT4ge1xuICAgICAgICBkb20uc3R5bGUudmlzaWJpbGl0eSA9IFwiXCI7XG4gICAgICAgIGRvbS5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJcIjtcbiAgICAgIH07XG4gICAgICByZXR1cm4gbm9kZVZpZXc7XG4gICAgfTtcbiAgfSxcbiAgYWRkQ29tbWFuZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNldEltYWdlOiAob3B0aW9ucykgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICByZXR1cm4gY29tbWFuZHMuaW5zZXJ0Q29udGVudCh7XG4gICAgICAgICAgdHlwZTogdGhpcy5uYW1lLFxuICAgICAgICAgIGF0dHJzOiBvcHRpb25zXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIGFkZElucHV0UnVsZXMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG5vZGVJbnB1dFJ1bGUoe1xuICAgICAgICBmaW5kOiBpbnB1dFJlZ2V4LFxuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgIGdldEF0dHJpYnV0ZXM6IChtYXRjaCkgPT4ge1xuICAgICAgICAgIGNvbnN0IFssICwgYWx0LCBzcmMsIHRpdGxlXSA9IG1hdGNoO1xuICAgICAgICAgIHJldHVybiB7IHNyYywgYWx0LCB0aXRsZSB9O1xuICAgICAgICB9XG4gICAgICB9KVxuICAgIF07XG4gIH1cbn0pO1xuXG4vLyBzcmMvaW5kZXgudHNcbnZhciBpbmRleF9kZWZhdWx0ID0gSW1hZ2U7XG5leHBvcnQge1xuICBJbWFnZSxcbiAgaW5kZXhfZGVmYXVsdCBhcyBkZWZhdWx0LFxuICBpbnB1dFJlZ2V4XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIm1lcmdlQXR0cmlidXRlcyIsIk5vZGUiLCJub2RlSW5wdXRSdWxlIiwiUmVzaXphYmxlTm9kZVZpZXciLCJpbnB1dFJlZ2V4IiwiSW1hZ2UiLCJjcmVhdGUiLCJuYW1lIiwiYWRkT3B0aW9ucyIsImlubGluZSIsImFsbG93QmFzZTY0IiwiSFRNTEF0dHJpYnV0ZXMiLCJyZXNpemUiLCJvcHRpb25zIiwiZ3JvdXAiLCJkcmFnZ2FibGUiLCJhZGRBdHRyaWJ1dGVzIiwic3JjIiwiZGVmYXVsdCIsImFsdCIsInRpdGxlIiwid2lkdGgiLCJoZWlnaHQiLCJwYXJzZUhUTUwiLCJ0YWciLCJyZW5kZXJIVE1MIiwicGFyc2VNYXJrZG93biIsInRva2VuIiwiaGVscGVycyIsImNyZWF0ZU5vZGUiLCJocmVmIiwidGV4dCIsInJlbmRlck1hcmtkb3duIiwibm9kZSIsIl9hIiwiX2IiLCJfYyIsIl9kIiwiX2UiLCJfZiIsImF0dHJzIiwiYWRkTm9kZVZpZXciLCJlbmFibGVkIiwiZG9jdW1lbnQiLCJkaXJlY3Rpb25zIiwibWluV2lkdGgiLCJtaW5IZWlnaHQiLCJhbHdheXNQcmVzZXJ2ZUFzcGVjdFJhdGlvIiwiZ2V0UG9zIiwiZWRpdG9yIiwiZWwiLCJjcmVhdGVFbGVtZW50IiwiT2JqZWN0IiwiZW50cmllcyIsImZvckVhY2giLCJrZXkiLCJ2YWx1ZSIsInNldEF0dHJpYnV0ZSIsIm5vZGVWaWV3IiwiZWxlbWVudCIsIm9uUmVzaXplIiwic3R5bGUiLCJvbkNvbW1pdCIsInBvcyIsImNoYWluIiwic2V0Tm9kZVNlbGVjdGlvbiIsInVwZGF0ZUF0dHJpYnV0ZXMiLCJydW4iLCJvblVwZGF0ZSIsInVwZGF0ZWROb2RlIiwiX2RlY29yYXRpb25zIiwiX2lubmVyRGVjb3JhdGlvbnMiLCJ0eXBlIiwibWluIiwicHJlc2VydmVBc3BlY3RSYXRpbyIsImRvbSIsInZpc2liaWxpdHkiLCJwb2ludGVyRXZlbnRzIiwib25sb2FkIiwiYWRkQ29tbWFuZHMiLCJzZXRJbWFnZSIsImNvbW1hbmRzIiwiaW5zZXJ0Q29udGVudCIsImFkZElucHV0UnVsZXMiLCJmaW5kIiwiZ2V0QXR0cmlidXRlcyIsIm1hdGNoIiwiaW5kZXhfZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-image/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-italic/dist/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@tiptap/extension-italic/dist/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Italic: () => (/* binding */ Italic),\n/* harmony export */   \"default\": () => (/* binding */ index_default),\n/* harmony export */   starInputRegex: () => (/* binding */ starInputRegex),\n/* harmony export */   starPasteRegex: () => (/* binding */ starPasteRegex),\n/* harmony export */   underscoreInputRegex: () => (/* binding */ underscoreInputRegex),\n/* harmony export */   underscorePasteRegex: () => (/* binding */ underscorePasteRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n// src/italic.ts\n\nvar starInputRegex = /(?:^|\\s)(\\*(?!\\s+\\*)((?:[^*]+))\\*(?!\\s+\\*))$/;\nvar starPasteRegex = /(?:^|\\s)(\\*(?!\\s+\\*)((?:[^*]+))\\*(?!\\s+\\*))/g;\nvar underscoreInputRegex = /(?:^|\\s)(_(?!\\s+_)((?:[^_]+))_(?!\\s+_))$/;\nvar underscorePasteRegex = /(?:^|\\s)(_(?!\\s+_)((?:[^_]+))_(?!\\s+_))/g;\nvar Italic = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Mark.create({\n    name: \"italic\",\n    addOptions () {\n        return {\n            HTMLAttributes: {}\n        };\n    },\n    parseHTML () {\n        return [\n            {\n                tag: \"em\"\n            },\n            {\n                tag: \"i\",\n                getAttrs: (node)=>node.style.fontStyle !== \"normal\" && null\n            },\n            {\n                style: \"font-style=normal\",\n                clearMark: (mark)=>mark.type.name === this.name\n            },\n            {\n                style: \"font-style=italic\"\n            }\n        ];\n    },\n    renderHTML ({ HTMLAttributes }) {\n        return [\n            \"em\",\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes),\n            0\n        ];\n    },\n    addCommands () {\n        return {\n            setItalic: ()=>({ commands })=>{\n                    return commands.setMark(this.name);\n                },\n            toggleItalic: ()=>({ commands })=>{\n                    return commands.toggleMark(this.name);\n                },\n            unsetItalic: ()=>({ commands })=>{\n                    return commands.unsetMark(this.name);\n                }\n        };\n    },\n    markdownTokenName: \"em\",\n    parseMarkdown: (token, helpers)=>{\n        return helpers.applyMark(\"italic\", helpers.parseInline(token.tokens || []));\n    },\n    renderMarkdown: (node, h)=>{\n        return `*${h.renderChildren(node)}*`;\n    },\n    addKeyboardShortcuts () {\n        return {\n            \"Mod-i\": ()=>this.editor.commands.toggleItalic(),\n            \"Mod-I\": ()=>this.editor.commands.toggleItalic()\n        };\n    },\n    addInputRules () {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({\n                find: starInputRegex,\n                type: this.type\n            }),\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({\n                find: underscoreInputRegex,\n                type: this.type\n            })\n        ];\n    },\n    addPasteRules () {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({\n                find: starPasteRegex,\n                type: this.type\n            }),\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({\n                find: underscorePasteRegex,\n                type: this.type\n            })\n        ];\n    }\n});\n// src/index.ts\nvar index_default = Italic;\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24taXRhbGljL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBLGdCQUFnQjtBQUNtRTtBQUNuRixJQUFJSSxpQkFBaUI7QUFDckIsSUFBSUMsaUJBQWlCO0FBQ3JCLElBQUlDLHVCQUF1QjtBQUMzQixJQUFJQyx1QkFBdUI7QUFDM0IsSUFBSUMsU0FBU1IsOENBQUlBLENBQUNTLE1BQU0sQ0FBQztJQUN2QkMsTUFBTTtJQUNOQztRQUNFLE9BQU87WUFDTEMsZ0JBQWdCLENBQUM7UUFDbkI7SUFDRjtJQUNBQztRQUNFLE9BQU87WUFDTDtnQkFDRUMsS0FBSztZQUNQO1lBQ0E7Z0JBQ0VBLEtBQUs7Z0JBQ0xDLFVBQVUsQ0FBQ0MsT0FBU0EsS0FBS0MsS0FBSyxDQUFDQyxTQUFTLEtBQUssWUFBWTtZQUMzRDtZQUNBO2dCQUNFRCxPQUFPO2dCQUNQRSxXQUFXLENBQUNDLE9BQVNBLEtBQUtDLElBQUksQ0FBQ1gsSUFBSSxLQUFLLElBQUksQ0FBQ0EsSUFBSTtZQUNuRDtZQUNBO2dCQUNFTyxPQUFPO1lBQ1Q7U0FDRDtJQUNIO0lBQ0FLLFlBQVcsRUFBRVYsY0FBYyxFQUFFO1FBQzNCLE9BQU87WUFBQztZQUFNVCw2REFBZUEsQ0FBQyxJQUFJLENBQUNvQixPQUFPLENBQUNYLGNBQWMsRUFBRUE7WUFBaUI7U0FBRTtJQUNoRjtJQUNBWTtRQUNFLE9BQU87WUFDTEMsV0FBVyxJQUFNLENBQUMsRUFBRUMsUUFBUSxFQUFFO29CQUM1QixPQUFPQSxTQUFTQyxPQUFPLENBQUMsSUFBSSxDQUFDakIsSUFBSTtnQkFDbkM7WUFDQWtCLGNBQWMsSUFBTSxDQUFDLEVBQUVGLFFBQVEsRUFBRTtvQkFDL0IsT0FBT0EsU0FBU0csVUFBVSxDQUFDLElBQUksQ0FBQ25CLElBQUk7Z0JBQ3RDO1lBQ0FvQixhQUFhLElBQU0sQ0FBQyxFQUFFSixRQUFRLEVBQUU7b0JBQzlCLE9BQU9BLFNBQVNLLFNBQVMsQ0FBQyxJQUFJLENBQUNyQixJQUFJO2dCQUNyQztRQUNGO0lBQ0Y7SUFDQXNCLG1CQUFtQjtJQUNuQkMsZUFBZSxDQUFDQyxPQUFPQztRQUNyQixPQUFPQSxRQUFRQyxTQUFTLENBQUMsVUFBVUQsUUFBUUUsV0FBVyxDQUFDSCxNQUFNSSxNQUFNLElBQUksRUFBRTtJQUMzRTtJQUNBQyxnQkFBZ0IsQ0FBQ3ZCLE1BQU13QjtRQUNyQixPQUFPLENBQUMsQ0FBQyxFQUFFQSxFQUFFQyxjQUFjLENBQUN6QixNQUFNLENBQUMsQ0FBQztJQUN0QztJQUNBMEI7UUFDRSxPQUFPO1lBQ0wsU0FBUyxJQUFNLElBQUksQ0FBQ0MsTUFBTSxDQUFDakIsUUFBUSxDQUFDRSxZQUFZO1lBQ2hELFNBQVMsSUFBTSxJQUFJLENBQUNlLE1BQU0sQ0FBQ2pCLFFBQVEsQ0FBQ0UsWUFBWTtRQUNsRDtJQUNGO0lBQ0FnQjtRQUNFLE9BQU87WUFDTDNDLDJEQUFhQSxDQUFDO2dCQUNaNEMsTUFBTXpDO2dCQUNOaUIsTUFBTSxJQUFJLENBQUNBLElBQUk7WUFDakI7WUFDQXBCLDJEQUFhQSxDQUFDO2dCQUNaNEMsTUFBTXZDO2dCQUNOZSxNQUFNLElBQUksQ0FBQ0EsSUFBSTtZQUNqQjtTQUNEO0lBQ0g7SUFDQXlCO1FBQ0UsT0FBTztZQUNMNUMsMkRBQWFBLENBQUM7Z0JBQ1oyQyxNQUFNeEM7Z0JBQ05nQixNQUFNLElBQUksQ0FBQ0EsSUFBSTtZQUNqQjtZQUNBbkIsMkRBQWFBLENBQUM7Z0JBQ1oyQyxNQUFNdEM7Z0JBQ05jLE1BQU0sSUFBSSxDQUFDQSxJQUFJO1lBQ2pCO1NBQ0Q7SUFDSDtBQUNGO0FBRUEsZUFBZTtBQUNmLElBQUkwQixnQkFBZ0J2QztBQVFsQixDQUNGLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3ByYXNvYnBhaS13ZWIvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24taXRhbGljL2Rpc3QvaW5kZXguanM/MTM3NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvaXRhbGljLnRzXG5pbXBvcnQgeyBNYXJrLCBtYXJrSW5wdXRSdWxlLCBtYXJrUGFzdGVSdWxlLCBtZXJnZUF0dHJpYnV0ZXMgfSBmcm9tIFwiQHRpcHRhcC9jb3JlXCI7XG52YXIgc3RhcklucHV0UmVnZXggPSAvKD86XnxcXHMpKFxcKig/IVxccytcXCopKCg/OlteKl0rKSlcXCooPyFcXHMrXFwqKSkkLztcbnZhciBzdGFyUGFzdGVSZWdleCA9IC8oPzpefFxccykoXFwqKD8hXFxzK1xcKikoKD86W14qXSspKVxcKig/IVxccytcXCopKS9nO1xudmFyIHVuZGVyc2NvcmVJbnB1dFJlZ2V4ID0gLyg/Ol58XFxzKShfKD8hXFxzK18pKCg/OlteX10rKSlfKD8hXFxzK18pKSQvO1xudmFyIHVuZGVyc2NvcmVQYXN0ZVJlZ2V4ID0gLyg/Ol58XFxzKShfKD8hXFxzK18pKCg/OlteX10rKSlfKD8hXFxzK18pKS9nO1xudmFyIEl0YWxpYyA9IE1hcmsuY3JlYXRlKHtcbiAgbmFtZTogXCJpdGFsaWNcIixcbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9XG4gICAgfTtcbiAgfSxcbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIHRhZzogXCJlbVwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB0YWc6IFwiaVwiLFxuICAgICAgICBnZXRBdHRyczogKG5vZGUpID0+IG5vZGUuc3R5bGUuZm9udFN0eWxlICE9PSBcIm5vcm1hbFwiICYmIG51bGxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHN0eWxlOiBcImZvbnQtc3R5bGU9bm9ybWFsXCIsXG4gICAgICAgIGNsZWFyTWFyazogKG1hcmspID0+IG1hcmsudHlwZS5uYW1lID09PSB0aGlzLm5hbWVcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHN0eWxlOiBcImZvbnQtc3R5bGU9aXRhbGljXCJcbiAgICAgIH1cbiAgICBdO1xuICB9LFxuICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgIHJldHVybiBbXCJlbVwiLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdO1xuICB9LFxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2V0SXRhbGljOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy5zZXRNYXJrKHRoaXMubmFtZSk7XG4gICAgICB9LFxuICAgICAgdG9nZ2xlSXRhbGljOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy50b2dnbGVNYXJrKHRoaXMubmFtZSk7XG4gICAgICB9LFxuICAgICAgdW5zZXRJdGFsaWM6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnVuc2V0TWFyayh0aGlzLm5hbWUpO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIG1hcmtkb3duVG9rZW5OYW1lOiBcImVtXCIsXG4gIHBhcnNlTWFya2Rvd246ICh0b2tlbiwgaGVscGVycykgPT4ge1xuICAgIHJldHVybiBoZWxwZXJzLmFwcGx5TWFyayhcIml0YWxpY1wiLCBoZWxwZXJzLnBhcnNlSW5saW5lKHRva2VuLnRva2VucyB8fCBbXSkpO1xuICB9LFxuICByZW5kZXJNYXJrZG93bjogKG5vZGUsIGgpID0+IHtcbiAgICByZXR1cm4gYCoke2gucmVuZGVyQ2hpbGRyZW4obm9kZSl9KmA7XG4gIH0sXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBcIk1vZC1pXCI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZUl0YWxpYygpLFxuICAgICAgXCJNb2QtSVwiOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVJdGFsaWMoKVxuICAgIH07XG4gIH0sXG4gIGFkZElucHV0UnVsZXMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG1hcmtJbnB1dFJ1bGUoe1xuICAgICAgICBmaW5kOiBzdGFySW5wdXRSZWdleCxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlXG4gICAgICB9KSxcbiAgICAgIG1hcmtJbnB1dFJ1bGUoe1xuICAgICAgICBmaW5kOiB1bmRlcnNjb3JlSW5wdXRSZWdleCxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlXG4gICAgICB9KVxuICAgIF07XG4gIH0sXG4gIGFkZFBhc3RlUnVsZXMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG1hcmtQYXN0ZVJ1bGUoe1xuICAgICAgICBmaW5kOiBzdGFyUGFzdGVSZWdleCxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlXG4gICAgICB9KSxcbiAgICAgIG1hcmtQYXN0ZVJ1bGUoe1xuICAgICAgICBmaW5kOiB1bmRlcnNjb3JlUGFzdGVSZWdleCxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlXG4gICAgICB9KVxuICAgIF07XG4gIH1cbn0pO1xuXG4vLyBzcmMvaW5kZXgudHNcbnZhciBpbmRleF9kZWZhdWx0ID0gSXRhbGljO1xuZXhwb3J0IHtcbiAgSXRhbGljLFxuICBpbmRleF9kZWZhdWx0IGFzIGRlZmF1bHQsXG4gIHN0YXJJbnB1dFJlZ2V4LFxuICBzdGFyUGFzdGVSZWdleCxcbiAgdW5kZXJzY29yZUlucHV0UmVnZXgsXG4gIHVuZGVyc2NvcmVQYXN0ZVJlZ2V4XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIk1hcmsiLCJtYXJrSW5wdXRSdWxlIiwibWFya1Bhc3RlUnVsZSIsIm1lcmdlQXR0cmlidXRlcyIsInN0YXJJbnB1dFJlZ2V4Iiwic3RhclBhc3RlUmVnZXgiLCJ1bmRlcnNjb3JlSW5wdXRSZWdleCIsInVuZGVyc2NvcmVQYXN0ZVJlZ2V4IiwiSXRhbGljIiwiY3JlYXRlIiwibmFtZSIsImFkZE9wdGlvbnMiLCJIVE1MQXR0cmlidXRlcyIsInBhcnNlSFRNTCIsInRhZyIsImdldEF0dHJzIiwibm9kZSIsInN0eWxlIiwiZm9udFN0eWxlIiwiY2xlYXJNYXJrIiwibWFyayIsInR5cGUiLCJyZW5kZXJIVE1MIiwib3B0aW9ucyIsImFkZENvbW1hbmRzIiwic2V0SXRhbGljIiwiY29tbWFuZHMiLCJzZXRNYXJrIiwidG9nZ2xlSXRhbGljIiwidG9nZ2xlTWFyayIsInVuc2V0SXRhbGljIiwidW5zZXRNYXJrIiwibWFya2Rvd25Ub2tlbk5hbWUiLCJwYXJzZU1hcmtkb3duIiwidG9rZW4iLCJoZWxwZXJzIiwiYXBwbHlNYXJrIiwicGFyc2VJbmxpbmUiLCJ0b2tlbnMiLCJyZW5kZXJNYXJrZG93biIsImgiLCJyZW5kZXJDaGlsZHJlbiIsImFkZEtleWJvYXJkU2hvcnRjdXRzIiwiZWRpdG9yIiwiYWRkSW5wdXRSdWxlcyIsImZpbmQiLCJhZGRQYXN0ZVJ1bGVzIiwiaW5kZXhfZGVmYXVsdCIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-italic/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-link/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@tiptap/extension-link/dist/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Link: () => (/* binding */ Link),\n/* harmony export */   \"default\": () => (/* binding */ index_default),\n/* harmony export */   isAllowedUri: () => (/* binding */ isAllowedUri),\n/* harmony export */   pasteRegex: () => (/* binding */ pasteRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var linkifyjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! linkifyjs */ \"(ssr)/./node_modules/linkifyjs/dist/linkify.mjs\");\n/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/pm/state */ \"(ssr)/./node_modules/@tiptap/pm/dist/state/index.js\");\n// src/link.ts\n\n\n// src/helpers/autolink.ts\n\n\n\n// src/helpers/whitespace.ts\nvar UNICODE_WHITESPACE_PATTERN = \"[\\x00- \\xa0-\\u2029]\";\nvar UNICODE_WHITESPACE_REGEX = new RegExp(UNICODE_WHITESPACE_PATTERN);\nvar UNICODE_WHITESPACE_REGEX_END = new RegExp(`${UNICODE_WHITESPACE_PATTERN}$`);\nvar UNICODE_WHITESPACE_REGEX_GLOBAL = new RegExp(UNICODE_WHITESPACE_PATTERN, \"g\");\n// src/helpers/autolink.ts\nfunction isValidLinkStructure(tokens) {\n    if (tokens.length === 1) {\n        return tokens[0].isLink;\n    }\n    if (tokens.length === 3 && tokens[1].isLink) {\n        return [\n            \"()\",\n            \"[]\"\n        ].includes(tokens[0].value + tokens[2].value);\n    }\n    return false;\n}\nfunction autolink(options) {\n    return new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_1__.Plugin({\n        key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_1__.PluginKey(\"autolink\"),\n        appendTransaction: (transactions, oldState, newState)=>{\n            const docChanges = transactions.some((transaction)=>transaction.docChanged) && !oldState.doc.eq(newState.doc);\n            const preventAutolink = transactions.some((transaction)=>transaction.getMeta(\"preventAutolink\"));\n            if (!docChanges || preventAutolink) {\n                return;\n            }\n            const { tr } = newState;\n            const transform = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.combineTransactionSteps)(oldState.doc, [\n                ...transactions\n            ]);\n            const changes = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getChangedRanges)(transform);\n            changes.forEach(({ newRange })=>{\n                const nodesInChangedRanges = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.findChildrenInRange)(newState.doc, newRange, (node)=>node.isTextblock);\n                let textBlock;\n                let textBeforeWhitespace;\n                if (nodesInChangedRanges.length > 1) {\n                    textBlock = nodesInChangedRanges[0];\n                    textBeforeWhitespace = newState.doc.textBetween(textBlock.pos, textBlock.pos + textBlock.node.nodeSize, void 0, \" \");\n                } else if (nodesInChangedRanges.length) {\n                    const endText = newState.doc.textBetween(newRange.from, newRange.to, \" \", \" \");\n                    if (!UNICODE_WHITESPACE_REGEX_END.test(endText)) {\n                        return;\n                    }\n                    textBlock = nodesInChangedRanges[0];\n                    textBeforeWhitespace = newState.doc.textBetween(textBlock.pos, newRange.to, void 0, \" \");\n                }\n                if (textBlock && textBeforeWhitespace) {\n                    const wordsBeforeWhitespace = textBeforeWhitespace.split(UNICODE_WHITESPACE_REGEX).filter(Boolean);\n                    if (wordsBeforeWhitespace.length <= 0) {\n                        return false;\n                    }\n                    const lastWordBeforeSpace = wordsBeforeWhitespace[wordsBeforeWhitespace.length - 1];\n                    const lastWordAndBlockOffset = textBlock.pos + textBeforeWhitespace.lastIndexOf(lastWordBeforeSpace);\n                    if (!lastWordBeforeSpace) {\n                        return false;\n                    }\n                    const linksBeforeSpace = (0,linkifyjs__WEBPACK_IMPORTED_MODULE_0__.tokenize)(lastWordBeforeSpace).map((t)=>t.toObject(options.defaultProtocol));\n                    if (!isValidLinkStructure(linksBeforeSpace)) {\n                        return false;\n                    }\n                    linksBeforeSpace.filter((link)=>link.isLink).map((link)=>({\n                            ...link,\n                            from: lastWordAndBlockOffset + link.start + 1,\n                            to: lastWordAndBlockOffset + link.end + 1\n                        })).filter((link)=>{\n                        if (!newState.schema.marks.code) {\n                            return true;\n                        }\n                        return !newState.doc.rangeHasMark(link.from, link.to, newState.schema.marks.code);\n                    }).filter((link)=>options.validate(link.value)).filter((link)=>options.shouldAutoLink(link.value)).forEach((link)=>{\n                        if ((0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getMarksBetween)(link.from, link.to, newState.doc).some((item)=>item.mark.type === options.type)) {\n                            return;\n                        }\n                        tr.addMark(link.from, link.to, options.type.create({\n                            href: link.href\n                        }));\n                    });\n                }\n            });\n            if (!tr.steps.length) {\n                return;\n            }\n            return tr;\n        }\n    });\n}\n// src/helpers/clickHandler.ts\n\n\nfunction clickHandler(options) {\n    return new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_1__.Plugin({\n        key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_1__.PluginKey(\"handleClickLink\"),\n        props: {\n            handleClick: (view, pos, event)=>{\n                var _a, _b;\n                if (event.button !== 0) {\n                    return false;\n                }\n                if (!view.editable) {\n                    return false;\n                }\n                let handled = false;\n                if (options.enableClickSelection) {\n                    const commandResult = options.editor.commands.extendMarkRange(options.type.name);\n                    handled = commandResult;\n                }\n                if (options.openOnClick) {\n                    let link = null;\n                    if (event.target instanceof HTMLAnchorElement) {\n                        link = event.target;\n                    } else {\n                        let a = event.target;\n                        const els = [];\n                        while(a.nodeName !== \"DIV\"){\n                            els.push(a);\n                            a = a.parentNode;\n                        }\n                        link = els.find((value)=>value.nodeName === \"A\");\n                    }\n                    if (!link) {\n                        return handled;\n                    }\n                    const attrs = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getAttributes)(view.state, options.type.name);\n                    const href = (_a = link == null ? void 0 : link.href) != null ? _a : attrs.href;\n                    const target = (_b = link == null ? void 0 : link.target) != null ? _b : attrs.target;\n                    if (link && href) {\n                        window.open(href, target);\n                        handled = true;\n                    }\n                }\n                return handled;\n            }\n        }\n    });\n}\n// src/helpers/pasteHandler.ts\n\n\nfunction pasteHandler(options) {\n    return new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_1__.Plugin({\n        key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_1__.PluginKey(\"handlePasteLink\"),\n        props: {\n            handlePaste: (view, _event, slice)=>{\n                const { shouldAutoLink } = options;\n                const { state } = view;\n                const { selection } = state;\n                const { empty } = selection;\n                if (empty) {\n                    return false;\n                }\n                let textContent = \"\";\n                slice.content.forEach((node)=>{\n                    textContent += node.textContent;\n                });\n                const link = (0,linkifyjs__WEBPACK_IMPORTED_MODULE_0__.find)(textContent, {\n                    defaultProtocol: options.defaultProtocol\n                }).find((item)=>item.isLink && item.value === textContent);\n                if (!textContent || !link || shouldAutoLink !== void 0 && !shouldAutoLink(link.href)) {\n                    return false;\n                }\n                return options.editor.commands.setMark(options.type, {\n                    href: link.href\n                });\n            }\n        }\n    });\n}\n// src/link.ts\nvar pasteRegex = /https?:\\/\\/(?:www\\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z]{2,}\\b(?:[-a-zA-Z0-9@:%._+~#=?!&/]*)(?:[-a-zA-Z0-9@:%._+~#=?!&/]*)/gi;\nfunction isAllowedUri(uri, protocols) {\n    const allowedProtocols = [\n        \"http\",\n        \"https\",\n        \"ftp\",\n        \"ftps\",\n        \"mailto\",\n        \"tel\",\n        \"callto\",\n        \"sms\",\n        \"cid\",\n        \"xmpp\"\n    ];\n    if (protocols) {\n        protocols.forEach((protocol)=>{\n            const nextProtocol = typeof protocol === \"string\" ? protocol : protocol.scheme;\n            if (nextProtocol) {\n                allowedProtocols.push(nextProtocol);\n            }\n        });\n    }\n    return !uri || uri.replace(UNICODE_WHITESPACE_REGEX_GLOBAL, \"\").match(new RegExp(// eslint-disable-next-line no-useless-escape\n    `^(?:(?:${allowedProtocols.join(\"|\")}):|[^a-z]|[a-z0-9+.-]+(?:[^a-z+.-:]|$))`, \"i\"));\n}\nvar Link = _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.Mark.create({\n    name: \"link\",\n    priority: 1e3,\n    keepOnSplit: false,\n    exitable: true,\n    onCreate () {\n        if (this.options.validate && !this.options.shouldAutoLink) {\n            this.options.shouldAutoLink = this.options.validate;\n            console.warn(\"The `validate` option is deprecated. Rename to the `shouldAutoLink` option instead.\");\n        }\n        this.options.protocols.forEach((protocol)=>{\n            if (typeof protocol === \"string\") {\n                (0,linkifyjs__WEBPACK_IMPORTED_MODULE_0__.registerCustomProtocol)(protocol);\n                return;\n            }\n            (0,linkifyjs__WEBPACK_IMPORTED_MODULE_0__.registerCustomProtocol)(protocol.scheme, protocol.optionalSlashes);\n        });\n    },\n    onDestroy () {\n        (0,linkifyjs__WEBPACK_IMPORTED_MODULE_0__.reset)();\n    },\n    inclusive () {\n        return this.options.autolink;\n    },\n    addOptions () {\n        return {\n            openOnClick: true,\n            enableClickSelection: false,\n            linkOnPaste: true,\n            autolink: true,\n            protocols: [],\n            defaultProtocol: \"http\",\n            HTMLAttributes: {\n                target: \"_blank\",\n                rel: \"noopener noreferrer nofollow\",\n                class: null\n            },\n            isAllowedUri: (url, ctx)=>!!isAllowedUri(url, ctx.protocols),\n            validate: (url)=>!!url,\n            shouldAutoLink: (url)=>!!url\n        };\n    },\n    addAttributes () {\n        return {\n            href: {\n                default: null,\n                parseHTML (element) {\n                    return element.getAttribute(\"href\");\n                }\n            },\n            target: {\n                default: this.options.HTMLAttributes.target\n            },\n            rel: {\n                default: this.options.HTMLAttributes.rel\n            },\n            class: {\n                default: this.options.HTMLAttributes.class\n            }\n        };\n    },\n    parseHTML () {\n        return [\n            {\n                tag: \"a[href]\",\n                getAttrs: (dom)=>{\n                    const href = dom.getAttribute(\"href\");\n                    if (!href || !this.options.isAllowedUri(href, {\n                        defaultValidate: (url)=>!!isAllowedUri(url, this.options.protocols),\n                        protocols: this.options.protocols,\n                        defaultProtocol: this.options.defaultProtocol\n                    })) {\n                        return false;\n                    }\n                    return null;\n                }\n            }\n        ];\n    },\n    renderHTML ({ HTMLAttributes }) {\n        if (!this.options.isAllowedUri(HTMLAttributes.href, {\n            defaultValidate: (href)=>!!isAllowedUri(href, this.options.protocols),\n            protocols: this.options.protocols,\n            defaultProtocol: this.options.defaultProtocol\n        })) {\n            return [\n                \"a\",\n                (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.mergeAttributes)(this.options.HTMLAttributes, {\n                    ...HTMLAttributes,\n                    href: \"\"\n                }),\n                0\n            ];\n        }\n        return [\n            \"a\",\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes),\n            0\n        ];\n    },\n    markdownTokenName: \"link\",\n    parseMarkdown: (token, helpers)=>{\n        return helpers.applyMark(\"link\", helpers.parseInline(token.tokens || []), {\n            href: token.href,\n            title: token.title || null\n        });\n    },\n    renderMarkdown: (node, h)=>{\n        var _a;\n        const href = ((_a = node.attrs) == null ? void 0 : _a.href) || \"\";\n        const text = h.renderChildren(node);\n        return `[${text}](${href})`;\n    },\n    addCommands () {\n        return {\n            setLink: (attributes)=>({ chain })=>{\n                    const { href } = attributes;\n                    if (!this.options.isAllowedUri(href, {\n                        defaultValidate: (url)=>!!isAllowedUri(url, this.options.protocols),\n                        protocols: this.options.protocols,\n                        defaultProtocol: this.options.defaultProtocol\n                    })) {\n                        return false;\n                    }\n                    return chain().setMark(this.name, attributes).setMeta(\"preventAutolink\", true).run();\n                },\n            toggleLink: (attributes)=>({ chain })=>{\n                    const { href } = attributes || {};\n                    if (href && !this.options.isAllowedUri(href, {\n                        defaultValidate: (url)=>!!isAllowedUri(url, this.options.protocols),\n                        protocols: this.options.protocols,\n                        defaultProtocol: this.options.defaultProtocol\n                    })) {\n                        return false;\n                    }\n                    return chain().toggleMark(this.name, attributes, {\n                        extendEmptyMarkRange: true\n                    }).setMeta(\"preventAutolink\", true).run();\n                },\n            unsetLink: ()=>({ chain })=>{\n                    return chain().unsetMark(this.name, {\n                        extendEmptyMarkRange: true\n                    }).setMeta(\"preventAutolink\", true).run();\n                }\n        };\n    },\n    addPasteRules () {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.markPasteRule)({\n                find: (text)=>{\n                    const foundLinks = [];\n                    if (text) {\n                        const { protocols, defaultProtocol } = this.options;\n                        const links = (0,linkifyjs__WEBPACK_IMPORTED_MODULE_0__.find)(text).filter((item)=>item.isLink && this.options.isAllowedUri(item.value, {\n                                defaultValidate: (href)=>!!isAllowedUri(href, protocols),\n                                protocols,\n                                defaultProtocol\n                            }));\n                        if (links.length) {\n                            links.forEach((link)=>{\n                                if (!this.options.shouldAutoLink(link.value)) {\n                                    return;\n                                }\n                                foundLinks.push({\n                                    text: link.value,\n                                    data: {\n                                        href: link.href\n                                    },\n                                    index: link.start\n                                });\n                            });\n                        }\n                    }\n                    return foundLinks;\n                },\n                type: this.type,\n                getAttributes: (match)=>{\n                    var _a;\n                    return {\n                        href: (_a = match.data) == null ? void 0 : _a.href\n                    };\n                }\n            })\n        ];\n    },\n    addProseMirrorPlugins () {\n        const plugins = [];\n        const { protocols, defaultProtocol } = this.options;\n        if (this.options.autolink) {\n            plugins.push(autolink({\n                type: this.type,\n                defaultProtocol: this.options.defaultProtocol,\n                validate: (url)=>this.options.isAllowedUri(url, {\n                        defaultValidate: (href)=>!!isAllowedUri(href, protocols),\n                        protocols,\n                        defaultProtocol\n                    }),\n                shouldAutoLink: this.options.shouldAutoLink\n            }));\n        }\n        plugins.push(clickHandler({\n            type: this.type,\n            editor: this.editor,\n            openOnClick: this.options.openOnClick === \"whenNotEditable\" ? true : this.options.openOnClick,\n            enableClickSelection: this.options.enableClickSelection\n        }));\n        if (this.options.linkOnPaste) {\n            plugins.push(pasteHandler({\n                editor: this.editor,\n                defaultProtocol: this.options.defaultProtocol,\n                type: this.type,\n                shouldAutoLink: this.options.shouldAutoLink\n            }));\n        }\n        return plugins;\n    }\n});\n// src/index.ts\nvar index_default = Link;\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tbGluay9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSxjQUFjO0FBQ3NEO0FBQ0s7QUFFekUsMEJBQTBCO0FBQ3FGO0FBQzFEO0FBQ2hCO0FBRXJDLDRCQUE0QjtBQUM1QixJQUFJYyw2QkFBNkI7QUFDakMsSUFBSUMsMkJBQTJCLElBQUlDLE9BQU9GO0FBQzFDLElBQUlHLCtCQUErQixJQUFJRCxPQUFPLENBQUMsRUFBRUYsMkJBQTJCLENBQUMsQ0FBQztBQUM5RSxJQUFJSSxrQ0FBa0MsSUFBSUYsT0FBT0YsNEJBQTRCO0FBRTdFLDBCQUEwQjtBQUMxQixTQUFTSyxxQkFBcUJDLE1BQU07SUFDbEMsSUFBSUEsT0FBT0MsTUFBTSxLQUFLLEdBQUc7UUFDdkIsT0FBT0QsTUFBTSxDQUFDLEVBQUUsQ0FBQ0UsTUFBTTtJQUN6QjtJQUNBLElBQUlGLE9BQU9DLE1BQU0sS0FBSyxLQUFLRCxNQUFNLENBQUMsRUFBRSxDQUFDRSxNQUFNLEVBQUU7UUFDM0MsT0FBTztZQUFDO1lBQU07U0FBSyxDQUFDQyxRQUFRLENBQUNILE1BQU0sQ0FBQyxFQUFFLENBQUNJLEtBQUssR0FBR0osTUFBTSxDQUFDLEVBQUUsQ0FBQ0ksS0FBSztJQUNoRTtJQUNBLE9BQU87QUFDVDtBQUNBLFNBQVNDLFNBQVNDLE9BQU87SUFDdkIsT0FBTyxJQUFJZixvREFBTUEsQ0FBQztRQUNoQmdCLEtBQUssSUFBSWYsdURBQVNBLENBQUM7UUFDbkJnQixtQkFBbUIsQ0FBQ0MsY0FBY0MsVUFBVUM7WUFDMUMsTUFBTUMsYUFBYUgsYUFBYUksSUFBSSxDQUFDLENBQUNDLGNBQWdCQSxZQUFZQyxVQUFVLEtBQUssQ0FBQ0wsU0FBU00sR0FBRyxDQUFDQyxFQUFFLENBQUNOLFNBQVNLLEdBQUc7WUFDOUcsTUFBTUUsa0JBQWtCVCxhQUFhSSxJQUFJLENBQUMsQ0FBQ0MsY0FBZ0JBLFlBQVlLLE9BQU8sQ0FB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QUFJQyxnQkFBZ0J4RDtBQU1sQixDQUNGLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3ByYXNvYnBhaS13ZWIvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tbGluay9kaXN0L2luZGV4LmpzPzA1MGQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2xpbmsudHNcbmltcG9ydCB7IE1hcmssIG1hcmtQYXN0ZVJ1bGUsIG1lcmdlQXR0cmlidXRlcyB9IGZyb20gXCJAdGlwdGFwL2NvcmVcIjtcbmltcG9ydCB7IGZpbmQgYXMgZmluZDIsIHJlZ2lzdGVyQ3VzdG9tUHJvdG9jb2wsIHJlc2V0IH0gZnJvbSBcImxpbmtpZnlqc1wiO1xuXG4vLyBzcmMvaGVscGVycy9hdXRvbGluay50c1xuaW1wb3J0IHsgY29tYmluZVRyYW5zYWN0aW9uU3RlcHMsIGZpbmRDaGlsZHJlbkluUmFuZ2UsIGdldENoYW5nZWRSYW5nZXMsIGdldE1hcmtzQmV0d2VlbiB9IGZyb20gXCJAdGlwdGFwL2NvcmVcIjtcbmltcG9ydCB7IFBsdWdpbiwgUGx1Z2luS2V5IH0gZnJvbSBcIkB0aXB0YXAvcG0vc3RhdGVcIjtcbmltcG9ydCB7IHRva2VuaXplIH0gZnJvbSBcImxpbmtpZnlqc1wiO1xuXG4vLyBzcmMvaGVscGVycy93aGl0ZXNwYWNlLnRzXG52YXIgVU5JQ09ERV9XSElURVNQQUNFX1BBVFRFUk4gPSBcIltcXDAtIFxceEEwXFx1MTY4MFxcdTE4MEVcXHUyMDAwLVxcdTIwMjlcXHUyMDVGXFx1MzAwMF1cIjtcbnZhciBVTklDT0RFX1dISVRFU1BBQ0VfUkVHRVggPSBuZXcgUmVnRXhwKFVOSUNPREVfV0hJVEVTUEFDRV9QQVRURVJOKTtcbnZhciBVTklDT0RFX1dISVRFU1BBQ0VfUkVHRVhfRU5EID0gbmV3IFJlZ0V4cChgJHtVTklDT0RFX1dISVRFU1BBQ0VfUEFUVEVSTn0kYCk7XG52YXIgVU5JQ09ERV9XSElURVNQQUNFX1JFR0VYX0dMT0JBTCA9IG5ldyBSZWdFeHAoVU5JQ09ERV9XSElURVNQQUNFX1BBVFRFUk4sIFwiZ1wiKTtcblxuLy8gc3JjL2hlbHBlcnMvYXV0b2xpbmsudHNcbmZ1bmN0aW9uIGlzVmFsaWRMaW5rU3RydWN0dXJlKHRva2Vucykge1xuICBpZiAodG9rZW5zLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiB0b2tlbnNbMF0uaXNMaW5rO1xuICB9XG4gIGlmICh0b2tlbnMubGVuZ3RoID09PSAzICYmIHRva2Vuc1sxXS5pc0xpbmspIHtcbiAgICByZXR1cm4gW1wiKClcIiwgXCJbXVwiXS5pbmNsdWRlcyh0b2tlbnNbMF0udmFsdWUgKyB0b2tlbnNbMl0udmFsdWUpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGF1dG9saW5rKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBQbHVnaW4oe1xuICAgIGtleTogbmV3IFBsdWdpbktleShcImF1dG9saW5rXCIpLFxuICAgIGFwcGVuZFRyYW5zYWN0aW9uOiAodHJhbnNhY3Rpb25zLCBvbGRTdGF0ZSwgbmV3U3RhdGUpID0+IHtcbiAgICAgIGNvbnN0IGRvY0NoYW5nZXMgPSB0cmFuc2FjdGlvbnMuc29tZSgodHJhbnNhY3Rpb24pID0+IHRyYW5zYWN0aW9uLmRvY0NoYW5nZWQpICYmICFvbGRTdGF0ZS5kb2MuZXEobmV3U3RhdGUuZG9jKTtcbiAgICAgIGNvbnN0IHByZXZlbnRBdXRvbGluayA9IHRyYW5zYWN0aW9ucy5zb21lKCh0cmFuc2FjdGlvbikgPT4gdHJhbnNhY3Rpb24uZ2V0TWV0YShcInByZXZlbnRBdXRvbGlua1wiKSk7XG4gICAgICBpZiAoIWRvY0NoYW5nZXMgfHwgcHJldmVudEF1dG9saW5rKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgdHIgfSA9IG5ld1N0YXRlO1xuICAgICAgY29uc3QgdHJhbnNmb3JtID0gY29tYmluZVRyYW5zYWN0aW9uU3RlcHMob2xkU3RhdGUuZG9jLCBbLi4udHJhbnNhY3Rpb25zXSk7XG4gICAgICBjb25zdCBjaGFuZ2VzID0gZ2V0Q2hhbmdlZFJhbmdlcyh0cmFuc2Zvcm0pO1xuICAgICAgY2hhbmdlcy5mb3JFYWNoKCh7IG5ld1JhbmdlIH0pID0+IHtcbiAgICAgICAgY29uc3Qgbm9kZXNJbkNoYW5nZWRSYW5nZXMgPSBmaW5kQ2hpbGRyZW5JblJhbmdlKG5ld1N0YXRlLmRvYywgbmV3UmFuZ2UsIChub2RlKSA9PiBub2RlLmlzVGV4dGJsb2NrKTtcbiAgICAgICAgbGV0IHRleHRCbG9jaztcbiAgICAgICAgbGV0IHRleHRCZWZvcmVXaGl0ZXNwYWNlO1xuICAgICAgICBpZiAobm9kZXNJbkNoYW5nZWRSYW5nZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHRleHRCbG9jayA9IG5vZGVzSW5DaGFuZ2VkUmFuZ2VzWzBdO1xuICAgICAgICAgIHRleHRCZWZvcmVXaGl0ZXNwYWNlID0gbmV3U3RhdGUuZG9jLnRleHRCZXR3ZWVuKFxuICAgICAgICAgICAgdGV4dEJsb2NrLnBvcyxcbiAgICAgICAgICAgIHRleHRCbG9jay5wb3MgKyB0ZXh0QmxvY2subm9kZS5ub2RlU2l6ZSxcbiAgICAgICAgICAgIHZvaWQgMCxcbiAgICAgICAgICAgIFwiIFwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChub2Rlc0luQ2hhbmdlZFJhbmdlcy5sZW5ndGgpIHtcbiAgICAgICAgICBjb25zdCBlbmRUZXh0ID0gbmV3U3RhdGUuZG9jLnRleHRCZXR3ZWVuKG5ld1JhbmdlLmZyb20sIG5ld1JhbmdlLnRvLCBcIiBcIiwgXCIgXCIpO1xuICAgICAgICAgIGlmICghVU5JQ09ERV9XSElURVNQQUNFX1JFR0VYX0VORC50ZXN0KGVuZFRleHQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHRleHRCbG9jayA9IG5vZGVzSW5DaGFuZ2VkUmFuZ2VzWzBdO1xuICAgICAgICAgIHRleHRCZWZvcmVXaGl0ZXNwYWNlID0gbmV3U3RhdGUuZG9jLnRleHRCZXR3ZWVuKHRleHRCbG9jay5wb3MsIG5ld1JhbmdlLnRvLCB2b2lkIDAsIFwiIFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGV4dEJsb2NrICYmIHRleHRCZWZvcmVXaGl0ZXNwYWNlKSB7XG4gICAgICAgICAgY29uc3Qgd29yZHNCZWZvcmVXaGl0ZXNwYWNlID0gdGV4dEJlZm9yZVdoaXRlc3BhY2Uuc3BsaXQoVU5JQ09ERV9XSElURVNQQUNFX1JFR0VYKS5maWx0ZXIoQm9vbGVhbik7XG4gICAgICAgICAgaWYgKHdvcmRzQmVmb3JlV2hpdGVzcGFjZS5sZW5ndGggPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBsYXN0V29yZEJlZm9yZVNwYWNlID0gd29yZHNCZWZvcmVXaGl0ZXNwYWNlW3dvcmRzQmVmb3JlV2hpdGVzcGFjZS5sZW5ndGggLSAxXTtcbiAgICAgICAgICBjb25zdCBsYXN0V29yZEFuZEJsb2NrT2Zmc2V0ID0gdGV4dEJsb2NrLnBvcyArIHRleHRCZWZvcmVXaGl0ZXNwYWNlLmxhc3RJbmRleE9mKGxhc3RXb3JkQmVmb3JlU3BhY2UpO1xuICAgICAgICAgIGlmICghbGFzdFdvcmRCZWZvcmVTcGFjZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBsaW5rc0JlZm9yZVNwYWNlID0gdG9rZW5pemUobGFzdFdvcmRCZWZvcmVTcGFjZSkubWFwKCh0KSA9PiB0LnRvT2JqZWN0KG9wdGlvbnMuZGVmYXVsdFByb3RvY29sKSk7XG4gICAgICAgICAgaWYgKCFpc1ZhbGlkTGlua1N0cnVjdHVyZShsaW5rc0JlZm9yZVNwYWNlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsaW5rc0JlZm9yZVNwYWNlLmZpbHRlcigobGluaykgPT4gbGluay5pc0xpbmspLm1hcCgobGluaykgPT4gKHtcbiAgICAgICAgICAgIC4uLmxpbmssXG4gICAgICAgICAgICBmcm9tOiBsYXN0V29yZEFuZEJsb2NrT2Zmc2V0ICsgbGluay5zdGFydCArIDEsXG4gICAgICAgICAgICB0bzogbGFzdFdvcmRBbmRCbG9ja09mZnNldCArIGxpbmsuZW5kICsgMVxuICAgICAgICAgIH0pKS5maWx0ZXIoKGxpbmspID0+IHtcbiAgICAgICAgICAgIGlmICghbmV3U3RhdGUuc2NoZW1hLm1hcmtzLmNvZGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gIW5ld1N0YXRlLmRvYy5yYW5nZUhhc01hcmsobGluay5mcm9tLCBsaW5rLnRvLCBuZXdTdGF0ZS5zY2hlbWEubWFya3MuY29kZSk7XG4gICAgICAgICAgfSkuZmlsdGVyKChsaW5rKSA9PiBvcHRpb25zLnZhbGlkYXRlKGxpbmsudmFsdWUpKS5maWx0ZXIoKGxpbmspID0+IG9wdGlvbnMuc2hvdWxkQXV0b0xpbmsobGluay52YWx1ZSkpLmZvckVhY2goKGxpbmspID0+IHtcbiAgICAgICAgICAgIGlmIChnZXRNYXJrc0JldHdlZW4obGluay5mcm9tLCBsaW5rLnRvLCBuZXdTdGF0ZS5kb2MpLnNvbWUoKGl0ZW0pID0+IGl0ZW0ubWFyay50eXBlID09PSBvcHRpb25zLnR5cGUpKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyLmFkZE1hcmsoXG4gICAgICAgICAgICAgIGxpbmsuZnJvbSxcbiAgICAgICAgICAgICAgbGluay50byxcbiAgICAgICAgICAgICAgb3B0aW9ucy50eXBlLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgaHJlZjogbGluay5ocmVmXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmICghdHIuc3RlcHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cjtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzcmMvaGVscGVycy9jbGlja0hhbmRsZXIudHNcbmltcG9ydCB7IGdldEF0dHJpYnV0ZXMgfSBmcm9tIFwiQHRpcHRhcC9jb3JlXCI7XG5pbXBvcnQgeyBQbHVnaW4gYXMgUGx1Z2luMiwgUGx1Z2luS2V5IGFzIFBsdWdpbktleTIgfSBmcm9tIFwiQHRpcHRhcC9wbS9zdGF0ZVwiO1xuZnVuY3Rpb24gY2xpY2tIYW5kbGVyKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBQbHVnaW4yKHtcbiAgICBrZXk6IG5ldyBQbHVnaW5LZXkyKFwiaGFuZGxlQ2xpY2tMaW5rXCIpLFxuICAgIHByb3BzOiB7XG4gICAgICBoYW5kbGVDbGljazogKHZpZXcsIHBvcywgZXZlbnQpID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXZpZXcuZWRpdGFibGUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGhhbmRsZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKG9wdGlvbnMuZW5hYmxlQ2xpY2tTZWxlY3Rpb24pIHtcbiAgICAgICAgICBjb25zdCBjb21tYW5kUmVzdWx0ID0gb3B0aW9ucy5lZGl0b3IuY29tbWFuZHMuZXh0ZW5kTWFya1JhbmdlKG9wdGlvbnMudHlwZS5uYW1lKTtcbiAgICAgICAgICBoYW5kbGVkID0gY29tbWFuZFJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5vcGVuT25DbGljaykge1xuICAgICAgICAgIGxldCBsaW5rID0gbnVsbDtcbiAgICAgICAgICBpZiAoZXZlbnQudGFyZ2V0IGluc3RhbmNlb2YgSFRNTEFuY2hvckVsZW1lbnQpIHtcbiAgICAgICAgICAgIGxpbmsgPSBldmVudC50YXJnZXQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBhID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgY29uc3QgZWxzID0gW107XG4gICAgICAgICAgICB3aGlsZSAoYS5ub2RlTmFtZSAhPT0gXCJESVZcIikge1xuICAgICAgICAgICAgICBlbHMucHVzaChhKTtcbiAgICAgICAgICAgICAgYSA9IGEucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpbmsgPSBlbHMuZmluZCgodmFsdWUpID0+IHZhbHVlLm5vZGVOYW1lID09PSBcIkFcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghbGluaykge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGF0dHJzID0gZ2V0QXR0cmlidXRlcyh2aWV3LnN0YXRlLCBvcHRpb25zLnR5cGUubmFtZSk7XG4gICAgICAgICAgY29uc3QgaHJlZiA9IChfYSA9IGxpbmsgPT0gbnVsbCA/IHZvaWQgMCA6IGxpbmsuaHJlZikgIT0gbnVsbCA/IF9hIDogYXR0cnMuaHJlZjtcbiAgICAgICAgICBjb25zdCB0YXJnZXQgPSAoX2IgPSBsaW5rID09IG51bGwgPyB2b2lkIDAgOiBsaW5rLnRhcmdldCkgIT0gbnVsbCA/IF9iIDogYXR0cnMudGFyZ2V0O1xuICAgICAgICAgIGlmIChsaW5rICYmIGhyZWYpIHtcbiAgICAgICAgICAgIHdpbmRvdy5vcGVuKGhyZWYsIHRhcmdldCk7XG4gICAgICAgICAgICBoYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhhbmRsZWQ7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3JjL2hlbHBlcnMvcGFzdGVIYW5kbGVyLnRzXG5pbXBvcnQgeyBQbHVnaW4gYXMgUGx1Z2luMywgUGx1Z2luS2V5IGFzIFBsdWdpbktleTMgfSBmcm9tIFwiQHRpcHRhcC9wbS9zdGF0ZVwiO1xuaW1wb3J0IHsgZmluZCB9IGZyb20gXCJsaW5raWZ5anNcIjtcbmZ1bmN0aW9uIHBhc3RlSGFuZGxlcihvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgUGx1Z2luMyh7XG4gICAga2V5OiBuZXcgUGx1Z2luS2V5MyhcImhhbmRsZVBhc3RlTGlua1wiKSxcbiAgICBwcm9wczoge1xuICAgICAgaGFuZGxlUGFzdGU6ICh2aWV3LCBfZXZlbnQsIHNsaWNlKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgc2hvdWxkQXV0b0xpbmsgfSA9IG9wdGlvbnM7XG4gICAgICAgIGNvbnN0IHsgc3RhdGUgfSA9IHZpZXc7XG4gICAgICAgIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSBzdGF0ZTtcbiAgICAgICAgY29uc3QgeyBlbXB0eSB9ID0gc2VsZWN0aW9uO1xuICAgICAgICBpZiAoZW1wdHkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRleHRDb250ZW50ID0gXCJcIjtcbiAgICAgICAgc2xpY2UuY29udGVudC5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICAgICAgdGV4dENvbnRlbnQgKz0gbm9kZS50ZXh0Q29udGVudDtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGxpbmsgPSBmaW5kKHRleHRDb250ZW50LCB7IGRlZmF1bHRQcm90b2NvbDogb3B0aW9ucy5kZWZhdWx0UHJvdG9jb2wgfSkuZmluZChcbiAgICAgICAgICAoaXRlbSkgPT4gaXRlbS5pc0xpbmsgJiYgaXRlbS52YWx1ZSA9PT0gdGV4dENvbnRlbnRcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKCF0ZXh0Q29udGVudCB8fCAhbGluayB8fCBzaG91bGRBdXRvTGluayAhPT0gdm9pZCAwICYmICFzaG91bGRBdXRvTGluayhsaW5rLmhyZWYpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcHRpb25zLmVkaXRvci5jb21tYW5kcy5zZXRNYXJrKG9wdGlvbnMudHlwZSwge1xuICAgICAgICAgIGhyZWY6IGxpbmsuaHJlZlxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzcmMvbGluay50c1xudmFyIHBhc3RlUmVnZXggPSAvaHR0cHM/OlxcL1xcLyg/Ond3d1xcLik/Wy1hLXpBLVowLTlAOiUuXyt+Iz1dezEsMjU2fVxcLlthLXpBLVpdezIsfVxcYig/OlstYS16QS1aMC05QDolLl8rfiM9PyEmL10qKSg/OlstYS16QS1aMC05QDolLl8rfiM9PyEmL10qKS9naTtcbmZ1bmN0aW9uIGlzQWxsb3dlZFVyaSh1cmksIHByb3RvY29scykge1xuICBjb25zdCBhbGxvd2VkUHJvdG9jb2xzID0gW1wiaHR0cFwiLCBcImh0dHBzXCIsIFwiZnRwXCIsIFwiZnRwc1wiLCBcIm1haWx0b1wiLCBcInRlbFwiLCBcImNhbGx0b1wiLCBcInNtc1wiLCBcImNpZFwiLCBcInhtcHBcIl07XG4gIGlmIChwcm90b2NvbHMpIHtcbiAgICBwcm90b2NvbHMuZm9yRWFjaCgocHJvdG9jb2wpID0+IHtcbiAgICAgIGNvbnN0IG5leHRQcm90b2NvbCA9IHR5cGVvZiBwcm90b2NvbCA9PT0gXCJzdHJpbmdcIiA/IHByb3RvY29sIDogcHJvdG9jb2wuc2NoZW1lO1xuICAgICAgaWYgKG5leHRQcm90b2NvbCkge1xuICAgICAgICBhbGxvd2VkUHJvdG9jb2xzLnB1c2gobmV4dFByb3RvY29sKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gIXVyaSB8fCB1cmkucmVwbGFjZShVTklDT0RFX1dISVRFU1BBQ0VfUkVHRVhfR0xPQkFMLCBcIlwiKS5tYXRjaChcbiAgICBuZXcgUmVnRXhwKFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZWxlc3MtZXNjYXBlXG4gICAgICBgXig/Oig/OiR7YWxsb3dlZFByb3RvY29scy5qb2luKFwifFwiKX0pOnxbXmEtel18W2EtejAtOSsuLV0rKD86W15hLXorLi06XXwkKSlgLFxuICAgICAgXCJpXCJcbiAgICApXG4gICk7XG59XG52YXIgTGluayA9IE1hcmsuY3JlYXRlKHtcbiAgbmFtZTogXCJsaW5rXCIsXG4gIHByaW9yaXR5OiAxZTMsXG4gIGtlZXBPblNwbGl0OiBmYWxzZSxcbiAgZXhpdGFibGU6IHRydWUsXG4gIG9uQ3JlYXRlKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMudmFsaWRhdGUgJiYgIXRoaXMub3B0aW9ucy5zaG91bGRBdXRvTGluaykge1xuICAgICAgdGhpcy5vcHRpb25zLnNob3VsZEF1dG9MaW5rID0gdGhpcy5vcHRpb25zLnZhbGlkYXRlO1xuICAgICAgY29uc29sZS53YXJuKFwiVGhlIGB2YWxpZGF0ZWAgb3B0aW9uIGlzIGRlcHJlY2F0ZWQuIFJlbmFtZSB0byB0aGUgYHNob3VsZEF1dG9MaW5rYCBvcHRpb24gaW5zdGVhZC5cIik7XG4gICAgfVxuICAgIHRoaXMub3B0aW9ucy5wcm90b2NvbHMuZm9yRWFjaCgocHJvdG9jb2wpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgcHJvdG9jb2wgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmVnaXN0ZXJDdXN0b21Qcm90b2NvbChwcm90b2NvbCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJlZ2lzdGVyQ3VzdG9tUHJvdG9jb2wocHJvdG9jb2wuc2NoZW1lLCBwcm90b2NvbC5vcHRpb25hbFNsYXNoZXMpO1xuICAgIH0pO1xuICB9LFxuICBvbkRlc3Ryb3koKSB7XG4gICAgcmVzZXQoKTtcbiAgfSxcbiAgaW5jbHVzaXZlKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuYXV0b2xpbms7XG4gIH0sXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9wZW5PbkNsaWNrOiB0cnVlLFxuICAgICAgZW5hYmxlQ2xpY2tTZWxlY3Rpb246IGZhbHNlLFxuICAgICAgbGlua09uUGFzdGU6IHRydWUsXG4gICAgICBhdXRvbGluazogdHJ1ZSxcbiAgICAgIHByb3RvY29sczogW10sXG4gICAgICBkZWZhdWx0UHJvdG9jb2w6IFwiaHR0cFwiLFxuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHtcbiAgICAgICAgdGFyZ2V0OiBcIl9ibGFua1wiLFxuICAgICAgICByZWw6IFwibm9vcGVuZXIgbm9yZWZlcnJlciBub2ZvbGxvd1wiLFxuICAgICAgICBjbGFzczogbnVsbFxuICAgICAgfSxcbiAgICAgIGlzQWxsb3dlZFVyaTogKHVybCwgY3R4KSA9PiAhIWlzQWxsb3dlZFVyaSh1cmwsIGN0eC5wcm90b2NvbHMpLFxuICAgICAgdmFsaWRhdGU6ICh1cmwpID0+ICEhdXJsLFxuICAgICAgc2hvdWxkQXV0b0xpbms6ICh1cmwpID0+ICEhdXJsXG4gICAgfTtcbiAgfSxcbiAgYWRkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaHJlZjoge1xuICAgICAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgICBwYXJzZUhUTUwoZWxlbWVudCkge1xuICAgICAgICAgIHJldHVybiBlbGVtZW50LmdldEF0dHJpYnV0ZShcImhyZWZcIik7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0YXJnZXQ6IHtcbiAgICAgICAgZGVmYXVsdDogdGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLnRhcmdldFxuICAgICAgfSxcbiAgICAgIHJlbDoge1xuICAgICAgICBkZWZhdWx0OiB0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMucmVsXG4gICAgICB9LFxuICAgICAgY2xhc3M6IHtcbiAgICAgICAgZGVmYXVsdDogdGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLmNsYXNzXG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIHRhZzogXCJhW2hyZWZdXCIsXG4gICAgICAgIGdldEF0dHJzOiAoZG9tKSA9PiB7XG4gICAgICAgICAgY29uc3QgaHJlZiA9IGRvbS5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpO1xuICAgICAgICAgIGlmICghaHJlZiB8fCAhdGhpcy5vcHRpb25zLmlzQWxsb3dlZFVyaShocmVmLCB7XG4gICAgICAgICAgICBkZWZhdWx0VmFsaWRhdGU6ICh1cmwpID0+ICEhaXNBbGxvd2VkVXJpKHVybCwgdGhpcy5vcHRpb25zLnByb3RvY29scyksXG4gICAgICAgICAgICBwcm90b2NvbHM6IHRoaXMub3B0aW9ucy5wcm90b2NvbHMsXG4gICAgICAgICAgICBkZWZhdWx0UHJvdG9jb2w6IHRoaXMub3B0aW9ucy5kZWZhdWx0UHJvdG9jb2xcbiAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIF07XG4gIH0sXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuaXNBbGxvd2VkVXJpKEhUTUxBdHRyaWJ1dGVzLmhyZWYsIHtcbiAgICAgIGRlZmF1bHRWYWxpZGF0ZTogKGhyZWYpID0+ICEhaXNBbGxvd2VkVXJpKGhyZWYsIHRoaXMub3B0aW9ucy5wcm90b2NvbHMpLFxuICAgICAgcHJvdG9jb2xzOiB0aGlzLm9wdGlvbnMucHJvdG9jb2xzLFxuICAgICAgZGVmYXVsdFByb3RvY29sOiB0aGlzLm9wdGlvbnMuZGVmYXVsdFByb3RvY29sXG4gICAgfSkpIHtcbiAgICAgIHJldHVybiBbXCJhXCIsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIHsgLi4uSFRNTEF0dHJpYnV0ZXMsIGhyZWY6IFwiXCIgfSksIDBdO1xuICAgIH1cbiAgICByZXR1cm4gW1wiYVwiLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdO1xuICB9LFxuICBtYXJrZG93blRva2VuTmFtZTogXCJsaW5rXCIsXG4gIHBhcnNlTWFya2Rvd246ICh0b2tlbiwgaGVscGVycykgPT4ge1xuICAgIHJldHVybiBoZWxwZXJzLmFwcGx5TWFyayhcImxpbmtcIiwgaGVscGVycy5wYXJzZUlubGluZSh0b2tlbi50b2tlbnMgfHwgW10pLCB7XG4gICAgICBocmVmOiB0b2tlbi5ocmVmLFxuICAgICAgdGl0bGU6IHRva2VuLnRpdGxlIHx8IG51bGxcbiAgICB9KTtcbiAgfSxcbiAgcmVuZGVyTWFya2Rvd246IChub2RlLCBoKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGhyZWYgPSAoKF9hID0gbm9kZS5hdHRycykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmhyZWYpIHx8IFwiXCI7XG4gICAgY29uc3QgdGV4dCA9IGgucmVuZGVyQ2hpbGRyZW4obm9kZSk7XG4gICAgcmV0dXJuIGBbJHt0ZXh0fV0oJHtocmVmfSlgO1xuICB9LFxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2V0TGluazogKGF0dHJpYnV0ZXMpID0+ICh7IGNoYWluIH0pID0+IHtcbiAgICAgICAgY29uc3QgeyBocmVmIH0gPSBhdHRyaWJ1dGVzO1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5pc0FsbG93ZWRVcmkoaHJlZiwge1xuICAgICAgICAgIGRlZmF1bHRWYWxpZGF0ZTogKHVybCkgPT4gISFpc0FsbG93ZWRVcmkodXJsLCB0aGlzLm9wdGlvbnMucHJvdG9jb2xzKSxcbiAgICAgICAgICBwcm90b2NvbHM6IHRoaXMub3B0aW9ucy5wcm90b2NvbHMsXG4gICAgICAgICAgZGVmYXVsdFByb3RvY29sOiB0aGlzLm9wdGlvbnMuZGVmYXVsdFByb3RvY29sXG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGFpbigpLnNldE1hcmsodGhpcy5uYW1lLCBhdHRyaWJ1dGVzKS5zZXRNZXRhKFwicHJldmVudEF1dG9saW5rXCIsIHRydWUpLnJ1bigpO1xuICAgICAgfSxcbiAgICAgIHRvZ2dsZUxpbms6IChhdHRyaWJ1dGVzKSA9PiAoeyBjaGFpbiB9KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgaHJlZiB9ID0gYXR0cmlidXRlcyB8fCB7fTtcbiAgICAgICAgaWYgKGhyZWYgJiYgIXRoaXMub3B0aW9ucy5pc0FsbG93ZWRVcmkoaHJlZiwge1xuICAgICAgICAgIGRlZmF1bHRWYWxpZGF0ZTogKHVybCkgPT4gISFpc0FsbG93ZWRVcmkodXJsLCB0aGlzLm9wdGlvbnMucHJvdG9jb2xzKSxcbiAgICAgICAgICBwcm90b2NvbHM6IHRoaXMub3B0aW9ucy5wcm90b2NvbHMsXG4gICAgICAgICAgZGVmYXVsdFByb3RvY29sOiB0aGlzLm9wdGlvbnMuZGVmYXVsdFByb3RvY29sXG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGFpbigpLnRvZ2dsZU1hcmsodGhpcy5uYW1lLCBhdHRyaWJ1dGVzLCB7IGV4dGVuZEVtcHR5TWFya1JhbmdlOiB0cnVlIH0pLnNldE1ldGEoXCJwcmV2ZW50QXV0b2xpbmtcIiwgdHJ1ZSkucnVuKCk7XG4gICAgICB9LFxuICAgICAgdW5zZXRMaW5rOiAoKSA9PiAoeyBjaGFpbiB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjaGFpbigpLnVuc2V0TWFyayh0aGlzLm5hbWUsIHsgZXh0ZW5kRW1wdHlNYXJrUmFuZ2U6IHRydWUgfSkuc2V0TWV0YShcInByZXZlbnRBdXRvbGlua1wiLCB0cnVlKS5ydW4oKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBhZGRQYXN0ZVJ1bGVzKCkge1xuICAgIHJldHVybiBbXG4gICAgICBtYXJrUGFzdGVSdWxlKHtcbiAgICAgICAgZmluZDogKHRleHQpID0+IHtcbiAgICAgICAgICBjb25zdCBmb3VuZExpbmtzID0gW107XG4gICAgICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcHJvdG9jb2xzLCBkZWZhdWx0UHJvdG9jb2wgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgICAgIGNvbnN0IGxpbmtzID0gZmluZDIodGV4dCkuZmlsdGVyKFxuICAgICAgICAgICAgICAoaXRlbSkgPT4gaXRlbS5pc0xpbmsgJiYgdGhpcy5vcHRpb25zLmlzQWxsb3dlZFVyaShpdGVtLnZhbHVlLCB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdFZhbGlkYXRlOiAoaHJlZikgPT4gISFpc0FsbG93ZWRVcmkoaHJlZiwgcHJvdG9jb2xzKSxcbiAgICAgICAgICAgICAgICBwcm90b2NvbHMsXG4gICAgICAgICAgICAgICAgZGVmYXVsdFByb3RvY29sXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKGxpbmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgICBsaW5rcy5mb3JFYWNoKChsaW5rKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuc2hvdWxkQXV0b0xpbmsobGluay52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm91bmRMaW5rcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIHRleHQ6IGxpbmsudmFsdWUsXG4gICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIGhyZWY6IGxpbmsuaHJlZlxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIGluZGV4OiBsaW5rLnN0YXJ0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZm91bmRMaW5rcztcbiAgICAgICAgfSxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICBnZXRBdHRyaWJ1dGVzOiAobWF0Y2gpID0+IHtcbiAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhyZWY6IChfYSA9IG1hdGNoLmRhdGEpID09IG51bGwgPyB2b2lkIDAgOiBfYS5ocmVmXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICBdO1xuICB9LFxuICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgY29uc3QgcGx1Z2lucyA9IFtdO1xuICAgIGNvbnN0IHsgcHJvdG9jb2xzLCBkZWZhdWx0UHJvdG9jb2wgfSA9IHRoaXMub3B0aW9ucztcbiAgICBpZiAodGhpcy5vcHRpb25zLmF1dG9saW5rKSB7XG4gICAgICBwbHVnaW5zLnB1c2goXG4gICAgICAgIGF1dG9saW5rKHtcbiAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgZGVmYXVsdFByb3RvY29sOiB0aGlzLm9wdGlvbnMuZGVmYXVsdFByb3RvY29sLFxuICAgICAgICAgIHZhbGlkYXRlOiAodXJsKSA9PiB0aGlzLm9wdGlvbnMuaXNBbGxvd2VkVXJpKHVybCwge1xuICAgICAgICAgICAgZGVmYXVsdFZhbGlkYXRlOiAoaHJlZikgPT4gISFpc0FsbG93ZWRVcmkoaHJlZiwgcHJvdG9jb2xzKSxcbiAgICAgICAgICAgIHByb3RvY29scyxcbiAgICAgICAgICAgIGRlZmF1bHRQcm90b2NvbFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHNob3VsZEF1dG9MaW5rOiB0aGlzLm9wdGlvbnMuc2hvdWxkQXV0b0xpbmtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICAgIHBsdWdpbnMucHVzaChcbiAgICAgIGNsaWNrSGFuZGxlcih7XG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcbiAgICAgICAgb3Blbk9uQ2xpY2s6IHRoaXMub3B0aW9ucy5vcGVuT25DbGljayA9PT0gXCJ3aGVuTm90RWRpdGFibGVcIiA/IHRydWUgOiB0aGlzLm9wdGlvbnMub3Blbk9uQ2xpY2ssXG4gICAgICAgIGVuYWJsZUNsaWNrU2VsZWN0aW9uOiB0aGlzLm9wdGlvbnMuZW5hYmxlQ2xpY2tTZWxlY3Rpb25cbiAgICAgIH0pXG4gICAgKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmxpbmtPblBhc3RlKSB7XG4gICAgICBwbHVnaW5zLnB1c2goXG4gICAgICAgIHBhc3RlSGFuZGxlcih7XG4gICAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcbiAgICAgICAgICBkZWZhdWx0UHJvdG9jb2w6IHRoaXMub3B0aW9ucy5kZWZhdWx0UHJvdG9jb2wsXG4gICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgIHNob3VsZEF1dG9MaW5rOiB0aGlzLm9wdGlvbnMuc2hvdWxkQXV0b0xpbmtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBwbHVnaW5zO1xuICB9XG59KTtcblxuLy8gc3JjL2luZGV4LnRzXG52YXIgaW5kZXhfZGVmYXVsdCA9IExpbms7XG5leHBvcnQge1xuICBMaW5rLFxuICBpbmRleF9kZWZhdWx0IGFzIGRlZmF1bHQsXG4gIGlzQWxsb3dlZFVyaSxcbiAgcGFzdGVSZWdleFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJNYXJrIiwibWFya1Bhc3RlUnVsZSIsIm1lcmdlQXR0cmlidXRlcyIsImZpbmQiLCJmaW5kMiIsInJlZ2lzdGVyQ3VzdG9tUHJvdG9jb2wiLCJyZXNldCIsImNvbWJpbmVUcmFuc2FjdGlvblN0ZXBzIiwiZmluZENoaWxkcmVuSW5SYW5nZSIsImdldENoYW5nZWRSYW5nZXMiLCJnZXRNYXJrc0JldHdlZW4iLCJQbHVnaW4iLCJQbHVnaW5LZXkiLCJ0b2tlbml6ZSIsIlVOSUNPREVfV0hJVEVTUEFDRV9QQVRURVJOIiwiVU5JQ09ERV9XSElURVNQQUNFX1JFR0VYIiwiUmVnRXhwIiwiVU5JQ09ERV9XSElURVNQQUNFX1JFR0VYX0VORCIsIlVOSUNPREVfV0hJVEVTUEFDRV9SRUdFWF9HTE9CQUwiLCJpc1ZhbGlkTGlua1N0cnVjdHVyZSIsInRva2VucyIsImxlbmd0aCIsImlzTGluayIsImluY2x1ZGVzIiwidmFsdWUiLCJhdXRvbGluayIsIm9wdGlvbnMiLCJrZXkiLCJhcHBlbmRUcmFuc2FjdGlvbiIsInRyYW5zYWN0aW9ucyIsIm9sZFN0YXRlIiwibmV3U3RhdGUiLCJkb2NDaGFuZ2VzIiwic29tZSIsInRyYW5zYWN0aW9uIiwiZG9jQ2hhbmdlZCIsImRvYyIsImVxIiwicHJldmVudEF1dG9saW5rIiwiZ2V0TWV0YSIsInRyIiwidHJhbnNmb3JtIiwiY2hhbmdlcyIsImZvckVhY2giLCJuZXdSYW5nZSIsIm5vZGVzSW5DaGFuZ2VkUmFuZ2VzIiwibm9kZSIsImlzVGV4dGJsb2NrIiwidGV4dEJsb2NrIiwidGV4dEJlZm9yZVdoaXRlc3BhY2UiLCJ0ZXh0QmV0d2VlbiIsInBvcyIsIm5vZGVTaXplIiwiZW5kVGV4dCIsImZyb20iLCJ0byIsInRlc3QiLCJ3b3Jkc0JlZm9yZVdoaXRlc3BhY2UiLCJzcGxpdCIsImZpbHRlciIsIkJvb2xlYW4iLCJsYXN0V29yZEJlZm9yZVNwYWNlIiwibGFzdFdvcmRBbmRCbG9ja09mZnNldCIsImxhc3RJbmRleE9mIiwibGlua3NCZWZvcmVTcGFjZSIsIm1hcCIsInQiLCJ0b09iamVjdCIsImRlZmF1bHRQcm90b2NvbCIsImxpbmsiLCJzdGFydCIsImVuZCIsInNjaGVtYSIsIm1hcmtzIiwiY29kZSIsInJhbmdlSGFzTWFyayIsInZhbGlkYXRlIiwic2hvdWxkQXV0b0xpbmsiLCJpdGVtIiwibWFyayIsInR5cGUiLCJhZGRNYXJrIiwiY3JlYXRlIiwiaHJlZiIsInN0ZXBzIiwiZ2V0QXR0cmlidXRlcyIsIlBsdWdpbjIiLCJQbHVnaW5LZXkyIiwiY2xpY2tIYW5kbGVyIiwicHJvcHMiLCJoYW5kbGVDbGljayIsInZpZXciLCJldmVudCIsIl9hIiwiX2IiLCJidXR0b24iLCJlZGl0YWJsZSIsImhhbmRsZWQiLCJlbmFibGVDbGlja1NlbGVjdGlvbiIsImNvbW1hbmRSZXN1bHQiLCJlZGl0b3IiLCJjb21tYW5kcyIsImV4dGVuZE1hcmtSYW5nZSIsIm5hbWUiLCJvcGVuT25DbGljayIsInRhcmdldCIsIkhUTUxBbmNob3JFbGVtZW50IiwiYSIsImVscyIsIm5vZGVOYW1lIiwicHVzaCIsInBhcmVudE5vZGUiLCJhdHRycyIsInN0YXRlIiwid2luZG93Iiwib3BlbiIsIlBsdWdpbjMiLCJQbHVnaW5LZXkzIiwicGFzdGVIYW5kbGVyIiwiaGFuZGxlUGFzdGUiLCJfZXZlbnQiLCJzbGljZSIsInNlbGVjdGlvbiIsImVtcHR5IiwidGV4dENvbnRlbnQiLCJjb250ZW50Iiwic2V0TWFyayIsInBhc3RlUmVnZXgiLCJpc0FsbG93ZWRVcmkiLCJ1cmkiLCJwcm90b2NvbHMiLCJhbGxvd2VkUHJvdG9jb2xzIiwicHJvdG9jb2wiLCJuZXh0UHJvdG9jb2wiLCJzY2hlbWUiLCJyZXBsYWNlIiwibWF0Y2giLCJqb2luIiwiTGluayIsInByaW9yaXR5Iiwia2VlcE9uU3BsaXQiLCJleGl0YWJsZSIsIm9uQ3JlYXRlIiwiY29uc29sZSIsIndhcm4iLCJvcHRpb25hbFNsYXNoZXMiLCJvbkRlc3Ryb3kiLCJpbmNsdXNpdmUiLCJhZGRPcHRpb25zIiwibGlua09uUGFzdGUiLCJIVE1MQXR0cmlidXRlcyIsInJlbCIsImNsYXNzIiwidXJsIiwiY3R4IiwiYWRkQXR0cmlidXRlcyIsImRlZmF1bHQiLCJwYXJzZUhUTUwiLCJlbGVtZW50IiwiZ2V0QXR0cmlidXRlIiwidGFnIiwiZ2V0QXR0cnMiLCJkb20iLCJkZWZhdWx0VmFsaWRhdGUiLCJyZW5kZXJIVE1MIiwibWFya2Rvd25Ub2tlbk5hbWUiLCJwYXJzZU1hcmtkb3duIiwidG9rZW4iLCJoZWxwZXJzIiwiYXBwbHlNYXJrIiwicGFyc2VJbmxpbmUiLCJ0aXRsZSIsInJlbmRlck1hcmtkb3duIiwiaCIsInRleHQiLCJyZW5kZXJDaGlsZHJlbiIsImFkZENvbW1hbmRzIiwic2V0TGluayIsImF0dHJpYnV0ZXMiLCJjaGFpbiIsInNldE1ldGEiLCJydW4iLCJ0b2dnbGVMaW5rIiwidG9nZ2xlTWFyayIsImV4dGVuZEVtcHR5TWFya1JhbmdlIiwidW5zZXRMaW5rIiwidW5zZXRNYXJrIiwiYWRkUGFzdGVSdWxlcyIsImZvdW5kTGlua3MiLCJsaW5rcyIsImRhdGEiLCJpbmRleCIsImFkZFByb3NlTWlycm9yUGx1Z2lucyIsInBsdWdpbnMiLCJpbmRleF9kZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-link/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-list/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@tiptap/extension-list/dist/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BulletList: () => (/* binding */ BulletList),\n/* harmony export */   ListItem: () => (/* binding */ ListItem),\n/* harmony export */   ListKeymap: () => (/* binding */ ListKeymap),\n/* harmony export */   ListKit: () => (/* binding */ ListKit),\n/* harmony export */   OrderedList: () => (/* binding */ OrderedList),\n/* harmony export */   TaskItem: () => (/* binding */ TaskItem),\n/* harmony export */   TaskList: () => (/* binding */ TaskList),\n/* harmony export */   bulletListInputRegex: () => (/* binding */ bulletListInputRegex),\n/* harmony export */   inputRegex: () => (/* binding */ inputRegex),\n/* harmony export */   listHelpers: () => (/* binding */ listHelpers_exports),\n/* harmony export */   orderedListInputRegex: () => (/* binding */ orderedListInputRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\nvar __defProp = Object.defineProperty;\nvar __export = (target, all)=>{\n    for(var name in all)__defProp(target, name, {\n        get: all[name],\n        enumerable: true\n    });\n};\n// src/bullet-list/bullet-list.ts\n\nvar ListItemName = \"listItem\";\nvar TextStyleName = \"textStyle\";\nvar bulletListInputRegex = /^\\s*([-+*])\\s$/;\nvar BulletList = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n    name: \"bulletList\",\n    addOptions () {\n        return {\n            itemTypeName: \"listItem\",\n            HTMLAttributes: {},\n            keepMarks: false,\n            keepAttributes: false\n        };\n    },\n    group: \"block list\",\n    content () {\n        return `${this.options.itemTypeName}+`;\n    },\n    parseHTML () {\n        return [\n            {\n                tag: \"ul\"\n            }\n        ];\n    },\n    renderHTML ({ HTMLAttributes }) {\n        return [\n            \"ul\",\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes),\n            0\n        ];\n    },\n    markdownTokenName: \"list\",\n    parseMarkdown: (token, helpers)=>{\n        if (token.type !== \"list\" || token.ordered) {\n            return [];\n        }\n        return {\n            type: \"bulletList\",\n            content: token.items ? helpers.parseChildren(token.items) : []\n        };\n    },\n    renderMarkdown: (node, h)=>{\n        if (!node.content) {\n            return \"\";\n        }\n        return h.renderChildren(node.content, \"\\n\");\n    },\n    markdownOptions: {\n        indentsContent: true\n    },\n    addCommands () {\n        return {\n            toggleBulletList: ()=>({ commands, chain })=>{\n                    if (this.options.keepAttributes) {\n                        return chain().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(ListItemName, this.editor.getAttributes(TextStyleName)).run();\n                    }\n                    return commands.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks);\n                }\n        };\n    },\n    addKeyboardShortcuts () {\n        return {\n            \"Mod-Shift-8\": ()=>this.editor.commands.toggleBulletList()\n        };\n    },\n    addInputRules () {\n        let inputRule = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.wrappingInputRule)({\n            find: bulletListInputRegex,\n            type: this.type\n        });\n        if (this.options.keepMarks || this.options.keepAttributes) {\n            inputRule = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.wrappingInputRule)({\n                find: bulletListInputRegex,\n                type: this.type,\n                keepMarks: this.options.keepMarks,\n                keepAttributes: this.options.keepAttributes,\n                getAttributes: ()=>{\n                    return this.editor.getAttributes(TextStyleName);\n                },\n                editor: this.editor\n            });\n        }\n        return [\n            inputRule\n        ];\n    }\n});\n// src/item/list-item.ts\n\nvar ListItem = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n    name: \"listItem\",\n    addOptions () {\n        return {\n            HTMLAttributes: {},\n            bulletListTypeName: \"bulletList\",\n            orderedListTypeName: \"orderedList\"\n        };\n    },\n    content: \"paragraph block*\",\n    defining: true,\n    parseHTML () {\n        return [\n            {\n                tag: \"li\"\n            }\n        ];\n    },\n    renderHTML ({ HTMLAttributes }) {\n        return [\n            \"li\",\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes),\n            0\n        ];\n    },\n    markdownTokenName: \"list_item\",\n    parseMarkdown: (token, helpers)=>{\n        if (token.type !== \"list_item\") {\n            return [];\n        }\n        let content = [];\n        if (token.tokens && token.tokens.length > 0) {\n            const hasParagraphTokens = token.tokens.some((t)=>t.type === \"paragraph\");\n            if (hasParagraphTokens) {\n                content = helpers.parseChildren(token.tokens);\n            } else {\n                const firstToken = token.tokens[0];\n                if (firstToken && firstToken.type === \"text\" && firstToken.tokens && firstToken.tokens.length > 0) {\n                    const inlineContent = helpers.parseInline(firstToken.tokens);\n                    content = [\n                        {\n                            type: \"paragraph\",\n                            content: inlineContent\n                        }\n                    ];\n                    if (token.tokens.length > 1) {\n                        const remainingTokens = token.tokens.slice(1);\n                        const additionalContent = helpers.parseChildren(remainingTokens);\n                        content.push(...additionalContent);\n                    }\n                } else {\n                    content = helpers.parseChildren(token.tokens);\n                }\n            }\n        }\n        if (content.length === 0) {\n            content = [\n                {\n                    type: \"paragraph\",\n                    content: []\n                }\n            ];\n        }\n        return {\n            type: \"listItem\",\n            content\n        };\n    },\n    renderMarkdown: (node, h, ctx)=>{\n        return (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.renderNestedMarkdownContent)(node, h, (context)=>{\n            if (context.parentType === \"bulletList\") {\n                return \"- \";\n            }\n            if (context.parentType === \"orderedList\") {\n                return `${context.index + 1}. `;\n            }\n            return \"- \";\n        }, ctx);\n    },\n    addKeyboardShortcuts () {\n        return {\n            Enter: ()=>this.editor.commands.splitListItem(this.name),\n            Tab: ()=>this.editor.commands.sinkListItem(this.name),\n            \"Shift-Tab\": ()=>this.editor.commands.liftListItem(this.name)\n        };\n    }\n});\n// src/keymap/list-keymap.ts\n\n// src/keymap/listHelpers/index.ts\nvar listHelpers_exports = {};\n__export(listHelpers_exports, {\n    findListItemPos: ()=>findListItemPos,\n    getNextListDepth: ()=>getNextListDepth,\n    handleBackspace: ()=>handleBackspace,\n    handleDelete: ()=>handleDelete,\n    hasListBefore: ()=>hasListBefore,\n    hasListItemAfter: ()=>hasListItemAfter,\n    hasListItemBefore: ()=>hasListItemBefore,\n    listItemHasSubList: ()=>listItemHasSubList,\n    nextListIsDeeper: ()=>nextListIsDeeper,\n    nextListIsHigher: ()=>nextListIsHigher\n});\n// src/keymap/listHelpers/findListItemPos.ts\n\nvar findListItemPos = (typeOrName, state)=>{\n    const { $from } = state.selection;\n    const nodeType = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.getNodeType)(typeOrName, state.schema);\n    let currentNode = null;\n    let currentDepth = $from.depth;\n    let currentPos = $from.pos;\n    let targetDepth = null;\n    while(currentDepth > 0 && targetDepth === null){\n        currentNode = $from.node(currentDepth);\n        if (currentNode.type === nodeType) {\n            targetDepth = currentDepth;\n        } else {\n            currentDepth -= 1;\n            currentPos -= 1;\n        }\n    }\n    if (targetDepth === null) {\n        return null;\n    }\n    return {\n        $pos: state.doc.resolve(currentPos),\n        depth: targetDepth\n    };\n};\n// src/keymap/listHelpers/getNextListDepth.ts\n\nvar getNextListDepth = (typeOrName, state)=>{\n    const listItemPos = findListItemPos(typeOrName, state);\n    if (!listItemPos) {\n        return false;\n    }\n    const [, depth] = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.getNodeAtPosition)(state, typeOrName, listItemPos.$pos.pos + 4);\n    return depth;\n};\n// src/keymap/listHelpers/handleBackspace.ts\n\n// src/keymap/listHelpers/hasListBefore.ts\nvar hasListBefore = (editorState, name, parentListTypes)=>{\n    const { $anchor } = editorState.selection;\n    const previousNodePos = Math.max(0, $anchor.pos - 2);\n    const previousNode = editorState.doc.resolve(previousNodePos).node();\n    if (!previousNode || !parentListTypes.includes(previousNode.type.name)) {\n        return false;\n    }\n    return true;\n};\n// src/keymap/listHelpers/hasListItemBefore.ts\nvar hasListItemBefore = (typeOrName, state)=>{\n    var _a;\n    const { $anchor } = state.selection;\n    const $targetPos = state.doc.resolve($anchor.pos - 2);\n    if ($targetPos.index() === 0) {\n        return false;\n    }\n    if (((_a = $targetPos.nodeBefore) == null ? void 0 : _a.type.name) !== typeOrName) {\n        return false;\n    }\n    return true;\n};\n// src/keymap/listHelpers/listItemHasSubList.ts\n\nvar listItemHasSubList = (typeOrName, state, node)=>{\n    if (!node) {\n        return false;\n    }\n    const nodeType = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.getNodeType)(typeOrName, state.schema);\n    let hasSubList = false;\n    node.descendants((child)=>{\n        if (child.type === nodeType) {\n            hasSubList = true;\n        }\n    });\n    return hasSubList;\n};\n// src/keymap/listHelpers/handleBackspace.ts\nvar handleBackspace = (editor, name, parentListTypes)=>{\n    if (editor.commands.undoInputRule()) {\n        return true;\n    }\n    if (editor.state.selection.from !== editor.state.selection.to) {\n        return false;\n    }\n    if (!(0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.isNodeActive)(editor.state, name) && hasListBefore(editor.state, name, parentListTypes)) {\n        const { $anchor } = editor.state.selection;\n        const $listPos = editor.state.doc.resolve($anchor.before() - 1);\n        const listDescendants = [];\n        $listPos.node().descendants((node, pos)=>{\n            if (node.type.name === name) {\n                listDescendants.push({\n                    node,\n                    pos\n                });\n            }\n        });\n        const lastItem = listDescendants.at(-1);\n        if (!lastItem) {\n            return false;\n        }\n        const $lastItemPos = editor.state.doc.resolve($listPos.start() + lastItem.pos + 1);\n        return editor.chain().cut({\n            from: $anchor.start() - 1,\n            to: $anchor.end() + 1\n        }, $lastItemPos.end()).joinForward().run();\n    }\n    if (!(0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.isNodeActive)(editor.state, name)) {\n        return false;\n    }\n    if (!(0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.isAtStartOfNode)(editor.state)) {\n        return false;\n    }\n    const listItemPos = findListItemPos(name, editor.state);\n    if (!listItemPos) {\n        return false;\n    }\n    const $prev = editor.state.doc.resolve(listItemPos.$pos.pos - 2);\n    const prevNode = $prev.node(listItemPos.depth);\n    const previousListItemHasSubList = listItemHasSubList(name, editor.state, prevNode);\n    if (hasListItemBefore(name, editor.state) && !previousListItemHasSubList) {\n        return editor.commands.joinItemBackward();\n    }\n    return editor.chain().liftListItem(name).run();\n};\n// src/keymap/listHelpers/handleDelete.ts\n\n// src/keymap/listHelpers/nextListIsDeeper.ts\nvar nextListIsDeeper = (typeOrName, state)=>{\n    const listDepth = getNextListDepth(typeOrName, state);\n    const listItemPos = findListItemPos(typeOrName, state);\n    if (!listItemPos || !listDepth) {\n        return false;\n    }\n    if (listDepth > listItemPos.depth) {\n        return true;\n    }\n    return false;\n};\n// src/keymap/listHelpers/nextListIsHigher.ts\nvar nextListIsHigher = (typeOrName, state)=>{\n    const listDepth = getNextListDepth(typeOrName, state);\n    const listItemPos = findListItemPos(typeOrName, state);\n    if (!listItemPos || !listDepth) {\n        return false;\n    }\n    if (listDepth < listItemPos.depth) {\n        return true;\n    }\n    return false;\n};\n// src/keymap/listHelpers/handleDelete.ts\nvar handleDelete = (editor, name)=>{\n    if (!(0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.isNodeActive)(editor.state, name)) {\n        return false;\n    }\n    if (!(0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.isAtEndOfNode)(editor.state, name)) {\n        return false;\n    }\n    const { selection } = editor.state;\n    const { $from, $to } = selection;\n    if (!selection.empty && $from.sameParent($to)) {\n        return false;\n    }\n    if (nextListIsDeeper(name, editor.state)) {\n        return editor.chain().focus(editor.state.selection.from + 4).lift(name).joinBackward().run();\n    }\n    if (nextListIsHigher(name, editor.state)) {\n        return editor.chain().joinForward().joinBackward().run();\n    }\n    return editor.commands.joinItemForward();\n};\n// src/keymap/listHelpers/hasListItemAfter.ts\nvar hasListItemAfter = (typeOrName, state)=>{\n    var _a;\n    const { $anchor } = state.selection;\n    const $targetPos = state.doc.resolve($anchor.pos - $anchor.parentOffset - 2);\n    if ($targetPos.index() === $targetPos.parent.childCount - 1) {\n        return false;\n    }\n    if (((_a = $targetPos.nodeAfter) == null ? void 0 : _a.type.name) !== typeOrName) {\n        return false;\n    }\n    return true;\n};\n// src/keymap/list-keymap.ts\nvar ListKeymap = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Extension.create({\n    name: \"listKeymap\",\n    addOptions () {\n        return {\n            listTypes: [\n                {\n                    itemName: \"listItem\",\n                    wrapperNames: [\n                        \"bulletList\",\n                        \"orderedList\"\n                    ]\n                },\n                {\n                    itemName: \"taskItem\",\n                    wrapperNames: [\n                        \"taskList\"\n                    ]\n                }\n            ]\n        };\n    },\n    addKeyboardShortcuts () {\n        return {\n            Delete: ({ editor })=>{\n                let handled = false;\n                this.options.listTypes.forEach(({ itemName })=>{\n                    if (editor.state.schema.nodes[itemName] === void 0) {\n                        return;\n                    }\n                    if (handleDelete(editor, itemName)) {\n                        handled = true;\n                    }\n                });\n                return handled;\n            },\n            \"Mod-Delete\": ({ editor })=>{\n                let handled = false;\n                this.options.listTypes.forEach(({ itemName })=>{\n                    if (editor.state.schema.nodes[itemName] === void 0) {\n                        return;\n                    }\n                    if (handleDelete(editor, itemName)) {\n                        handled = true;\n                    }\n                });\n                return handled;\n            },\n            Backspace: ({ editor })=>{\n                let handled = false;\n                this.options.listTypes.forEach(({ itemName, wrapperNames })=>{\n                    if (editor.state.schema.nodes[itemName] === void 0) {\n                        return;\n                    }\n                    if (handleBackspace(editor, itemName, wrapperNames)) {\n                        handled = true;\n                    }\n                });\n                return handled;\n            },\n            \"Mod-Backspace\": ({ editor })=>{\n                let handled = false;\n                this.options.listTypes.forEach(({ itemName, wrapperNames })=>{\n                    if (editor.state.schema.nodes[itemName] === void 0) {\n                        return;\n                    }\n                    if (handleBackspace(editor, itemName, wrapperNames)) {\n                        handled = true;\n                    }\n                });\n                return handled;\n            }\n        };\n    }\n});\n// src/kit/index.ts\n\n// src/ordered-list/ordered-list.ts\n\n// src/ordered-list/utils.ts\nvar ORDERED_LIST_ITEM_REGEX = /^(\\s*)(\\d+)\\.\\s+(.*)$/;\nvar INDENTED_LINE_REGEX = /^\\s/;\nfunction collectOrderedListItems(lines) {\n    const listItems = [];\n    let currentLineIndex = 0;\n    let consumed = 0;\n    while(currentLineIndex < lines.length){\n        const line = lines[currentLineIndex];\n        const match = line.match(ORDERED_LIST_ITEM_REGEX);\n        if (!match) {\n            break;\n        }\n        const [, indent, number, content] = match;\n        const indentLevel = indent.length;\n        let itemContent = content;\n        let nextLineIndex = currentLineIndex + 1;\n        const itemLines = [\n            line\n        ];\n        while(nextLineIndex < lines.length){\n            const nextLine = lines[nextLineIndex];\n            const nextMatch = nextLine.match(ORDERED_LIST_ITEM_REGEX);\n            if (nextMatch) {\n                break;\n            }\n            if (nextLine.trim() === \"\") {\n                itemLines.push(nextLine);\n                itemContent += \"\\n\";\n                nextLineIndex += 1;\n            } else if (nextLine.match(INDENTED_LINE_REGEX)) {\n                itemLines.push(nextLine);\n                itemContent += `\n${nextLine.slice(indentLevel + 2)}`;\n                nextLineIndex += 1;\n            } else {\n                break;\n            }\n        }\n        listItems.push({\n            indent: indentLevel,\n            number: parseInt(number, 10),\n            content: itemContent.trim(),\n            raw: itemLines.join(\"\\n\")\n        });\n        consumed = nextLineIndex;\n        currentLineIndex = nextLineIndex;\n    }\n    return [\n        listItems,\n        consumed\n    ];\n}\nfunction buildNestedStructure(items, baseIndent, lexer) {\n    var _a;\n    const result = [];\n    let currentIndex = 0;\n    while(currentIndex < items.length){\n        const item = items[currentIndex];\n        if (item.indent === baseIndent) {\n            const contentLines = item.content.split(\"\\n\");\n            const mainText = ((_a = contentLines[0]) == null ? void 0 : _a.trim()) || \"\";\n            const tokens = [];\n            if (mainText) {\n                tokens.push({\n                    type: \"paragraph\",\n                    raw: mainText,\n                    tokens: lexer.inlineTokens(mainText)\n                });\n            }\n            const additionalContent = contentLines.slice(1).join(\"\\n\").trim();\n            if (additionalContent) {\n                const blockTokens = lexer.blockTokens(additionalContent);\n                tokens.push(...blockTokens);\n            }\n            let lookAheadIndex = currentIndex + 1;\n            const nestedItems = [];\n            while(lookAheadIndex < items.length && items[lookAheadIndex].indent > baseIndent){\n                nestedItems.push(items[lookAheadIndex]);\n                lookAheadIndex += 1;\n            }\n            if (nestedItems.length > 0) {\n                const nextIndent = Math.min(...nestedItems.map((nestedItem)=>nestedItem.indent));\n                const nestedListItems = buildNestedStructure(nestedItems, nextIndent, lexer);\n                tokens.push({\n                    type: \"list\",\n                    ordered: true,\n                    start: nestedItems[0].number,\n                    items: nestedListItems,\n                    raw: nestedItems.map((nestedItem)=>nestedItem.raw).join(\"\\n\")\n                });\n            }\n            result.push({\n                type: \"list_item\",\n                raw: item.raw,\n                tokens\n            });\n            currentIndex = lookAheadIndex;\n        } else {\n            currentIndex += 1;\n        }\n    }\n    return result;\n}\nfunction parseListItems(items, helpers) {\n    return items.map((item)=>{\n        if (item.type !== \"list_item\") {\n            return helpers.parseChildren([\n                item\n            ])[0];\n        }\n        const content = [];\n        if (item.tokens && item.tokens.length > 0) {\n            item.tokens.forEach((itemToken)=>{\n                if (itemToken.type === \"paragraph\" || itemToken.type === \"list\" || itemToken.type === \"blockquote\" || itemToken.type === \"code\") {\n                    content.push(...helpers.parseChildren([\n                        itemToken\n                    ]));\n                } else if (itemToken.type === \"text\" && itemToken.tokens) {\n                    const inlineContent = helpers.parseChildren([\n                        itemToken\n                    ]);\n                    content.push({\n                        type: \"paragraph\",\n                        content: inlineContent\n                    });\n                } else {\n                    const parsed = helpers.parseChildren([\n                        itemToken\n                    ]);\n                    if (parsed.length > 0) {\n                        content.push(...parsed);\n                    }\n                }\n            });\n        }\n        return {\n            type: \"listItem\",\n            content\n        };\n    });\n}\n// src/ordered-list/ordered-list.ts\nvar ListItemName2 = \"listItem\";\nvar TextStyleName2 = \"textStyle\";\nvar orderedListInputRegex = /^(\\d+)\\.\\s$/;\nvar OrderedList = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n    name: \"orderedList\",\n    addOptions () {\n        return {\n            itemTypeName: \"listItem\",\n            HTMLAttributes: {},\n            keepMarks: false,\n            keepAttributes: false\n        };\n    },\n    group: \"block list\",\n    content () {\n        return `${this.options.itemTypeName}+`;\n    },\n    addAttributes () {\n        return {\n            start: {\n                default: 1,\n                parseHTML: (element)=>{\n                    return element.hasAttribute(\"start\") ? parseInt(element.getAttribute(\"start\") || \"\", 10) : 1;\n                }\n            },\n            type: {\n                default: null,\n                parseHTML: (element)=>element.getAttribute(\"type\")\n            }\n        };\n    },\n    parseHTML () {\n        return [\n            {\n                tag: \"ol\"\n            }\n        ];\n    },\n    renderHTML ({ HTMLAttributes }) {\n        const { start, ...attributesWithoutStart } = HTMLAttributes;\n        return start === 1 ? [\n            \"ol\",\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, attributesWithoutStart),\n            0\n        ] : [\n            \"ol\",\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes),\n            0\n        ];\n    },\n    markdownTokenName: \"list\",\n    parseMarkdown: (token, helpers)=>{\n        if (token.type !== \"list\" || !token.ordered) {\n            return [];\n        }\n        const startValue = token.start || 1;\n        const content = token.items ? parseListItems(token.items, helpers) : [];\n        if (startValue !== 1) {\n            return {\n                type: \"orderedList\",\n                attrs: {\n                    start: startValue\n                },\n                content\n            };\n        }\n        return {\n            type: \"orderedList\",\n            content\n        };\n    },\n    renderMarkdown: (node, h)=>{\n        if (!node.content) {\n            return \"\";\n        }\n        return h.renderChildren(node.content, \"\\n\");\n    },\n    markdownTokenizer: {\n        name: \"orderedList\",\n        level: \"block\",\n        start: (src)=>{\n            const match = src.match(/^(\\s*)(\\d+)\\.\\s+/);\n            const index = match == null ? void 0 : match.index;\n            return index !== void 0 ? index : -1;\n        },\n        tokenize: (src, _tokens, lexer)=>{\n            var _a;\n            const lines = src.split(\"\\n\");\n            const [listItems, consumed] = collectOrderedListItems(lines);\n            if (listItems.length === 0) {\n                return void 0;\n            }\n            const items = buildNestedStructure(listItems, 0, lexer);\n            if (items.length === 0) {\n                return void 0;\n            }\n            const startValue = ((_a = listItems[0]) == null ? void 0 : _a.number) || 1;\n            return {\n                type: \"list\",\n                ordered: true,\n                start: startValue,\n                items,\n                raw: lines.slice(0, consumed).join(\"\\n\")\n            };\n        }\n    },\n    markdownOptions: {\n        indentsContent: true\n    },\n    addCommands () {\n        return {\n            toggleOrderedList: ()=>({ commands, chain })=>{\n                    if (this.options.keepAttributes) {\n                        return chain().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(ListItemName2, this.editor.getAttributes(TextStyleName2)).run();\n                    }\n                    return commands.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks);\n                }\n        };\n    },\n    addKeyboardShortcuts () {\n        return {\n            \"Mod-Shift-7\": ()=>this.editor.commands.toggleOrderedList()\n        };\n    },\n    addInputRules () {\n        let inputRule = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.wrappingInputRule)({\n            find: orderedListInputRegex,\n            type: this.type,\n            getAttributes: (match)=>({\n                    start: +match[1]\n                }),\n            joinPredicate: (match, node)=>node.childCount + node.attrs.start === +match[1]\n        });\n        if (this.options.keepMarks || this.options.keepAttributes) {\n            inputRule = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.wrappingInputRule)({\n                find: orderedListInputRegex,\n                type: this.type,\n                keepMarks: this.options.keepMarks,\n                keepAttributes: this.options.keepAttributes,\n                getAttributes: (match)=>({\n                        start: +match[1],\n                        ...this.editor.getAttributes(TextStyleName2)\n                    }),\n                joinPredicate: (match, node)=>node.childCount + node.attrs.start === +match[1],\n                editor: this.editor\n            });\n        }\n        return [\n            inputRule\n        ];\n    }\n});\n// src/task-item/task-item.ts\n\nvar inputRegex = /^\\s*(\\[([( |x])?\\])\\s$/;\nvar TaskItem = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n    name: \"taskItem\",\n    addOptions () {\n        return {\n            nested: false,\n            HTMLAttributes: {},\n            taskListTypeName: \"taskList\",\n            a11y: void 0\n        };\n    },\n    content () {\n        return this.options.nested ? \"paragraph block*\" : \"paragraph+\";\n    },\n    defining: true,\n    addAttributes () {\n        return {\n            checked: {\n                default: false,\n                keepOnSplit: false,\n                parseHTML: (element)=>{\n                    const dataChecked = element.getAttribute(\"data-checked\");\n                    return dataChecked === \"\" || dataChecked === \"true\";\n                },\n                renderHTML: (attributes)=>({\n                        \"data-checked\": attributes.checked\n                    })\n            }\n        };\n    },\n    parseHTML () {\n        return [\n            {\n                tag: `li[data-type=\"${this.name}\"]`,\n                priority: 51\n            }\n        ];\n    },\n    renderHTML ({ node, HTMLAttributes }) {\n        return [\n            \"li\",\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes, {\n                \"data-type\": this.name\n            }),\n            [\n                \"label\",\n                [\n                    \"input\",\n                    {\n                        type: \"checkbox\",\n                        checked: node.attrs.checked ? \"checked\" : null\n                    }\n                ],\n                [\n                    \"span\"\n                ]\n            ],\n            [\n                \"div\",\n                0\n            ]\n        ];\n    },\n    parseMarkdown: (token, h)=>{\n        const content = [];\n        if (token.tokens && token.tokens.length > 0) {\n            content.push(h.createNode(\"paragraph\", {}, h.parseInline(token.tokens)));\n        } else if (token.text) {\n            content.push(h.createNode(\"paragraph\", {}, [\n                h.createNode(\"text\", {\n                    text: token.text\n                })\n            ]));\n        } else {\n            content.push(h.createNode(\"paragraph\", {}, []));\n        }\n        if (token.nestedTokens && token.nestedTokens.length > 0) {\n            const nestedContent = h.parseChildren(token.nestedTokens);\n            content.push(...nestedContent);\n        }\n        return h.createNode(\"taskItem\", {\n            checked: token.checked || false\n        }, content);\n    },\n    renderMarkdown: (node, h)=>{\n        var _a;\n        const checkedChar = ((_a = node.attrs) == null ? void 0 : _a.checked) ? \"x\" : \" \";\n        const prefix = `- [${checkedChar}] `;\n        return (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.renderNestedMarkdownContent)(node, h, prefix);\n    },\n    addKeyboardShortcuts () {\n        const shortcuts = {\n            Enter: ()=>this.editor.commands.splitListItem(this.name),\n            \"Shift-Tab\": ()=>this.editor.commands.liftListItem(this.name)\n        };\n        if (!this.options.nested) {\n            return shortcuts;\n        }\n        return {\n            ...shortcuts,\n            Tab: ()=>this.editor.commands.sinkListItem(this.name)\n        };\n    },\n    addNodeView () {\n        return ({ node, HTMLAttributes, getPos, editor })=>{\n            const listItem = document.createElement(\"li\");\n            const checkboxWrapper = document.createElement(\"label\");\n            const checkboxStyler = document.createElement(\"span\");\n            const checkbox = document.createElement(\"input\");\n            const content = document.createElement(\"div\");\n            const updateA11Y = (currentNode)=>{\n                var _a, _b;\n                checkbox.ariaLabel = ((_b = (_a = this.options.a11y) == null ? void 0 : _a.checkboxLabel) == null ? void 0 : _b.call(_a, currentNode, checkbox.checked)) || `Task item checkbox for ${currentNode.textContent || \"empty task item\"}`;\n            };\n            updateA11Y(node);\n            checkboxWrapper.contentEditable = \"false\";\n            checkbox.type = \"checkbox\";\n            checkbox.addEventListener(\"mousedown\", (event)=>event.preventDefault());\n            checkbox.addEventListener(\"change\", (event)=>{\n                if (!editor.isEditable && !this.options.onReadOnlyChecked) {\n                    checkbox.checked = !checkbox.checked;\n                    return;\n                }\n                const { checked } = event.target;\n                if (editor.isEditable && typeof getPos === \"function\") {\n                    editor.chain().focus(void 0, {\n                        scrollIntoView: false\n                    }).command(({ tr })=>{\n                        const position = getPos();\n                        if (typeof position !== \"number\") {\n                            return false;\n                        }\n                        const currentNode = tr.doc.nodeAt(position);\n                        tr.setNodeMarkup(position, void 0, {\n                            ...currentNode == null ? void 0 : currentNode.attrs,\n                            checked\n                        });\n                        return true;\n                    }).run();\n                }\n                if (!editor.isEditable && this.options.onReadOnlyChecked) {\n                    if (!this.options.onReadOnlyChecked(node, checked)) {\n                        checkbox.checked = !checkbox.checked;\n                    }\n                }\n            });\n            Object.entries(this.options.HTMLAttributes).forEach(([key, value])=>{\n                listItem.setAttribute(key, value);\n            });\n            listItem.dataset.checked = node.attrs.checked;\n            checkbox.checked = node.attrs.checked;\n            checkboxWrapper.append(checkbox, checkboxStyler);\n            listItem.append(checkboxWrapper, content);\n            Object.entries(HTMLAttributes).forEach(([key, value])=>{\n                listItem.setAttribute(key, value);\n            });\n            return {\n                dom: listItem,\n                contentDOM: content,\n                update: (updatedNode)=>{\n                    if (updatedNode.type !== this.type) {\n                        return false;\n                    }\n                    listItem.dataset.checked = updatedNode.attrs.checked;\n                    checkbox.checked = updatedNode.attrs.checked;\n                    updateA11Y(updatedNode);\n                    return true;\n                }\n            };\n        };\n    },\n    addInputRules () {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.wrappingInputRule)({\n                find: inputRegex,\n                type: this.type,\n                getAttributes: (match)=>({\n                        checked: match[match.length - 1] === \"x\"\n                    })\n            })\n        ];\n    }\n});\n// src/task-list/task-list.ts\n\nvar TaskList = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n    name: \"taskList\",\n    addOptions () {\n        return {\n            itemTypeName: \"taskItem\",\n            HTMLAttributes: {}\n        };\n    },\n    group: \"block list\",\n    content () {\n        return `${this.options.itemTypeName}+`;\n    },\n    parseHTML () {\n        return [\n            {\n                tag: `ul[data-type=\"${this.name}\"]`,\n                priority: 51\n            }\n        ];\n    },\n    renderHTML ({ HTMLAttributes }) {\n        return [\n            \"ul\",\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes, {\n                \"data-type\": this.name\n            }),\n            0\n        ];\n    },\n    parseMarkdown: (token, h)=>{\n        return h.createNode(\"taskList\", {}, h.parseChildren(token.items || []));\n    },\n    renderMarkdown: (node, h)=>{\n        if (!node.content) {\n            return \"\";\n        }\n        return h.renderChildren(node.content, \"\\n\");\n    },\n    markdownTokenizer: {\n        name: \"taskList\",\n        level: \"block\",\n        start (src) {\n            var _a;\n            const index = (_a = src.match(/^\\s*[-+*]\\s+\\[([ xX])\\]\\s+/)) == null ? void 0 : _a.index;\n            return index !== void 0 ? index : -1;\n        },\n        tokenize (src, tokens, lexer) {\n            const parseTaskListContent = (content)=>{\n                const nestedResult = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.parseIndentedBlocks)(content, {\n                    itemPattern: /^(\\s*)([-+*])\\s+\\[([ xX])\\]\\s+(.*)$/,\n                    extractItemData: (match)=>({\n                            indentLevel: match[1].length,\n                            mainContent: match[4],\n                            checked: match[3].toLowerCase() === \"x\"\n                        }),\n                    createToken: (data, nestedTokens)=>({\n                            type: \"taskItem\",\n                            raw: \"\",\n                            mainContent: data.mainContent,\n                            indentLevel: data.indentLevel,\n                            checked: data.checked,\n                            text: data.mainContent,\n                            tokens: lexer.inlineTokens(data.mainContent),\n                            nestedTokens\n                        }),\n                    // Allow recursive nesting\n                    customNestedParser: parseTaskListContent\n                }, lexer);\n                if (nestedResult) {\n                    return [\n                        {\n                            type: \"taskList\",\n                            raw: nestedResult.raw,\n                            items: nestedResult.items\n                        }\n                    ];\n                }\n                return lexer.blockTokens(content);\n            };\n            const result = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.parseIndentedBlocks)(src, {\n                itemPattern: /^(\\s*)([-+*])\\s+\\[([ xX])\\]\\s+(.*)$/,\n                extractItemData: (match)=>({\n                        indentLevel: match[1].length,\n                        mainContent: match[4],\n                        checked: match[3].toLowerCase() === \"x\"\n                    }),\n                createToken: (data, nestedTokens)=>({\n                        type: \"taskItem\",\n                        raw: \"\",\n                        mainContent: data.mainContent,\n                        indentLevel: data.indentLevel,\n                        checked: data.checked,\n                        text: data.mainContent,\n                        tokens: lexer.inlineTokens(data.mainContent),\n                        nestedTokens\n                    }),\n                // Use the recursive parser for nested content\n                customNestedParser: parseTaskListContent\n            }, lexer);\n            if (!result) {\n                return void 0;\n            }\n            return {\n                type: \"taskList\",\n                raw: result.raw,\n                items: result.items\n            };\n        }\n    },\n    markdownOptions: {\n        indentsContent: true\n    },\n    addCommands () {\n        return {\n            toggleTaskList: ()=>({ commands })=>{\n                    return commands.toggleList(this.name, this.options.itemTypeName);\n                }\n        };\n    },\n    addKeyboardShortcuts () {\n        return {\n            \"Mod-Shift-9\": ()=>this.editor.commands.toggleTaskList()\n        };\n    }\n});\n// src/kit/index.ts\nvar ListKit = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Extension.create({\n    name: \"listKit\",\n    addExtensions () {\n        const extensions = [];\n        if (this.options.bulletList !== false) {\n            extensions.push(BulletList.configure(this.options.bulletList));\n        }\n        if (this.options.listItem !== false) {\n            extensions.push(ListItem.configure(this.options.listItem));\n        }\n        if (this.options.listKeymap !== false) {\n            extensions.push(ListKeymap.configure(this.options.listKeymap));\n        }\n        if (this.options.orderedList !== false) {\n            extensions.push(OrderedList.configure(this.options.orderedList));\n        }\n        if (this.options.taskItem !== false) {\n            extensions.push(TaskItem.configure(this.options.taskItem));\n        }\n        if (this.options.taskList !== false) {\n            extensions.push(TaskList.configure(this.options.taskList));\n        }\n        return extensions;\n    }\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tbGlzdC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBLElBQUlBLFlBQVlDLE9BQU9DLGNBQWM7QUFDckMsSUFBSUMsV0FBVyxDQUFDQyxRQUFRQztJQUN0QixJQUFLLElBQUlDLFFBQVFELElBQ2ZMLFVBQVVJLFFBQVFFLE1BQU07UUFBRUMsS0FBS0YsR0FBRyxDQUFDQyxLQUFLO1FBQUVFLFlBQVk7SUFBSztBQUMvRDtBQUVBLGlDQUFpQztBQUN1QztBQUN4RSxJQUFJSSxlQUFlO0FBQ25CLElBQUlDLGdCQUFnQjtBQUNwQixJQUFJQyx1QkFBdUI7QUFDM0IsSUFBSUMsYUFBYUwsOENBQUlBLENBQUNNLE1BQU0sQ0FBQztJQUMzQlYsTUFBTTtJQUNOVztRQUNFLE9BQU87WUFDTEMsY0FBYztZQUNkQyxnQkFBZ0IsQ0FBQztZQUNqQkMsV0FBVztZQUNYQyxnQkFBZ0I7UUFDbEI7SUFDRjtJQUNBQyxPQUFPO0lBQ1BDO1FBQ0UsT0FBTyxDQUFDLEVBQUUsSUFBSSxDQUFDQyxPQUFPLENBQUNOLFlBQVksQ0FBQyxDQUFDLENBQUM7SUFDeEM7SUFDQU87UUFDRSxPQUFPO1lBQUM7Z0JBQUVDLEtBQUs7WUFBSztTQUFFO0lBQ3hCO0lBQ0FDLFlBQVcsRUFBRVIsY0FBYyxFQUFFO1FBQzNCLE9BQU87WUFBQztZQUFNViw2REFBZUEsQ0FBQyxJQUFJLENBQUNlLE9BQU8sQ0FBQ0wsY0FBYyxFQUFFQTtZQUFpQjtTQUFFO0lBQ2hGO0lBQ0FTLG1CQUFtQjtJQUNuQkMsZUFBZSxDQUFDQyxPQUFPQztRQUNyQixJQUFJRCxNQUFNRSxJQUFJLEtBQUssVUFBVUYsTUFBTUcsT0FBTyxFQUFFO1lBQzFDLE9BQU8sRUFBRTtRQUNYO1FBQ0EsT0FBTztZQUNMRCxNQUFNO1lBQ05ULFNBQVNPLE1BQU1JLEtBQUssR0FBR0gsUUFBUUksYUFBYSxDQUFDTCxNQUFNSSxLQUFLLElB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K1IsVUFBVTtRQUM5RDtRQUNBLElBQUksSUFBSSxDQUFDL1IsT0FBTyxDQUFDZ1MsV0FBVyxLQUFLLE9BQU87WUFDdENKLFdBQVczTyxJQUFJLENBQUNrSixZQUFZMkYsU0FBUyxDQUFDLElBQUksQ0FBQzlSLE9BQU8sQ0FBQ2dTLFdBQVc7UUFDaEU7UUFDQSxJQUFJLElBQUksQ0FBQ2hTLE9BQU8sQ0FBQ2lTLFFBQVEsS0FBSyxPQUFPO1lBQ25DTCxXQUFXM08sSUFBSSxDQUFDdUssU0FBU3NFLFNBQVMsQ0FBQyxJQUFJLENBQUM5UixPQUFPLENBQUNpUyxRQUFRO1FBQzFEO1FBQ0EsSUFBSSxJQUFJLENBQUNqUyxPQUFPLENBQUNrUyxRQUFRLEtBQUssT0FBTztZQUNuQ04sV0FBVzNPLElBQUksQ0FBQzhOLFNBQVNlLFNBQVMsQ0FBQyxJQUFJLENBQUM5UixPQUFPLENBQUNrUyxRQUFRO1FBQzFEO1FBQ0EsT0FBT047SUFDVDtBQUNGO0FBYUUsQ0FDRixpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcmFzb2JwYWktd2ViLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWxpc3QvZGlzdC9pbmRleC5qcz8xOGJmIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG5cbi8vIHNyYy9idWxsZXQtbGlzdC9idWxsZXQtbGlzdC50c1xuaW1wb3J0IHsgbWVyZ2VBdHRyaWJ1dGVzLCBOb2RlLCB3cmFwcGluZ0lucHV0UnVsZSB9IGZyb20gXCJAdGlwdGFwL2NvcmVcIjtcbnZhciBMaXN0SXRlbU5hbWUgPSBcImxpc3RJdGVtXCI7XG52YXIgVGV4dFN0eWxlTmFtZSA9IFwidGV4dFN0eWxlXCI7XG52YXIgYnVsbGV0TGlzdElucHV0UmVnZXggPSAvXlxccyooWy0rKl0pXFxzJC87XG52YXIgQnVsbGV0TGlzdCA9IE5vZGUuY3JlYXRlKHtcbiAgbmFtZTogXCJidWxsZXRMaXN0XCIsXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGl0ZW1UeXBlTmFtZTogXCJsaXN0SXRlbVwiLFxuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgICAga2VlcE1hcmtzOiBmYWxzZSxcbiAgICAgIGtlZXBBdHRyaWJ1dGVzOiBmYWxzZVxuICAgIH07XG4gIH0sXG4gIGdyb3VwOiBcImJsb2NrIGxpc3RcIixcbiAgY29udGVudCgpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5vcHRpb25zLml0ZW1UeXBlTmFtZX0rYDtcbiAgfSxcbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbeyB0YWc6IFwidWxcIiB9XTtcbiAgfSxcbiAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICByZXR1cm4gW1widWxcIiwgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLCAwXTtcbiAgfSxcbiAgbWFya2Rvd25Ub2tlbk5hbWU6IFwibGlzdFwiLFxuICBwYXJzZU1hcmtkb3duOiAodG9rZW4sIGhlbHBlcnMpID0+IHtcbiAgICBpZiAodG9rZW4udHlwZSAhPT0gXCJsaXN0XCIgfHwgdG9rZW4ub3JkZXJlZCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJidWxsZXRMaXN0XCIsXG4gICAgICBjb250ZW50OiB0b2tlbi5pdGVtcyA/IGhlbHBlcnMucGFyc2VDaGlsZHJlbih0b2tlbi5pdGVtcykgOiBbXVxuICAgIH07XG4gIH0sXG4gIHJlbmRlck1hcmtkb3duOiAobm9kZSwgaCkgPT4ge1xuICAgIGlmICghbm9kZS5jb250ZW50KSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgcmV0dXJuIGgucmVuZGVyQ2hpbGRyZW4obm9kZS5jb250ZW50LCBcIlxcblwiKTtcbiAgfSxcbiAgbWFya2Rvd25PcHRpb25zOiB7XG4gICAgaW5kZW50c0NvbnRlbnQ6IHRydWVcbiAgfSxcbiAgYWRkQ29tbWFuZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvZ2dsZUJ1bGxldExpc3Q6ICgpID0+ICh7IGNvbW1hbmRzLCBjaGFpbiB9KSA9PiB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMua2VlcEF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICByZXR1cm4gY2hhaW4oKS50b2dnbGVMaXN0KHRoaXMubmFtZSwgdGhpcy5vcHRpb25zLml0ZW1UeXBlTmFtZSwgdGhpcy5vcHRpb25zLmtlZXBNYXJrcykudXBkYXRlQXR0cmlidXRlcyhMaXN0SXRlbU5hbWUsIHRoaXMuZWRpdG9yLmdldEF0dHJpYnV0ZXMoVGV4dFN0eWxlTmFtZSkpLnJ1bigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21tYW5kcy50b2dnbGVMaXN0KHRoaXMubmFtZSwgdGhpcy5vcHRpb25zLml0ZW1UeXBlTmFtZSwgdGhpcy5vcHRpb25zLmtlZXBNYXJrcyk7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFwiTW9kLVNoaWZ0LThcIjogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlQnVsbGV0TGlzdCgpXG4gICAgfTtcbiAgfSxcbiAgYWRkSW5wdXRSdWxlcygpIHtcbiAgICBsZXQgaW5wdXRSdWxlID0gd3JhcHBpbmdJbnB1dFJ1bGUoe1xuICAgICAgZmluZDogYnVsbGV0TGlzdElucHV0UmVnZXgsXG4gICAgICB0eXBlOiB0aGlzLnR5cGVcbiAgICB9KTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmtlZXBNYXJrcyB8fCB0aGlzLm9wdGlvbnMua2VlcEF0dHJpYnV0ZXMpIHtcbiAgICAgIGlucHV0UnVsZSA9IHdyYXBwaW5nSW5wdXRSdWxlKHtcbiAgICAgICAgZmluZDogYnVsbGV0TGlzdElucHV0UmVnZXgsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAga2VlcE1hcmtzOiB0aGlzLm9wdGlvbnMua2VlcE1hcmtzLFxuICAgICAgICBrZWVwQXR0cmlidXRlczogdGhpcy5vcHRpb25zLmtlZXBBdHRyaWJ1dGVzLFxuICAgICAgICBnZXRBdHRyaWJ1dGVzOiAoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZWRpdG9yLmdldEF0dHJpYnV0ZXMoVGV4dFN0eWxlTmFtZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVkaXRvcjogdGhpcy5lZGl0b3JcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gW2lucHV0UnVsZV07XG4gIH1cbn0pO1xuXG4vLyBzcmMvaXRlbS9saXN0LWl0ZW0udHNcbmltcG9ydCB7IG1lcmdlQXR0cmlidXRlcyBhcyBtZXJnZUF0dHJpYnV0ZXMyLCBOb2RlIGFzIE5vZGUyLCByZW5kZXJOZXN0ZWRNYXJrZG93bkNvbnRlbnQgfSBmcm9tIFwiQHRpcHRhcC9jb3JlXCI7XG52YXIgTGlzdEl0ZW0gPSBOb2RlMi5jcmVhdGUoe1xuICBuYW1lOiBcImxpc3RJdGVtXCIsXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fSxcbiAgICAgIGJ1bGxldExpc3RUeXBlTmFtZTogXCJidWxsZXRMaXN0XCIsXG4gICAgICBvcmRlcmVkTGlzdFR5cGVOYW1lOiBcIm9yZGVyZWRMaXN0XCJcbiAgICB9O1xuICB9LFxuICBjb250ZW50OiBcInBhcmFncmFwaCBibG9jaypcIixcbiAgZGVmaW5pbmc6IHRydWUsXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICB0YWc6IFwibGlcIlxuICAgICAgfVxuICAgIF07XG4gIH0sXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgcmV0dXJuIFtcImxpXCIsIG1lcmdlQXR0cmlidXRlczIodGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdO1xuICB9LFxuICBtYXJrZG93blRva2VuTmFtZTogXCJsaXN0X2l0ZW1cIixcbiAgcGFyc2VNYXJrZG93bjogKHRva2VuLCBoZWxwZXJzKSA9PiB7XG4gICAgaWYgKHRva2VuLnR5cGUgIT09IFwibGlzdF9pdGVtXCIpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgbGV0IGNvbnRlbnQgPSBbXTtcbiAgICBpZiAodG9rZW4udG9rZW5zICYmIHRva2VuLnRva2Vucy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBoYXNQYXJhZ3JhcGhUb2tlbnMgPSB0b2tlbi50b2tlbnMuc29tZSgodCkgPT4gdC50eXBlID09PSBcInBhcmFncmFwaFwiKTtcbiAgICAgIGlmIChoYXNQYXJhZ3JhcGhUb2tlbnMpIHtcbiAgICAgICAgY29udGVudCA9IGhlbHBlcnMucGFyc2VDaGlsZHJlbih0b2tlbi50b2tlbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZmlyc3RUb2tlbiA9IHRva2VuLnRva2Vuc1swXTtcbiAgICAgICAgaWYgKGZpcnN0VG9rZW4gJiYgZmlyc3RUb2tlbi50eXBlID09PSBcInRleHRcIiAmJiBmaXJzdFRva2VuLnRva2VucyAmJiBmaXJzdFRva2VuLnRva2Vucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc3QgaW5saW5lQ29udGVudCA9IGhlbHBlcnMucGFyc2VJbmxpbmUoZmlyc3RUb2tlbi50b2tlbnMpO1xuICAgICAgICAgIGNvbnRlbnQgPSBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHR5cGU6IFwicGFyYWdyYXBoXCIsXG4gICAgICAgICAgICAgIGNvbnRlbnQ6IGlubGluZUNvbnRlbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdO1xuICAgICAgICAgIGlmICh0b2tlbi50b2tlbnMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgY29uc3QgcmVtYWluaW5nVG9rZW5zID0gdG9rZW4udG9rZW5zLnNsaWNlKDEpO1xuICAgICAgICAgICAgY29uc3QgYWRkaXRpb25hbENvbnRlbnQgPSBoZWxwZXJzLnBhcnNlQ2hpbGRyZW4ocmVtYWluaW5nVG9rZW5zKTtcbiAgICAgICAgICAgIGNvbnRlbnQucHVzaCguLi5hZGRpdGlvbmFsQ29udGVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRlbnQgPSBoZWxwZXJzLnBhcnNlQ2hpbGRyZW4odG9rZW4udG9rZW5zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29udGVudC5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnRlbnQgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiBcInBhcmFncmFwaFwiLFxuICAgICAgICAgIGNvbnRlbnQ6IFtdXG4gICAgICAgIH1cbiAgICAgIF07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImxpc3RJdGVtXCIsXG4gICAgICBjb250ZW50XG4gICAgfTtcbiAgfSxcbiAgcmVuZGVyTWFya2Rvd246IChub2RlLCBoLCBjdHgpID0+IHtcbiAgICByZXR1cm4gcmVuZGVyTmVzdGVkTWFya2Rvd25Db250ZW50KFxuICAgICAgbm9kZSxcbiAgICAgIGgsXG4gICAgICAoY29udGV4dCkgPT4ge1xuICAgICAgICBpZiAoY29udGV4dC5wYXJlbnRUeXBlID09PSBcImJ1bGxldExpc3RcIikge1xuICAgICAgICAgIHJldHVybiBcIi0gXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRleHQucGFyZW50VHlwZSA9PT0gXCJvcmRlcmVkTGlzdFwiKSB7XG4gICAgICAgICAgcmV0dXJuIGAke2NvbnRleHQuaW5kZXggKyAxfS4gYDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCItIFwiO1xuICAgICAgfSxcbiAgICAgIGN0eFxuICAgICk7XG4gIH0sXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBFbnRlcjogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuc3BsaXRMaXN0SXRlbSh0aGlzLm5hbWUpLFxuICAgICAgVGFiOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5zaW5rTGlzdEl0ZW0odGhpcy5uYW1lKSxcbiAgICAgIFwiU2hpZnQtVGFiXCI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLmxpZnRMaXN0SXRlbSh0aGlzLm5hbWUpXG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHNyYy9rZXltYXAvbGlzdC1rZXltYXAudHNcbmltcG9ydCB7IEV4dGVuc2lvbiB9IGZyb20gXCJAdGlwdGFwL2NvcmVcIjtcblxuLy8gc3JjL2tleW1hcC9saXN0SGVscGVycy9pbmRleC50c1xudmFyIGxpc3RIZWxwZXJzX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGxpc3RIZWxwZXJzX2V4cG9ydHMsIHtcbiAgZmluZExpc3RJdGVtUG9zOiAoKSA9PiBmaW5kTGlzdEl0ZW1Qb3MsXG4gIGdldE5leHRMaXN0RGVwdGg6ICgpID0+IGdldE5leHRMaXN0RGVwdGgsXG4gIGhhbmRsZUJhY2tzcGFjZTogKCkgPT4gaGFuZGxlQmFja3NwYWNlLFxuICBoYW5kbGVEZWxldGU6ICgpID0+IGhhbmRsZURlbGV0ZSxcbiAgaGFzTGlzdEJlZm9yZTogKCkgPT4gaGFzTGlzdEJlZm9yZSxcbiAgaGFzTGlzdEl0ZW1BZnRlcjogKCkgPT4gaGFzTGlzdEl0ZW1BZnRlcixcbiAgaGFzTGlzdEl0ZW1CZWZvcmU6ICgpID0+IGhhc0xpc3RJdGVtQmVmb3JlLFxuICBsaXN0SXRlbUhhc1N1Ykxpc3Q6ICgpID0+IGxpc3RJdGVtSGFzU3ViTGlzdCxcbiAgbmV4dExpc3RJc0RlZXBlcjogKCkgPT4gbmV4dExpc3RJc0RlZXBlcixcbiAgbmV4dExpc3RJc0hpZ2hlcjogKCkgPT4gbmV4dExpc3RJc0hpZ2hlclxufSk7XG5cbi8vIHNyYy9rZXltYXAvbGlzdEhlbHBlcnMvZmluZExpc3RJdGVtUG9zLnRzXG5pbXBvcnQgeyBnZXROb2RlVHlwZSB9IGZyb20gXCJAdGlwdGFwL2NvcmVcIjtcbnZhciBmaW5kTGlzdEl0ZW1Qb3MgPSAodHlwZU9yTmFtZSwgc3RhdGUpID0+IHtcbiAgY29uc3QgeyAkZnJvbSB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICBjb25zdCBub2RlVHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XG4gIGxldCBjdXJyZW50Tm9kZSA9IG51bGw7XG4gIGxldCBjdXJyZW50RGVwdGggPSAkZnJvbS5kZXB0aDtcbiAgbGV0IGN1cnJlbnRQb3MgPSAkZnJvbS5wb3M7XG4gIGxldCB0YXJnZXREZXB0aCA9IG51bGw7XG4gIHdoaWxlIChjdXJyZW50RGVwdGggPiAwICYmIHRhcmdldERlcHRoID09PSBudWxsKSB7XG4gICAgY3VycmVudE5vZGUgPSAkZnJvbS5ub2RlKGN1cnJlbnREZXB0aCk7XG4gICAgaWYgKGN1cnJlbnROb2RlLnR5cGUgPT09IG5vZGVUeXBlKSB7XG4gICAgICB0YXJnZXREZXB0aCA9IGN1cnJlbnREZXB0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudERlcHRoIC09IDE7XG4gICAgICBjdXJyZW50UG9zIC09IDE7XG4gICAgfVxuICB9XG4gIGlmICh0YXJnZXREZXB0aCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiB7ICRwb3M6IHN0YXRlLmRvYy5yZXNvbHZlKGN1cnJlbnRQb3MpLCBkZXB0aDogdGFyZ2V0RGVwdGggfTtcbn07XG5cbi8vIHNyYy9rZXltYXAvbGlzdEhlbHBlcnMvZ2V0TmV4dExpc3REZXB0aC50c1xuaW1wb3J0IHsgZ2V0Tm9kZUF0UG9zaXRpb24gfSBmcm9tIFwiQHRpcHRhcC9jb3JlXCI7XG52YXIgZ2V0TmV4dExpc3REZXB0aCA9ICh0eXBlT3JOYW1lLCBzdGF0ZSkgPT4ge1xuICBjb25zdCBsaXN0SXRlbVBvcyA9IGZpbmRMaXN0SXRlbVBvcyh0eXBlT3JOYW1lLCBzdGF0ZSk7XG4gIGlmICghbGlzdEl0ZW1Qb3MpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgWywgZGVwdGhdID0gZ2V0Tm9kZUF0UG9zaXRpb24oc3RhdGUsIHR5cGVPck5hbWUsIGxpc3RJdGVtUG9zLiRwb3MucG9zICsgNCk7XG4gIHJldHVybiBkZXB0aDtcbn07XG5cbi8vIHNyYy9rZXltYXAvbGlzdEhlbHBlcnMvaGFuZGxlQmFja3NwYWNlLnRzXG5pbXBvcnQgeyBpc0F0U3RhcnRPZk5vZGUsIGlzTm9kZUFjdGl2ZSB9IGZyb20gXCJAdGlwdGFwL2NvcmVcIjtcblxuLy8gc3JjL2tleW1hcC9saXN0SGVscGVycy9oYXNMaXN0QmVmb3JlLnRzXG52YXIgaGFzTGlzdEJlZm9yZSA9IChlZGl0b3JTdGF0ZSwgbmFtZSwgcGFyZW50TGlzdFR5cGVzKSA9PiB7XG4gIGNvbnN0IHsgJGFuY2hvciB9ID0gZWRpdG9yU3RhdGUuc2VsZWN0aW9uO1xuICBjb25zdCBwcmV2aW91c05vZGVQb3MgPSBNYXRoLm1heCgwLCAkYW5jaG9yLnBvcyAtIDIpO1xuICBjb25zdCBwcmV2aW91c05vZGUgPSBlZGl0b3JTdGF0ZS5kb2MucmVzb2x2ZShwcmV2aW91c05vZGVQb3MpLm5vZGUoKTtcbiAgaWYgKCFwcmV2aW91c05vZGUgfHwgIXBhcmVudExpc3RUeXBlcy5pbmNsdWRlcyhwcmV2aW91c05vZGUudHlwZS5uYW1lKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIHNyYy9rZXltYXAvbGlzdEhlbHBlcnMvaGFzTGlzdEl0ZW1CZWZvcmUudHNcbnZhciBoYXNMaXN0SXRlbUJlZm9yZSA9ICh0eXBlT3JOYW1lLCBzdGF0ZSkgPT4ge1xuICB2YXIgX2E7XG4gIGNvbnN0IHsgJGFuY2hvciB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICBjb25zdCAkdGFyZ2V0UG9zID0gc3RhdGUuZG9jLnJlc29sdmUoJGFuY2hvci5wb3MgLSAyKTtcbiAgaWYgKCR0YXJnZXRQb3MuaW5kZXgoKSA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoKChfYSA9ICR0YXJnZXRQb3Mubm9kZUJlZm9yZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnR5cGUubmFtZSkgIT09IHR5cGVPck5hbWUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vLyBzcmMva2V5bWFwL2xpc3RIZWxwZXJzL2xpc3RJdGVtSGFzU3ViTGlzdC50c1xuaW1wb3J0IHsgZ2V0Tm9kZVR5cGUgYXMgZ2V0Tm9kZVR5cGUyIH0gZnJvbSBcIkB0aXB0YXAvY29yZVwiO1xudmFyIGxpc3RJdGVtSGFzU3ViTGlzdCA9ICh0eXBlT3JOYW1lLCBzdGF0ZSwgbm9kZSkgPT4ge1xuICBpZiAoIW5vZGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3Qgbm9kZVR5cGUgPSBnZXROb2RlVHlwZTIodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgbGV0IGhhc1N1Ykxpc3QgPSBmYWxzZTtcbiAgbm9kZS5kZXNjZW5kYW50cygoY2hpbGQpID0+IHtcbiAgICBpZiAoY2hpbGQudHlwZSA9PT0gbm9kZVR5cGUpIHtcbiAgICAgIGhhc1N1Ykxpc3QgPSB0cnVlO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBoYXNTdWJMaXN0O1xufTtcblxuLy8gc3JjL2tleW1hcC9saXN0SGVscGVycy9oYW5kbGVCYWNrc3BhY2UudHNcbnZhciBoYW5kbGVCYWNrc3BhY2UgPSAoZWRpdG9yLCBuYW1lLCBwYXJlbnRMaXN0VHlwZXMpID0+IHtcbiAgaWYgKGVkaXRvci5jb21tYW5kcy51bmRvSW5wdXRSdWxlKCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoZWRpdG9yLnN0YXRlLnNlbGVjdGlvbi5mcm9tICE9PSBlZGl0b3Iuc3RhdGUuc2VsZWN0aW9uLnRvKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICghaXNOb2RlQWN0aXZlKGVkaXRvci5zdGF0ZSwgbmFtZSkgJiYgaGFzTGlzdEJlZm9yZShlZGl0b3Iuc3RhdGUsIG5hbWUsIHBhcmVudExpc3RUeXBlcykpIHtcbiAgICBjb25zdCB7ICRhbmNob3IgfSA9IGVkaXRvci5zdGF0ZS5zZWxlY3Rpb247XG4gICAgY29uc3QgJGxpc3RQb3MgPSBlZGl0b3Iuc3RhdGUuZG9jLnJlc29sdmUoJGFuY2hvci5iZWZvcmUoKSAtIDEpO1xuICAgIGNvbnN0IGxpc3REZXNjZW5kYW50cyA9IFtdO1xuICAgICRsaXN0UG9zLm5vZGUoKS5kZXNjZW5kYW50cygobm9kZSwgcG9zKSA9PiB7XG4gICAgICBpZiAobm9kZS50eXBlLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgbGlzdERlc2NlbmRhbnRzLnB1c2goeyBub2RlLCBwb3MgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgbGFzdEl0ZW0gPSBsaXN0RGVzY2VuZGFudHMuYXQoLTEpO1xuICAgIGlmICghbGFzdEl0ZW0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgJGxhc3RJdGVtUG9zID0gZWRpdG9yLnN0YXRlLmRvYy5yZXNvbHZlKCRsaXN0UG9zLnN0YXJ0KCkgKyBsYXN0SXRlbS5wb3MgKyAxKTtcbiAgICByZXR1cm4gZWRpdG9yLmNoYWluKCkuY3V0KHsgZnJvbTogJGFuY2hvci5zdGFydCgpIC0gMSwgdG86ICRhbmNob3IuZW5kKCkgKyAxIH0sICRsYXN0SXRlbVBvcy5lbmQoKSkuam9pbkZvcndhcmQoKS5ydW4oKTtcbiAgfVxuICBpZiAoIWlzTm9kZUFjdGl2ZShlZGl0b3Iuc3RhdGUsIG5hbWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICghaXNBdFN0YXJ0T2ZOb2RlKGVkaXRvci5zdGF0ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgbGlzdEl0ZW1Qb3MgPSBmaW5kTGlzdEl0ZW1Qb3MobmFtZSwgZWRpdG9yLnN0YXRlKTtcbiAgaWYgKCFsaXN0SXRlbVBvcykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCAkcHJldiA9IGVkaXRvci5zdGF0ZS5kb2MucmVzb2x2ZShsaXN0SXRlbVBvcy4kcG9zLnBvcyAtIDIpO1xuICBjb25zdCBwcmV2Tm9kZSA9ICRwcmV2Lm5vZGUobGlzdEl0ZW1Qb3MuZGVwdGgpO1xuICBjb25zdCBwcmV2aW91c0xpc3RJdGVtSGFzU3ViTGlzdCA9IGxpc3RJdGVtSGFzU3ViTGlzdChuYW1lLCBlZGl0b3Iuc3RhdGUsIHByZXZOb2RlKTtcbiAgaWYgKGhhc0xpc3RJdGVtQmVmb3JlKG5hbWUsIGVkaXRvci5zdGF0ZSkgJiYgIXByZXZpb3VzTGlzdEl0ZW1IYXNTdWJMaXN0KSB7XG4gICAgcmV0dXJuIGVkaXRvci5jb21tYW5kcy5qb2luSXRlbUJhY2t3YXJkKCk7XG4gIH1cbiAgcmV0dXJuIGVkaXRvci5jaGFpbigpLmxpZnRMaXN0SXRlbShuYW1lKS5ydW4oKTtcbn07XG5cbi8vIHNyYy9rZXltYXAvbGlzdEhlbHBlcnMvaGFuZGxlRGVsZXRlLnRzXG5pbXBvcnQgeyBpc0F0RW5kT2ZOb2RlLCBpc05vZGVBY3RpdmUgYXMgaXNOb2RlQWN0aXZlMiB9IGZyb20gXCJAdGlwdGFwL2NvcmVcIjtcblxuLy8gc3JjL2tleW1hcC9saXN0SGVscGVycy9uZXh0TGlzdElzRGVlcGVyLnRzXG52YXIgbmV4dExpc3RJc0RlZXBlciA9ICh0eXBlT3JOYW1lLCBzdGF0ZSkgPT4ge1xuICBjb25zdCBsaXN0RGVwdGggPSBnZXROZXh0TGlzdERlcHRoKHR5cGVPck5hbWUsIHN0YXRlKTtcbiAgY29uc3QgbGlzdEl0ZW1Qb3MgPSBmaW5kTGlzdEl0ZW1Qb3ModHlwZU9yTmFtZSwgc3RhdGUpO1xuICBpZiAoIWxpc3RJdGVtUG9zIHx8ICFsaXN0RGVwdGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGxpc3REZXB0aCA+IGxpc3RJdGVtUG9zLmRlcHRoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLy8gc3JjL2tleW1hcC9saXN0SGVscGVycy9uZXh0TGlzdElzSGlnaGVyLnRzXG52YXIgbmV4dExpc3RJc0hpZ2hlciA9ICh0eXBlT3JOYW1lLCBzdGF0ZSkgPT4ge1xuICBjb25zdCBsaXN0RGVwdGggPSBnZXROZXh0TGlzdERlcHRoKHR5cGVPck5hbWUsIHN0YXRlKTtcbiAgY29uc3QgbGlzdEl0ZW1Qb3MgPSBmaW5kTGlzdEl0ZW1Qb3ModHlwZU9yTmFtZSwgc3RhdGUpO1xuICBpZiAoIWxpc3RJdGVtUG9zIHx8ICFsaXN0RGVwdGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGxpc3REZXB0aCA8IGxpc3RJdGVtUG9zLmRlcHRoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLy8gc3JjL2tleW1hcC9saXN0SGVscGVycy9oYW5kbGVEZWxldGUudHNcbnZhciBoYW5kbGVEZWxldGUgPSAoZWRpdG9yLCBuYW1lKSA9PiB7XG4gIGlmICghaXNOb2RlQWN0aXZlMihlZGl0b3Iuc3RhdGUsIG5hbWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICghaXNBdEVuZE9mTm9kZShlZGl0b3Iuc3RhdGUsIG5hbWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSBlZGl0b3Iuc3RhdGU7XG4gIGNvbnN0IHsgJGZyb20sICR0byB9ID0gc2VsZWN0aW9uO1xuICBpZiAoIXNlbGVjdGlvbi5lbXB0eSAmJiAkZnJvbS5zYW1lUGFyZW50KCR0bykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKG5leHRMaXN0SXNEZWVwZXIobmFtZSwgZWRpdG9yLnN0YXRlKSkge1xuICAgIHJldHVybiBlZGl0b3IuY2hhaW4oKS5mb2N1cyhlZGl0b3Iuc3RhdGUuc2VsZWN0aW9uLmZyb20gKyA0KS5saWZ0KG5hbWUpLmpvaW5CYWNrd2FyZCgpLnJ1bigpO1xuICB9XG4gIGlmIChuZXh0TGlzdElzSGlnaGVyKG5hbWUsIGVkaXRvci5zdGF0ZSkpIHtcbiAgICByZXR1cm4gZWRpdG9yLmNoYWluKCkuam9pbkZvcndhcmQoKS5qb2luQmFja3dhcmQoKS5ydW4oKTtcbiAgfVxuICByZXR1cm4gZWRpdG9yLmNvbW1hbmRzLmpvaW5JdGVtRm9yd2FyZCgpO1xufTtcblxuLy8gc3JjL2tleW1hcC9saXN0SGVscGVycy9oYXNMaXN0SXRlbUFmdGVyLnRzXG52YXIgaGFzTGlzdEl0ZW1BZnRlciA9ICh0eXBlT3JOYW1lLCBzdGF0ZSkgPT4ge1xuICB2YXIgX2E7XG4gIGNvbnN0IHsgJGFuY2hvciB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICBjb25zdCAkdGFyZ2V0UG9zID0gc3RhdGUuZG9jLnJlc29sdmUoJGFuY2hvci5wb3MgLSAkYW5jaG9yLnBhcmVudE9mZnNldCAtIDIpO1xuICBpZiAoJHRhcmdldFBvcy5pbmRleCgpID09PSAkdGFyZ2V0UG9zLnBhcmVudC5jaGlsZENvdW50IC0gMSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoKChfYSA9ICR0YXJnZXRQb3Mubm9kZUFmdGVyKSA9PSBudWxsID8gdm9pZCAwIDogX2EudHlwZS5uYW1lKSAhPT0gdHlwZU9yTmFtZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIHNyYy9rZXltYXAvbGlzdC1rZXltYXAudHNcbnZhciBMaXN0S2V5bWFwID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gIG5hbWU6IFwibGlzdEtleW1hcFwiLFxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsaXN0VHlwZXM6IFtcbiAgICAgICAge1xuICAgICAgICAgIGl0ZW1OYW1lOiBcImxpc3RJdGVtXCIsXG4gICAgICAgICAgd3JhcHBlck5hbWVzOiBbXCJidWxsZXRMaXN0XCIsIFwib3JkZXJlZExpc3RcIl1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGl0ZW1OYW1lOiBcInRhc2tJdGVtXCIsXG4gICAgICAgICAgd3JhcHBlck5hbWVzOiBbXCJ0YXNrTGlzdFwiXVxuICAgICAgICB9XG4gICAgICBdXG4gICAgfTtcbiAgfSxcbiAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIERlbGV0ZTogKHsgZWRpdG9yIH0pID0+IHtcbiAgICAgICAgbGV0IGhhbmRsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vcHRpb25zLmxpc3RUeXBlcy5mb3JFYWNoKCh7IGl0ZW1OYW1lIH0pID0+IHtcbiAgICAgICAgICBpZiAoZWRpdG9yLnN0YXRlLnNjaGVtYS5ub2Rlc1tpdGVtTmFtZV0gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaGFuZGxlRGVsZXRlKGVkaXRvciwgaXRlbU5hbWUpKSB7XG4gICAgICAgICAgICBoYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaGFuZGxlZDtcbiAgICAgIH0sXG4gICAgICBcIk1vZC1EZWxldGVcIjogKHsgZWRpdG9yIH0pID0+IHtcbiAgICAgICAgbGV0IGhhbmRsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vcHRpb25zLmxpc3RUeXBlcy5mb3JFYWNoKCh7IGl0ZW1OYW1lIH0pID0+IHtcbiAgICAgICAgICBpZiAoZWRpdG9yLnN0YXRlLnNjaGVtYS5ub2Rlc1tpdGVtTmFtZV0gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaGFuZGxlRGVsZXRlKGVkaXRvciwgaXRlbU5hbWUpKSB7XG4gICAgICAgICAgICBoYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaGFuZGxlZDtcbiAgICAgIH0sXG4gICAgICBCYWNrc3BhY2U6ICh7IGVkaXRvciB9KSA9PiB7XG4gICAgICAgIGxldCBoYW5kbGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMub3B0aW9ucy5saXN0VHlwZXMuZm9yRWFjaCgoeyBpdGVtTmFtZSwgd3JhcHBlck5hbWVzIH0pID0+IHtcbiAgICAgICAgICBpZiAoZWRpdG9yLnN0YXRlLnNjaGVtYS5ub2Rlc1tpdGVtTmFtZV0gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaGFuZGxlQmFja3NwYWNlKGVkaXRvciwgaXRlbU5hbWUsIHdyYXBwZXJOYW1lcykpIHtcbiAgICAgICAgICAgIGhhbmRsZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBoYW5kbGVkO1xuICAgICAgfSxcbiAgICAgIFwiTW9kLUJhY2tzcGFjZVwiOiAoeyBlZGl0b3IgfSkgPT4ge1xuICAgICAgICBsZXQgaGFuZGxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9wdGlvbnMubGlzdFR5cGVzLmZvckVhY2goKHsgaXRlbU5hbWUsIHdyYXBwZXJOYW1lcyB9KSA9PiB7XG4gICAgICAgICAgaWYgKGVkaXRvci5zdGF0ZS5zY2hlbWEubm9kZXNbaXRlbU5hbWVdID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGhhbmRsZUJhY2tzcGFjZShlZGl0b3IsIGl0ZW1OYW1lLCB3cmFwcGVyTmFtZXMpKSB7XG4gICAgICAgICAgICBoYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaGFuZGxlZDtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59KTtcblxuLy8gc3JjL2tpdC9pbmRleC50c1xuaW1wb3J0IHsgRXh0ZW5zaW9uIGFzIEV4dGVuc2lvbjIgfSBmcm9tIFwiQHRpcHRhcC9jb3JlXCI7XG5cbi8vIHNyYy9vcmRlcmVkLWxpc3Qvb3JkZXJlZC1saXN0LnRzXG5pbXBvcnQgeyBtZXJnZUF0dHJpYnV0ZXMgYXMgbWVyZ2VBdHRyaWJ1dGVzMywgTm9kZSBhcyBOb2RlMywgd3JhcHBpbmdJbnB1dFJ1bGUgYXMgd3JhcHBpbmdJbnB1dFJ1bGUyIH0gZnJvbSBcIkB0aXB0YXAvY29yZVwiO1xuXG4vLyBzcmMvb3JkZXJlZC1saXN0L3V0aWxzLnRzXG52YXIgT1JERVJFRF9MSVNUX0lURU1fUkVHRVggPSAvXihcXHMqKShcXGQrKVxcLlxccysoLiopJC87XG52YXIgSU5ERU5URURfTElORV9SRUdFWCA9IC9eXFxzLztcbmZ1bmN0aW9uIGNvbGxlY3RPcmRlcmVkTGlzdEl0ZW1zKGxpbmVzKSB7XG4gIGNvbnN0IGxpc3RJdGVtcyA9IFtdO1xuICBsZXQgY3VycmVudExpbmVJbmRleCA9IDA7XG4gIGxldCBjb25zdW1lZCA9IDA7XG4gIHdoaWxlIChjdXJyZW50TGluZUluZGV4IDwgbGluZXMubGVuZ3RoKSB7XG4gICAgY29uc3QgbGluZSA9IGxpbmVzW2N1cnJlbnRMaW5lSW5kZXhdO1xuICAgIGNvbnN0IG1hdGNoID0gbGluZS5tYXRjaChPUkRFUkVEX0xJU1RfSVRFTV9SRUdFWCk7XG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNvbnN0IFssIGluZGVudCwgbnVtYmVyLCBjb250ZW50XSA9IG1hdGNoO1xuICAgIGNvbnN0IGluZGVudExldmVsID0gaW5kZW50Lmxlbmd0aDtcbiAgICBsZXQgaXRlbUNvbnRlbnQgPSBjb250ZW50O1xuICAgIGxldCBuZXh0TGluZUluZGV4ID0gY3VycmVudExpbmVJbmRleCArIDE7XG4gICAgY29uc3QgaXRlbUxpbmVzID0gW2xpbmVdO1xuICAgIHdoaWxlIChuZXh0TGluZUluZGV4IDwgbGluZXMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBuZXh0TGluZSA9IGxpbmVzW25leHRMaW5lSW5kZXhdO1xuICAgICAgY29uc3QgbmV4dE1hdGNoID0gbmV4dExpbmUubWF0Y2goT1JERVJFRF9MSVNUX0lURU1fUkVHRVgpO1xuICAgICAgaWYgKG5leHRNYXRjaCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChuZXh0TGluZS50cmltKCkgPT09IFwiXCIpIHtcbiAgICAgICAgaXRlbUxpbmVzLnB1c2gobmV4dExpbmUpO1xuICAgICAgICBpdGVtQ29udGVudCArPSBcIlxcblwiO1xuICAgICAgICBuZXh0TGluZUluZGV4ICs9IDE7XG4gICAgICB9IGVsc2UgaWYgKG5leHRMaW5lLm1hdGNoKElOREVOVEVEX0xJTkVfUkVHRVgpKSB7XG4gICAgICAgIGl0ZW1MaW5lcy5wdXNoKG5leHRMaW5lKTtcbiAgICAgICAgaXRlbUNvbnRlbnQgKz0gYFxuJHtuZXh0TGluZS5zbGljZShpbmRlbnRMZXZlbCArIDIpfWA7XG4gICAgICAgIG5leHRMaW5lSW5kZXggKz0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBsaXN0SXRlbXMucHVzaCh7XG4gICAgICBpbmRlbnQ6IGluZGVudExldmVsLFxuICAgICAgbnVtYmVyOiBwYXJzZUludChudW1iZXIsIDEwKSxcbiAgICAgIGNvbnRlbnQ6IGl0ZW1Db250ZW50LnRyaW0oKSxcbiAgICAgIHJhdzogaXRlbUxpbmVzLmpvaW4oXCJcXG5cIilcbiAgICB9KTtcbiAgICBjb25zdW1lZCA9IG5leHRMaW5lSW5kZXg7XG4gICAgY3VycmVudExpbmVJbmRleCA9IG5leHRMaW5lSW5kZXg7XG4gIH1cbiAgcmV0dXJuIFtsaXN0SXRlbXMsIGNvbnN1bWVkXTtcbn1cbmZ1bmN0aW9uIGJ1aWxkTmVzdGVkU3RydWN0dXJlKGl0ZW1zLCBiYXNlSW5kZW50LCBsZXhlcikge1xuICB2YXIgX2E7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBsZXQgY3VycmVudEluZGV4ID0gMDtcbiAgd2hpbGUgKGN1cnJlbnRJbmRleCA8IGl0ZW1zLmxlbmd0aCkge1xuICAgIGNvbnN0IGl0ZW0gPSBpdGVtc1tjdXJyZW50SW5kZXhdO1xuICAgIGlmIChpdGVtLmluZGVudCA9PT0gYmFzZUluZGVudCkge1xuICAgICAgY29uc3QgY29udGVudExpbmVzID0gaXRlbS5jb250ZW50LnNwbGl0KFwiXFxuXCIpO1xuICAgICAgY29uc3QgbWFpblRleHQgPSAoKF9hID0gY29udGVudExpbmVzWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2EudHJpbSgpKSB8fCBcIlwiO1xuICAgICAgY29uc3QgdG9rZW5zID0gW107XG4gICAgICBpZiAobWFpblRleHQpIHtcbiAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgIHR5cGU6IFwicGFyYWdyYXBoXCIsXG4gICAgICAgICAgcmF3OiBtYWluVGV4dCxcbiAgICAgICAgICB0b2tlbnM6IGxleGVyLmlubGluZVRva2VucyhtYWluVGV4dClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCBhZGRpdGlvbmFsQ29udGVudCA9IGNvbnRlbnRMaW5lcy5zbGljZSgxKS5qb2luKFwiXFxuXCIpLnRyaW0oKTtcbiAgICAgIGlmIChhZGRpdGlvbmFsQ29udGVudCkge1xuICAgICAgICBjb25zdCBibG9ja1Rva2VucyA9IGxleGVyLmJsb2NrVG9rZW5zKGFkZGl0aW9uYWxDb250ZW50KTtcbiAgICAgICAgdG9rZW5zLnB1c2goLi4uYmxvY2tUb2tlbnMpO1xuICAgICAgfVxuICAgICAgbGV0IGxvb2tBaGVhZEluZGV4ID0gY3VycmVudEluZGV4ICsgMTtcbiAgICAgIGNvbnN0IG5lc3RlZEl0ZW1zID0gW107XG4gICAgICB3aGlsZSAobG9va0FoZWFkSW5kZXggPCBpdGVtcy5sZW5ndGggJiYgaXRlbXNbbG9va0FoZWFkSW5kZXhdLmluZGVudCA+IGJhc2VJbmRlbnQpIHtcbiAgICAgICAgbmVzdGVkSXRlbXMucHVzaChpdGVtc1tsb29rQWhlYWRJbmRleF0pO1xuICAgICAgICBsb29rQWhlYWRJbmRleCArPSAxO1xuICAgICAgfVxuICAgICAgaWYgKG5lc3RlZEl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgbmV4dEluZGVudCA9IE1hdGgubWluKC4uLm5lc3RlZEl0ZW1zLm1hcCgobmVzdGVkSXRlbSkgPT4gbmVzdGVkSXRlbS5pbmRlbnQpKTtcbiAgICAgICAgY29uc3QgbmVzdGVkTGlzdEl0ZW1zID0gYnVpbGROZXN0ZWRTdHJ1Y3R1cmUobmVzdGVkSXRlbXMsIG5leHRJbmRlbnQsIGxleGVyKTtcbiAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgIHR5cGU6IFwibGlzdFwiLFxuICAgICAgICAgIG9yZGVyZWQ6IHRydWUsXG4gICAgICAgICAgc3RhcnQ6IG5lc3RlZEl0ZW1zWzBdLm51bWJlcixcbiAgICAgICAgICBpdGVtczogbmVzdGVkTGlzdEl0ZW1zLFxuICAgICAgICAgIHJhdzogbmVzdGVkSXRlbXMubWFwKChuZXN0ZWRJdGVtKSA9PiBuZXN0ZWRJdGVtLnJhdykuam9pbihcIlxcblwiKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJsaXN0X2l0ZW1cIixcbiAgICAgICAgcmF3OiBpdGVtLnJhdyxcbiAgICAgICAgdG9rZW5zXG4gICAgICB9KTtcbiAgICAgIGN1cnJlbnRJbmRleCA9IGxvb2tBaGVhZEluZGV4O1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50SW5kZXggKz0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHBhcnNlTGlzdEl0ZW1zKGl0ZW1zLCBoZWxwZXJzKSB7XG4gIHJldHVybiBpdGVtcy5tYXAoKGl0ZW0pID0+IHtcbiAgICBpZiAoaXRlbS50eXBlICE9PSBcImxpc3RfaXRlbVwiKSB7XG4gICAgICByZXR1cm4gaGVscGVycy5wYXJzZUNoaWxkcmVuKFtpdGVtXSlbMF07XG4gICAgfVxuICAgIGNvbnN0IGNvbnRlbnQgPSBbXTtcbiAgICBpZiAoaXRlbS50b2tlbnMgJiYgaXRlbS50b2tlbnMubGVuZ3RoID4gMCkge1xuICAgICAgaXRlbS50b2tlbnMuZm9yRWFjaCgoaXRlbVRva2VuKSA9PiB7XG4gICAgICAgIGlmIChpdGVtVG9rZW4udHlwZSA9PT0gXCJwYXJhZ3JhcGhcIiB8fCBpdGVtVG9rZW4udHlwZSA9PT0gXCJsaXN0XCIgfHwgaXRlbVRva2VuLnR5cGUgPT09IFwiYmxvY2txdW90ZVwiIHx8IGl0ZW1Ub2tlbi50eXBlID09PSBcImNvZGVcIikge1xuICAgICAgICAgIGNvbnRlbnQucHVzaCguLi5oZWxwZXJzLnBhcnNlQ2hpbGRyZW4oW2l0ZW1Ub2tlbl0pKTtcbiAgICAgICAgfSBlbHNlIGlmIChpdGVtVG9rZW4udHlwZSA9PT0gXCJ0ZXh0XCIgJiYgaXRlbVRva2VuLnRva2Vucykge1xuICAgICAgICAgIGNvbnN0IGlubGluZUNvbnRlbnQgPSBoZWxwZXJzLnBhcnNlQ2hpbGRyZW4oW2l0ZW1Ub2tlbl0pO1xuICAgICAgICAgIGNvbnRlbnQucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiBcInBhcmFncmFwaFwiLFxuICAgICAgICAgICAgY29udGVudDogaW5saW5lQ29udGVudFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IGhlbHBlcnMucGFyc2VDaGlsZHJlbihbaXRlbVRva2VuXSk7XG4gICAgICAgICAgaWYgKHBhcnNlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb250ZW50LnB1c2goLi4ucGFyc2VkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJsaXN0SXRlbVwiLFxuICAgICAgY29udGVudFxuICAgIH07XG4gIH0pO1xufVxuXG4vLyBzcmMvb3JkZXJlZC1saXN0L29yZGVyZWQtbGlzdC50c1xudmFyIExpc3RJdGVtTmFtZTIgPSBcImxpc3RJdGVtXCI7XG52YXIgVGV4dFN0eWxlTmFtZTIgPSBcInRleHRTdHlsZVwiO1xudmFyIG9yZGVyZWRMaXN0SW5wdXRSZWdleCA9IC9eKFxcZCspXFwuXFxzJC87XG52YXIgT3JkZXJlZExpc3QgPSBOb2RlMy5jcmVhdGUoe1xuICBuYW1lOiBcIm9yZGVyZWRMaXN0XCIsXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGl0ZW1UeXBlTmFtZTogXCJsaXN0SXRlbVwiLFxuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgICAga2VlcE1hcmtzOiBmYWxzZSxcbiAgICAgIGtlZXBBdHRyaWJ1dGVzOiBmYWxzZVxuICAgIH07XG4gIH0sXG4gIGdyb3VwOiBcImJsb2NrIGxpc3RcIixcbiAgY29udGVudCgpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5vcHRpb25zLml0ZW1UeXBlTmFtZX0rYDtcbiAgfSxcbiAgYWRkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQ6IHtcbiAgICAgICAgZGVmYXVsdDogMSxcbiAgICAgICAgcGFyc2VIVE1MOiAoZWxlbWVudCkgPT4ge1xuICAgICAgICAgIHJldHVybiBlbGVtZW50Lmhhc0F0dHJpYnV0ZShcInN0YXJ0XCIpID8gcGFyc2VJbnQoZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJzdGFydFwiKSB8fCBcIlwiLCAxMCkgOiAxO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdHlwZToge1xuICAgICAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgICBwYXJzZUhUTUw6IChlbGVtZW50KSA9PiBlbGVtZW50LmdldEF0dHJpYnV0ZShcInR5cGVcIilcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBwYXJzZUhUTUwoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgdGFnOiBcIm9sXCJcbiAgICAgIH1cbiAgICBdO1xuICB9LFxuICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgIGNvbnN0IHsgc3RhcnQsIC4uLmF0dHJpYnV0ZXNXaXRob3V0U3RhcnQgfSA9IEhUTUxBdHRyaWJ1dGVzO1xuICAgIHJldHVybiBzdGFydCA9PT0gMSA/IFtcIm9sXCIsIG1lcmdlQXR0cmlidXRlczModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBhdHRyaWJ1dGVzV2l0aG91dFN0YXJ0KSwgMF0gOiBbXCJvbFwiLCBtZXJnZUF0dHJpYnV0ZXMzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLCAwXTtcbiAgfSxcbiAgbWFya2Rvd25Ub2tlbk5hbWU6IFwibGlzdFwiLFxuICBwYXJzZU1hcmtkb3duOiAodG9rZW4sIGhlbHBlcnMpID0+IHtcbiAgICBpZiAodG9rZW4udHlwZSAhPT0gXCJsaXN0XCIgfHwgIXRva2VuLm9yZGVyZWQpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3Qgc3RhcnRWYWx1ZSA9IHRva2VuLnN0YXJ0IHx8IDE7XG4gICAgY29uc3QgY29udGVudCA9IHRva2VuLml0ZW1zID8gcGFyc2VMaXN0SXRlbXModG9rZW4uaXRlbXMsIGhlbHBlcnMpIDogW107XG4gICAgaWYgKHN0YXJ0VmFsdWUgIT09IDEpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwib3JkZXJlZExpc3RcIixcbiAgICAgICAgYXR0cnM6IHsgc3RhcnQ6IHN0YXJ0VmFsdWUgfSxcbiAgICAgICAgY29udGVudFxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwib3JkZXJlZExpc3RcIixcbiAgICAgIGNvbnRlbnRcbiAgICB9O1xuICB9LFxuICByZW5kZXJNYXJrZG93bjogKG5vZGUsIGgpID0+IHtcbiAgICBpZiAoIW5vZGUuY29udGVudCkge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIHJldHVybiBoLnJlbmRlckNoaWxkcmVuKG5vZGUuY29udGVudCwgXCJcXG5cIik7XG4gIH0sXG4gIG1hcmtkb3duVG9rZW5pemVyOiB7XG4gICAgbmFtZTogXCJvcmRlcmVkTGlzdFwiLFxuICAgIGxldmVsOiBcImJsb2NrXCIsXG4gICAgc3RhcnQ6IChzcmMpID0+IHtcbiAgICAgIGNvbnN0IG1hdGNoID0gc3JjLm1hdGNoKC9eKFxccyopKFxcZCspXFwuXFxzKy8pO1xuICAgICAgY29uc3QgaW5kZXggPSBtYXRjaCA9PSBudWxsID8gdm9pZCAwIDogbWF0Y2guaW5kZXg7XG4gICAgICByZXR1cm4gaW5kZXggIT09IHZvaWQgMCA/IGluZGV4IDogLTE7XG4gICAgfSxcbiAgICB0b2tlbml6ZTogKHNyYywgX3Rva2VucywgbGV4ZXIpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IGxpbmVzID0gc3JjLnNwbGl0KFwiXFxuXCIpO1xuICAgICAgY29uc3QgW2xpc3RJdGVtcywgY29uc3VtZWRdID0gY29sbGVjdE9yZGVyZWRMaXN0SXRlbXMobGluZXMpO1xuICAgICAgaWYgKGxpc3RJdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGl0ZW1zID0gYnVpbGROZXN0ZWRTdHJ1Y3R1cmUobGlzdEl0ZW1zLCAwLCBsZXhlcik7XG4gICAgICBpZiAoaXRlbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9XG4gICAgICBjb25zdCBzdGFydFZhbHVlID0gKChfYSA9IGxpc3RJdGVtc1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLm51bWJlcikgfHwgMTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwibGlzdFwiLFxuICAgICAgICBvcmRlcmVkOiB0cnVlLFxuICAgICAgICBzdGFydDogc3RhcnRWYWx1ZSxcbiAgICAgICAgaXRlbXMsXG4gICAgICAgIHJhdzogbGluZXMuc2xpY2UoMCwgY29uc3VtZWQpLmpvaW4oXCJcXG5cIilcbiAgICAgIH07XG4gICAgfVxuICB9LFxuICBtYXJrZG93bk9wdGlvbnM6IHtcbiAgICBpbmRlbnRzQ29udGVudDogdHJ1ZVxuICB9LFxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9nZ2xlT3JkZXJlZExpc3Q6ICgpID0+ICh7IGNvbW1hbmRzLCBjaGFpbiB9KSA9PiB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMua2VlcEF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICByZXR1cm4gY2hhaW4oKS50b2dnbGVMaXN0KHRoaXMubmFtZSwgdGhpcy5vcHRpb25zLml0ZW1UeXBlTmFtZSwgdGhpcy5vcHRpb25zLmtlZXBNYXJrcykudXBkYXRlQXR0cmlidXRlcyhMaXN0SXRlbU5hbWUyLCB0aGlzLmVkaXRvci5nZXRBdHRyaWJ1dGVzKFRleHRTdHlsZU5hbWUyKSkucnVuKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnRvZ2dsZUxpc3QodGhpcy5uYW1lLCB0aGlzLm9wdGlvbnMuaXRlbVR5cGVOYW1lLCB0aGlzLm9wdGlvbnMua2VlcE1hcmtzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgXCJNb2QtU2hpZnQtN1wiOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVPcmRlcmVkTGlzdCgpXG4gICAgfTtcbiAgfSxcbiAgYWRkSW5wdXRSdWxlcygpIHtcbiAgICBsZXQgaW5wdXRSdWxlID0gd3JhcHBpbmdJbnB1dFJ1bGUyKHtcbiAgICAgIGZpbmQ6IG9yZGVyZWRMaXN0SW5wdXRSZWdleCxcbiAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgIGdldEF0dHJpYnV0ZXM6IChtYXRjaCkgPT4gKHsgc3RhcnQ6ICttYXRjaFsxXSB9KSxcbiAgICAgIGpvaW5QcmVkaWNhdGU6IChtYXRjaCwgbm9kZSkgPT4gbm9kZS5jaGlsZENvdW50ICsgbm9kZS5hdHRycy5zdGFydCA9PT0gK21hdGNoWzFdXG4gICAgfSk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5rZWVwTWFya3MgfHwgdGhpcy5vcHRpb25zLmtlZXBBdHRyaWJ1dGVzKSB7XG4gICAgICBpbnB1dFJ1bGUgPSB3cmFwcGluZ0lucHV0UnVsZTIoe1xuICAgICAgICBmaW5kOiBvcmRlcmVkTGlzdElucHV0UmVnZXgsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAga2VlcE1hcmtzOiB0aGlzLm9wdGlvbnMua2VlcE1hcmtzLFxuICAgICAgICBrZWVwQXR0cmlidXRlczogdGhpcy5vcHRpb25zLmtlZXBBdHRyaWJ1dGVzLFxuICAgICAgICBnZXRBdHRyaWJ1dGVzOiAobWF0Y2gpID0+ICh7IHN0YXJ0OiArbWF0Y2hbMV0sIC4uLnRoaXMuZWRpdG9yLmdldEF0dHJpYnV0ZXMoVGV4dFN0eWxlTmFtZTIpIH0pLFxuICAgICAgICBqb2luUHJlZGljYXRlOiAobWF0Y2gsIG5vZGUpID0+IG5vZGUuY2hpbGRDb3VudCArIG5vZGUuYXR0cnMuc3RhcnQgPT09ICttYXRjaFsxXSxcbiAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvclxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBbaW5wdXRSdWxlXTtcbiAgfVxufSk7XG5cbi8vIHNyYy90YXNrLWl0ZW0vdGFzay1pdGVtLnRzXG5pbXBvcnQgeyBtZXJnZUF0dHJpYnV0ZXMgYXMgbWVyZ2VBdHRyaWJ1dGVzNCwgTm9kZSBhcyBOb2RlNCwgcmVuZGVyTmVzdGVkTWFya2Rvd25Db250ZW50IGFzIHJlbmRlck5lc3RlZE1hcmtkb3duQ29udGVudDIsIHdyYXBwaW5nSW5wdXRSdWxlIGFzIHdyYXBwaW5nSW5wdXRSdWxlMyB9IGZyb20gXCJAdGlwdGFwL2NvcmVcIjtcbnZhciBpbnB1dFJlZ2V4ID0gL15cXHMqKFxcWyhbKCB8eF0pP1xcXSlcXHMkLztcbnZhciBUYXNrSXRlbSA9IE5vZGU0LmNyZWF0ZSh7XG4gIG5hbWU6IFwidGFza0l0ZW1cIixcbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmVzdGVkOiBmYWxzZSxcbiAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fSxcbiAgICAgIHRhc2tMaXN0VHlwZU5hbWU6IFwidGFza0xpc3RcIixcbiAgICAgIGExMXk6IHZvaWQgMFxuICAgIH07XG4gIH0sXG4gIGNvbnRlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5uZXN0ZWQgPyBcInBhcmFncmFwaCBibG9jaypcIiA6IFwicGFyYWdyYXBoK1wiO1xuICB9LFxuICBkZWZpbmluZzogdHJ1ZSxcbiAgYWRkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2hlY2tlZDoge1xuICAgICAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICAgICAga2VlcE9uU3BsaXQ6IGZhbHNlLFxuICAgICAgICBwYXJzZUhUTUw6IChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgY29uc3QgZGF0YUNoZWNrZWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtY2hlY2tlZFwiKTtcbiAgICAgICAgICByZXR1cm4gZGF0YUNoZWNrZWQgPT09IFwiXCIgfHwgZGF0YUNoZWNrZWQgPT09IFwidHJ1ZVwiO1xuICAgICAgICB9LFxuICAgICAgICByZW5kZXJIVE1MOiAoYXR0cmlidXRlcykgPT4gKHtcbiAgICAgICAgICBcImRhdGEtY2hlY2tlZFwiOiBhdHRyaWJ1dGVzLmNoZWNrZWRcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBwYXJzZUhUTUwoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgdGFnOiBgbGlbZGF0YS10eXBlPVwiJHt0aGlzLm5hbWV9XCJdYCxcbiAgICAgICAgcHJpb3JpdHk6IDUxXG4gICAgICB9XG4gICAgXTtcbiAgfSxcbiAgcmVuZGVySFRNTCh7IG5vZGUsIEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICByZXR1cm4gW1xuICAgICAgXCJsaVwiLFxuICAgICAgbWVyZ2VBdHRyaWJ1dGVzNCh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzLCB7XG4gICAgICAgIFwiZGF0YS10eXBlXCI6IHRoaXMubmFtZVxuICAgICAgfSksXG4gICAgICBbXG4gICAgICAgIFwibGFiZWxcIixcbiAgICAgICAgW1xuICAgICAgICAgIFwiaW5wdXRcIixcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiBcImNoZWNrYm94XCIsXG4gICAgICAgICAgICBjaGVja2VkOiBub2RlLmF0dHJzLmNoZWNrZWQgPyBcImNoZWNrZWRcIiA6IG51bGxcbiAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIFtcInNwYW5cIl1cbiAgICAgIF0sXG4gICAgICBbXCJkaXZcIiwgMF1cbiAgICBdO1xuICB9LFxuICBwYXJzZU1hcmtkb3duOiAodG9rZW4sIGgpID0+IHtcbiAgICBjb25zdCBjb250ZW50ID0gW107XG4gICAgaWYgKHRva2VuLnRva2VucyAmJiB0b2tlbi50b2tlbnMubGVuZ3RoID4gMCkge1xuICAgICAgY29udGVudC5wdXNoKGguY3JlYXRlTm9kZShcInBhcmFncmFwaFwiLCB7fSwgaC5wYXJzZUlubGluZSh0b2tlbi50b2tlbnMpKSk7XG4gICAgfSBlbHNlIGlmICh0b2tlbi50ZXh0KSB7XG4gICAgICBjb250ZW50LnB1c2goaC5jcmVhdGVOb2RlKFwicGFyYWdyYXBoXCIsIHt9LCBbaC5jcmVhdGVOb2RlKFwidGV4dFwiLCB7IHRleHQ6IHRva2VuLnRleHQgfSldKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRlbnQucHVzaChoLmNyZWF0ZU5vZGUoXCJwYXJhZ3JhcGhcIiwge30sIFtdKSk7XG4gICAgfVxuICAgIGlmICh0b2tlbi5uZXN0ZWRUb2tlbnMgJiYgdG9rZW4ubmVzdGVkVG9rZW5zLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IG5lc3RlZENvbnRlbnQgPSBoLnBhcnNlQ2hpbGRyZW4odG9rZW4ubmVzdGVkVG9rZW5zKTtcbiAgICAgIGNvbnRlbnQucHVzaCguLi5uZXN0ZWRDb250ZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIGguY3JlYXRlTm9kZShcInRhc2tJdGVtXCIsIHsgY2hlY2tlZDogdG9rZW4uY2hlY2tlZCB8fCBmYWxzZSB9LCBjb250ZW50KTtcbiAgfSxcbiAgcmVuZGVyTWFya2Rvd246IChub2RlLCBoKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGNoZWNrZWRDaGFyID0gKChfYSA9IG5vZGUuYXR0cnMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jaGVja2VkKSA/IFwieFwiIDogXCIgXCI7XG4gICAgY29uc3QgcHJlZml4ID0gYC0gWyR7Y2hlY2tlZENoYXJ9XSBgO1xuICAgIHJldHVybiByZW5kZXJOZXN0ZWRNYXJrZG93bkNvbnRlbnQyKG5vZGUsIGgsIHByZWZpeCk7XG4gIH0sXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgIGNvbnN0IHNob3J0Y3V0cyA9IHtcbiAgICAgIEVudGVyOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5zcGxpdExpc3RJdGVtKHRoaXMubmFtZSksXG4gICAgICBcIlNoaWZ0LVRhYlwiOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5saWZ0TGlzdEl0ZW0odGhpcy5uYW1lKVxuICAgIH07XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMubmVzdGVkKSB7XG4gICAgICByZXR1cm4gc2hvcnRjdXRzO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgLi4uc2hvcnRjdXRzLFxuICAgICAgVGFiOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5zaW5rTGlzdEl0ZW0odGhpcy5uYW1lKVxuICAgIH07XG4gIH0sXG4gIGFkZE5vZGVWaWV3KCkge1xuICAgIHJldHVybiAoeyBub2RlLCBIVE1MQXR0cmlidXRlcywgZ2V0UG9zLCBlZGl0b3IgfSkgPT4ge1xuICAgICAgY29uc3QgbGlzdEl0ZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlcIik7XG4gICAgICBjb25zdCBjaGVja2JveFdyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGFiZWxcIik7XG4gICAgICBjb25zdCBjaGVja2JveFN0eWxlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgY29uc3QgY2hlY2tib3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgICBjb25zdCBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIGNvbnN0IHVwZGF0ZUExMVkgPSAoY3VycmVudE5vZGUpID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY2hlY2tib3guYXJpYUxhYmVsID0gKChfYiA9IChfYSA9IHRoaXMub3B0aW9ucy5hMTF5KSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2hlY2tib3hMYWJlbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIGN1cnJlbnROb2RlLCBjaGVja2JveC5jaGVja2VkKSkgfHwgYFRhc2sgaXRlbSBjaGVja2JveCBmb3IgJHtjdXJyZW50Tm9kZS50ZXh0Q29udGVudCB8fCBcImVtcHR5IHRhc2sgaXRlbVwifWA7XG4gICAgICB9O1xuICAgICAgdXBkYXRlQTExWShub2RlKTtcbiAgICAgIGNoZWNrYm94V3JhcHBlci5jb250ZW50RWRpdGFibGUgPSBcImZhbHNlXCI7XG4gICAgICBjaGVja2JveC50eXBlID0gXCJjaGVja2JveFwiO1xuICAgICAgY2hlY2tib3guYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCAoZXZlbnQpID0+IGV2ZW50LnByZXZlbnREZWZhdWx0KCkpO1xuICAgICAgY2hlY2tib3guYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKCFlZGl0b3IuaXNFZGl0YWJsZSAmJiAhdGhpcy5vcHRpb25zLm9uUmVhZE9ubHlDaGVja2VkKSB7XG4gICAgICAgICAgY2hlY2tib3guY2hlY2tlZCA9ICFjaGVja2JveC5jaGVja2VkO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGNoZWNrZWQgfSA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgaWYgKGVkaXRvci5pc0VkaXRhYmxlICYmIHR5cGVvZiBnZXRQb3MgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIGVkaXRvci5jaGFpbigpLmZvY3VzKHZvaWQgMCwgeyBzY3JvbGxJbnRvVmlldzogZmFsc2UgfSkuY29tbWFuZCgoeyB0ciB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFBvcygpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwb3NpdGlvbiAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50Tm9kZSA9IHRyLmRvYy5ub2RlQXQocG9zaXRpb24pO1xuICAgICAgICAgICAgdHIuc2V0Tm9kZU1hcmt1cChwb3NpdGlvbiwgdm9pZCAwLCB7XG4gICAgICAgICAgICAgIC4uLmN1cnJlbnROb2RlID09IG51bGwgPyB2b2lkIDAgOiBjdXJyZW50Tm9kZS5hdHRycyxcbiAgICAgICAgICAgICAgY2hlY2tlZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9KS5ydW4oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWVkaXRvci5pc0VkaXRhYmxlICYmIHRoaXMub3B0aW9ucy5vblJlYWRPbmx5Q2hlY2tlZCkge1xuICAgICAgICAgIGlmICghdGhpcy5vcHRpb25zLm9uUmVhZE9ubHlDaGVja2VkKG5vZGUsIGNoZWNrZWQpKSB7XG4gICAgICAgICAgICBjaGVja2JveC5jaGVja2VkID0gIWNoZWNrYm94LmNoZWNrZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5lbnRyaWVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIGxpc3RJdGVtLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgIH0pO1xuICAgICAgbGlzdEl0ZW0uZGF0YXNldC5jaGVja2VkID0gbm9kZS5hdHRycy5jaGVja2VkO1xuICAgICAgY2hlY2tib3guY2hlY2tlZCA9IG5vZGUuYXR0cnMuY2hlY2tlZDtcbiAgICAgIGNoZWNrYm94V3JhcHBlci5hcHBlbmQoY2hlY2tib3gsIGNoZWNrYm94U3R5bGVyKTtcbiAgICAgIGxpc3RJdGVtLmFwcGVuZChjaGVja2JveFdyYXBwZXIsIGNvbnRlbnQpO1xuICAgICAgT2JqZWN0LmVudHJpZXMoSFRNTEF0dHJpYnV0ZXMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICBsaXN0SXRlbS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRvbTogbGlzdEl0ZW0sXG4gICAgICAgIGNvbnRlbnRET006IGNvbnRlbnQsXG4gICAgICAgIHVwZGF0ZTogKHVwZGF0ZWROb2RlKSA9PiB7XG4gICAgICAgICAgaWYgKHVwZGF0ZWROb2RlLnR5cGUgIT09IHRoaXMudHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsaXN0SXRlbS5kYXRhc2V0LmNoZWNrZWQgPSB1cGRhdGVkTm9kZS5hdHRycy5jaGVja2VkO1xuICAgICAgICAgIGNoZWNrYm94LmNoZWNrZWQgPSB1cGRhdGVkTm9kZS5hdHRycy5jaGVja2VkO1xuICAgICAgICAgIHVwZGF0ZUExMVkodXBkYXRlZE5vZGUpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG4gIH0sXG4gIGFkZElucHV0UnVsZXMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHdyYXBwaW5nSW5wdXRSdWxlMyh7XG4gICAgICAgIGZpbmQ6IGlucHV0UmVnZXgsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgZ2V0QXR0cmlidXRlczogKG1hdGNoKSA9PiAoe1xuICAgICAgICAgIGNoZWNrZWQ6IG1hdGNoW21hdGNoLmxlbmd0aCAtIDFdID09PSBcInhcIlxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICBdO1xuICB9XG59KTtcblxuLy8gc3JjL3Rhc2stbGlzdC90YXNrLWxpc3QudHNcbmltcG9ydCB7IG1lcmdlQXR0cmlidXRlcyBhcyBtZXJnZUF0dHJpYnV0ZXM1LCBOb2RlIGFzIE5vZGU1LCBwYXJzZUluZGVudGVkQmxvY2tzIH0gZnJvbSBcIkB0aXB0YXAvY29yZVwiO1xudmFyIFRhc2tMaXN0ID0gTm9kZTUuY3JlYXRlKHtcbiAgbmFtZTogXCJ0YXNrTGlzdFwiLFxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBpdGVtVHlwZU5hbWU6IFwidGFza0l0ZW1cIixcbiAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fVxuICAgIH07XG4gIH0sXG4gIGdyb3VwOiBcImJsb2NrIGxpc3RcIixcbiAgY29udGVudCgpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5vcHRpb25zLml0ZW1UeXBlTmFtZX0rYDtcbiAgfSxcbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIHRhZzogYHVsW2RhdGEtdHlwZT1cIiR7dGhpcy5uYW1lfVwiXWAsXG4gICAgICAgIHByaW9yaXR5OiA1MVxuICAgICAgfVxuICAgIF07XG4gIH0sXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgcmV0dXJuIFtcInVsXCIsIG1lcmdlQXR0cmlidXRlczUodGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcywgeyBcImRhdGEtdHlwZVwiOiB0aGlzLm5hbWUgfSksIDBdO1xuICB9LFxuICBwYXJzZU1hcmtkb3duOiAodG9rZW4sIGgpID0+IHtcbiAgICByZXR1cm4gaC5jcmVhdGVOb2RlKFwidGFza0xpc3RcIiwge30sIGgucGFyc2VDaGlsZHJlbih0b2tlbi5pdGVtcyB8fCBbXSkpO1xuICB9LFxuICByZW5kZXJNYXJrZG93bjogKG5vZGUsIGgpID0+IHtcbiAgICBpZiAoIW5vZGUuY29udGVudCkge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIHJldHVybiBoLnJlbmRlckNoaWxkcmVuKG5vZGUuY29udGVudCwgXCJcXG5cIik7XG4gIH0sXG4gIG1hcmtkb3duVG9rZW5pemVyOiB7XG4gICAgbmFtZTogXCJ0YXNrTGlzdFwiLFxuICAgIGxldmVsOiBcImJsb2NrXCIsXG4gICAgc3RhcnQoc3JjKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBpbmRleCA9IChfYSA9IHNyYy5tYXRjaCgvXlxccypbLSsqXVxccytcXFsoWyB4WF0pXFxdXFxzKy8pKSA9PSBudWxsID8gdm9pZCAwIDogX2EuaW5kZXg7XG4gICAgICByZXR1cm4gaW5kZXggIT09IHZvaWQgMCA/IGluZGV4IDogLTE7XG4gICAgfSxcbiAgICB0b2tlbml6ZShzcmMsIHRva2VucywgbGV4ZXIpIHtcbiAgICAgIGNvbnN0IHBhcnNlVGFza0xpc3RDb250ZW50ID0gKGNvbnRlbnQpID0+IHtcbiAgICAgICAgY29uc3QgbmVzdGVkUmVzdWx0ID0gcGFyc2VJbmRlbnRlZEJsb2NrcyhcbiAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGl0ZW1QYXR0ZXJuOiAvXihcXHMqKShbLSsqXSlcXHMrXFxbKFsgeFhdKVxcXVxccysoLiopJC8sXG4gICAgICAgICAgICBleHRyYWN0SXRlbURhdGE6IChtYXRjaCkgPT4gKHtcbiAgICAgICAgICAgICAgaW5kZW50TGV2ZWw6IG1hdGNoWzFdLmxlbmd0aCxcbiAgICAgICAgICAgICAgbWFpbkNvbnRlbnQ6IG1hdGNoWzRdLFxuICAgICAgICAgICAgICBjaGVja2VkOiBtYXRjaFszXS50b0xvd2VyQ2FzZSgpID09PSBcInhcIlxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBjcmVhdGVUb2tlbjogKGRhdGEsIG5lc3RlZFRva2VucykgPT4gKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJ0YXNrSXRlbVwiLFxuICAgICAgICAgICAgICByYXc6IFwiXCIsXG4gICAgICAgICAgICAgIG1haW5Db250ZW50OiBkYXRhLm1haW5Db250ZW50LFxuICAgICAgICAgICAgICBpbmRlbnRMZXZlbDogZGF0YS5pbmRlbnRMZXZlbCxcbiAgICAgICAgICAgICAgY2hlY2tlZDogZGF0YS5jaGVja2VkLFxuICAgICAgICAgICAgICB0ZXh0OiBkYXRhLm1haW5Db250ZW50LFxuICAgICAgICAgICAgICB0b2tlbnM6IGxleGVyLmlubGluZVRva2VucyhkYXRhLm1haW5Db250ZW50KSxcbiAgICAgICAgICAgICAgbmVzdGVkVG9rZW5zXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIC8vIEFsbG93IHJlY3Vyc2l2ZSBuZXN0aW5nXG4gICAgICAgICAgICBjdXN0b21OZXN0ZWRQYXJzZXI6IHBhcnNlVGFza0xpc3RDb250ZW50XG4gICAgICAgICAgfSxcbiAgICAgICAgICBsZXhlclxuICAgICAgICApO1xuICAgICAgICBpZiAobmVzdGVkUmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdHlwZTogXCJ0YXNrTGlzdFwiLFxuICAgICAgICAgICAgICByYXc6IG5lc3RlZFJlc3VsdC5yYXcsXG4gICAgICAgICAgICAgIGl0ZW1zOiBuZXN0ZWRSZXN1bHQuaXRlbXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsZXhlci5ibG9ja1Rva2Vucyhjb250ZW50KTtcbiAgICAgIH07XG4gICAgICBjb25zdCByZXN1bHQgPSBwYXJzZUluZGVudGVkQmxvY2tzKFxuICAgICAgICBzcmMsXG4gICAgICAgIHtcbiAgICAgICAgICBpdGVtUGF0dGVybjogL14oXFxzKikoWy0rKl0pXFxzK1xcWyhbIHhYXSlcXF1cXHMrKC4qKSQvLFxuICAgICAgICAgIGV4dHJhY3RJdGVtRGF0YTogKG1hdGNoKSA9PiAoe1xuICAgICAgICAgICAgaW5kZW50TGV2ZWw6IG1hdGNoWzFdLmxlbmd0aCxcbiAgICAgICAgICAgIG1haW5Db250ZW50OiBtYXRjaFs0XSxcbiAgICAgICAgICAgIGNoZWNrZWQ6IG1hdGNoWzNdLnRvTG93ZXJDYXNlKCkgPT09IFwieFwiXG4gICAgICAgICAgfSksXG4gICAgICAgICAgY3JlYXRlVG9rZW46IChkYXRhLCBuZXN0ZWRUb2tlbnMpID0+ICh7XG4gICAgICAgICAgICB0eXBlOiBcInRhc2tJdGVtXCIsXG4gICAgICAgICAgICByYXc6IFwiXCIsXG4gICAgICAgICAgICBtYWluQ29udGVudDogZGF0YS5tYWluQ29udGVudCxcbiAgICAgICAgICAgIGluZGVudExldmVsOiBkYXRhLmluZGVudExldmVsLFxuICAgICAgICAgICAgY2hlY2tlZDogZGF0YS5jaGVja2VkLFxuICAgICAgICAgICAgdGV4dDogZGF0YS5tYWluQ29udGVudCxcbiAgICAgICAgICAgIHRva2VuczogbGV4ZXIuaW5saW5lVG9rZW5zKGRhdGEubWFpbkNvbnRlbnQpLFxuICAgICAgICAgICAgbmVzdGVkVG9rZW5zXG4gICAgICAgICAgfSksXG4gICAgICAgICAgLy8gVXNlIHRoZSByZWN1cnNpdmUgcGFyc2VyIGZvciBuZXN0ZWQgY29udGVudFxuICAgICAgICAgIGN1c3RvbU5lc3RlZFBhcnNlcjogcGFyc2VUYXNrTGlzdENvbnRlbnRcbiAgICAgICAgfSxcbiAgICAgICAgbGV4ZXJcbiAgICAgICk7XG4gICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJ0YXNrTGlzdFwiLFxuICAgICAgICByYXc6IHJlc3VsdC5yYXcsXG4gICAgICAgIGl0ZW1zOiByZXN1bHQuaXRlbXNcbiAgICAgIH07XG4gICAgfVxuICB9LFxuICBtYXJrZG93bk9wdGlvbnM6IHtcbiAgICBpbmRlbnRzQ29udGVudDogdHJ1ZVxuICB9LFxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9nZ2xlVGFza0xpc3Q6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnRvZ2dsZUxpc3QodGhpcy5uYW1lLCB0aGlzLm9wdGlvbnMuaXRlbVR5cGVOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgXCJNb2QtU2hpZnQtOVwiOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVUYXNrTGlzdCgpXG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHNyYy9raXQvaW5kZXgudHNcbnZhciBMaXN0S2l0ID0gRXh0ZW5zaW9uMi5jcmVhdGUoe1xuICBuYW1lOiBcImxpc3RLaXRcIixcbiAgYWRkRXh0ZW5zaW9ucygpIHtcbiAgICBjb25zdCBleHRlbnNpb25zID0gW107XG4gICAgaWYgKHRoaXMub3B0aW9ucy5idWxsZXRMaXN0ICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKEJ1bGxldExpc3QuY29uZmlndXJlKHRoaXMub3B0aW9ucy5idWxsZXRMaXN0KSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMubGlzdEl0ZW0gIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goTGlzdEl0ZW0uY29uZmlndXJlKHRoaXMub3B0aW9ucy5saXN0SXRlbSkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmxpc3RLZXltYXAgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goTGlzdEtleW1hcC5jb25maWd1cmUodGhpcy5vcHRpb25zLmxpc3RLZXltYXApKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5vcmRlcmVkTGlzdCAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuc2lvbnMucHVzaChPcmRlcmVkTGlzdC5jb25maWd1cmUodGhpcy5vcHRpb25zLm9yZGVyZWRMaXN0KSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMudGFza0l0ZW0gIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goVGFza0l0ZW0uY29uZmlndXJlKHRoaXMub3B0aW9ucy50YXNrSXRlbSkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLnRhc2tMaXN0ICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKFRhc2tMaXN0LmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnMudGFza0xpc3QpKTtcbiAgICB9XG4gICAgcmV0dXJuIGV4dGVuc2lvbnM7XG4gIH1cbn0pO1xuZXhwb3J0IHtcbiAgQnVsbGV0TGlzdCxcbiAgTGlzdEl0ZW0sXG4gIExpc3RLZXltYXAsXG4gIExpc3RLaXQsXG4gIE9yZGVyZWRMaXN0LFxuICBUYXNrSXRlbSxcbiAgVGFza0xpc3QsXG4gIGJ1bGxldExpc3RJbnB1dFJlZ2V4LFxuICBpbnB1dFJlZ2V4LFxuICBsaXN0SGVscGVyc19leHBvcnRzIGFzIGxpc3RIZWxwZXJzLFxuICBvcmRlcmVkTGlzdElucHV0UmVnZXhcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsiX19kZWZQcm9wIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJfX2V4cG9ydCIsInRhcmdldCIsImFsbCIsIm5hbWUiLCJnZXQiLCJlbnVtZXJhYmxlIiwibWVyZ2VBdHRyaWJ1dGVzIiwiTm9kZSIsIndyYXBwaW5nSW5wdXRSdWxlIiwiTGlzdEl0ZW1OYW1lIiwiVGV4dFN0eWxlTmFtZSIsImJ1bGxldExpc3RJbnB1dFJlZ2V4IiwiQnVsbGV0TGlzdCIsImNyZWF0ZSIsImFkZE9wdGlvbnMiLCJpdGVtVHlwZU5hbWUiLCJIVE1MQXR0cmlidXRlcyIsImtlZXBNYXJrcyIsImtlZXBBdHRyaWJ1dGVzIiwiZ3JvdXAiLCJjb250ZW50Iiwib3B0aW9ucyIsInBhcnNlSFRNTCIsInRhZyIsInJlbmRlckhUTUwiLCJtYXJrZG93blRva2VuTmFtZSIsInBhcnNlTWFya2Rvd24iLCJ0b2tlbiIsImhlbHBlcnMiLCJ0eXBlIiwib3JkZXJlZCIsIml0ZW1zIiwicGFyc2VDaGlsZHJlbiIsInJlbmRlck1hcmtkb3duIiwibm9kZSIsImgiLCJyZW5kZXJDaGlsZHJlbiIsIm1hcmtkb3duT3B0aW9ucyIsImluZGVudHNDb250ZW50IiwiYWRkQ29tbWFuZHMiLCJ0b2dnbGVCdWxsZXRMaXN0IiwiY29tbWFuZHMiLCJjaGFpbiIsInRvZ2dsZUxpc3QiLCJ1cGRhdGVBdHRyaWJ1dGVzIiwiZWRpdG9yIiwiZ2V0QXR0cmlidXRlcyIsInJ1biIsImFkZEtleWJvYXJkU2hvcnRjdXRzIiwiYWRkSW5wdXRSdWxlcyIsImlucHV0UnVsZSIsImZpbmQiLCJtZXJnZUF0dHJpYnV0ZXMyIiwiTm9kZTIiLCJyZW5kZXJOZXN0ZWRNYXJrZG93bkNvbnRlbnQiLCJMaXN0SXRlbSIsImJ1bGxldExpc3RUeXBlTmFtZSIsIm9yZGVyZWRMaXN0VHlwZU5hbWUiLCJkZWZpbmluZyIsInRva2VucyIsImxlbmd0aCIsImhhc1BhcmFncmFwaFRva2VucyIsInNvbWUiLCJ0IiwiZmlyc3RUb2tlbiIsImlubGluZUNvbnRlbnQiLCJwYXJzZUlubGluZSIsInJlbWFpbmluZ1Rva2VucyIsInNsaWNlIiwiYWRkaXRpb25hbENvbnRlbnQiLCJwdXNoIiwiY3R4IiwiY29udGV4dCIsInBhcmVudFR5cGUiLCJpbmRleCIsIkVudGVyIiwic3BsaXRMaXN0SXRlbSIsIlRhYiIsInNpbmtMaXN0SXRlbSIsImxpZnRMaXN0SXRlbSIsIkV4dGVuc2lvbiIsImxpc3RIZWxwZXJzX2V4cG9ydHMiLCJmaW5kTGlzdEl0ZW1Qb3MiLCJnZXROZXh0TGlzdERlcHRoIiwiaGFuZGxlQmFja3NwYWNlIiwiaGFuZGxlRGVsZXRlIiwiaGFzTGlzdEJlZm9yZSIsImhhc0xpc3RJdGVtQWZ0ZXIiLCJoYXNMaXN0SXRlbUJlZm9yZSIsImxpc3RJdGVtSGFzU3ViTGlzdCIsIm5leHRMaXN0SXNEZWVwZXIiLCJuZXh0TGlzdElzSGlnaGVyIiwiZ2V0Tm9kZVR5cGUiLCJ0eXBlT3JOYW1lIiwic3RhdGUiLCIkZnJvbSIsInNlbGVjdGlvbiIsIm5vZGVUeXBlIiwic2NoZW1hIiwiY3VycmVudE5vZGUiLCJjdXJyZW50RGVwdGgiLCJkZXB0aCIsImN1cnJlbnRQb3MiLCJwb3MiLCJ0YXJnZXREZXB0aCIsIiRwb3MiLCJkb2MiLCJyZXNvbHZlIiwiZ2V0Tm9kZUF0UG9zaXRpb24iLCJsaXN0SXRlbVBvcyIsImlzQXRTdGFydE9mTm9kZSIsImlzTm9kZUFjdGl2ZSIsImVkaXRvclN0YXRlIiwicGFyZW50TGlzdFR5cGVzIiwiJGFuY2hvciIsInByZXZpb3VzTm9kZVBvcyIsIk1hdGgiLCJtYXgiLCJwcmV2aW91c05vZGUiLCJpbmNsdWRlcyIsIl9hIiwiJHRhcmdldFBvcyIsIm5vZGVCZWZvcmUiLCJnZXROb2RlVHlwZTIiLCJoYXNTdWJMaXN0IiwiZGVzY2VuZGFudHMiLCJjaGlsZCIsInVuZG9JbnB1dFJ1bGUiLCJmcm9tIiwidG8iLCIkbGlzdFBvcyIsImJlZm9yZSIsImxpc3REZXNjZW5kYW50cyIsImxhc3RJdGVtIiwiYXQiLCIkbGFzdEl0ZW1Qb3MiLCJzdGFydCIsImN1dCIsImVuZCIsImpvaW5Gb3J3YXJkIiwiJHByZXYiLCJwcmV2Tm9kZSIsInByZXZpb3VzTGlzdEl0ZW1IYXNTdWJMaXN0Iiwiam9pbkl0ZW1CYWNrd2FyZCIsImlzQXRFbmRPZk5vZGUiLCJpc05vZGVBY3RpdmUyIiwibGlzdERlcHRoIiwiJHRvIiwiZW1wdHkiLCJzYW1lUGFyZW50IiwiZm9jdXMiLCJsaWZ0Iiwiam9pbkJhY2t3YXJkIiwiam9pbkl0ZW1Gb3J3YXJkIiwicGFyZW50T2Zmc2V0IiwicGFyZW50IiwiY2hpbGRDb3VudCIsIm5vZGVBZnRlciIsIkxpc3RLZXltYXAiLCJsaXN0VHlwZXMiLCJpdGVtTmFtZSIsIndyYXBwZXJOYW1lcyIsIkRlbGV0ZSIsImhhbmRsZWQiLCJmb3JFYWNoIiwibm9kZXMiLCJCYWNrc3BhY2UiLCJFeHRlbnNpb24yIiwibWVyZ2VBdHRyaWJ1dGVzMyIsIk5vZGUzIiwid3JhcHBpbmdJbnB1dFJ1bGUyIiwiT1JERVJFRF9MSVNUX0lURU1fUkVHRVgiLCJJTkRFTlRFRF9MSU5FX1JFR0VYIiwiY29sbGVjdE9yZGVyZWRMaXN0SXRlbXMiLCJsaW5lcyIsImxpc3RJdGVtcyIsImN1cnJlbnRMaW5lSW5kZXgiLCJjb25zdW1lZCIsImxpbmUiLCJtYXRjaCIsImluZGVudCIsIm51bWJlciIsImluZGVudExldmVsIiwiaXRlbUNvbnRlbnQiLCJuZXh0TGluZUluZGV4IiwiaXRlbUxpbmVzIiwibmV4dExpbmUiLCJuZXh0TWF0Y2giLCJ0cmltIiwicGFyc2VJbnQiLCJyYXciLCJqb2luIiwiYnVpbGROZXN0ZWRTdHJ1Y3R1cmUiLCJiYXNlSW5kZW50IiwibGV4ZXIiLCJyZXN1bHQiLCJjdXJyZW50SW5kZXgiLCJpdGVtIiwiY29udGVudExpbmVzIiwic3BsaXQiLCJtYWluVGV4dCIsImlubGluZVRva2VucyIsImJsb2NrVG9rZW5zIiwibG9va0FoZWFkSW5kZXgiLCJuZXN0ZWRJdGVtcyIsIm5leHRJbmRlbnQiLCJtaW4iLCJtYXAiLCJuZXN0ZWRJdGVtIiwibmVzdGVkTGlzdEl0ZW1zIiwicGFyc2VMaXN0SXRlbXMiLCJpdGVtVG9rZW4iLCJwYXJzZWQiLCJMaXN0SXRlbU5hbWUyIiwiVGV4dFN0eWxlTmFtZTIiLCJvcmRlcmVkTGlzdElucHV0UmVnZXgiLCJPcmRlcmVkTGlzdCIsImFkZEF0dHJpYnV0ZXMiLCJkZWZhdWx0IiwiZWxlbWVudCIsImhhc0F0dHJpYnV0ZSIsImdldEF0dHJpYnV0ZSIsImF0dHJpYnV0ZXNXaXRob3V0U3RhcnQiLCJzdGFydFZhbHVlIiwiYXR0cnMiLCJtYXJrZG93blRva2VuaXplciIsImxldmVsIiwic3JjIiwidG9rZW5pemUiLCJfdG9rZW5zIiwidG9nZ2xlT3JkZXJlZExpc3QiLCJqb2luUHJlZGljYXRlIiwibWVyZ2VBdHRyaWJ1dGVzNCIsIk5vZGU0IiwicmVuZGVyTmVzdGVkTWFya2Rvd25Db250ZW50MiIsIndyYXBwaW5nSW5wdXRSdWxlMyIsImlucHV0UmVnZXgiLCJUYXNrSXRlbSIsIm5lc3RlZCIsInRhc2tMaXN0VHlwZU5hbWUiLCJhMTF5IiwiY2hlY2tlZCIsImtlZXBPblNwbGl0IiwiZGF0YUNoZWNrZWQiLCJhdHRyaWJ1dGVzIiwicHJpb3JpdHkiLCJjcmVhdGVOb2RlIiwidGV4dCIsIm5lc3RlZFRva2VucyIsIm5lc3RlZENvbnRlbnQiLCJjaGVja2VkQ2hhciIsInByZWZpeCIsInNob3J0Y3V0cyIsImFkZE5vZGVWaWV3IiwiZ2V0UG9zIiwibGlzdEl0ZW0iLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJjaGVja2JveFdyYXBwZXIiLCJjaGVja2JveFN0eWxlciIsImNoZWNrYm94IiwidXBkYXRlQTExWSIsIl9iIiwiYXJpYUxhYmVsIiwiY2hlY2tib3hMYWJlbCIsImNhbGwiLCJ0ZXh0Q29udGVudCIsImNvbnRlbnRFZGl0YWJsZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJldmVudCIsInByZXZlbnREZWZhdWx0IiwiaXNFZGl0YWJsZSIsIm9uUmVhZE9ubHlDaGVja2VkIiwic2Nyb2xsSW50b1ZpZXciLCJjb21tYW5kIiwidHIiLCJwb3NpdGlvbiIsIm5vZGVBdCIsInNldE5vZGVNYXJrdXAiLCJlbnRyaWVzIiwia2V5IiwidmFsdWUiLCJzZXRBdHRyaWJ1dGUiLCJkYXRhc2V0IiwiYXBwZW5kIiwiZG9tIiwiY29udGVudERPTSIsInVwZGF0ZSIsInVwZGF0ZWROb2RlIiwibWVyZ2VBdHRyaWJ1dGVzNSIsIk5vZGU1IiwicGFyc2VJbmRlbnRlZEJsb2NrcyIsIlRhc2tMaXN0IiwicGFyc2VUYXNrTGlzdENvbnRlbnQiLCJuZXN0ZWRSZXN1bHQiLCJpdGVtUGF0dGVybiIsImV4dHJhY3RJdGVtRGF0YSIsIm1haW5Db250ZW50IiwidG9Mb3dlckNhc2UiLCJjcmVhdGVUb2tlbiIsImRhdGEiLCJjdXN0b21OZXN0ZWRQYXJzZXIiLCJ0b2dnbGVUYXNrTGlzdCIsIkxpc3RLaXQiLCJhZGRFeHRlbnNpb25zIiwiZXh0ZW5zaW9ucyIsImJ1bGxldExpc3QiLCJjb25maWd1cmUiLCJsaXN0S2V5bWFwIiwib3JkZXJlZExpc3QiLCJ0YXNrSXRlbSIsInRhc2tMaXN0IiwibGlzdEhlbHBlcnMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-list/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-paragraph/dist/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-paragraph/dist/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Paragraph: () => (/* binding */ Paragraph),\n/* harmony export */   \"default\": () => (/* binding */ index_default)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n// src/paragraph.ts\n\nvar Paragraph = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n    name: \"paragraph\",\n    priority: 1e3,\n    addOptions () {\n        return {\n            HTMLAttributes: {}\n        };\n    },\n    group: \"block\",\n    content: \"inline*\",\n    parseHTML () {\n        return [\n            {\n                tag: \"p\"\n            }\n        ];\n    },\n    renderHTML ({ HTMLAttributes }) {\n        return [\n            \"p\",\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes),\n            0\n        ];\n    },\n    parseMarkdown: (token, helpers)=>{\n        const tokens = token.tokens || [];\n        if (tokens.length === 1 && tokens[0].type === \"image\") {\n            return helpers.parseChildren([\n                tokens[0]\n            ]);\n        }\n        return helpers.createNode(\"paragraph\", void 0, // no attributes for paragraph\n        helpers.parseInline(tokens));\n    },\n    renderMarkdown: (node, h)=>{\n        if (!node || !Array.isArray(node.content)) {\n            return \"\";\n        }\n        return h.renderChildren(node.content);\n    },\n    addCommands () {\n        return {\n            setParagraph: ()=>({ commands })=>{\n                    return commands.setNode(this.name);\n                }\n        };\n    },\n    addKeyboardShortcuts () {\n        return {\n            \"Mod-Alt-0\": ()=>this.editor.commands.setParagraph()\n        };\n    }\n});\n// src/index.ts\nvar index_default = Paragraph;\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tcGFyYWdyYXBoL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsbUJBQW1CO0FBQ2tDO0FBQ3JELElBQUlFLFlBQVlELDhDQUFJQSxDQUFDRSxNQUFNLENBQUM7SUFDMUJDLE1BQU07SUFDTkMsVUFBVTtJQUNWQztRQUNFLE9BQU87WUFDTEMsZ0JBQWdCLENBQUM7UUFDbkI7SUFDRjtJQUNBQyxPQUFPO0lBQ1BDLFNBQVM7SUFDVEM7UUFDRSxPQUFPO1lBQUM7Z0JBQUVDLEtBQUs7WUFBSTtTQUFFO0lBQ3ZCO0lBQ0FDLFlBQVcsRUFBRUwsY0FBYyxFQUFFO1FBQzNCLE9BQU87WUFBQztZQUFLUCw2REFBZUEsQ0FBQyxJQUFJLENBQUNhLE9BQU8sQ0FBQ04sY0FBYyxFQUFFQTtZQUFpQjtTQUFFO0lBQy9FO0lBQ0FPLGVBQWUsQ0FBQ0MsT0FBT0M7UUFDckIsTUFBTUMsU0FBU0YsTUFBTUUsTUFBTSxJQUFJLEVBQUU7UUFDakMsSUFBSUEsT0FBT0MsTUFBTSxLQUFLLEtBQUtELE1BQU0sQ0FBQyxFQUFFLENBQUNFLElBQUksS0FBSyxTQUFTO1lBQ3JELE9BQU9ILFFBQVFJLGFBQWEsQ0FBQztnQkFBQ0gsTUFBTSxDQUFDLEVBQUU7YUFBQztRQUMxQztRQUNBLE9BQU9ELFFBQVFLLFVBQVUsQ0FDdkIsYUFDQSxLQUFLLEdBQ0wsOEJBQThCO1FBQzlCTCxRQUFRTSxXQUFXLENBQUNMO0lBRXhCO0lBQ0FNLGdCQUFnQixDQUFDQyxNQUFNQztRQUNyQixJQUFJLENBQUNELFFBQVEsQ0FBQ0UsTUFBTUMsT0FBTyxDQUFDSCxLQUFLZixPQUFPLEdBQUc7WUFDekMsT0FBTztRQUNUO1FBQ0EsT0FBT2dCLEVBQUVHLGNBQWMsQ0FBQ0osS0FBS2YsT0FBTztJQUN0QztJQUNBb0I7UUFDRSxPQUFPO1lBQ0xDLGNBQWMsSUFBTSxDQUFDLEVBQUVDLFFBQVEsRUFBRTtvQkFDL0IsT0FBT0EsU0FBU0MsT0FBTyxDQUFDLElBQUksQ0FBQzVCLElBQUk7Z0JBQ25DO1FBQ0Y7SUFDRjtJQUNBNkI7UUFDRSxPQUFPO1lBQ0wsYUFBYSxJQUFNLElBQUksQ0FBQ0MsTUFBTSxDQUFDSCxRQUFRLENBQUNELFlBQVk7UUFDdEQ7SUFDRjtBQUNGO0FBRUEsZUFBZTtBQUNmLElBQUlLLGdCQUFnQmpDO0FBSWxCLENBQ0YsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJhc29icGFpLXdlYi8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1wYXJhZ3JhcGgvZGlzdC9pbmRleC5qcz84YmEzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9wYXJhZ3JhcGgudHNcbmltcG9ydCB7IG1lcmdlQXR0cmlidXRlcywgTm9kZSB9IGZyb20gXCJAdGlwdGFwL2NvcmVcIjtcbnZhciBQYXJhZ3JhcGggPSBOb2RlLmNyZWF0ZSh7XG4gIG5hbWU6IFwicGFyYWdyYXBoXCIsXG4gIHByaW9yaXR5OiAxZTMsXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fVxuICAgIH07XG4gIH0sXG4gIGdyb3VwOiBcImJsb2NrXCIsXG4gIGNvbnRlbnQ6IFwiaW5saW5lKlwiLFxuICBwYXJzZUhUTUwoKSB7XG4gICAgcmV0dXJuIFt7IHRhZzogXCJwXCIgfV07XG4gIH0sXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgcmV0dXJuIFtcInBcIiwgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLCAwXTtcbiAgfSxcbiAgcGFyc2VNYXJrZG93bjogKHRva2VuLCBoZWxwZXJzKSA9PiB7XG4gICAgY29uc3QgdG9rZW5zID0gdG9rZW4udG9rZW5zIHx8IFtdO1xuICAgIGlmICh0b2tlbnMubGVuZ3RoID09PSAxICYmIHRva2Vuc1swXS50eXBlID09PSBcImltYWdlXCIpIHtcbiAgICAgIHJldHVybiBoZWxwZXJzLnBhcnNlQ2hpbGRyZW4oW3Rva2Vuc1swXV0pO1xuICAgIH1cbiAgICByZXR1cm4gaGVscGVycy5jcmVhdGVOb2RlKFxuICAgICAgXCJwYXJhZ3JhcGhcIixcbiAgICAgIHZvaWQgMCxcbiAgICAgIC8vIG5vIGF0dHJpYnV0ZXMgZm9yIHBhcmFncmFwaFxuICAgICAgaGVscGVycy5wYXJzZUlubGluZSh0b2tlbnMpXG4gICAgKTtcbiAgfSxcbiAgcmVuZGVyTWFya2Rvd246IChub2RlLCBoKSA9PiB7XG4gICAgaWYgKCFub2RlIHx8ICFBcnJheS5pc0FycmF5KG5vZGUuY29udGVudCkpIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICByZXR1cm4gaC5yZW5kZXJDaGlsZHJlbihub2RlLmNvbnRlbnQpO1xuICB9LFxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2V0UGFyYWdyYXBoOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy5zZXROb2RlKHRoaXMubmFtZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFwiTW9kLUFsdC0wXCI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnNldFBhcmFncmFwaCgpXG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHNyYy9pbmRleC50c1xudmFyIGluZGV4X2RlZmF1bHQgPSBQYXJhZ3JhcGg7XG5leHBvcnQge1xuICBQYXJhZ3JhcGgsXG4gIGluZGV4X2RlZmF1bHQgYXMgZGVmYXVsdFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJtZXJnZUF0dHJpYnV0ZXMiLCJOb2RlIiwiUGFyYWdyYXBoIiwiY3JlYXRlIiwibmFtZSIsInByaW9yaXR5IiwiYWRkT3B0aW9ucyIsIkhUTUxBdHRyaWJ1dGVzIiwiZ3JvdXAiLCJjb250ZW50IiwicGFyc2VIVE1MIiwidGFnIiwicmVuZGVySFRNTCIsIm9wdGlvbnMiLCJwYXJzZU1hcmtkb3duIiwidG9rZW4iLCJoZWxwZXJzIiwidG9rZW5zIiwibGVuZ3RoIiwidHlwZSIsInBhcnNlQ2hpbGRyZW4iLCJjcmVhdGVOb2RlIiwicGFyc2VJbmxpbmUiLCJyZW5kZXJNYXJrZG93biIsIm5vZGUiLCJoIiwiQXJyYXkiLCJpc0FycmF5IiwicmVuZGVyQ2hpbGRyZW4iLCJhZGRDb21tYW5kcyIsInNldFBhcmFncmFwaCIsImNvbW1hbmRzIiwic2V0Tm9kZSIsImFkZEtleWJvYXJkU2hvcnRjdXRzIiwiZWRpdG9yIiwiaW5kZXhfZGVmYXVsdCIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-paragraph/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-placeholder/dist/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@tiptap/extension-placeholder/dist/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Placeholder: () => (/* reexport safe */ _tiptap_extensions__WEBPACK_IMPORTED_MODULE_0__.Placeholder),\n/* harmony export */   \"default\": () => (/* binding */ index_default)\n/* harmony export */ });\n/* harmony import */ var _tiptap_extensions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/extensions */ \"(ssr)/./node_modules/@tiptap/extensions/dist/index.js\");\n// src/index.ts\n\n\nvar index_default = _tiptap_extensions__WEBPACK_IMPORTED_MODULE_0__.Placeholder;\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tcGxhY2Vob2xkZXIvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxlQUFlO0FBQ2tDO0FBQ2dCO0FBQ2pFLElBQUlFLGdCQUFnQkYsMkRBQVdBO0FBSTdCLENBQ0YsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJhc29icGFpLXdlYi8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1wbGFjZWhvbGRlci9kaXN0L2luZGV4LmpzPzIzYTEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2luZGV4LnRzXG5pbXBvcnQgeyBQbGFjZWhvbGRlciB9IGZyb20gXCJAdGlwdGFwL2V4dGVuc2lvbnNcIjtcbmltcG9ydCB7IFBsYWNlaG9sZGVyIGFzIFBsYWNlaG9sZGVyMiB9IGZyb20gXCJAdGlwdGFwL2V4dGVuc2lvbnNcIjtcbnZhciBpbmRleF9kZWZhdWx0ID0gUGxhY2Vob2xkZXI7XG5leHBvcnQge1xuICBQbGFjZWhvbGRlcjIgYXMgUGxhY2Vob2xkZXIsXG4gIGluZGV4X2RlZmF1bHQgYXMgZGVmYXVsdFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJQbGFjZWhvbGRlciIsIlBsYWNlaG9sZGVyMiIsImluZGV4X2RlZmF1bHQiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-placeholder/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-strike/dist/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@tiptap/extension-strike/dist/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Strike: () => (/* binding */ Strike),\n/* harmony export */   \"default\": () => (/* binding */ index_default),\n/* harmony export */   inputRegex: () => (/* binding */ inputRegex),\n/* harmony export */   pasteRegex: () => (/* binding */ pasteRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n// src/strike.ts\n\nvar inputRegex = /(?:^|\\s)(~~(?!\\s+~~)((?:[^~]+))~~(?!\\s+~~))$/;\nvar pasteRegex = /(?:^|\\s)(~~(?!\\s+~~)((?:[^~]+))~~(?!\\s+~~))/g;\nvar Strike = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Mark.create({\n    name: \"strike\",\n    addOptions () {\n        return {\n            HTMLAttributes: {}\n        };\n    },\n    parseHTML () {\n        return [\n            {\n                tag: \"s\"\n            },\n            {\n                tag: \"del\"\n            },\n            {\n                tag: \"strike\"\n            },\n            {\n                style: \"text-decoration\",\n                consuming: false,\n                getAttrs: (style)=>style.includes(\"line-through\") ? {} : false\n            }\n        ];\n    },\n    renderHTML ({ HTMLAttributes }) {\n        return [\n            \"s\",\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes),\n            0\n        ];\n    },\n    markdownTokenName: \"del\",\n    parseMarkdown: (token, helpers)=>{\n        return helpers.applyMark(\"strike\", helpers.parseInline(token.tokens || []));\n    },\n    renderMarkdown: (node, h)=>{\n        return `~~${h.renderChildren(node)}~~`;\n    },\n    addCommands () {\n        return {\n            setStrike: ()=>({ commands })=>{\n                    return commands.setMark(this.name);\n                },\n            toggleStrike: ()=>({ commands })=>{\n                    return commands.toggleMark(this.name);\n                },\n            unsetStrike: ()=>({ commands })=>{\n                    return commands.unsetMark(this.name);\n                }\n        };\n    },\n    addKeyboardShortcuts () {\n        return {\n            \"Mod-Shift-s\": ()=>this.editor.commands.toggleStrike()\n        };\n    },\n    addInputRules () {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({\n                find: inputRegex,\n                type: this.type\n            })\n        ];\n    },\n    addPasteRules () {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({\n                find: pasteRegex,\n                type: this.type\n            })\n        ];\n    }\n});\n// src/index.ts\nvar index_default = Strike;\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tc3RyaWtlL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQSxnQkFBZ0I7QUFDbUU7QUFDbkYsSUFBSUksYUFBYTtBQUNqQixJQUFJQyxhQUFhO0FBQ2pCLElBQUlDLFNBQVNOLDhDQUFJQSxDQUFDTyxNQUFNLENBQUM7SUFDdkJDLE1BQU07SUFDTkM7UUFDRSxPQUFPO1lBQ0xDLGdCQUFnQixDQUFDO1FBQ25CO0lBQ0Y7SUFDQUM7UUFDRSxPQUFPO1lBQ0w7Z0JBQ0VDLEtBQUs7WUFDUDtZQUNBO2dCQUNFQSxLQUFLO1lBQ1A7WUFDQTtnQkFDRUEsS0FBSztZQUNQO1lBQ0E7Z0JBQ0VDLE9BQU87Z0JBQ1BDLFdBQVc7Z0JBQ1hDLFVBQVUsQ0FBQ0YsUUFBVUEsTUFBTUcsUUFBUSxDQUFDLGtCQUFrQixDQUFDLElBQUk7WUFDN0Q7U0FDRDtJQUNIO0lBQ0FDLFlBQVcsRUFBRVAsY0FBYyxFQUFFO1FBQzNCLE9BQU87WUFBQztZQUFLUCw2REFBZUEsQ0FBQyxJQUFJLENBQUNlLE9BQU8sQ0FBQ1IsY0FBYyxFQUFFQTtZQUFpQjtTQUFFO0lBQy9FO0lBQ0FTLG1CQUFtQjtJQUNuQkMsZUFBZSxDQUFDQyxPQUFPQztRQUNyQixPQUFPQSxRQUFRQyxTQUFTLENBQUMsVUFBVUQsUUFBUUUsV0FBVyxDQUFDSCxNQUFNSSxNQUFNLElBQUksRUFBRTtJQUMzRTtJQUNBQyxnQkFBZ0IsQ0FBQ0MsTUFBTUM7UUFDckIsT0FBTyxDQUFDLEVBQUUsRUFBRUEsRUFBRUMsY0FBYyxDQUFDRixNQUFNLEVBQUUsQ0FBQztJQUN4QztJQUNBRztRQUNFLE9BQU87WUFDTEMsV0FBVyxJQUFNLENBQUMsRUFBRUMsUUFBUSxFQUFFO29CQUM1QixPQUFPQSxTQUFTQyxPQUFPLENBQUMsSUFBSSxDQUFDekIsSUFBSTtnQkFDbkM7WUFDQTBCLGNBQWMsSUFBTSxDQUFDLEVBQUVGLFFBQVEsRUFBRTtvQkFDL0IsT0FBT0EsU0FBU0csVUFBVSxDQUFDLElBQUksQ0FBQzNCLElBQUk7Z0JBQ3RDO1lBQ0E0QixhQUFhLElBQU0sQ0FBQyxFQUFFSixRQUFRLEVBQUU7b0JBQzlCLE9BQU9BLFNBQVNLLFNBQVMsQ0FBQyxJQUFJLENBQUM3QixJQUFJO2dCQUNyQztRQUNGO0lBQ0Y7SUFDQThCO1FBQ0UsT0FBTztZQUNMLGVBQWUsSUFBTSxJQUFJLENBQUNDLE1BQU0sQ0FBQ1AsUUFBUSxDQUFDRSxZQUFZO1FBQ3hEO0lBQ0Y7SUFDQU07UUFDRSxPQUFPO1lBQ0x2QywyREFBYUEsQ0FBQztnQkFDWndDLE1BQU1yQztnQkFDTnNDLE1BQU0sSUFBSSxDQUFDQSxJQUFJO1lBQ2pCO1NBQ0Q7SUFDSDtJQUNBQztRQUNFLE9BQU87WUFDTHpDLDJEQUFhQSxDQUFDO2dCQUNadUMsTUFBTXBDO2dCQUNOcUMsTUFBTSxJQUFJLENBQUNBLElBQUk7WUFDakI7U0FDRDtJQUNIO0FBQ0Y7QUFFQSxlQUFlO0FBQ2YsSUFBSUUsZ0JBQWdCdEM7QUFNbEIsQ0FDRixpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcmFzb2JwYWktd2ViLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLXN0cmlrZS9kaXN0L2luZGV4LmpzPzhlNDAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL3N0cmlrZS50c1xuaW1wb3J0IHsgTWFyaywgbWFya0lucHV0UnVsZSwgbWFya1Bhc3RlUnVsZSwgbWVyZ2VBdHRyaWJ1dGVzIH0gZnJvbSBcIkB0aXB0YXAvY29yZVwiO1xudmFyIGlucHV0UmVnZXggPSAvKD86XnxcXHMpKH5+KD8hXFxzK35+KSgoPzpbXn5dKykpfn4oPyFcXHMrfn4pKSQvO1xudmFyIHBhc3RlUmVnZXggPSAvKD86XnxcXHMpKH5+KD8hXFxzK35+KSgoPzpbXn5dKykpfn4oPyFcXHMrfn4pKS9nO1xudmFyIFN0cmlrZSA9IE1hcmsuY3JlYXRlKHtcbiAgbmFtZTogXCJzdHJpa2VcIixcbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9XG4gICAgfTtcbiAgfSxcbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIHRhZzogXCJzXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHRhZzogXCJkZWxcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgdGFnOiBcInN0cmlrZVwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzdHlsZTogXCJ0ZXh0LWRlY29yYXRpb25cIixcbiAgICAgICAgY29uc3VtaW5nOiBmYWxzZSxcbiAgICAgICAgZ2V0QXR0cnM6IChzdHlsZSkgPT4gc3R5bGUuaW5jbHVkZXMoXCJsaW5lLXRocm91Z2hcIikgPyB7fSA6IGZhbHNlXG4gICAgICB9XG4gICAgXTtcbiAgfSxcbiAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICByZXR1cm4gW1wic1wiLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdO1xuICB9LFxuICBtYXJrZG93blRva2VuTmFtZTogXCJkZWxcIixcbiAgcGFyc2VNYXJrZG93bjogKHRva2VuLCBoZWxwZXJzKSA9PiB7XG4gICAgcmV0dXJuIGhlbHBlcnMuYXBwbHlNYXJrKFwic3RyaWtlXCIsIGhlbHBlcnMucGFyc2VJbmxpbmUodG9rZW4udG9rZW5zIHx8IFtdKSk7XG4gIH0sXG4gIHJlbmRlck1hcmtkb3duOiAobm9kZSwgaCkgPT4ge1xuICAgIHJldHVybiBgfn4ke2gucmVuZGVyQ2hpbGRyZW4obm9kZSl9fn5gO1xuICB9LFxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2V0U3RyaWtlOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy5zZXRNYXJrKHRoaXMubmFtZSk7XG4gICAgICB9LFxuICAgICAgdG9nZ2xlU3RyaWtlOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy50b2dnbGVNYXJrKHRoaXMubmFtZSk7XG4gICAgICB9LFxuICAgICAgdW5zZXRTdHJpa2U6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnVuc2V0TWFyayh0aGlzLm5hbWUpO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBcIk1vZC1TaGlmdC1zXCI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZVN0cmlrZSgpXG4gICAgfTtcbiAgfSxcbiAgYWRkSW5wdXRSdWxlcygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgbWFya0lucHV0UnVsZSh7XG4gICAgICAgIGZpbmQ6IGlucHV0UmVnZXgsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZVxuICAgICAgfSlcbiAgICBdO1xuICB9LFxuICBhZGRQYXN0ZVJ1bGVzKCkge1xuICAgIHJldHVybiBbXG4gICAgICBtYXJrUGFzdGVSdWxlKHtcbiAgICAgICAgZmluZDogcGFzdGVSZWdleCxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlXG4gICAgICB9KVxuICAgIF07XG4gIH1cbn0pO1xuXG4vLyBzcmMvaW5kZXgudHNcbnZhciBpbmRleF9kZWZhdWx0ID0gU3RyaWtlO1xuZXhwb3J0IHtcbiAgU3RyaWtlLFxuICBpbmRleF9kZWZhdWx0IGFzIGRlZmF1bHQsXG4gIGlucHV0UmVnZXgsXG4gIHBhc3RlUmVnZXhcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsiTWFyayIsIm1hcmtJbnB1dFJ1bGUiLCJtYXJrUGFzdGVSdWxlIiwibWVyZ2VBdHRyaWJ1dGVzIiwiaW5wdXRSZWdleCIsInBhc3RlUmVnZXgiLCJTdHJpa2UiLCJjcmVhdGUiLCJuYW1lIiwiYWRkT3B0aW9ucyIsIkhUTUxBdHRyaWJ1dGVzIiwicGFyc2VIVE1MIiwidGFnIiwic3R5bGUiLCJjb25zdW1pbmciLCJnZXRBdHRycyIsImluY2x1ZGVzIiwicmVuZGVySFRNTCIsIm9wdGlvbnMiLCJtYXJrZG93blRva2VuTmFtZSIsInBhcnNlTWFya2Rvd24iLCJ0b2tlbiIsImhlbHBlcnMiLCJhcHBseU1hcmsiLCJwYXJzZUlubGluZSIsInRva2VucyIsInJlbmRlck1hcmtkb3duIiwibm9kZSIsImgiLCJyZW5kZXJDaGlsZHJlbiIsImFkZENvbW1hbmRzIiwic2V0U3RyaWtlIiwiY29tbWFuZHMiLCJzZXRNYXJrIiwidG9nZ2xlU3RyaWtlIiwidG9nZ2xlTWFyayIsInVuc2V0U3RyaWtlIiwidW5zZXRNYXJrIiwiYWRkS2V5Ym9hcmRTaG9ydGN1dHMiLCJlZGl0b3IiLCJhZGRJbnB1dFJ1bGVzIiwiZmluZCIsInR5cGUiLCJhZGRQYXN0ZVJ1bGVzIiwiaW5kZXhfZGVmYXVsdCIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-strike/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-text-align/dist/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-text-align/dist/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TextAlign: () => (/* binding */ TextAlign),\n/* harmony export */   \"default\": () => (/* binding */ index_default)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n// src/text-align.ts\n\nvar TextAlign = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Extension.create({\n    name: \"textAlign\",\n    addOptions () {\n        return {\n            types: [],\n            alignments: [\n                \"left\",\n                \"center\",\n                \"right\",\n                \"justify\"\n            ],\n            defaultAlignment: null\n        };\n    },\n    addGlobalAttributes () {\n        return [\n            {\n                types: this.options.types,\n                attributes: {\n                    textAlign: {\n                        default: this.options.defaultAlignment,\n                        parseHTML: (element)=>{\n                            const alignment = element.style.textAlign;\n                            return this.options.alignments.includes(alignment) ? alignment : this.options.defaultAlignment;\n                        },\n                        renderHTML: (attributes)=>{\n                            if (!attributes.textAlign) {\n                                return {};\n                            }\n                            return {\n                                style: `text-align: ${attributes.textAlign}`\n                            };\n                        }\n                    }\n                }\n            }\n        ];\n    },\n    addCommands () {\n        return {\n            setTextAlign: (alignment)=>({ commands })=>{\n                    if (!this.options.alignments.includes(alignment)) {\n                        return false;\n                    }\n                    return this.options.types.map((type)=>commands.updateAttributes(type, {\n                            textAlign: alignment\n                        })).some((response)=>response);\n                },\n            unsetTextAlign: ()=>({ commands })=>{\n                    return this.options.types.map((type)=>commands.resetAttributes(type, \"textAlign\")).some((response)=>response);\n                },\n            toggleTextAlign: (alignment)=>({ editor, commands })=>{\n                    if (!this.options.alignments.includes(alignment)) {\n                        return false;\n                    }\n                    if (editor.isActive({\n                        textAlign: alignment\n                    })) {\n                        return commands.unsetTextAlign();\n                    }\n                    return commands.setTextAlign(alignment);\n                }\n        };\n    },\n    addKeyboardShortcuts () {\n        return {\n            \"Mod-Shift-l\": ()=>this.editor.commands.setTextAlign(\"left\"),\n            \"Mod-Shift-e\": ()=>this.editor.commands.setTextAlign(\"center\"),\n            \"Mod-Shift-r\": ()=>this.editor.commands.setTextAlign(\"right\"),\n            \"Mod-Shift-j\": ()=>this.editor.commands.setTextAlign(\"justify\")\n        };\n    }\n});\n// src/index.ts\nvar index_default = TextAlign;\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tdGV4dC1hbGlnbi9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLG9CQUFvQjtBQUNxQjtBQUN6QyxJQUFJQyxZQUFZRCxtREFBU0EsQ0FBQ0UsTUFBTSxDQUFDO0lBQy9CQyxNQUFNO0lBQ05DO1FBQ0UsT0FBTztZQUNMQyxPQUFPLEVBQUU7WUFDVEMsWUFBWTtnQkFBQztnQkFBUTtnQkFBVTtnQkFBUzthQUFVO1lBQ2xEQyxrQkFBa0I7UUFDcEI7SUFDRjtJQUNBQztRQUNFLE9BQU87WUFDTDtnQkFDRUgsT0FBTyxJQUFJLENBQUNJLE9BQU8sQ0FBQ0osS0FBSztnQkFDekJLLFlBQVk7b0JBQ1ZDLFdBQVc7d0JBQ1RDLFNBQVMsSUFBSSxDQUFDSCxPQUFPLENBQUNGLGdCQUFnQjt3QkFDdENNLFdBQVcsQ0FBQ0M7NEJBQ1YsTUFBTUMsWUFBWUQsUUFBUUUsS0FBSyxDQUFDTCxTQUFTOzRCQUN6QyxPQUFPLElBQUksQ0FBQ0YsT0FBTyxDQUFDSCxVQUFVLENBQUNXLFFBQVEsQ0FBQ0YsYUFBYUEsWUFBWSxJQUFJLENBQUNOLE9BQU8sQ0FBQ0YsZ0JBQWdCO3dCQUNoRzt3QkFDQVcsWUFBWSxDQUFDUjs0QkFDWCxJQUFJLENBQUNBLFdBQVdDLFNBQVMsRUFBRTtnQ0FDekIsT0FBTyxDQUFDOzRCQUNWOzRCQUNBLE9BQU87Z0NBQUVLLE9BQU8sQ0FBQyxZQUFZLEVBQUVOLFdBQVdDLFNBQVMsQ0FBQyxDQUFDOzRCQUFDO3dCQUN4RDtvQkFDRjtnQkFDRjtZQUNGO1NBQ0Q7SUFDSDtJQUNBUTtRQUNFLE9BQU87WUFDTEMsY0FBYyxDQUFDTCxZQUFjLENBQUMsRUFBRU0sUUFBUSxFQUFFO29CQUN4QyxJQUFJLENBQUMsSUFBSSxDQUFDWixPQUFPLENBQUNILFVBQVUsQ0FBQ1csUUFBUSxDQUFDRixZQUFZO3dCQUNoRCxPQUFPO29CQUNUO29CQUNBLE9BQU8sSUFBSSxDQUFDTixPQUFPLENBQUNKLEtBQUssQ0FBQ2lCLEdBQUcsQ0FBQyxDQUFDQyxPQUFTRixTQUFTRyxnQkFBZ0IsQ0FBQ0QsTUFBTTs0QkFBRVosV0FBV0k7d0JBQVUsSUFBSVUsSUFBSSxDQUFDLENBQUNDLFdBQWFBO2dCQUN4SDtZQUNBQyxnQkFBZ0IsSUFBTSxDQUFDLEVBQUVOLFFBQVEsRUFBRTtvQkFDakMsT0FBTyxJQUFJLENBQUNaLE9BQU8sQ0FBQ0osS0FBSyxDQUFDaUIsR0FBRyxDQUFDLENBQUNDLE9BQVNGLFNBQVNPLGVBQWUsQ0FBQ0wsTUFBTSxjQUFjRSxJQUFJLENBQUMsQ0FBQ0MsV0FBYUE7Z0JBQzFHO1lBQ0FHLGlCQUFpQixDQUFDZCxZQUFjLENBQUMsRUFBRWUsTUFBTSxFQUFFVCxRQUFRLEVBQUU7b0JBQ25ELElBQUksQ0FBQyxJQUFJLENBQUNaLE9BQU8sQ0FBQ0gsVUFBVSxDQUFDVyxRQUFRLENBQUNGLFlBQVk7d0JBQ2hELE9BQU87b0JBQ1Q7b0JBQ0EsSUFBSWUsT0FBT0MsUUFBUSxDQUFDO3dCQUFFcEIsV0FBV0k7b0JBQVUsSUFBSTt3QkFDN0MsT0FBT00sU0FBU00sY0FBYztvQkFDaEM7b0JBQ0EsT0FBT04sU0FBU0QsWUFBWSxDQUFDTDtnQkFDL0I7UUFDRjtJQUNGO0lBQ0FpQjtRQUNFLE9BQU87WUFDTCxlQUFlLElBQU0sSUFBSSxDQUFDRixNQUFNLENBQUNULFFBQVEsQ0FBQ0QsWUFBWSxDQUFDO1lBQ3ZELGVBQWUsSUFBTSxJQUFJLENBQUNVLE1BQU0sQ0FBQ1QsUUFBUSxDQUFDRCxZQUFZLENBQUM7WUFDdkQsZUFBZSxJQUFNLElBQUksQ0FBQ1UsTUFBTSxDQUFDVCxRQUFRLENBQUNELFlBQVksQ0FBQztZQUN2RCxlQUFlLElBQU0sSUFBSSxDQUFDVSxNQUFNLENBQUNULFFBQVEsQ0FBQ0QsWUFBWSxDQUFDO1FBQ3pEO0lBQ0Y7QUFDRjtBQUVBLGVBQWU7QUFDZixJQUFJYSxnQkFBZ0JoQztBQUlsQixDQUNGLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3ByYXNvYnBhaS13ZWIvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tdGV4dC1hbGlnbi9kaXN0L2luZGV4LmpzPzk5MzkiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL3RleHQtYWxpZ24udHNcbmltcG9ydCB7IEV4dGVuc2lvbiB9IGZyb20gXCJAdGlwdGFwL2NvcmVcIjtcbnZhciBUZXh0QWxpZ24gPSBFeHRlbnNpb24uY3JlYXRlKHtcbiAgbmFtZTogXCJ0ZXh0QWxpZ25cIixcbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZXM6IFtdLFxuICAgICAgYWxpZ25tZW50czogW1wibGVmdFwiLCBcImNlbnRlclwiLCBcInJpZ2h0XCIsIFwianVzdGlmeVwiXSxcbiAgICAgIGRlZmF1bHRBbGlnbm1lbnQ6IG51bGxcbiAgICB9O1xuICB9LFxuICBhZGRHbG9iYWxBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIHR5cGVzOiB0aGlzLm9wdGlvbnMudHlwZXMsXG4gICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICB0ZXh0QWxpZ246IHtcbiAgICAgICAgICAgIGRlZmF1bHQ6IHRoaXMub3B0aW9ucy5kZWZhdWx0QWxpZ25tZW50LFxuICAgICAgICAgICAgcGFyc2VIVE1MOiAoZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBhbGlnbm1lbnQgPSBlbGVtZW50LnN0eWxlLnRleHRBbGlnbjtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5hbGlnbm1lbnRzLmluY2x1ZGVzKGFsaWdubWVudCkgPyBhbGlnbm1lbnQgOiB0aGlzLm9wdGlvbnMuZGVmYXVsdEFsaWdubWVudDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZW5kZXJIVE1MOiAoYXR0cmlidXRlcykgPT4ge1xuICAgICAgICAgICAgICBpZiAoIWF0dHJpYnV0ZXMudGV4dEFsaWduKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiB7IHN0eWxlOiBgdGV4dC1hbGlnbjogJHthdHRyaWJ1dGVzLnRleHRBbGlnbn1gIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgXTtcbiAgfSxcbiAgYWRkQ29tbWFuZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNldFRleHRBbGlnbjogKGFsaWdubWVudCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5hbGlnbm1lbnRzLmluY2x1ZGVzKGFsaWdubWVudCkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy50eXBlcy5tYXAoKHR5cGUpID0+IGNvbW1hbmRzLnVwZGF0ZUF0dHJpYnV0ZXModHlwZSwgeyB0ZXh0QWxpZ246IGFsaWdubWVudCB9KSkuc29tZSgocmVzcG9uc2UpID0+IHJlc3BvbnNlKTtcbiAgICAgIH0sXG4gICAgICB1bnNldFRleHRBbGlnbjogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnR5cGVzLm1hcCgodHlwZSkgPT4gY29tbWFuZHMucmVzZXRBdHRyaWJ1dGVzKHR5cGUsIFwidGV4dEFsaWduXCIpKS5zb21lKChyZXNwb25zZSkgPT4gcmVzcG9uc2UpO1xuICAgICAgfSxcbiAgICAgIHRvZ2dsZVRleHRBbGlnbjogKGFsaWdubWVudCkgPT4gKHsgZWRpdG9yLCBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmFsaWdubWVudHMuaW5jbHVkZXMoYWxpZ25tZW50KSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWRpdG9yLmlzQWN0aXZlKHsgdGV4dEFsaWduOiBhbGlnbm1lbnQgfSkpIHtcbiAgICAgICAgICByZXR1cm4gY29tbWFuZHMudW5zZXRUZXh0QWxpZ24oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tbWFuZHMuc2V0VGV4dEFsaWduKGFsaWdubWVudCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFwiTW9kLVNoaWZ0LWxcIjogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuc2V0VGV4dEFsaWduKFwibGVmdFwiKSxcbiAgICAgIFwiTW9kLVNoaWZ0LWVcIjogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuc2V0VGV4dEFsaWduKFwiY2VudGVyXCIpLFxuICAgICAgXCJNb2QtU2hpZnQtclwiOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5zZXRUZXh0QWxpZ24oXCJyaWdodFwiKSxcbiAgICAgIFwiTW9kLVNoaWZ0LWpcIjogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuc2V0VGV4dEFsaWduKFwianVzdGlmeVwiKVxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBzcmMvaW5kZXgudHNcbnZhciBpbmRleF9kZWZhdWx0ID0gVGV4dEFsaWduO1xuZXhwb3J0IHtcbiAgVGV4dEFsaWduLFxuICBpbmRleF9kZWZhdWx0IGFzIGRlZmF1bHRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsiRXh0ZW5zaW9uIiwiVGV4dEFsaWduIiwiY3JlYXRlIiwibmFtZSIsImFkZE9wdGlvbnMiLCJ0eXBlcyIsImFsaWdubWVudHMiLCJkZWZhdWx0QWxpZ25tZW50IiwiYWRkR2xvYmFsQXR0cmlidXRlcyIsIm9wdGlvbnMiLCJhdHRyaWJ1dGVzIiwidGV4dEFsaWduIiwiZGVmYXVsdCIsInBhcnNlSFRNTCIsImVsZW1lbnQiLCJhbGlnbm1lbnQiLCJzdHlsZSIsImluY2x1ZGVzIiwicmVuZGVySFRNTCIsImFkZENvbW1hbmRzIiwic2V0VGV4dEFsaWduIiwiY29tbWFuZHMiLCJtYXAiLCJ0eXBlIiwidXBkYXRlQXR0cmlidXRlcyIsInNvbWUiLCJyZXNwb25zZSIsInVuc2V0VGV4dEFsaWduIiwicmVzZXRBdHRyaWJ1dGVzIiwidG9nZ2xlVGV4dEFsaWduIiwiZWRpdG9yIiwiaXNBY3RpdmUiLCJhZGRLZXlib2FyZFNob3J0Y3V0cyIsImluZGV4X2RlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-text-align/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-text/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@tiptap/extension-text/dist/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Text: () => (/* binding */ Text),\n/* harmony export */   \"default\": () => (/* binding */ index_default)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n// src/text.ts\n\nvar Text = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n    name: \"text\",\n    group: \"inline\",\n    parseMarkdown: (token)=>{\n        return {\n            type: \"text\",\n            text: token.text || \"\"\n        };\n    },\n    renderMarkdown: (node)=>node.text || \"\"\n});\n// src/index.ts\nvar index_default = Text;\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tdGV4dC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLGNBQWM7QUFDc0I7QUFDcEMsSUFBSUMsT0FBT0QsOENBQUlBLENBQUNFLE1BQU0sQ0FBQztJQUNyQkMsTUFBTTtJQUNOQyxPQUFPO0lBQ1BDLGVBQWUsQ0FBQ0M7UUFDZCxPQUFPO1lBQ0xDLE1BQU07WUFDTkMsTUFBTUYsTUFBTUUsSUFBSSxJQUFJO1FBQ3RCO0lBQ0Y7SUFDQUMsZ0JBQWdCLENBQUNDLE9BQVNBLEtBQUtGLElBQUksSUFBSTtBQUN6QztBQUVBLGVBQWU7QUFDZixJQUFJRyxnQkFBZ0JWO0FBSWxCLENBQ0YsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJhc29icGFpLXdlYi8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi10ZXh0L2Rpc3QvaW5kZXguanM/OWU0NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvdGV4dC50c1xuaW1wb3J0IHsgTm9kZSB9IGZyb20gXCJAdGlwdGFwL2NvcmVcIjtcbnZhciBUZXh0ID0gTm9kZS5jcmVhdGUoe1xuICBuYW1lOiBcInRleHRcIixcbiAgZ3JvdXA6IFwiaW5saW5lXCIsXG4gIHBhcnNlTWFya2Rvd246ICh0b2tlbikgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgIHRleHQ6IHRva2VuLnRleHQgfHwgXCJcIlxuICAgIH07XG4gIH0sXG4gIHJlbmRlck1hcmtkb3duOiAobm9kZSkgPT4gbm9kZS50ZXh0IHx8IFwiXCJcbn0pO1xuXG4vLyBzcmMvaW5kZXgudHNcbnZhciBpbmRleF9kZWZhdWx0ID0gVGV4dDtcbmV4cG9ydCB7XG4gIFRleHQsXG4gIGluZGV4X2RlZmF1bHQgYXMgZGVmYXVsdFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJOb2RlIiwiVGV4dCIsImNyZWF0ZSIsIm5hbWUiLCJncm91cCIsInBhcnNlTWFya2Rvd24iLCJ0b2tlbiIsInR5cGUiLCJ0ZXh0IiwicmVuZGVyTWFya2Rvd24iLCJub2RlIiwiaW5kZXhfZGVmYXVsdCIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-text/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-underline/dist/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-underline/dist/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Underline: () => (/* binding */ Underline),\n/* harmony export */   \"default\": () => (/* binding */ index_default)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n// src/underline.ts\n\nvar Underline = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Mark.create({\n    name: \"underline\",\n    addOptions () {\n        return {\n            HTMLAttributes: {}\n        };\n    },\n    parseHTML () {\n        return [\n            {\n                tag: \"u\"\n            },\n            {\n                style: \"text-decoration\",\n                consuming: false,\n                getAttrs: (style)=>style.includes(\"underline\") ? {} : false\n            }\n        ];\n    },\n    renderHTML ({ HTMLAttributes }) {\n        return [\n            \"u\",\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes),\n            0\n        ];\n    },\n    parseMarkdown (token, helpers) {\n        return helpers.applyMark(this.name || \"underline\", helpers.parseInline(token.tokens || []));\n    },\n    renderMarkdown (node, helpers) {\n        return `++${helpers.renderChildren(node)}++`;\n    },\n    markdownTokenizer: {\n        name: \"underline\",\n        level: \"inline\",\n        start (src) {\n            return src.indexOf(\"++\");\n        },\n        tokenize (src, _tokens, lexer) {\n            const rule = /^(\\+\\+)([\\s\\S]+?)(\\+\\+)/;\n            const match = rule.exec(src);\n            if (!match) {\n                return void 0;\n            }\n            const innerContent = match[2].trim();\n            return {\n                type: \"underline\",\n                raw: match[0],\n                text: innerContent,\n                tokens: lexer.inlineTokens(innerContent)\n            };\n        }\n    },\n    addCommands () {\n        return {\n            setUnderline: ()=>({ commands })=>{\n                    return commands.setMark(this.name);\n                },\n            toggleUnderline: ()=>({ commands })=>{\n                    return commands.toggleMark(this.name);\n                },\n            unsetUnderline: ()=>({ commands })=>{\n                    return commands.unsetMark(this.name);\n                }\n        };\n    },\n    addKeyboardShortcuts () {\n        return {\n            \"Mod-u\": ()=>this.editor.commands.toggleUnderline(),\n            \"Mod-U\": ()=>this.editor.commands.toggleUnderline()\n        };\n    }\n});\n// src/index.ts\nvar index_default = Underline;\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tdW5kZXJsaW5lL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsbUJBQW1CO0FBQ2tDO0FBQ3JELElBQUlFLFlBQVlGLDhDQUFJQSxDQUFDRyxNQUFNLENBQUM7SUFDMUJDLE1BQU07SUFDTkM7UUFDRSxPQUFPO1lBQ0xDLGdCQUFnQixDQUFDO1FBQ25CO0lBQ0Y7SUFDQUM7UUFDRSxPQUFPO1lBQ0w7Z0JBQ0VDLEtBQUs7WUFDUDtZQUNBO2dCQUNFQyxPQUFPO2dCQUNQQyxXQUFXO2dCQUNYQyxVQUFVLENBQUNGLFFBQVVBLE1BQU1HLFFBQVEsQ0FBQyxlQUFlLENBQUMsSUFBSTtZQUMxRDtTQUNEO0lBQ0g7SUFDQUMsWUFBVyxFQUFFUCxjQUFjLEVBQUU7UUFDM0IsT0FBTztZQUFDO1lBQUtMLDZEQUFlQSxDQUFDLElBQUksQ0FBQ2EsT0FBTyxDQUFDUixjQUFjLEVBQUVBO1lBQWlCO1NBQUU7SUFDL0U7SUFDQVMsZUFBY0MsS0FBSyxFQUFFQyxPQUFPO1FBQzFCLE9BQU9BLFFBQVFDLFNBQVMsQ0FBQyxJQUFJLENBQUNkLElBQUksSUFBSSxhQUFhYSxRQUFRRSxXQUFXLENBQUNILE1BQU1JLE1BQU0sSUFBSSxFQUFFO0lBQzNGO0lBQ0FDLGdCQUFlQyxJQUFJLEVBQUVMLE9BQU87UUFDMUIsT0FBTyxDQUFDLEVBQUUsRUFBRUEsUUFBUU0sY0FBYyxDQUFDRCxNQUFNLEVBQUUsQ0FBQztJQUM5QztJQUNBRSxtQkFBbUI7UUFDakJwQixNQUFNO1FBQ05xQixPQUFPO1FBQ1BDLE9BQU1DLEdBQUc7WUFDUCxPQUFPQSxJQUFJQyxPQUFPLENBQUM7UUFDckI7UUFDQUMsVUFBU0YsR0FBRyxFQUFFRyxPQUFPLEVBQUVDLEtBQUs7WUFDMUIsTUFBTUMsT0FBTztZQUNiLE1BQU1DLFFBQVFELEtBQUtFLElBQUksQ0FBQ1A7WUFDeEIsSUFBSSxDQUFDTSxPQUFPO2dCQUNWLE9BQU8sS0FBSztZQUNkO1lBQ0EsTUFBTUUsZUFBZUYsS0FBSyxDQUFDLEVBQUUsQ0FBQ0csSUFBSTtZQUNsQyxPQUFPO2dCQUNMQyxNQUFNO2dCQUNOQyxLQUFLTCxLQUFLLENBQUMsRUFBRTtnQkFDYk0sTUFBTUo7Z0JBQ05mLFFBQVFXLE1BQU1TLFlBQVksQ0FBQ0w7WUFDN0I7UUFDRjtJQUNGO0lBQ0FNO1FBQ0UsT0FBTztZQUNMQyxjQUFjLElBQU0sQ0FBQyxFQUFFQyxRQUFRLEVBQUU7b0JBQy9CLE9BQU9BLFNBQVNDLE9BQU8sQ0FBQyxJQUFJLENBQUN4QyxJQUFJO2dCQUNuQztZQUNBeUMsaUJBQWlCLElBQU0sQ0FBQyxFQUFFRixRQUFRLEVBQUU7b0JBQ2xDLE9BQU9BLFNBQVNHLFVBQVUsQ0FBQyxJQUFJLENBQUMxQyxJQUFJO2dCQUN0QztZQUNBMkMsZ0JBQWdCLElBQU0sQ0FBQyxFQUFFSixRQUFRLEVBQUU7b0JBQ2pDLE9BQU9BLFNBQVNLLFNBQVMsQ0FBQyxJQUFJLENBQUM1QyxJQUFJO2dCQUNyQztRQUNGO0lBQ0Y7SUFDQTZDO1FBQ0UsT0FBTztZQUNMLFNBQVMsSUFBTSxJQUFJLENBQUNDLE1BQU0sQ0FBQ1AsUUFBUSxDQUFDRSxlQUFlO1lBQ25ELFNBQVMsSUFBTSxJQUFJLENBQUNLLE1BQU0sQ0FBQ1AsUUFBUSxDQUFDRSxlQUFlO1FBQ3JEO0lBQ0Y7QUFDRjtBQUVBLGVBQWU7QUFDZixJQUFJTSxnQkFBZ0JqRDtBQUlsQixDQUNGLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3ByYXNvYnBhaS13ZWIvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tdW5kZXJsaW5lL2Rpc3QvaW5kZXguanM/MzY1MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvdW5kZXJsaW5lLnRzXG5pbXBvcnQgeyBNYXJrLCBtZXJnZUF0dHJpYnV0ZXMgfSBmcm9tIFwiQHRpcHRhcC9jb3JlXCI7XG52YXIgVW5kZXJsaW5lID0gTWFyay5jcmVhdGUoe1xuICBuYW1lOiBcInVuZGVybGluZVwiLFxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBIVE1MQXR0cmlidXRlczoge31cbiAgICB9O1xuICB9LFxuICBwYXJzZUhUTUwoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgdGFnOiBcInVcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgc3R5bGU6IFwidGV4dC1kZWNvcmF0aW9uXCIsXG4gICAgICAgIGNvbnN1bWluZzogZmFsc2UsXG4gICAgICAgIGdldEF0dHJzOiAoc3R5bGUpID0+IHN0eWxlLmluY2x1ZGVzKFwidW5kZXJsaW5lXCIpID8ge30gOiBmYWxzZVxuICAgICAgfVxuICAgIF07XG4gIH0sXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgcmV0dXJuIFtcInVcIiwgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLCAwXTtcbiAgfSxcbiAgcGFyc2VNYXJrZG93bih0b2tlbiwgaGVscGVycykge1xuICAgIHJldHVybiBoZWxwZXJzLmFwcGx5TWFyayh0aGlzLm5hbWUgfHwgXCJ1bmRlcmxpbmVcIiwgaGVscGVycy5wYXJzZUlubGluZSh0b2tlbi50b2tlbnMgfHwgW10pKTtcbiAgfSxcbiAgcmVuZGVyTWFya2Rvd24obm9kZSwgaGVscGVycykge1xuICAgIHJldHVybiBgKyske2hlbHBlcnMucmVuZGVyQ2hpbGRyZW4obm9kZSl9KytgO1xuICB9LFxuICBtYXJrZG93blRva2VuaXplcjoge1xuICAgIG5hbWU6IFwidW5kZXJsaW5lXCIsXG4gICAgbGV2ZWw6IFwiaW5saW5lXCIsXG4gICAgc3RhcnQoc3JjKSB7XG4gICAgICByZXR1cm4gc3JjLmluZGV4T2YoXCIrK1wiKTtcbiAgICB9LFxuICAgIHRva2VuaXplKHNyYywgX3Rva2VucywgbGV4ZXIpIHtcbiAgICAgIGNvbnN0IHJ1bGUgPSAvXihcXCtcXCspKFtcXHNcXFNdKz8pKFxcK1xcKykvO1xuICAgICAgY29uc3QgbWF0Y2ggPSBydWxlLmV4ZWMoc3JjKTtcbiAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlubmVyQ29udGVudCA9IG1hdGNoWzJdLnRyaW0oKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwidW5kZXJsaW5lXCIsXG4gICAgICAgIHJhdzogbWF0Y2hbMF0sXG4gICAgICAgIHRleHQ6IGlubmVyQ29udGVudCxcbiAgICAgICAgdG9rZW5zOiBsZXhlci5pbmxpbmVUb2tlbnMoaW5uZXJDb250ZW50KVxuICAgICAgfTtcbiAgICB9XG4gIH0sXG4gIGFkZENvbW1hbmRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzZXRVbmRlcmxpbmU6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnNldE1hcmsodGhpcy5uYW1lKTtcbiAgICAgIH0sXG4gICAgICB0b2dnbGVVbmRlcmxpbmU6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnRvZ2dsZU1hcmsodGhpcy5uYW1lKTtcbiAgICAgIH0sXG4gICAgICB1bnNldFVuZGVybGluZTogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICByZXR1cm4gY29tbWFuZHMudW5zZXRNYXJrKHRoaXMubmFtZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFwiTW9kLXVcIjogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlVW5kZXJsaW5lKCksXG4gICAgICBcIk1vZC1VXCI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZVVuZGVybGluZSgpXG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHNyYy9pbmRleC50c1xudmFyIGluZGV4X2RlZmF1bHQgPSBVbmRlcmxpbmU7XG5leHBvcnQge1xuICBVbmRlcmxpbmUsXG4gIGluZGV4X2RlZmF1bHQgYXMgZGVmYXVsdFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJNYXJrIiwibWVyZ2VBdHRyaWJ1dGVzIiwiVW5kZXJsaW5lIiwiY3JlYXRlIiwibmFtZSIsImFkZE9wdGlvbnMiLCJIVE1MQXR0cmlidXRlcyIsInBhcnNlSFRNTCIsInRhZyIsInN0eWxlIiwiY29uc3VtaW5nIiwiZ2V0QXR0cnMiLCJpbmNsdWRlcyIsInJlbmRlckhUTUwiLCJvcHRpb25zIiwicGFyc2VNYXJrZG93biIsInRva2VuIiwiaGVscGVycyIsImFwcGx5TWFyayIsInBhcnNlSW5saW5lIiwidG9rZW5zIiwicmVuZGVyTWFya2Rvd24iLCJub2RlIiwicmVuZGVyQ2hpbGRyZW4iLCJtYXJrZG93blRva2VuaXplciIsImxldmVsIiwic3RhcnQiLCJzcmMiLCJpbmRleE9mIiwidG9rZW5pemUiLCJfdG9rZW5zIiwibGV4ZXIiLCJydWxlIiwibWF0Y2giLCJleGVjIiwiaW5uZXJDb250ZW50IiwidHJpbSIsInR5cGUiLCJyYXciLCJ0ZXh0IiwiaW5saW5lVG9rZW5zIiwiYWRkQ29tbWFuZHMiLCJzZXRVbmRlcmxpbmUiLCJjb21tYW5kcyIsInNldE1hcmsiLCJ0b2dnbGVVbmRlcmxpbmUiLCJ0b2dnbGVNYXJrIiwidW5zZXRVbmRlcmxpbmUiLCJ1bnNldE1hcmsiLCJhZGRLZXlib2FyZFNob3J0Y3V0cyIsImVkaXRvciIsImluZGV4X2RlZmF1bHQiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-underline/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-youtube/dist/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@tiptap/extension-youtube/dist/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Youtube: () => (/* binding */ Youtube),\n/* harmony export */   \"default\": () => (/* binding */ index_default)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n// src/youtube.ts\n\n// src/utils.ts\nvar YOUTUBE_REGEX = /^((?:https?:)?\\/\\/)?((?:www|m|music)\\.)?((?:youtube\\.com|youtu\\.be|youtube-nocookie\\.com))(\\/(?:[\\w-]+\\?v=|embed\\/|v\\/)?)([\\w-]+)(\\S+)?$/;\nvar YOUTUBE_REGEX_GLOBAL = /^((?:https?:)?\\/\\/)?((?:www|m|music)\\.)?((?:youtube\\.com|youtu\\.be|youtube-nocookie\\.com))(\\/(?:[\\w-]+\\?v=|embed\\/|v\\/)?)([\\w-]+)(\\S+)?$/g;\nvar isValidYoutubeUrl = (url)=>{\n    return url.match(YOUTUBE_REGEX);\n};\nvar getYoutubeEmbedUrl = (nocookie, isPlaylist)=>{\n    if (isPlaylist) {\n        return \"https://www.youtube-nocookie.com/embed/videoseries?list=\";\n    }\n    return nocookie ? \"https://www.youtube-nocookie.com/embed/\" : \"https://www.youtube.com/embed/\";\n};\nvar getEmbedUrlFromYoutubeUrl = (options)=>{\n    const { url, allowFullscreen, autoplay, ccLanguage, ccLoadPolicy, controls, disableKBcontrols, enableIFrameApi, endTime, interfaceLanguage, ivLoadPolicy, loop, modestBranding, nocookie, origin, playlist, progressBarColor, startAt, rel } = options;\n    if (!isValidYoutubeUrl(url)) {\n        return null;\n    }\n    if (url.includes(\"/embed/\")) {\n        return url;\n    }\n    if (url.includes(\"youtu.be\")) {\n        const id = url.split(\"/\").pop();\n        if (!id) {\n            return null;\n        }\n        return `${getYoutubeEmbedUrl(nocookie)}${id}`;\n    }\n    const videoIdRegex = /(?:(v|list)=|shorts\\/)([-\\w]+)/gm;\n    const matches = videoIdRegex.exec(url);\n    if (!matches || !matches[2]) {\n        return null;\n    }\n    let outputUrl = `${getYoutubeEmbedUrl(nocookie, matches[1] === \"list\")}${matches[2]}`;\n    const params = [];\n    if (allowFullscreen === false) {\n        params.push(\"fs=0\");\n    }\n    if (autoplay) {\n        params.push(\"autoplay=1\");\n    }\n    if (ccLanguage) {\n        params.push(`cc_lang_pref=${ccLanguage}`);\n    }\n    if (ccLoadPolicy) {\n        params.push(\"cc_load_policy=1\");\n    }\n    if (!controls) {\n        params.push(\"controls=0\");\n    }\n    if (disableKBcontrols) {\n        params.push(\"disablekb=1\");\n    }\n    if (enableIFrameApi) {\n        params.push(\"enablejsapi=1\");\n    }\n    if (endTime) {\n        params.push(`end=${endTime}`);\n    }\n    if (interfaceLanguage) {\n        params.push(`hl=${interfaceLanguage}`);\n    }\n    if (ivLoadPolicy) {\n        params.push(`iv_load_policy=${ivLoadPolicy}`);\n    }\n    if (loop) {\n        params.push(\"loop=1\");\n    }\n    if (modestBranding) {\n        params.push(\"modestbranding=1\");\n    }\n    if (origin) {\n        params.push(`origin=${origin}`);\n    }\n    if (playlist) {\n        params.push(`playlist=${playlist}`);\n    }\n    if (startAt) {\n        params.push(`start=${startAt}`);\n    }\n    if (progressBarColor) {\n        params.push(`color=${progressBarColor}`);\n    }\n    if (rel !== void 0) {\n        params.push(`rel=${rel}`);\n    }\n    if (params.length) {\n        outputUrl += `${matches[1] === \"v\" ? \"?\" : \"&\"}${params.join(\"&\")}`;\n    }\n    return outputUrl;\n};\n// src/youtube.ts\nvar Youtube = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n    name: \"youtube\",\n    addOptions () {\n        return {\n            addPasteHandler: true,\n            allowFullscreen: true,\n            autoplay: false,\n            ccLanguage: void 0,\n            ccLoadPolicy: void 0,\n            controls: true,\n            disableKBcontrols: false,\n            enableIFrameApi: false,\n            endTime: 0,\n            height: 480,\n            interfaceLanguage: void 0,\n            ivLoadPolicy: 0,\n            loop: false,\n            modestBranding: false,\n            HTMLAttributes: {},\n            inline: false,\n            nocookie: false,\n            origin: \"\",\n            playlist: \"\",\n            progressBarColor: void 0,\n            width: 640,\n            rel: 1\n        };\n    },\n    inline () {\n        return this.options.inline;\n    },\n    group () {\n        return this.options.inline ? \"inline\" : \"block\";\n    },\n    draggable: true,\n    addAttributes () {\n        return {\n            src: {\n                default: null\n            },\n            start: {\n                default: 0\n            },\n            width: {\n                default: this.options.width\n            },\n            height: {\n                default: this.options.height\n            }\n        };\n    },\n    parseHTML () {\n        return [\n            {\n                tag: \"div[data-youtube-video] iframe\"\n            }\n        ];\n    },\n    addCommands () {\n        return {\n            setYoutubeVideo: (options)=>({ commands })=>{\n                    if (!isValidYoutubeUrl(options.src)) {\n                        return false;\n                    }\n                    return commands.insertContent({\n                        type: this.name,\n                        attrs: options\n                    });\n                }\n        };\n    },\n    addPasteRules () {\n        if (!this.options.addPasteHandler) {\n            return [];\n        }\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.nodePasteRule)({\n                find: YOUTUBE_REGEX_GLOBAL,\n                type: this.type,\n                getAttributes: (match)=>{\n                    return {\n                        src: match.input\n                    };\n                }\n            })\n        ];\n    },\n    renderHTML ({ HTMLAttributes }) {\n        const embedUrl = getEmbedUrlFromYoutubeUrl({\n            url: HTMLAttributes.src,\n            allowFullscreen: this.options.allowFullscreen,\n            autoplay: this.options.autoplay,\n            ccLanguage: this.options.ccLanguage,\n            ccLoadPolicy: this.options.ccLoadPolicy,\n            controls: this.options.controls,\n            disableKBcontrols: this.options.disableKBcontrols,\n            enableIFrameApi: this.options.enableIFrameApi,\n            endTime: this.options.endTime,\n            interfaceLanguage: this.options.interfaceLanguage,\n            ivLoadPolicy: this.options.ivLoadPolicy,\n            loop: this.options.loop,\n            modestBranding: this.options.modestBranding,\n            nocookie: this.options.nocookie,\n            origin: this.options.origin,\n            playlist: this.options.playlist,\n            progressBarColor: this.options.progressBarColor,\n            startAt: HTMLAttributes.start || 0,\n            rel: this.options.rel\n        });\n        HTMLAttributes.src = embedUrl;\n        return [\n            \"div\",\n            {\n                \"data-youtube-video\": \"\"\n            },\n            [\n                \"iframe\",\n                (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, {\n                    width: this.options.width,\n                    height: this.options.height,\n                    allowfullscreen: this.options.allowFullscreen,\n                    autoplay: this.options.autoplay,\n                    ccLanguage: this.options.ccLanguage,\n                    ccLoadPolicy: this.options.ccLoadPolicy,\n                    disableKBcontrols: this.options.disableKBcontrols,\n                    enableIFrameApi: this.options.enableIFrameApi,\n                    endTime: this.options.endTime,\n                    interfaceLanguage: this.options.interfaceLanguage,\n                    ivLoadPolicy: this.options.ivLoadPolicy,\n                    loop: this.options.loop,\n                    modestBranding: this.options.modestBranding,\n                    origin: this.options.origin,\n                    playlist: this.options.playlist,\n                    progressBarColor: this.options.progressBarColor,\n                    rel: this.options.rel\n                }, HTMLAttributes)\n            ]\n        ];\n    },\n    ...(0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.createAtomBlockMarkdownSpec)({\n        nodeName: \"youtube\",\n        allowedAttributes: [\n            \"src\",\n            \"width\",\n            \"height\",\n            \"start\"\n        ]\n    })\n});\n// src/index.ts\nvar index_default = Youtube;\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24teW91dHViZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLGlCQUFpQjtBQUNnRjtBQUVqRyxlQUFlO0FBQ2YsSUFBSUksZ0JBQWdCO0FBQ3BCLElBQUlDLHVCQUF1QjtBQUMzQixJQUFJQyxvQkFBb0IsQ0FBQ0M7SUFDdkIsT0FBT0EsSUFBSUMsS0FBSyxDQUFDSjtBQUNuQjtBQUNBLElBQUlLLHFCQUFxQixDQUFDQyxVQUFVQztJQUNsQyxJQUFJQSxZQUFZO1FBQ2QsT0FBTztJQUNUO0lBQ0EsT0FBT0QsV0FBVyw0Q0FBNEM7QUFDaEU7QUFDQSxJQUFJRSw0QkFBNEIsQ0FBQ0M7SUFDL0IsTUFBTSxFQUNKTixHQUFHLEVBQ0hPLGVBQWUsRUFDZkMsUUFBUSxFQUNSQyxVQUFVLEVBQ1ZDLFlBQVksRUFDWkMsUUFBUSxFQUNSQyxpQkFBaUIsRUFDakJDLGVBQWUsRUFDZkMsT0FBTyxFQUNQQyxpQkFBaUIsRUFDakJDLFlBQVksRUFDWkMsSUFBSSxFQUNKQyxjQUFjLEVBQ2RmLFFBQVEsRUFDUmdCLE1BQU0sRUFDTkMsUUFBUSxFQUNSQyxnQkFBZ0IsRUFDaEJDLE9BQU8sRUFDUEMsR0FBRyxFQUNKLEdBQUdqQjtJQUNKLElBQUksQ0FBQ1Asa0JBQWtCQyxNQUFNO1FBQzNCLE9BQU87SUFDVDtJQUNBLElBQUlBLElBQUl3QixRQUFRLENBQUMsWUFBWTtRQUMzQixPQUFPeEI7SUFDVDtJQUNBLElBQUlBLElBQUl3QixRQUFRLENBQUMsYUFBYTtRQUM1QixNQUFNQyxLQUFLekIsSUFBSTBCLEtBQUssQ0FBQyxLQUFLQyxHQUFHO1FBQzdCLElBQUksQ0FBQ0YsSUFBSTtZQUNQLE9BQU87UUFDVDtRQUNBLE9BQU8sQ0FBQyxFQUFFdkIsbUJBQW1CQyxVQUFVLEVBQUVzQixHQUFHLENBQUM7SUFDL0M7SUFDQSxNQUFNRyxlQUFlO0lBQ3JCLE1BQU1DLFVBQVVELGFBQWFFLElBQUks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QyxNQUFNO29CQUMzQndCLGlCQUFpQixJQUFJLENBQUMzRCxPQUFPLENBQUNDLGVBQWU7b0JBQzdDQyxVQUFVLElBQUksQ0FBQ0YsT0FBTyxDQUFDRSxRQUFRO29CQUMvQkMsWUFBWSxJQUFJLENBQUNILE9BQU8sQ0FBQ0csVUFBVTtvQkFDbkNDLGNBQWMsSUFBSSxDQUFDSixPQUFPLENBQUNJLFlBQVk7b0JBQ3ZDRSxtQkFBbUIsSUFBSSxDQUFDTixPQUFPLENBQUNNLGlCQUFpQjtvQkFDakRDLGlCQUFpQixJQUFJLENBQUNQLE9BQU8sQ0FBQ08sZUFBZTtvQkFDN0NDLFNBQVMsSUFBSSxDQUFDUixPQUFPLENBQUNRLE9BQU87b0JBQzdCQyxtQkFBbUIsSUFBSSxDQUFDVCxPQUFPLENBQUNTLGlCQUFpQjtvQkFDakRDLGNBQWMsSUFBSSxDQUFDVixPQUFPLENBQUNVLFlBQVk7b0JBQ3ZDQyxNQUFNLElBQUksQ0FBQ1gsT0FBTyxDQUFDVyxJQUFJO29CQUN2QkMsZ0JBQWdCLElBQUksQ0FBQ1osT0FBTyxDQUFDWSxjQUFjO29CQUMzQ0MsUUFBUSxJQUFJLENBQUNiLE9BQU8sQ0FBQ2EsTUFBTTtvQkFDM0JDLFVBQVUsSUFBSSxDQUFDZCxPQUFPLENBQUNjLFFBQVE7b0JBQy9CQyxrQkFBa0IsSUFBSSxDQUFDZixPQUFPLENBQUNlLGdCQUFnQjtvQkFDL0NFLEtBQUssSUFBSSxDQUFDakIsT0FBTyxDQUFDaUIsR0FBRztnQkFDdkIsR0FDQW1CO2FBRUg7U0FDRjtJQUNIO0lBQ0EsR0FBR2pELHlFQUEyQkEsQ0FBQztRQUM3QnlFLFVBQVU7UUFDVkMsbUJBQW1CO1lBQUM7WUFBTztZQUFTO1lBQVU7U0FBUTtJQUN4RCxFQUFFO0FBQ0o7QUFFQSxlQUFlO0FBQ2YsSUFBSUMsZ0JBQWdCaEM7QUFJbEIsQ0FDRixpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcmFzb2JwYWktd2ViLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLXlvdXR1YmUvZGlzdC9pbmRleC5qcz9mYzU5Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy95b3V0dWJlLnRzXG5pbXBvcnQgeyBjcmVhdGVBdG9tQmxvY2tNYXJrZG93blNwZWMsIG1lcmdlQXR0cmlidXRlcywgTm9kZSwgbm9kZVBhc3RlUnVsZSB9IGZyb20gXCJAdGlwdGFwL2NvcmVcIjtcblxuLy8gc3JjL3V0aWxzLnRzXG52YXIgWU9VVFVCRV9SRUdFWCA9IC9eKCg/Omh0dHBzPzopP1xcL1xcLyk/KCg/Ond3d3xtfG11c2ljKVxcLik/KCg/OnlvdXR1YmVcXC5jb218eW91dHVcXC5iZXx5b3V0dWJlLW5vY29va2llXFwuY29tKSkoXFwvKD86W1xcdy1dK1xcP3Y9fGVtYmVkXFwvfHZcXC8pPykoW1xcdy1dKykoXFxTKyk/JC87XG52YXIgWU9VVFVCRV9SRUdFWF9HTE9CQUwgPSAvXigoPzpodHRwcz86KT9cXC9cXC8pPygoPzp3d3d8bXxtdXNpYylcXC4pPygoPzp5b3V0dWJlXFwuY29tfHlvdXR1XFwuYmV8eW91dHViZS1ub2Nvb2tpZVxcLmNvbSkpKFxcLyg/OltcXHctXStcXD92PXxlbWJlZFxcL3x2XFwvKT8pKFtcXHctXSspKFxcUyspPyQvZztcbnZhciBpc1ZhbGlkWW91dHViZVVybCA9ICh1cmwpID0+IHtcbiAgcmV0dXJuIHVybC5tYXRjaChZT1VUVUJFX1JFR0VYKTtcbn07XG52YXIgZ2V0WW91dHViZUVtYmVkVXJsID0gKG5vY29va2llLCBpc1BsYXlsaXN0KSA9PiB7XG4gIGlmIChpc1BsYXlsaXN0KSB7XG4gICAgcmV0dXJuIFwiaHR0cHM6Ly93d3cueW91dHViZS1ub2Nvb2tpZS5jb20vZW1iZWQvdmlkZW9zZXJpZXM/bGlzdD1cIjtcbiAgfVxuICByZXR1cm4gbm9jb29raWUgPyBcImh0dHBzOi8vd3d3LnlvdXR1YmUtbm9jb29raWUuY29tL2VtYmVkL1wiIDogXCJodHRwczovL3d3dy55b3V0dWJlLmNvbS9lbWJlZC9cIjtcbn07XG52YXIgZ2V0RW1iZWRVcmxGcm9tWW91dHViZVVybCA9IChvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHtcbiAgICB1cmwsXG4gICAgYWxsb3dGdWxsc2NyZWVuLFxuICAgIGF1dG9wbGF5LFxuICAgIGNjTGFuZ3VhZ2UsXG4gICAgY2NMb2FkUG9saWN5LFxuICAgIGNvbnRyb2xzLFxuICAgIGRpc2FibGVLQmNvbnRyb2xzLFxuICAgIGVuYWJsZUlGcmFtZUFwaSxcbiAgICBlbmRUaW1lLFxuICAgIGludGVyZmFjZUxhbmd1YWdlLFxuICAgIGl2TG9hZFBvbGljeSxcbiAgICBsb29wLFxuICAgIG1vZGVzdEJyYW5kaW5nLFxuICAgIG5vY29va2llLFxuICAgIG9yaWdpbixcbiAgICBwbGF5bGlzdCxcbiAgICBwcm9ncmVzc0JhckNvbG9yLFxuICAgIHN0YXJ0QXQsXG4gICAgcmVsXG4gIH0gPSBvcHRpb25zO1xuICBpZiAoIWlzVmFsaWRZb3V0dWJlVXJsKHVybCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAodXJsLmluY2x1ZGVzKFwiL2VtYmVkL1wiKSkge1xuICAgIHJldHVybiB1cmw7XG4gIH1cbiAgaWYgKHVybC5pbmNsdWRlcyhcInlvdXR1LmJlXCIpKSB7XG4gICAgY29uc3QgaWQgPSB1cmwuc3BsaXQoXCIvXCIpLnBvcCgpO1xuICAgIGlmICghaWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gYCR7Z2V0WW91dHViZUVtYmVkVXJsKG5vY29va2llKX0ke2lkfWA7XG4gIH1cbiAgY29uc3QgdmlkZW9JZFJlZ2V4ID0gLyg/Oih2fGxpc3QpPXxzaG9ydHNcXC8pKFstXFx3XSspL2dtO1xuICBjb25zdCBtYXRjaGVzID0gdmlkZW9JZFJlZ2V4LmV4ZWModXJsKTtcbiAgaWYgKCFtYXRjaGVzIHx8ICFtYXRjaGVzWzJdKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgbGV0IG91dHB1dFVybCA9IGAke2dldFlvdXR1YmVFbWJlZFVybChub2Nvb2tpZSwgbWF0Y2hlc1sxXSA9PT0gXCJsaXN0XCIpfSR7bWF0Y2hlc1syXX1gO1xuICBjb25zdCBwYXJhbXMgPSBbXTtcbiAgaWYgKGFsbG93RnVsbHNjcmVlbiA9PT0gZmFsc2UpIHtcbiAgICBwYXJhbXMucHVzaChcImZzPTBcIik7XG4gIH1cbiAgaWYgKGF1dG9wbGF5KSB7XG4gICAgcGFyYW1zLnB1c2goXCJhdXRvcGxheT0xXCIpO1xuICB9XG4gIGlmIChjY0xhbmd1YWdlKSB7XG4gICAgcGFyYW1zLnB1c2goYGNjX2xhbmdfcHJlZj0ke2NjTGFuZ3VhZ2V9YCk7XG4gIH1cbiAgaWYgKGNjTG9hZFBvbGljeSkge1xuICAgIHBhcmFtcy5wdXNoKFwiY2NfbG9hZF9wb2xpY3k9MVwiKTtcbiAgfVxuICBpZiAoIWNvbnRyb2xzKSB7XG4gICAgcGFyYW1zLnB1c2goXCJjb250cm9scz0wXCIpO1xuICB9XG4gIGlmIChkaXNhYmxlS0Jjb250cm9scykge1xuICAgIHBhcmFtcy5wdXNoKFwiZGlzYWJsZWtiPTFcIik7XG4gIH1cbiAgaWYgKGVuYWJsZUlGcmFtZUFwaSkge1xuICAgIHBhcmFtcy5wdXNoKFwiZW5hYmxlanNhcGk9MVwiKTtcbiAgfVxuICBpZiAoZW5kVGltZSkge1xuICAgIHBhcmFtcy5wdXNoKGBlbmQ9JHtlbmRUaW1lfWApO1xuICB9XG4gIGlmIChpbnRlcmZhY2VMYW5ndWFnZSkge1xuICAgIHBhcmFtcy5wdXNoKGBobD0ke2ludGVyZmFjZUxhbmd1YWdlfWApO1xuICB9XG4gIGlmIChpdkxvYWRQb2xpY3kpIHtcbiAgICBwYXJhbXMucHVzaChgaXZfbG9hZF9wb2xpY3k9JHtpdkxvYWRQb2xpY3l9YCk7XG4gIH1cbiAgaWYgKGxvb3ApIHtcbiAgICBwYXJhbXMucHVzaChcImxvb3A9MVwiKTtcbiAgfVxuICBpZiAobW9kZXN0QnJhbmRpbmcpIHtcbiAgICBwYXJhbXMucHVzaChcIm1vZGVzdGJyYW5kaW5nPTFcIik7XG4gIH1cbiAgaWYgKG9yaWdpbikge1xuICAgIHBhcmFtcy5wdXNoKGBvcmlnaW49JHtvcmlnaW59YCk7XG4gIH1cbiAgaWYgKHBsYXlsaXN0KSB7XG4gICAgcGFyYW1zLnB1c2goYHBsYXlsaXN0PSR7cGxheWxpc3R9YCk7XG4gIH1cbiAgaWYgKHN0YXJ0QXQpIHtcbiAgICBwYXJhbXMucHVzaChgc3RhcnQ9JHtzdGFydEF0fWApO1xuICB9XG4gIGlmIChwcm9ncmVzc0JhckNvbG9yKSB7XG4gICAgcGFyYW1zLnB1c2goYGNvbG9yPSR7cHJvZ3Jlc3NCYXJDb2xvcn1gKTtcbiAgfVxuICBpZiAocmVsICE9PSB2b2lkIDApIHtcbiAgICBwYXJhbXMucHVzaChgcmVsPSR7cmVsfWApO1xuICB9XG4gIGlmIChwYXJhbXMubGVuZ3RoKSB7XG4gICAgb3V0cHV0VXJsICs9IGAke21hdGNoZXNbMV0gPT09IFwidlwiID8gXCI/XCIgOiBcIiZcIn0ke3BhcmFtcy5qb2luKFwiJlwiKX1gO1xuICB9XG4gIHJldHVybiBvdXRwdXRVcmw7XG59O1xuXG4vLyBzcmMveW91dHViZS50c1xudmFyIFlvdXR1YmUgPSBOb2RlLmNyZWF0ZSh7XG4gIG5hbWU6IFwieW91dHViZVwiLFxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBhZGRQYXN0ZUhhbmRsZXI6IHRydWUsXG4gICAgICBhbGxvd0Z1bGxzY3JlZW46IHRydWUsXG4gICAgICBhdXRvcGxheTogZmFsc2UsXG4gICAgICBjY0xhbmd1YWdlOiB2b2lkIDAsXG4gICAgICBjY0xvYWRQb2xpY3k6IHZvaWQgMCxcbiAgICAgIGNvbnRyb2xzOiB0cnVlLFxuICAgICAgZGlzYWJsZUtCY29udHJvbHM6IGZhbHNlLFxuICAgICAgZW5hYmxlSUZyYW1lQXBpOiBmYWxzZSxcbiAgICAgIGVuZFRpbWU6IDAsXG4gICAgICBoZWlnaHQ6IDQ4MCxcbiAgICAgIGludGVyZmFjZUxhbmd1YWdlOiB2b2lkIDAsXG4gICAgICBpdkxvYWRQb2xpY3k6IDAsXG4gICAgICBsb29wOiBmYWxzZSxcbiAgICAgIG1vZGVzdEJyYW5kaW5nOiBmYWxzZSxcbiAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fSxcbiAgICAgIGlubGluZTogZmFsc2UsXG4gICAgICBub2Nvb2tpZTogZmFsc2UsXG4gICAgICBvcmlnaW46IFwiXCIsXG4gICAgICBwbGF5bGlzdDogXCJcIixcbiAgICAgIHByb2dyZXNzQmFyQ29sb3I6IHZvaWQgMCxcbiAgICAgIHdpZHRoOiA2NDAsXG4gICAgICByZWw6IDFcbiAgICB9O1xuICB9LFxuICBpbmxpbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5pbmxpbmU7XG4gIH0sXG4gIGdyb3VwKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuaW5saW5lID8gXCJpbmxpbmVcIiA6IFwiYmxvY2tcIjtcbiAgfSxcbiAgZHJhZ2dhYmxlOiB0cnVlLFxuICBhZGRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzcmM6IHtcbiAgICAgICAgZGVmYXVsdDogbnVsbFxuICAgICAgfSxcbiAgICAgIHN0YXJ0OiB7XG4gICAgICAgIGRlZmF1bHQ6IDBcbiAgICAgIH0sXG4gICAgICB3aWR0aDoge1xuICAgICAgICBkZWZhdWx0OiB0aGlzLm9wdGlvbnMud2lkdGhcbiAgICAgIH0sXG4gICAgICBoZWlnaHQ6IHtcbiAgICAgICAgZGVmYXVsdDogdGhpcy5vcHRpb25zLmhlaWdodFxuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICB0YWc6IFwiZGl2W2RhdGEteW91dHViZS12aWRlb10gaWZyYW1lXCJcbiAgICAgIH1cbiAgICBdO1xuICB9LFxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2V0WW91dHViZVZpZGVvOiAob3B0aW9ucykgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICBpZiAoIWlzVmFsaWRZb3V0dWJlVXJsKG9wdGlvbnMuc3JjKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tbWFuZHMuaW5zZXJ0Q29udGVudCh7XG4gICAgICAgICAgdHlwZTogdGhpcy5uYW1lLFxuICAgICAgICAgIGF0dHJzOiBvcHRpb25zXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIGFkZFBhc3RlUnVsZXMoKSB7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuYWRkUGFzdGVIYW5kbGVyKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHJldHVybiBbXG4gICAgICBub2RlUGFzdGVSdWxlKHtcbiAgICAgICAgZmluZDogWU9VVFVCRV9SRUdFWF9HTE9CQUwsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgZ2V0QXR0cmlidXRlczogKG1hdGNoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHsgc3JjOiBtYXRjaC5pbnB1dCB9O1xuICAgICAgICB9XG4gICAgICB9KVxuICAgIF07XG4gIH0sXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgY29uc3QgZW1iZWRVcmwgPSBnZXRFbWJlZFVybEZyb21Zb3V0dWJlVXJsKHtcbiAgICAgIHVybDogSFRNTEF0dHJpYnV0ZXMuc3JjLFxuICAgICAgYWxsb3dGdWxsc2NyZWVuOiB0aGlzLm9wdGlvbnMuYWxsb3dGdWxsc2NyZWVuLFxuICAgICAgYXV0b3BsYXk6IHRoaXMub3B0aW9ucy5hdXRvcGxheSxcbiAgICAgIGNjTGFuZ3VhZ2U6IHRoaXMub3B0aW9ucy5jY0xhbmd1YWdlLFxuICAgICAgY2NMb2FkUG9saWN5OiB0aGlzLm9wdGlvbnMuY2NMb2FkUG9saWN5LFxuICAgICAgY29udHJvbHM6IHRoaXMub3B0aW9ucy5jb250cm9scyxcbiAgICAgIGRpc2FibGVLQmNvbnRyb2xzOiB0aGlzLm9wdGlvbnMuZGlzYWJsZUtCY29udHJvbHMsXG4gICAgICBlbmFibGVJRnJhbWVBcGk6IHRoaXMub3B0aW9ucy5lbmFibGVJRnJhbWVBcGksXG4gICAgICBlbmRUaW1lOiB0aGlzLm9wdGlvbnMuZW5kVGltZSxcbiAgICAgIGludGVyZmFjZUxhbmd1YWdlOiB0aGlzLm9wdGlvbnMuaW50ZXJmYWNlTGFuZ3VhZ2UsXG4gICAgICBpdkxvYWRQb2xpY3k6IHRoaXMub3B0aW9ucy5pdkxvYWRQb2xpY3ksXG4gICAgICBsb29wOiB0aGlzLm9wdGlvbnMubG9vcCxcbiAgICAgIG1vZGVzdEJyYW5kaW5nOiB0aGlzLm9wdGlvbnMubW9kZXN0QnJhbmRpbmcsXG4gICAgICBub2Nvb2tpZTogdGhpcy5vcHRpb25zLm5vY29va2llLFxuICAgICAgb3JpZ2luOiB0aGlzLm9wdGlvbnMub3JpZ2luLFxuICAgICAgcGxheWxpc3Q6IHRoaXMub3B0aW9ucy5wbGF5bGlzdCxcbiAgICAgIHByb2dyZXNzQmFyQ29sb3I6IHRoaXMub3B0aW9ucy5wcm9ncmVzc0JhckNvbG9yLFxuICAgICAgc3RhcnRBdDogSFRNTEF0dHJpYnV0ZXMuc3RhcnQgfHwgMCxcbiAgICAgIHJlbDogdGhpcy5vcHRpb25zLnJlbFxuICAgIH0pO1xuICAgIEhUTUxBdHRyaWJ1dGVzLnNyYyA9IGVtYmVkVXJsO1xuICAgIHJldHVybiBbXG4gICAgICBcImRpdlwiLFxuICAgICAgeyBcImRhdGEteW91dHViZS12aWRlb1wiOiBcIlwiIH0sXG4gICAgICBbXG4gICAgICAgIFwiaWZyYW1lXCIsXG4gICAgICAgIG1lcmdlQXR0cmlidXRlcyhcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsXG4gICAgICAgICAge1xuICAgICAgICAgICAgd2lkdGg6IHRoaXMub3B0aW9ucy53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5vcHRpb25zLmhlaWdodCxcbiAgICAgICAgICAgIGFsbG93ZnVsbHNjcmVlbjogdGhpcy5vcHRpb25zLmFsbG93RnVsbHNjcmVlbixcbiAgICAgICAgICAgIGF1dG9wbGF5OiB0aGlzLm9wdGlvbnMuYXV0b3BsYXksXG4gICAgICAgICAgICBjY0xhbmd1YWdlOiB0aGlzLm9wdGlvbnMuY2NMYW5ndWFnZSxcbiAgICAgICAgICAgIGNjTG9hZFBvbGljeTogdGhpcy5vcHRpb25zLmNjTG9hZFBvbGljeSxcbiAgICAgICAgICAgIGRpc2FibGVLQmNvbnRyb2xzOiB0aGlzLm9wdGlvbnMuZGlzYWJsZUtCY29udHJvbHMsXG4gICAgICAgICAgICBlbmFibGVJRnJhbWVBcGk6IHRoaXMub3B0aW9ucy5lbmFibGVJRnJhbWVBcGksXG4gICAgICAgICAgICBlbmRUaW1lOiB0aGlzLm9wdGlvbnMuZW5kVGltZSxcbiAgICAgICAgICAgIGludGVyZmFjZUxhbmd1YWdlOiB0aGlzLm9wdGlvbnMuaW50ZXJmYWNlTGFuZ3VhZ2UsXG4gICAgICAgICAgICBpdkxvYWRQb2xpY3k6IHRoaXMub3B0aW9ucy5pdkxvYWRQb2xpY3ksXG4gICAgICAgICAgICBsb29wOiB0aGlzLm9wdGlvbnMubG9vcCxcbiAgICAgICAgICAgIG1vZGVzdEJyYW5kaW5nOiB0aGlzLm9wdGlvbnMubW9kZXN0QnJhbmRpbmcsXG4gICAgICAgICAgICBvcmlnaW46IHRoaXMub3B0aW9ucy5vcmlnaW4sXG4gICAgICAgICAgICBwbGF5bGlzdDogdGhpcy5vcHRpb25zLnBsYXlsaXN0LFxuICAgICAgICAgICAgcHJvZ3Jlc3NCYXJDb2xvcjogdGhpcy5vcHRpb25zLnByb2dyZXNzQmFyQ29sb3IsXG4gICAgICAgICAgICByZWw6IHRoaXMub3B0aW9ucy5yZWxcbiAgICAgICAgICB9LFxuICAgICAgICAgIEhUTUxBdHRyaWJ1dGVzXG4gICAgICAgIClcbiAgICAgIF1cbiAgICBdO1xuICB9LFxuICAuLi5jcmVhdGVBdG9tQmxvY2tNYXJrZG93blNwZWMoe1xuICAgIG5vZGVOYW1lOiBcInlvdXR1YmVcIixcbiAgICBhbGxvd2VkQXR0cmlidXRlczogW1wic3JjXCIsIFwid2lkdGhcIiwgXCJoZWlnaHRcIiwgXCJzdGFydFwiXVxuICB9KVxufSk7XG5cbi8vIHNyYy9pbmRleC50c1xudmFyIGluZGV4X2RlZmF1bHQgPSBZb3V0dWJlO1xuZXhwb3J0IHtcbiAgWW91dHViZSxcbiAgaW5kZXhfZGVmYXVsdCBhcyBkZWZhdWx0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbImNyZWF0ZUF0b21CbG9ja01hcmtkb3duU3BlYyIsIm1lcmdlQXR0cmlidXRlcyIsIk5vZGUiLCJub2RlUGFzdGVSdWxlIiwiWU9VVFVCRV9SRUdFWCIsIllPVVRVQkVfUkVHRVhfR0xPQkFMIiwiaXNWYWxpZFlvdXR1YmVVcmwiLCJ1cmwiLCJtYXRjaCIsImdldFlvdXR1YmVFbWJlZFVybCIsIm5vY29va2llIiwiaXNQbGF5bGlzdCIsImdldEVtYmVkVXJsRnJvbVlvdXR1YmVVcmwiLCJvcHRpb25zIiwiYWxsb3dGdWxsc2NyZWVuIiwiYXV0b3BsYXkiLCJjY0xhbmd1YWdlIiwiY2NMb2FkUG9saWN5IiwiY29udHJvbHMiLCJkaXNhYmxlS0Jjb250cm9scyIsImVuYWJsZUlGcmFtZUFwaSIsImVuZFRpbWUiLCJpbnRlcmZhY2VMYW5ndWFnZSIsIml2TG9hZFBvbGljeSIsImxvb3AiLCJtb2Rlc3RCcmFuZGluZyIsIm9yaWdpbiIsInBsYXlsaXN0IiwicHJvZ3Jlc3NCYXJDb2xvciIsInN0YXJ0QXQiLCJyZWwiLCJpbmNsdWRlcyIsImlkIiwic3BsaXQiLCJwb3AiLCJ2aWRlb0lkUmVnZXgiLCJtYXRjaGVzIiwiZXhlYyIsIm91dHB1dFVybCIsInBhcmFtcyIsInB1c2giLCJsZW5ndGgiLCJqb2luIiwiWW91dHViZSIsImNyZWF0ZSIsIm5hbWUiLCJhZGRPcHRpb25zIiwiYWRkUGFzdGVIYW5kbGVyIiwiaGVpZ2h0IiwiSFRNTEF0dHJpYnV0ZXMiLCJpbmxpbmUiLCJ3aWR0aCIsImdyb3VwIiwiZHJhZ2dhYmxlIiwiYWRkQXR0cmlidXRlcyIsInNyYyIsImRlZmF1bHQiLCJzdGFydCIsInBhcnNlSFRNTCIsInRhZyIsImFkZENvbW1hbmRzIiwic2V0WW91dHViZVZpZGVvIiwiY29tbWFuZHMiLCJpbnNlcnRDb250ZW50IiwidHlwZSIsImF0dHJzIiwiYWRkUGFzdGVSdWxlcyIsImZpbmQiLCJnZXRBdHRyaWJ1dGVzIiwiaW5wdXQiLCJyZW5kZXJIVE1MIiwiZW1iZWRVcmwiLCJhbGxvd2Z1bGxzY3JlZW4iLCJub2RlTmFtZSIsImFsbG93ZWRBdHRyaWJ1dGVzIiwiaW5kZXhfZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-youtube/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extensions/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@tiptap/extensions/dist/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CharacterCount: () => (/* binding */ CharacterCount),\n/* harmony export */   Dropcursor: () => (/* binding */ Dropcursor),\n/* harmony export */   Focus: () => (/* binding */ Focus),\n/* harmony export */   Gapcursor: () => (/* binding */ Gapcursor),\n/* harmony export */   Placeholder: () => (/* binding */ Placeholder),\n/* harmony export */   Selection: () => (/* binding */ Selection),\n/* harmony export */   TrailingNode: () => (/* binding */ TrailingNode),\n/* harmony export */   UndoRedo: () => (/* binding */ UndoRedo)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/state */ \"(ssr)/./node_modules/@tiptap/pm/dist/state/index.js\");\n/* harmony import */ var _tiptap_pm_dropcursor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tiptap/pm/dropcursor */ \"(ssr)/./node_modules/@tiptap/pm/dist/dropcursor/index.js\");\n/* harmony import */ var _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tiptap/pm/view */ \"(ssr)/./node_modules/@tiptap/pm/dist/view/index.js\");\n/* harmony import */ var _tiptap_pm_gapcursor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tiptap/pm/gapcursor */ \"(ssr)/./node_modules/@tiptap/pm/dist/gapcursor/index.js\");\n/* harmony import */ var _tiptap_pm_history__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @tiptap/pm/history */ \"(ssr)/./node_modules/@tiptap/pm/dist/history/index.js\");\n// src/character-count/character-count.ts\n\n\nvar CharacterCount = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Extension.create({\n    name: \"characterCount\",\n    addOptions () {\n        return {\n            limit: null,\n            mode: \"textSize\",\n            textCounter: (text)=>text.length,\n            wordCounter: (text)=>text.split(\" \").filter((word)=>word !== \"\").length\n        };\n    },\n    addStorage () {\n        return {\n            characters: ()=>0,\n            words: ()=>0\n        };\n    },\n    onBeforeCreate () {\n        this.storage.characters = (options)=>{\n            const node = (options == null ? void 0 : options.node) || this.editor.state.doc;\n            const mode = (options == null ? void 0 : options.mode) || this.options.mode;\n            if (mode === \"textSize\") {\n                const text = node.textBetween(0, node.content.size, void 0, \" \");\n                return this.options.textCounter(text);\n            }\n            return node.nodeSize;\n        };\n        this.storage.words = (options)=>{\n            const node = (options == null ? void 0 : options.node) || this.editor.state.doc;\n            const text = node.textBetween(0, node.content.size, \" \", \" \");\n            return this.options.wordCounter(text);\n        };\n    },\n    addProseMirrorPlugins () {\n        let initialEvaluationDone = false;\n        return [\n            new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n                key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\"characterCount\"),\n                appendTransaction: (transactions, oldState, newState)=>{\n                    if (initialEvaluationDone) {\n                        return;\n                    }\n                    const limit = this.options.limit;\n                    if (limit === null || limit === void 0 || limit === 0) {\n                        initialEvaluationDone = true;\n                        return;\n                    }\n                    const initialContentSize = this.storage.characters({\n                        node: newState.doc\n                    });\n                    if (initialContentSize > limit) {\n                        const over = initialContentSize - limit;\n                        const from = 0;\n                        const to = over;\n                        console.warn(`[CharacterCount] Initial content exceeded limit of ${limit} characters. Content was automatically trimmed.`);\n                        const tr = newState.tr.deleteRange(from, to);\n                        initialEvaluationDone = true;\n                        return tr;\n                    }\n                    initialEvaluationDone = true;\n                },\n                filterTransaction: (transaction, state)=>{\n                    const limit = this.options.limit;\n                    if (!transaction.docChanged || limit === 0 || limit === null || limit === void 0) {\n                        return true;\n                    }\n                    const oldSize = this.storage.characters({\n                        node: state.doc\n                    });\n                    const newSize = this.storage.characters({\n                        node: transaction.doc\n                    });\n                    if (newSize <= limit) {\n                        return true;\n                    }\n                    if (oldSize > limit && newSize > limit && newSize <= oldSize) {\n                        return true;\n                    }\n                    if (oldSize > limit && newSize > limit && newSize > oldSize) {\n                        return false;\n                    }\n                    const isPaste = transaction.getMeta(\"paste\");\n                    if (!isPaste) {\n                        return false;\n                    }\n                    const pos = transaction.selection.$head.pos;\n                    const over = newSize - limit;\n                    const from = pos - over;\n                    const to = pos;\n                    transaction.deleteRange(from, to);\n                    const updatedSize = this.storage.characters({\n                        node: transaction.doc\n                    });\n                    if (updatedSize > limit) {\n                        return false;\n                    }\n                    return true;\n                }\n            })\n        ];\n    }\n});\n// src/drop-cursor/drop-cursor.ts\n\n\nvar Dropcursor = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Extension.create({\n    name: \"dropCursor\",\n    addOptions () {\n        return {\n            color: \"currentColor\",\n            width: 1,\n            class: void 0\n        };\n    },\n    addProseMirrorPlugins () {\n        return [\n            (0,_tiptap_pm_dropcursor__WEBPACK_IMPORTED_MODULE_2__.dropCursor)(this.options)\n        ];\n    }\n});\n// src/focus/focus.ts\n\n\n\nvar Focus = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Extension.create({\n    name: \"focus\",\n    addOptions () {\n        return {\n            className: \"has-focus\",\n            mode: \"all\"\n        };\n    },\n    addProseMirrorPlugins () {\n        return [\n            new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n                key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\"focus\"),\n                props: {\n                    decorations: ({ doc, selection })=>{\n                        const { isEditable, isFocused } = this.editor;\n                        const { anchor } = selection;\n                        const decorations = [];\n                        if (!isEditable || !isFocused) {\n                            return _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_3__.DecorationSet.create(doc, []);\n                        }\n                        let maxLevels = 0;\n                        if (this.options.mode === \"deepest\") {\n                            doc.descendants((node, pos)=>{\n                                if (node.isText) {\n                                    return;\n                                }\n                                const isCurrent = anchor >= pos && anchor <= pos + node.nodeSize - 1;\n                                if (!isCurrent) {\n                                    return false;\n                                }\n                                maxLevels += 1;\n                            });\n                        }\n                        let currentLevel = 0;\n                        doc.descendants((node, pos)=>{\n                            if (node.isText) {\n                                return false;\n                            }\n                            const isCurrent = anchor >= pos && anchor <= pos + node.nodeSize - 1;\n                            if (!isCurrent) {\n                                return false;\n                            }\n                            currentLevel += 1;\n                            const outOfScope = this.options.mode === \"deepest\" && maxLevels - currentLevel > 0 || this.options.mode === \"shallowest\" && currentLevel > 1;\n                            if (outOfScope) {\n                                return this.options.mode === \"deepest\";\n                            }\n                            decorations.push(_tiptap_pm_view__WEBPACK_IMPORTED_MODULE_3__.Decoration.node(pos, pos + node.nodeSize, {\n                                class: this.options.className\n                            }));\n                        });\n                        return _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_3__.DecorationSet.create(doc, decorations);\n                    }\n                }\n            })\n        ];\n    }\n});\n// src/gap-cursor/gap-cursor.ts\n\n\nvar Gapcursor = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Extension.create({\n    name: \"gapCursor\",\n    addProseMirrorPlugins () {\n        return [\n            (0,_tiptap_pm_gapcursor__WEBPACK_IMPORTED_MODULE_4__.gapCursor)()\n        ];\n    },\n    extendNodeSchema (extension) {\n        var _a;\n        const context = {\n            name: extension.name,\n            options: extension.options,\n            storage: extension.storage\n        };\n        return {\n            allowGapCursor: (_a = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.callOrReturn)((0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.getExtensionField)(extension, \"allowGapCursor\", context))) != null ? _a : null\n        };\n    }\n});\n// src/placeholder/placeholder.ts\n\n\n\nvar Placeholder = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Extension.create({\n    name: \"placeholder\",\n    addOptions () {\n        return {\n            emptyEditorClass: \"is-editor-empty\",\n            emptyNodeClass: \"is-empty\",\n            placeholder: \"Write something \",\n            showOnlyWhenEditable: true,\n            showOnlyCurrent: true,\n            includeChildren: false\n        };\n    },\n    addProseMirrorPlugins () {\n        return [\n            new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n                key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\"placeholder\"),\n                props: {\n                    decorations: ({ doc, selection })=>{\n                        const active = this.editor.isEditable || !this.options.showOnlyWhenEditable;\n                        const { anchor } = selection;\n                        const decorations = [];\n                        if (!active) {\n                            return null;\n                        }\n                        const isEmptyDoc = this.editor.isEmpty;\n                        doc.descendants((node, pos)=>{\n                            const hasAnchor = anchor >= pos && anchor <= pos + node.nodeSize;\n                            const isEmpty = !node.isLeaf && (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.isNodeEmpty)(node);\n                            if ((hasAnchor || !this.options.showOnlyCurrent) && isEmpty) {\n                                const classes = [\n                                    this.options.emptyNodeClass\n                                ];\n                                if (isEmptyDoc) {\n                                    classes.push(this.options.emptyEditorClass);\n                                }\n                                const decoration = _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_3__.Decoration.node(pos, pos + node.nodeSize, {\n                                    class: classes.join(\" \"),\n                                    \"data-placeholder\": typeof this.options.placeholder === \"function\" ? this.options.placeholder({\n                                        editor: this.editor,\n                                        node,\n                                        pos,\n                                        hasAnchor\n                                    }) : this.options.placeholder\n                                });\n                                decorations.push(decoration);\n                            }\n                            return this.options.includeChildren;\n                        });\n                        return _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_3__.DecorationSet.create(doc, decorations);\n                    }\n                }\n            })\n        ];\n    }\n});\n// src/selection/selection.ts\n\n\n\nvar Selection = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Extension.create({\n    name: \"selection\",\n    addOptions () {\n        return {\n            className: \"selection\"\n        };\n    },\n    addProseMirrorPlugins () {\n        const { editor, options } = this;\n        return [\n            new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n                key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\"selection\"),\n                props: {\n                    decorations (state) {\n                        if (state.selection.empty || editor.isFocused || !editor.isEditable || (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.isNodeSelection)(state.selection) || editor.view.dragging) {\n                            return null;\n                        }\n                        return _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_3__.DecorationSet.create(state.doc, [\n                            _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_3__.Decoration.inline(state.selection.from, state.selection.to, {\n                                class: options.className\n                            })\n                        ]);\n                    }\n                }\n            })\n        ];\n    }\n});\n// src/trailing-node/trailing-node.ts\n\n\nfunction nodeEqualsType({ types, node }) {\n    return node && Array.isArray(types) && types.includes(node.type) || (node == null ? void 0 : node.type) === types;\n}\nvar TrailingNode = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Extension.create({\n    name: \"trailingNode\",\n    addOptions () {\n        return {\n            node: void 0,\n            notAfter: []\n        };\n    },\n    addProseMirrorPlugins () {\n        var _a;\n        const plugin = new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(this.name);\n        const defaultNode = this.options.node || ((_a = this.editor.schema.topNodeType.contentMatch.defaultType) == null ? void 0 : _a.name) || \"paragraph\";\n        const disabledNodes = Object.entries(this.editor.schema.nodes).map(([, value])=>value).filter((node)=>(this.options.notAfter || []).concat(defaultNode).includes(node.name));\n        return [\n            new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n                key: plugin,\n                appendTransaction: (_, __, state)=>{\n                    const { doc, tr, schema } = state;\n                    const shouldInsertNodeAtEnd = plugin.getState(state);\n                    const endPosition = doc.content.size;\n                    const type = schema.nodes[defaultNode];\n                    if (!shouldInsertNodeAtEnd) {\n                        return;\n                    }\n                    return tr.insert(endPosition, type.create());\n                },\n                state: {\n                    init: (_, state)=>{\n                        const lastNode = state.tr.doc.lastChild;\n                        return !nodeEqualsType({\n                            node: lastNode,\n                            types: disabledNodes\n                        });\n                    },\n                    apply: (tr, value)=>{\n                        if (!tr.docChanged) {\n                            return value;\n                        }\n                        if (tr.getMeta(\"__uniqueIDTransaction\")) {\n                            return value;\n                        }\n                        const lastNode = tr.doc.lastChild;\n                        return !nodeEqualsType({\n                            node: lastNode,\n                            types: disabledNodes\n                        });\n                    }\n                }\n            })\n        ];\n    }\n});\n// src/undo-redo/undo-redo.ts\n\n\nvar UndoRedo = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Extension.create({\n    name: \"undoRedo\",\n    addOptions () {\n        return {\n            depth: 100,\n            newGroupDelay: 500\n        };\n    },\n    addCommands () {\n        return {\n            undo: ()=>({ state, dispatch })=>{\n                    return (0,_tiptap_pm_history__WEBPACK_IMPORTED_MODULE_5__.undo)(state, dispatch);\n                },\n            redo: ()=>({ state, dispatch })=>{\n                    return (0,_tiptap_pm_history__WEBPACK_IMPORTED_MODULE_5__.redo)(state, dispatch);\n                }\n        };\n    },\n    addProseMirrorPlugins () {\n        return [\n            (0,_tiptap_pm_history__WEBPACK_IMPORTED_MODULE_5__.history)(this.options)\n        ];\n    },\n    addKeyboardShortcuts () {\n        return {\n            \"Mod-z\": ()=>this.editor.commands.undo(),\n            \"Shift-Mod-z\": ()=>this.editor.commands.redo(),\n            \"Mod-y\": ()=>this.editor.commands.redo(),\n            // Russian keyboard layouts\n            \"Mod-\": ()=>this.editor.commands.undo(),\n            \"Shift-Mod-\": ()=>this.editor.commands.redo()\n        };\n    }\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb25zL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSx5Q0FBeUM7QUFDQTtBQUNZO0FBQ3JELElBQUlHLGlCQUFpQkgsbURBQVNBLENBQUNJLE1BQU0sQ0FBQztJQUNwQ0MsTUFBTTtJQUNOQztRQUNFLE9BQU87WUFDTEMsT0FBTztZQUNQQyxNQUFNO1lBQ05DLGFBQWEsQ0FBQ0MsT0FBU0EsS0FBS0MsTUFBTTtZQUNsQ0MsYUFBYSxDQUFDRixPQUFTQSxLQUFLRyxLQUFLLENBQUMsS0FBS0MsTUFBTSxDQUFDLENBQUNDLE9BQVNBLFNBQVMsSUFBSUosTUFBTTtRQUM3RTtJQUNGO0lBQ0FLO1FBQ0UsT0FBTztZQUNMQyxZQUFZLElBQU07WUFDbEJDLE9BQU8sSUFBTTtRQUNmO0lBQ0Y7SUFDQUM7UUFDRSxJQUFJLENBQUNDLE9BQU8sQ0FBQ0gsVUFBVSxHQUFHLENBQUNJO1lBQ3pCLE1BQU1DLE9BQU8sQ0FBQ0QsV0FBVyxPQUFPLEtBQUssSUFBSUEsUUFBUUMsSUFBSSxLQUFLLElBQUksQ0FBQ0MsTUFBTSxDQUFDQyxLQUFLLENBQUNDLEdBQUc7WUFDL0UsTUFBTWpCLE9BQU8sQ0FBQ2EsV0FBVyxPQUFPLEtBQUssSUFBSUEsUUFBUWIsSUFBSSxLQUFLLElBQUksQ0FBQ2EsT0FBTyxDQUFDYixJQUFJO1lBQzNFLElBQUlBLFNBQVMsWUFBWTtnQkFDdkIsTUFBTUUsT0FBT1ksS0FBS0ksV0FBVyxDQUFDLEdBQUdKLEtBQUtLLE9BQU8sQ0FBQ0MsSUFBSSxFQUFFLEtBQUssR0FBRztnQkFDNUQsT0FBTyxJQUFJLENBQUNQLE9BQU8sQ0FBQ1osV0FBVyxDQUFDQztZQUNsQztZQUNBLE9BQU9ZLEtBQUtPLFFBQVE7UUFDdEI7UUFDQSxJQUFJLENBQUNULE9BQU8sQ0FBQ0YsS0FBSyxHQUFHLENBQUNHO1lBQ3BCLE1BQU1DLE9BQU8sQ0FBQ0QsV0FBVyxPQUFPLEtB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ZXh0ZW5zaW9ucy9kaXN0L2luZGV4LmpzPzM1YzEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2NoYXJhY3Rlci1jb3VudC9jaGFyYWN0ZXItY291bnQudHNcbmltcG9ydCB7IEV4dGVuc2lvbiB9IGZyb20gXCJAdGlwdGFwL2NvcmVcIjtcbmltcG9ydCB7IFBsdWdpbiwgUGx1Z2luS2V5IH0gZnJvbSBcIkB0aXB0YXAvcG0vc3RhdGVcIjtcbnZhciBDaGFyYWN0ZXJDb3VudCA9IEV4dGVuc2lvbi5jcmVhdGUoe1xuICBuYW1lOiBcImNoYXJhY3RlckNvdW50XCIsXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxpbWl0OiBudWxsLFxuICAgICAgbW9kZTogXCJ0ZXh0U2l6ZVwiLFxuICAgICAgdGV4dENvdW50ZXI6ICh0ZXh0KSA9PiB0ZXh0Lmxlbmd0aCxcbiAgICAgIHdvcmRDb3VudGVyOiAodGV4dCkgPT4gdGV4dC5zcGxpdChcIiBcIikuZmlsdGVyKCh3b3JkKSA9PiB3b3JkICE9PSBcIlwiKS5sZW5ndGhcbiAgICB9O1xuICB9LFxuICBhZGRTdG9yYWdlKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjaGFyYWN0ZXJzOiAoKSA9PiAwLFxuICAgICAgd29yZHM6ICgpID0+IDBcbiAgICB9O1xuICB9LFxuICBvbkJlZm9yZUNyZWF0ZSgpIHtcbiAgICB0aGlzLnN0b3JhZ2UuY2hhcmFjdGVycyA9IChvcHRpb25zKSA9PiB7XG4gICAgICBjb25zdCBub2RlID0gKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMubm9kZSkgfHwgdGhpcy5lZGl0b3Iuc3RhdGUuZG9jO1xuICAgICAgY29uc3QgbW9kZSA9IChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLm1vZGUpIHx8IHRoaXMub3B0aW9ucy5tb2RlO1xuICAgICAgaWYgKG1vZGUgPT09IFwidGV4dFNpemVcIikge1xuICAgICAgICBjb25zdCB0ZXh0ID0gbm9kZS50ZXh0QmV0d2VlbigwLCBub2RlLmNvbnRlbnQuc2l6ZSwgdm9pZCAwLCBcIiBcIik7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMudGV4dENvdW50ZXIodGV4dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZS5ub2RlU2l6ZTtcbiAgICB9O1xuICAgIHRoaXMuc3RvcmFnZS53b3JkcyA9IChvcHRpb25zKSA9PiB7XG4gICAgICBjb25zdCBub2RlID0gKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMubm9kZSkgfHwgdGhpcy5lZGl0b3Iuc3RhdGUuZG9jO1xuICAgICAgY29uc3QgdGV4dCA9IG5vZGUudGV4dEJldHdlZW4oMCwgbm9kZS5jb250ZW50LnNpemUsIFwiIFwiLCBcIiBcIik7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLndvcmRDb3VudGVyKHRleHQpO1xuICAgIH07XG4gIH0sXG4gIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICBsZXQgaW5pdGlhbEV2YWx1YXRpb25Eb25lID0gZmFsc2U7XG4gICAgcmV0dXJuIFtcbiAgICAgIG5ldyBQbHVnaW4oe1xuICAgICAgICBrZXk6IG5ldyBQbHVnaW5LZXkoXCJjaGFyYWN0ZXJDb3VudFwiKSxcbiAgICAgICAgYXBwZW5kVHJhbnNhY3Rpb246ICh0cmFuc2FjdGlvbnMsIG9sZFN0YXRlLCBuZXdTdGF0ZSkgPT4ge1xuICAgICAgICAgIGlmIChpbml0aWFsRXZhbHVhdGlvbkRvbmUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgbGltaXQgPSB0aGlzLm9wdGlvbnMubGltaXQ7XG4gICAgICAgICAgaWYgKGxpbWl0ID09PSBudWxsIHx8IGxpbWl0ID09PSB2b2lkIDAgfHwgbGltaXQgPT09IDApIHtcbiAgICAgICAgICAgIGluaXRpYWxFdmFsdWF0aW9uRG9uZSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGluaXRpYWxDb250ZW50U2l6ZSA9IHRoaXMuc3RvcmFnZS5jaGFyYWN0ZXJzKHsgbm9kZTogbmV3U3RhdGUuZG9jIH0pO1xuICAgICAgICAgIGlmIChpbml0aWFsQ29udGVudFNpemUgPiBsaW1pdCkge1xuICAgICAgICAgICAgY29uc3Qgb3ZlciA9IGluaXRpYWxDb250ZW50U2l6ZSAtIGxpbWl0O1xuICAgICAgICAgICAgY29uc3QgZnJvbSA9IDA7XG4gICAgICAgICAgICBjb25zdCB0byA9IG92ZXI7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgIGBbQ2hhcmFjdGVyQ291bnRdIEluaXRpYWwgY29udGVudCBleGNlZWRlZCBsaW1pdCBvZiAke2xpbWl0fSBjaGFyYWN0ZXJzLiBDb250ZW50IHdhcyBhdXRvbWF0aWNhbGx5IHRyaW1tZWQuYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnN0IHRyID0gbmV3U3RhdGUudHIuZGVsZXRlUmFuZ2UoZnJvbSwgdG8pO1xuICAgICAgICAgICAgaW5pdGlhbEV2YWx1YXRpb25Eb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB0cjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW5pdGlhbEV2YWx1YXRpb25Eb25lID0gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZmlsdGVyVHJhbnNhY3Rpb246ICh0cmFuc2FjdGlvbiwgc3RhdGUpID0+IHtcbiAgICAgICAgICBjb25zdCBsaW1pdCA9IHRoaXMub3B0aW9ucy5saW1pdDtcbiAgICAgICAgICBpZiAoIXRyYW5zYWN0aW9uLmRvY0NoYW5nZWQgfHwgbGltaXQgPT09IDAgfHwgbGltaXQgPT09IG51bGwgfHwgbGltaXQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IG9sZFNpemUgPSB0aGlzLnN0b3JhZ2UuY2hhcmFjdGVycyh7IG5vZGU6IHN0YXRlLmRvYyB9KTtcbiAgICAgICAgICBjb25zdCBuZXdTaXplID0gdGhpcy5zdG9yYWdlLmNoYXJhY3RlcnMoeyBub2RlOiB0cmFuc2FjdGlvbi5kb2MgfSk7XG4gICAgICAgICAgaWYgKG5ld1NpemUgPD0gbGltaXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob2xkU2l6ZSA+IGxpbWl0ICYmIG5ld1NpemUgPiBsaW1pdCAmJiBuZXdTaXplIDw9IG9sZFNpemUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob2xkU2l6ZSA+IGxpbWl0ICYmIG5ld1NpemUgPiBsaW1pdCAmJiBuZXdTaXplID4gb2xkU2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBpc1Bhc3RlID0gdHJhbnNhY3Rpb24uZ2V0TWV0YShcInBhc3RlXCIpO1xuICAgICAgICAgIGlmICghaXNQYXN0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBwb3MgPSB0cmFuc2FjdGlvbi5zZWxlY3Rpb24uJGhlYWQucG9zO1xuICAgICAgICAgIGNvbnN0IG92ZXIgPSBuZXdTaXplIC0gbGltaXQ7XG4gICAgICAgICAgY29uc3QgZnJvbSA9IHBvcyAtIG92ZXI7XG4gICAgICAgICAgY29uc3QgdG8gPSBwb3M7XG4gICAgICAgICAgdHJhbnNhY3Rpb24uZGVsZXRlUmFuZ2UoZnJvbSwgdG8pO1xuICAgICAgICAgIGNvbnN0IHVwZGF0ZWRTaXplID0gdGhpcy5zdG9yYWdlLmNoYXJhY3RlcnMoeyBub2RlOiB0cmFuc2FjdGlvbi5kb2MgfSk7XG4gICAgICAgICAgaWYgKHVwZGF0ZWRTaXplID4gbGltaXQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgXTtcbiAgfVxufSk7XG5cbi8vIHNyYy9kcm9wLWN1cnNvci9kcm9wLWN1cnNvci50c1xuaW1wb3J0IHsgRXh0ZW5zaW9uIGFzIEV4dGVuc2lvbjIgfSBmcm9tIFwiQHRpcHRhcC9jb3JlXCI7XG5pbXBvcnQgeyBkcm9wQ3Vyc29yIH0gZnJvbSBcIkB0aXB0YXAvcG0vZHJvcGN1cnNvclwiO1xudmFyIERyb3BjdXJzb3IgPSBFeHRlbnNpb24yLmNyZWF0ZSh7XG4gIG5hbWU6IFwiZHJvcEN1cnNvclwiLFxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb2xvcjogXCJjdXJyZW50Q29sb3JcIixcbiAgICAgIHdpZHRoOiAxLFxuICAgICAgY2xhc3M6IHZvaWQgMFxuICAgIH07XG4gIH0sXG4gIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICByZXR1cm4gW2Ryb3BDdXJzb3IodGhpcy5vcHRpb25zKV07XG4gIH1cbn0pO1xuXG4vLyBzcmMvZm9jdXMvZm9jdXMudHNcbmltcG9ydCB7IEV4dGVuc2lvbiBhcyBFeHRlbnNpb24zIH0gZnJvbSBcIkB0aXB0YXAvY29yZVwiO1xuaW1wb3J0IHsgUGx1Z2luIGFzIFBsdWdpbjIsIFBsdWdpbktleSBhcyBQbHVnaW5LZXkyIH0gZnJvbSBcIkB0aXB0YXAvcG0vc3RhdGVcIjtcbmltcG9ydCB7IERlY29yYXRpb24sIERlY29yYXRpb25TZXQgfSBmcm9tIFwiQHRpcHRhcC9wbS92aWV3XCI7XG52YXIgRm9jdXMgPSBFeHRlbnNpb24zLmNyZWF0ZSh7XG4gIG5hbWU6IFwiZm9jdXNcIixcbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2xhc3NOYW1lOiBcImhhcy1mb2N1c1wiLFxuICAgICAgbW9kZTogXCJhbGxcIlxuICAgIH07XG4gIH0sXG4gIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgbmV3IFBsdWdpbjIoe1xuICAgICAgICBrZXk6IG5ldyBQbHVnaW5LZXkyKFwiZm9jdXNcIiksXG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgZGVjb3JhdGlvbnM6ICh7IGRvYywgc2VsZWN0aW9uIH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgaXNFZGl0YWJsZSwgaXNGb2N1c2VkIH0gPSB0aGlzLmVkaXRvcjtcbiAgICAgICAgICAgIGNvbnN0IHsgYW5jaG9yIH0gPSBzZWxlY3Rpb247XG4gICAgICAgICAgICBjb25zdCBkZWNvcmF0aW9ucyA9IFtdO1xuICAgICAgICAgICAgaWYgKCFpc0VkaXRhYmxlIHx8ICFpc0ZvY3VzZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb25TZXQuY3JlYXRlKGRvYywgW10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG1heExldmVscyA9IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLm1vZGUgPT09IFwiZGVlcGVzdFwiKSB7XG4gICAgICAgICAgICAgIGRvYy5kZXNjZW5kYW50cygobm9kZSwgcG9zKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuaXNUZXh0KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGlzQ3VycmVudCA9IGFuY2hvciA+PSBwb3MgJiYgYW5jaG9yIDw9IHBvcyArIG5vZGUubm9kZVNpemUgLSAxO1xuICAgICAgICAgICAgICAgIGlmICghaXNDdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1heExldmVscyArPSAxO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjdXJyZW50TGV2ZWwgPSAwO1xuICAgICAgICAgICAgZG9jLmRlc2NlbmRhbnRzKChub2RlLCBwb3MpID0+IHtcbiAgICAgICAgICAgICAgaWYgKG5vZGUuaXNUZXh0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IGlzQ3VycmVudCA9IGFuY2hvciA+PSBwb3MgJiYgYW5jaG9yIDw9IHBvcyArIG5vZGUubm9kZVNpemUgLSAxO1xuICAgICAgICAgICAgICBpZiAoIWlzQ3VycmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjdXJyZW50TGV2ZWwgKz0gMTtcbiAgICAgICAgICAgICAgY29uc3Qgb3V0T2ZTY29wZSA9IHRoaXMub3B0aW9ucy5tb2RlID09PSBcImRlZXBlc3RcIiAmJiBtYXhMZXZlbHMgLSBjdXJyZW50TGV2ZWwgPiAwIHx8IHRoaXMub3B0aW9ucy5tb2RlID09PSBcInNoYWxsb3dlc3RcIiAmJiBjdXJyZW50TGV2ZWwgPiAxO1xuICAgICAgICAgICAgICBpZiAob3V0T2ZTY29wZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMubW9kZSA9PT0gXCJkZWVwZXN0XCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGVjb3JhdGlvbnMucHVzaChcbiAgICAgICAgICAgICAgICBEZWNvcmF0aW9uLm5vZGUocG9zLCBwb3MgKyBub2RlLm5vZGVTaXplLCB7XG4gICAgICAgICAgICAgICAgICBjbGFzczogdGhpcy5vcHRpb25zLmNsYXNzTmFtZVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uU2V0LmNyZWF0ZShkb2MsIGRlY29yYXRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgXTtcbiAgfVxufSk7XG5cbi8vIHNyYy9nYXAtY3Vyc29yL2dhcC1jdXJzb3IudHNcbmltcG9ydCB7IGNhbGxPclJldHVybiwgRXh0ZW5zaW9uIGFzIEV4dGVuc2lvbjQsIGdldEV4dGVuc2lvbkZpZWxkIH0gZnJvbSBcIkB0aXB0YXAvY29yZVwiO1xuaW1wb3J0IHsgZ2FwQ3Vyc29yIH0gZnJvbSBcIkB0aXB0YXAvcG0vZ2FwY3Vyc29yXCI7XG52YXIgR2FwY3Vyc29yID0gRXh0ZW5zaW9uNC5jcmVhdGUoe1xuICBuYW1lOiBcImdhcEN1cnNvclwiLFxuICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgcmV0dXJuIFtnYXBDdXJzb3IoKV07XG4gIH0sXG4gIGV4dGVuZE5vZGVTY2hlbWEoZXh0ZW5zaW9uKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2VcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICBhbGxvd0dhcEN1cnNvcjogKF9hID0gY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgXCJhbGxvd0dhcEN1cnNvclwiLCBjb250ZXh0KSkpICE9IG51bGwgPyBfYSA6IG51bGxcbiAgICB9O1xuICB9XG59KTtcblxuLy8gc3JjL3BsYWNlaG9sZGVyL3BsYWNlaG9sZGVyLnRzXG5pbXBvcnQgeyBFeHRlbnNpb24gYXMgRXh0ZW5zaW9uNSwgaXNOb2RlRW1wdHkgfSBmcm9tIFwiQHRpcHRhcC9jb3JlXCI7XG5pbXBvcnQgeyBQbHVnaW4gYXMgUGx1Z2luMywgUGx1Z2luS2V5IGFzIFBsdWdpbktleTMgfSBmcm9tIFwiQHRpcHRhcC9wbS9zdGF0ZVwiO1xuaW1wb3J0IHsgRGVjb3JhdGlvbiBhcyBEZWNvcmF0aW9uMiwgRGVjb3JhdGlvblNldCBhcyBEZWNvcmF0aW9uU2V0MiB9IGZyb20gXCJAdGlwdGFwL3BtL3ZpZXdcIjtcbnZhciBQbGFjZWhvbGRlciA9IEV4dGVuc2lvbjUuY3JlYXRlKHtcbiAgbmFtZTogXCJwbGFjZWhvbGRlclwiLFxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBlbXB0eUVkaXRvckNsYXNzOiBcImlzLWVkaXRvci1lbXB0eVwiLFxuICAgICAgZW1wdHlOb2RlQ2xhc3M6IFwiaXMtZW1wdHlcIixcbiAgICAgIHBsYWNlaG9sZGVyOiBcIldyaXRlIHNvbWV0aGluZyBcXHUyMDI2XCIsXG4gICAgICBzaG93T25seVdoZW5FZGl0YWJsZTogdHJ1ZSxcbiAgICAgIHNob3dPbmx5Q3VycmVudDogdHJ1ZSxcbiAgICAgIGluY2x1ZGVDaGlsZHJlbjogZmFsc2VcbiAgICB9O1xuICB9LFxuICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG5ldyBQbHVnaW4zKHtcbiAgICAgICAga2V5OiBuZXcgUGx1Z2luS2V5MyhcInBsYWNlaG9sZGVyXCIpLFxuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIGRlY29yYXRpb25zOiAoeyBkb2MsIHNlbGVjdGlvbiB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhY3RpdmUgPSB0aGlzLmVkaXRvci5pc0VkaXRhYmxlIHx8ICF0aGlzLm9wdGlvbnMuc2hvd09ubHlXaGVuRWRpdGFibGU7XG4gICAgICAgICAgICBjb25zdCB7IGFuY2hvciB9ID0gc2VsZWN0aW9uO1xuICAgICAgICAgICAgY29uc3QgZGVjb3JhdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIGlmICghYWN0aXZlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaXNFbXB0eURvYyA9IHRoaXMuZWRpdG9yLmlzRW1wdHk7XG4gICAgICAgICAgICBkb2MuZGVzY2VuZGFudHMoKG5vZGUsIHBvcykgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBoYXNBbmNob3IgPSBhbmNob3IgPj0gcG9zICYmIGFuY2hvciA8PSBwb3MgKyBub2RlLm5vZGVTaXplO1xuICAgICAgICAgICAgICBjb25zdCBpc0VtcHR5ID0gIW5vZGUuaXNMZWFmICYmIGlzTm9kZUVtcHR5KG5vZGUpO1xuICAgICAgICAgICAgICBpZiAoKGhhc0FuY2hvciB8fCAhdGhpcy5vcHRpb25zLnNob3dPbmx5Q3VycmVudCkgJiYgaXNFbXB0eSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsYXNzZXMgPSBbdGhpcy5vcHRpb25zLmVtcHR5Tm9kZUNsYXNzXTtcbiAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eURvYykge1xuICAgICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKHRoaXMub3B0aW9ucy5lbXB0eUVkaXRvckNsYXNzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZGVjb3JhdGlvbiA9IERlY29yYXRpb24yLm5vZGUocG9zLCBwb3MgKyBub2RlLm5vZGVTaXplLCB7XG4gICAgICAgICAgICAgICAgICBjbGFzczogY2xhc3Nlcy5qb2luKFwiIFwiKSxcbiAgICAgICAgICAgICAgICAgIFwiZGF0YS1wbGFjZWhvbGRlclwiOiB0eXBlb2YgdGhpcy5vcHRpb25zLnBsYWNlaG9sZGVyID09PSBcImZ1bmN0aW9uXCIgPyB0aGlzLm9wdGlvbnMucGxhY2Vob2xkZXIoe1xuICAgICAgICAgICAgICAgICAgICBlZGl0b3I6IHRoaXMuZWRpdG9yLFxuICAgICAgICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICAgICAgICBwb3MsXG4gICAgICAgICAgICAgICAgICAgIGhhc0FuY2hvclxuICAgICAgICAgICAgICAgICAgfSkgOiB0aGlzLm9wdGlvbnMucGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBkZWNvcmF0aW9ucy5wdXNoKGRlY29yYXRpb24pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuaW5jbHVkZUNoaWxkcmVuO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvblNldDIuY3JlYXRlKGRvYywgZGVjb3JhdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICBdO1xuICB9XG59KTtcblxuLy8gc3JjL3NlbGVjdGlvbi9zZWxlY3Rpb24udHNcbmltcG9ydCB7IEV4dGVuc2lvbiBhcyBFeHRlbnNpb242LCBpc05vZGVTZWxlY3Rpb24gfSBmcm9tIFwiQHRpcHRhcC9jb3JlXCI7XG5pbXBvcnQgeyBQbHVnaW4gYXMgUGx1Z2luNCwgUGx1Z2luS2V5IGFzIFBsdWdpbktleTQgfSBmcm9tIFwiQHRpcHRhcC9wbS9zdGF0ZVwiO1xuaW1wb3J0IHsgRGVjb3JhdGlvbiBhcyBEZWNvcmF0aW9uMywgRGVjb3JhdGlvblNldCBhcyBEZWNvcmF0aW9uU2V0MyB9IGZyb20gXCJAdGlwdGFwL3BtL3ZpZXdcIjtcbnZhciBTZWxlY3Rpb24gPSBFeHRlbnNpb242LmNyZWF0ZSh7XG4gIG5hbWU6IFwic2VsZWN0aW9uXCIsXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsYXNzTmFtZTogXCJzZWxlY3Rpb25cIlxuICAgIH07XG4gIH0sXG4gIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICBjb25zdCB7IGVkaXRvciwgb3B0aW9ucyB9ID0gdGhpcztcbiAgICByZXR1cm4gW1xuICAgICAgbmV3IFBsdWdpbjQoe1xuICAgICAgICBrZXk6IG5ldyBQbHVnaW5LZXk0KFwic2VsZWN0aW9uXCIpLFxuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIGRlY29yYXRpb25zKHN0YXRlKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUuc2VsZWN0aW9uLmVtcHR5IHx8IGVkaXRvci5pc0ZvY3VzZWQgfHwgIWVkaXRvci5pc0VkaXRhYmxlIHx8IGlzTm9kZVNlbGVjdGlvbihzdGF0ZS5zZWxlY3Rpb24pIHx8IGVkaXRvci52aWV3LmRyYWdnaW5nKSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb25TZXQzLmNyZWF0ZShzdGF0ZS5kb2MsIFtcbiAgICAgICAgICAgICAgRGVjb3JhdGlvbjMuaW5saW5lKHN0YXRlLnNlbGVjdGlvbi5mcm9tLCBzdGF0ZS5zZWxlY3Rpb24udG8sIHtcbiAgICAgICAgICAgICAgICBjbGFzczogb3B0aW9ucy5jbGFzc05hbWVcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICBdO1xuICB9XG59KTtcblxuLy8gc3JjL3RyYWlsaW5nLW5vZGUvdHJhaWxpbmctbm9kZS50c1xuaW1wb3J0IHsgRXh0ZW5zaW9uIGFzIEV4dGVuc2lvbjcgfSBmcm9tIFwiQHRpcHRhcC9jb3JlXCI7XG5pbXBvcnQgeyBQbHVnaW4gYXMgUGx1Z2luNSwgUGx1Z2luS2V5IGFzIFBsdWdpbktleTUgfSBmcm9tIFwiQHRpcHRhcC9wbS9zdGF0ZVwiO1xuZnVuY3Rpb24gbm9kZUVxdWFsc1R5cGUoeyB0eXBlcywgbm9kZSB9KSB7XG4gIHJldHVybiBub2RlICYmIEFycmF5LmlzQXJyYXkodHlwZXMpICYmIHR5cGVzLmluY2x1ZGVzKG5vZGUudHlwZSkgfHwgKG5vZGUgPT0gbnVsbCA/IHZvaWQgMCA6IG5vZGUudHlwZSkgPT09IHR5cGVzO1xufVxudmFyIFRyYWlsaW5nTm9kZSA9IEV4dGVuc2lvbjcuY3JlYXRlKHtcbiAgbmFtZTogXCJ0cmFpbGluZ05vZGVcIixcbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbm9kZTogdm9pZCAwLFxuICAgICAgbm90QWZ0ZXI6IFtdXG4gICAgfTtcbiAgfSxcbiAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBwbHVnaW4gPSBuZXcgUGx1Z2luS2V5NSh0aGlzLm5hbWUpO1xuICAgIGNvbnN0IGRlZmF1bHROb2RlID0gdGhpcy5vcHRpb25zLm5vZGUgfHwgKChfYSA9IHRoaXMuZWRpdG9yLnNjaGVtYS50b3BOb2RlVHlwZS5jb250ZW50TWF0Y2guZGVmYXVsdFR5cGUpID09IG51bGwgPyB2b2lkIDAgOiBfYS5uYW1lKSB8fCBcInBhcmFncmFwaFwiO1xuICAgIGNvbnN0IGRpc2FibGVkTm9kZXMgPSBPYmplY3QuZW50cmllcyh0aGlzLmVkaXRvci5zY2hlbWEubm9kZXMpLm1hcCgoWywgdmFsdWVdKSA9PiB2YWx1ZSkuZmlsdGVyKChub2RlKSA9PiAodGhpcy5vcHRpb25zLm5vdEFmdGVyIHx8IFtdKS5jb25jYXQoZGVmYXVsdE5vZGUpLmluY2x1ZGVzKG5vZGUubmFtZSkpO1xuICAgIHJldHVybiBbXG4gICAgICBuZXcgUGx1Z2luNSh7XG4gICAgICAgIGtleTogcGx1Z2luLFxuICAgICAgICBhcHBlbmRUcmFuc2FjdGlvbjogKF8sIF9fLCBzdGF0ZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgZG9jLCB0ciwgc2NoZW1hIH0gPSBzdGF0ZTtcbiAgICAgICAgICBjb25zdCBzaG91bGRJbnNlcnROb2RlQXRFbmQgPSBwbHVnaW4uZ2V0U3RhdGUoc3RhdGUpO1xuICAgICAgICAgIGNvbnN0IGVuZFBvc2l0aW9uID0gZG9jLmNvbnRlbnQuc2l6ZTtcbiAgICAgICAgICBjb25zdCB0eXBlID0gc2NoZW1hLm5vZGVzW2RlZmF1bHROb2RlXTtcbiAgICAgICAgICBpZiAoIXNob3VsZEluc2VydE5vZGVBdEVuZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHIuaW5zZXJ0KGVuZFBvc2l0aW9uLCB0eXBlLmNyZWF0ZSgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgc3RhdGU6IHtcbiAgICAgICAgICBpbml0OiAoXywgc3RhdGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxhc3ROb2RlID0gc3RhdGUudHIuZG9jLmxhc3RDaGlsZDtcbiAgICAgICAgICAgIHJldHVybiAhbm9kZUVxdWFsc1R5cGUoeyBub2RlOiBsYXN0Tm9kZSwgdHlwZXM6IGRpc2FibGVkTm9kZXMgfSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBhcHBseTogKHRyLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0ci5kb2NDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0ci5nZXRNZXRhKFwiX191bmlxdWVJRFRyYW5zYWN0aW9uXCIpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxhc3ROb2RlID0gdHIuZG9jLmxhc3RDaGlsZDtcbiAgICAgICAgICAgIHJldHVybiAhbm9kZUVxdWFsc1R5cGUoeyBub2RlOiBsYXN0Tm9kZSwgdHlwZXM6IGRpc2FibGVkTm9kZXMgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIF07XG4gIH1cbn0pO1xuXG4vLyBzcmMvdW5kby1yZWRvL3VuZG8tcmVkby50c1xuaW1wb3J0IHsgRXh0ZW5zaW9uIGFzIEV4dGVuc2lvbjggfSBmcm9tIFwiQHRpcHRhcC9jb3JlXCI7XG5pbXBvcnQgeyBoaXN0b3J5LCByZWRvLCB1bmRvIH0gZnJvbSBcIkB0aXB0YXAvcG0vaGlzdG9yeVwiO1xudmFyIFVuZG9SZWRvID0gRXh0ZW5zaW9uOC5jcmVhdGUoe1xuICBuYW1lOiBcInVuZG9SZWRvXCIsXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRlcHRoOiAxMDAsXG4gICAgICBuZXdHcm91cERlbGF5OiA1MDBcbiAgICB9O1xuICB9LFxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdW5kbzogKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIHVuZG8oc3RhdGUsIGRpc3BhdGNoKTtcbiAgICAgIH0sXG4gICAgICByZWRvOiAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgICAgICByZXR1cm4gcmVkbyhzdGF0ZSwgZGlzcGF0Y2gpO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICByZXR1cm4gW2hpc3RvcnkodGhpcy5vcHRpb25zKV07XG4gIH0sXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBcIk1vZC16XCI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnVuZG8oKSxcbiAgICAgIFwiU2hpZnQtTW9kLXpcIjogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMucmVkbygpLFxuICAgICAgXCJNb2QteVwiOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5yZWRvKCksXG4gICAgICAvLyBSdXNzaWFuIGtleWJvYXJkIGxheW91dHNcbiAgICAgIFwiTW9kLVxcdTA0NEZcIjogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudW5kbygpLFxuICAgICAgXCJTaGlmdC1Nb2QtXFx1MDQ0RlwiOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5yZWRvKClcbiAgICB9O1xuICB9XG59KTtcbmV4cG9ydCB7XG4gIENoYXJhY3RlckNvdW50LFxuICBEcm9wY3Vyc29yLFxuICBGb2N1cyxcbiAgR2FwY3Vyc29yLFxuICBQbGFjZWhvbGRlcixcbiAgU2VsZWN0aW9uLFxuICBUcmFpbGluZ05vZGUsXG4gIFVuZG9SZWRvXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIkV4dGVuc2lvbiIsIlBsdWdpbiIsIlBsdWdpbktleSIsIkNoYXJhY3RlckNvdW50IiwiY3JlYXRlIiwibmFtZSIsImFkZE9wdGlvbnMiLCJsaW1pdCIsIm1vZGUiLCJ0ZXh0Q291bnRlciIsInRleHQiLCJsZW5ndGgiLCJ3b3JkQ291bnRlciIsInNwbGl0IiwiZmlsdGVyIiwid29yZCIsImFkZFN0b3JhZ2UiLCJjaGFyYWN0ZXJzIiwid29yZHMiLCJvbkJlZm9yZUNyZWF0ZSIsInN0b3JhZ2UiLCJvcHRpb25zIiwibm9kZSIsImVkaXRvciIsInN0YXRlIiwiZG9jIiwidGV4dEJldHdlZW4iLCJjb250ZW50Iiwic2l6ZSIsIm5vZGVTaXplIiwiYWRkUHJvc2VNaXJyb3JQbHVnaW5zIiwiaW5pdGlhbEV2YWx1YXRpb25Eb25lIiwia2V5IiwiYXBwZW5kVHJhbnNhY3Rpb24iLCJ0cmFuc2FjdGlvbnMiLCJvbGRTdGF0ZSIsIm5ld1N0YXRlIiwiaW5pdGlhbENvbnRlbnRTaXplIiwib3ZlciIsImZyb20iLCJ0byIsImNvbnNvbGUiLCJ3YXJuIiwidHIiLCJkZWxldGVSYW5nZSIsImZpbHRlclRyYW5zYWN0aW9uIiwidHJhbnNhY3Rpb24iLCJkb2NDaGFuZ2VkIiwib2xkU2l6ZSIsIm5ld1NpemUiLCJpc1Bhc3RlIiwiZ2V0TWV0YSIsInBvcyIsInNlbGVjdGlvbiIsIiRoZWFkIiwidXBkYXRlZFNpemUiLCJFeHRlbnNpb24yIiwiZHJvcEN1cnNvciIsIkRyb3BjdXJzb3IiLCJjb2xvciIsIndpZHRoIiwiY2xhc3MiLCJFeHRlbnNpb24zIiwiUGx1Z2luMiIsIlBsdWdpbktleTIiLCJEZWNvcmF0aW9uIiwiRGVjb3JhdGlvblNldCIsIkZvY3VzIiwiY2xhc3NOYW1lIiwicHJvcHMiLCJkZWNvcmF0aW9ucyIsImlzRWRpdGFibGUiLCJpc0ZvY3VzZWQiLCJhbmNob3IiLCJtYXhMZXZlbHMiLCJkZXNjZW5kYW50cyIsImlzVGV4dCIsImlzQ3VycmVudCIsImN1cnJlbnRMZXZlbCIsIm91dE9mU2NvcGUiLCJwdXNoIiwiY2FsbE9yUmV0dXJuIiwiRXh0ZW5zaW9uNCIsImdldEV4dGVuc2lvbkZpZWxkIiwiZ2FwQ3Vyc29yIiwiR2FwY3Vyc29yIiwiZXh0ZW5kTm9kZVNjaGVtYSIsImV4dGVuc2lvbiIsIl9hIiwiY29udGV4dCIsImFsbG93R2FwQ3Vyc29yIiwiRXh0ZW5zaW9uNSIsImlzTm9kZUVtcHR5IiwiUGx1Z2luMyIsIlBsdWdpbktleTMiLCJEZWNvcmF0aW9uMiIsIkRlY29yYXRpb25TZXQyIiwiUGxhY2Vob2xkZXIiLCJlbXB0eUVkaXRvckNsYXNzIiwiZW1wdHlOb2RlQ2xhc3MiLCJwbGFjZWhvbGRlciIsInNob3dPbmx5V2hlbkVkaXRhYmxlIiwic2hvd09ubHlDdXJyZW50IiwiaW5jbHVkZUNoaWxkcmVuIiwiYWN0aXZlIiwiaXNFbXB0eURvYyIsImlzRW1wdHkiLCJoYXNBbmNob3IiLCJpc0xlYWYiLCJjbGFzc2VzIiwiZGVjb3JhdGlvbiIsImpvaW4iLCJFeHRlbnNpb242IiwiaXNOb2RlU2VsZWN0aW9uIiwiUGx1Z2luNCIsIlBsdWdpbktleTQiLCJEZWNvcmF0aW9uMyIsIkRlY29yYXRpb25TZXQzIiwiU2VsZWN0aW9uIiwiZW1wdHkiLCJ2aWV3IiwiZHJhZ2dpbmciLCJpbmxpbmUiLCJFeHRlbnNpb243IiwiUGx1Z2luNSIsIlBsdWdpbktleTUiLCJub2RlRXF1YWxzVHlwZSIsInR5cGVzIiwiQXJyYXkiLCJpc0FycmF5IiwiaW5jbHVkZXMiLCJ0eXBlIiwiVHJhaWxpbmdOb2RlIiwibm90QWZ0ZXIiLCJwbHVnaW4iLCJkZWZhdWx0Tm9kZSIsInNjaGVtYSIsInRvcE5vZGVUeXBlIiwiY29udGVudE1hdGNoIiwiZGVmYXVsdFR5cGUiLCJkaXNhYmxlZE5vZGVzIiwiT2JqZWN0IiwiZW50cmllcyIsIm5vZGVzIiwibWFwIiwidmFsdWUiLCJjb25jYXQiLCJfIiwiX18iLCJzaG91bGRJbnNlcnROb2RlQXRFbmQiLCJnZXRTdGF0ZSIsImVuZFBvc2l0aW9uIiwiaW5zZXJ0IiwiaW5pdCIsImxhc3ROb2RlIiwibGFzdENoaWxkIiwiYXBwbHkiLCJFeHRlbnNpb244IiwiaGlzdG9yeSIsInJlZG8iLCJ1bmRvIiwiVW5kb1JlZG8iLCJkZXB0aCIsIm5ld0dyb3VwRGVsYXkiLCJhZGRDb21tYW5kcyIsImRpc3BhdGNoIiwiYWRkS2V5Ym9hcmRTaG9ydGN1dHMiLCJjb21tYW5kcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extensions/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/pm/dist/commands/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@tiptap/pm/dist/commands/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   autoJoin: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.autoJoin),\n/* harmony export */   baseKeymap: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.baseKeymap),\n/* harmony export */   chainCommands: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.chainCommands),\n/* harmony export */   createParagraphNear: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.createParagraphNear),\n/* harmony export */   deleteSelection: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.deleteSelection),\n/* harmony export */   exitCode: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.exitCode),\n/* harmony export */   joinBackward: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.joinBackward),\n/* harmony export */   joinDown: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.joinDown),\n/* harmony export */   joinForward: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.joinForward),\n/* harmony export */   joinTextblockBackward: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.joinTextblockBackward),\n/* harmony export */   joinTextblockForward: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.joinTextblockForward),\n/* harmony export */   joinUp: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.joinUp),\n/* harmony export */   lift: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.lift),\n/* harmony export */   liftEmptyBlock: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.liftEmptyBlock),\n/* harmony export */   macBaseKeymap: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.macBaseKeymap),\n/* harmony export */   newlineInCode: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.newlineInCode),\n/* harmony export */   pcBaseKeymap: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.pcBaseKeymap),\n/* harmony export */   selectAll: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.selectAll),\n/* harmony export */   selectNodeBackward: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.selectNodeBackward),\n/* harmony export */   selectNodeForward: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.selectNodeForward),\n/* harmony export */   selectParentNode: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.selectParentNode),\n/* harmony export */   selectTextblockEnd: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.selectTextblockEnd),\n/* harmony export */   selectTextblockStart: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.selectTextblockStart),\n/* harmony export */   setBlockType: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.setBlockType),\n/* harmony export */   splitBlock: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.splitBlock),\n/* harmony export */   splitBlockAs: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.splitBlockAs),\n/* harmony export */   splitBlockKeepMarks: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.splitBlockKeepMarks),\n/* harmony export */   toggleMark: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.toggleMark),\n/* harmony export */   wrapIn: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.wrapIn)\n/* harmony export */ });\n/* harmony import */ var prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-commands */ \"(ssr)/./node_modules/prosemirror-commands/dist/index.js\");\n// commands/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9kaXN0L2NvbW1hbmRzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLG9CQUFvQjtBQUNpQiIsInNvdXJjZXMiOlsid2VicGFjazovL3ByYXNvYnBhaS13ZWIvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9kaXN0L2NvbW1hbmRzL2luZGV4LmpzP2Q5ODIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gY29tbWFuZHMvaW5kZXgudHNcbmV4cG9ydCAqIGZyb20gXCJwcm9zZW1pcnJvci1jb21tYW5kc1wiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/pm/dist/commands/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/pm/dist/dropcursor/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@tiptap/pm/dist/dropcursor/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   dropCursor: () => (/* reexport safe */ prosemirror_dropcursor__WEBPACK_IMPORTED_MODULE_0__.dropCursor)\n/* harmony export */ });\n/* harmony import */ var prosemirror_dropcursor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-dropcursor */ \"(ssr)/./node_modules/prosemirror-dropcursor/dist/index.js\");\n// dropcursor/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9kaXN0L2Ryb3BjdXJzb3IvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxzQkFBc0I7QUFDaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcmFzb2JwYWktd2ViLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvcG0vZGlzdC9kcm9wY3Vyc29yL2luZGV4LmpzPzk3MWUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZHJvcGN1cnNvci9pbmRleC50c1xuZXhwb3J0ICogZnJvbSBcInByb3NlbWlycm9yLWRyb3BjdXJzb3JcIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/pm/dist/dropcursor/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/pm/dist/gapcursor/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@tiptap/pm/dist/gapcursor/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GapCursor: () => (/* reexport safe */ prosemirror_gapcursor__WEBPACK_IMPORTED_MODULE_0__.GapCursor),\n/* harmony export */   gapCursor: () => (/* reexport safe */ prosemirror_gapcursor__WEBPACK_IMPORTED_MODULE_0__.gapCursor)\n/* harmony export */ });\n/* harmony import */ var prosemirror_gapcursor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-gapcursor */ \"(ssr)/./node_modules/prosemirror-gapcursor/dist/index.js\");\n// gapcursor/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9kaXN0L2dhcGN1cnNvci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxxQkFBcUI7QUFDaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcmFzb2JwYWktd2ViLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvcG0vZGlzdC9nYXBjdXJzb3IvaW5kZXguanM/Y2M1ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBnYXBjdXJzb3IvaW5kZXgudHNcbmV4cG9ydCAqIGZyb20gXCJwcm9zZW1pcnJvci1nYXBjdXJzb3JcIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/pm/dist/gapcursor/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/pm/dist/history/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@tiptap/pm/dist/history/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   closeHistory: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.closeHistory),\n/* harmony export */   history: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.history),\n/* harmony export */   isHistoryTransaction: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.isHistoryTransaction),\n/* harmony export */   redo: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.redo),\n/* harmony export */   redoDepth: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.redoDepth),\n/* harmony export */   redoNoScroll: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.redoNoScroll),\n/* harmony export */   undo: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.undo),\n/* harmony export */   undoDepth: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.undoDepth),\n/* harmony export */   undoNoScroll: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.undoNoScroll)\n/* harmony export */ });\n/* harmony import */ var prosemirror_history__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-history */ \"(ssr)/./node_modules/prosemirror-history/dist/index.js\");\n// history/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9kaXN0L2hpc3RvcnkvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBLG1CQUFtQjtBQUNpQiIsInNvdXJjZXMiOlsid2VicGFjazovL3ByYXNvYnBhaS13ZWIvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9kaXN0L2hpc3RvcnkvaW5kZXguanM/ZGQ3MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBoaXN0b3J5L2luZGV4LnRzXG5leHBvcnQgKiBmcm9tIFwicHJvc2VtaXJyb3ItaGlzdG9yeVwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/pm/dist/history/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/pm/dist/keymap/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@tiptap/pm/dist/keymap/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   keydownHandler: () => (/* reexport safe */ prosemirror_keymap__WEBPACK_IMPORTED_MODULE_0__.keydownHandler),\n/* harmony export */   keymap: () => (/* reexport safe */ prosemirror_keymap__WEBPACK_IMPORTED_MODULE_0__.keymap)\n/* harmony export */ });\n/* harmony import */ var prosemirror_keymap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-keymap */ \"(ssr)/./node_modules/prosemirror-keymap/dist/index.js\");\n// keymap/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9kaXN0L2tleW1hcC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxrQkFBa0I7QUFDaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcmFzb2JwYWktd2ViLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvcG0vZGlzdC9rZXltYXAvaW5kZXguanM/NDkxMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBrZXltYXAvaW5kZXgudHNcbmV4cG9ydCAqIGZyb20gXCJwcm9zZW1pcnJvci1rZXltYXBcIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/pm/dist/keymap/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/pm/dist/model/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@tiptap/pm/dist/model/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ContentMatch: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.ContentMatch),\n/* harmony export */   DOMParser: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMParser),\n/* harmony export */   DOMSerializer: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMSerializer),\n/* harmony export */   Fragment: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment),\n/* harmony export */   Mark: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Mark),\n/* harmony export */   MarkType: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.MarkType),\n/* harmony export */   Node: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Node),\n/* harmony export */   NodeRange: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.NodeRange),\n/* harmony export */   NodeType: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.NodeType),\n/* harmony export */   ReplaceError: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.ReplaceError),\n/* harmony export */   ResolvedPos: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.ResolvedPos),\n/* harmony export */   Schema: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Schema),\n/* harmony export */   Slice: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice)\n/* harmony export */ });\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-model */ \"(ssr)/./node_modules/prosemirror-model/dist/index.js\");\n// model/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9kaXN0L21vZGVsL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsaUJBQWlCO0FBQ2lCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJhc29icGFpLXdlYi8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL3BtL2Rpc3QvbW9kZWwvaW5kZXguanM/YWEwYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBtb2RlbC9pbmRleC50c1xuZXhwb3J0ICogZnJvbSBcInByb3NlbWlycm9yLW1vZGVsXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/pm/dist/model/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/pm/dist/schema-list/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@tiptap/pm/dist/schema-list/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addListNodes: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.addListNodes),\n/* harmony export */   bulletList: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.bulletList),\n/* harmony export */   liftListItem: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.liftListItem),\n/* harmony export */   listItem: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.listItem),\n/* harmony export */   orderedList: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.orderedList),\n/* harmony export */   sinkListItem: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.sinkListItem),\n/* harmony export */   splitListItem: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.splitListItem),\n/* harmony export */   splitListItemKeepMarks: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.splitListItemKeepMarks),\n/* harmony export */   wrapInList: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.wrapInList),\n/* harmony export */   wrapRangeInList: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.wrapRangeInList)\n/* harmony export */ });\n/* harmony import */ var prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-schema-list */ \"(ssr)/./node_modules/prosemirror-schema-list/dist/index.js\");\n// schema-list/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9kaXN0L3NjaGVtYS1saXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUEsdUJBQXVCO0FBQ2lCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJhc29icGFpLXdlYi8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL3BtL2Rpc3Qvc2NoZW1hLWxpc3QvaW5kZXguanM/ZTUzMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzY2hlbWEtbGlzdC9pbmRleC50c1xuZXhwb3J0ICogZnJvbSBcInByb3NlbWlycm9yLXNjaGVtYS1saXN0XCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/pm/dist/schema-list/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/pm/dist/state/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@tiptap/pm/dist/state/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AllSelection: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.AllSelection),\n/* harmony export */   EditorState: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorState),\n/* harmony export */   NodeSelection: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection),\n/* harmony export */   Plugin: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin),\n/* harmony export */   PluginKey: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey),\n/* harmony export */   Selection: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection),\n/* harmony export */   SelectionRange: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.SelectionRange),\n/* harmony export */   TextSelection: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection),\n/* harmony export */   Transaction: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Transaction)\n/* harmony export */ });\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-state */ \"(ssr)/./node_modules/prosemirror-state/dist/index.js\");\n// state/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9kaXN0L3N0YXRlL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQSxpQkFBaUI7QUFDaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcmFzb2JwYWktd2ViLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvcG0vZGlzdC9zdGF0ZS9pbmRleC5qcz81NmY0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHN0YXRlL2luZGV4LnRzXG5leHBvcnQgKiBmcm9tIFwicHJvc2VtaXJyb3Itc3RhdGVcIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/pm/dist/state/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/pm/dist/transform/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@tiptap/pm/dist/transform/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AddMarkStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.AddMarkStep),\n/* harmony export */   AddNodeMarkStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.AddNodeMarkStep),\n/* harmony export */   AttrStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.AttrStep),\n/* harmony export */   DocAttrStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.DocAttrStep),\n/* harmony export */   MapResult: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.MapResult),\n/* harmony export */   Mapping: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.Mapping),\n/* harmony export */   RemoveMarkStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.RemoveMarkStep),\n/* harmony export */   RemoveNodeMarkStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.RemoveNodeMarkStep),\n/* harmony export */   ReplaceAroundStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.ReplaceAroundStep),\n/* harmony export */   ReplaceStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.ReplaceStep),\n/* harmony export */   Step: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.Step),\n/* harmony export */   StepMap: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.StepMap),\n/* harmony export */   StepResult: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.StepResult),\n/* harmony export */   Transform: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.Transform),\n/* harmony export */   TransformError: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.TransformError),\n/* harmony export */   canJoin: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin),\n/* harmony export */   canSplit: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit),\n/* harmony export */   dropPoint: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.dropPoint),\n/* harmony export */   findWrapping: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.findWrapping),\n/* harmony export */   insertPoint: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.insertPoint),\n/* harmony export */   joinPoint: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.joinPoint),\n/* harmony export */   liftTarget: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.liftTarget),\n/* harmony export */   replaceStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.replaceStep)\n/* harmony export */ });\n/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-transform */ \"(ssr)/./node_modules/prosemirror-transform/dist/index.js\");\n// transform/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9kaXN0L3RyYW5zZm9ybS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxxQkFBcUI7QUFDaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcmFzb2JwYWktd2ViLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvcG0vZGlzdC90cmFuc2Zvcm0vaW5kZXguanM/MTVkMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyB0cmFuc2Zvcm0vaW5kZXgudHNcbmV4cG9ydCAqIGZyb20gXCJwcm9zZW1pcnJvci10cmFuc2Zvcm1cIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/pm/dist/transform/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/pm/dist/view/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@tiptap/pm/dist/view/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Decoration: () => (/* reexport safe */ prosemirror_view__WEBPACK_IMPORTED_MODULE_0__.Decoration),\n/* harmony export */   DecorationSet: () => (/* reexport safe */ prosemirror_view__WEBPACK_IMPORTED_MODULE_0__.DecorationSet),\n/* harmony export */   EditorView: () => (/* reexport safe */ prosemirror_view__WEBPACK_IMPORTED_MODULE_0__.EditorView),\n/* harmony export */   __endComposition: () => (/* reexport safe */ prosemirror_view__WEBPACK_IMPORTED_MODULE_0__.__endComposition),\n/* harmony export */   __parseFromClipboard: () => (/* reexport safe */ prosemirror_view__WEBPACK_IMPORTED_MODULE_0__.__parseFromClipboard)\n/* harmony export */ });\n/* harmony import */ var prosemirror_view__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-view */ \"(ssr)/./node_modules/prosemirror-view/dist/index.js\");\n// view/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9kaXN0L3ZpZXcvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsZ0JBQWdCO0FBQ2lCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJhc29icGFpLXdlYi8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL3BtL2Rpc3Qvdmlldy9pbmRleC5qcz9jYWVhIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHZpZXcvaW5kZXgudHNcbmV4cG9ydCAqIGZyb20gXCJwcm9zZW1pcnJvci12aWV3XCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/pm/dist/view/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/react/dist/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@tiptap/react/dist/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CommandManager: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.CommandManager),\n/* harmony export */   Editor: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.Editor),\n/* harmony export */   EditorConsumer: () => (/* binding */ EditorConsumer),\n/* harmony export */   EditorContent: () => (/* binding */ EditorContent),\n/* harmony export */   EditorContext: () => (/* binding */ EditorContext),\n/* harmony export */   EditorProvider: () => (/* binding */ EditorProvider),\n/* harmony export */   Extendable: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.Extendable),\n/* harmony export */   Extension: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.Extension),\n/* harmony export */   Fragment: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.Fragment),\n/* harmony export */   InputRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.InputRule),\n/* harmony export */   MappablePosition: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.MappablePosition),\n/* harmony export */   Mark: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.Mark),\n/* harmony export */   MarkView: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.MarkView),\n/* harmony export */   MarkViewContent: () => (/* binding */ MarkViewContent),\n/* harmony export */   Node: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.Node),\n/* harmony export */   NodePos: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.NodePos),\n/* harmony export */   NodeView: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.NodeView),\n/* harmony export */   NodeViewContent: () => (/* binding */ NodeViewContent),\n/* harmony export */   NodeViewWrapper: () => (/* binding */ NodeViewWrapper),\n/* harmony export */   PasteRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.PasteRule),\n/* harmony export */   PureEditorContent: () => (/* binding */ PureEditorContent),\n/* harmony export */   ReactMarkView: () => (/* binding */ ReactMarkView),\n/* harmony export */   ReactMarkViewContext: () => (/* binding */ ReactMarkViewContext),\n/* harmony export */   ReactMarkViewRenderer: () => (/* binding */ ReactMarkViewRenderer),\n/* harmony export */   ReactNodeView: () => (/* binding */ ReactNodeView),\n/* harmony export */   ReactNodeViewContentProvider: () => (/* binding */ ReactNodeViewContentProvider),\n/* harmony export */   ReactNodeViewContext: () => (/* binding */ ReactNodeViewContext),\n/* harmony export */   ReactNodeViewRenderer: () => (/* binding */ ReactNodeViewRenderer),\n/* harmony export */   ReactRenderer: () => (/* binding */ ReactRenderer),\n/* harmony export */   ResizableNodeView: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.ResizableNodeView),\n/* harmony export */   ResizableNodeview: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.ResizableNodeview),\n/* harmony export */   Tracker: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.Tracker),\n/* harmony export */   callOrReturn: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.callOrReturn),\n/* harmony export */   canInsertNode: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.canInsertNode),\n/* harmony export */   combineTransactionSteps: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.combineTransactionSteps),\n/* harmony export */   commands: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.commands),\n/* harmony export */   createAtomBlockMarkdownSpec: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.createAtomBlockMarkdownSpec),\n/* harmony export */   createBlockMarkdownSpec: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.createBlockMarkdownSpec),\n/* harmony export */   createChainableState: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.createChainableState),\n/* harmony export */   createDocument: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.createDocument),\n/* harmony export */   createElement: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.createElement),\n/* harmony export */   createInlineMarkdownSpec: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.createInlineMarkdownSpec),\n/* harmony export */   createMappablePosition: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.createMappablePosition),\n/* harmony export */   createNodeFromContent: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.createNodeFromContent),\n/* harmony export */   createStyleTag: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.createStyleTag),\n/* harmony export */   defaultBlockAt: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.defaultBlockAt),\n/* harmony export */   deleteProps: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.deleteProps),\n/* harmony export */   elementFromString: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.elementFromString),\n/* harmony export */   escapeForRegEx: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.escapeForRegEx),\n/* harmony export */   extensions: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.extensions),\n/* harmony export */   findChildren: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.findChildren),\n/* harmony export */   findChildrenInRange: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.findChildrenInRange),\n/* harmony export */   findDuplicates: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.findDuplicates),\n/* harmony export */   findParentNode: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.findParentNode),\n/* harmony export */   findParentNodeClosestToPos: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.findParentNodeClosestToPos),\n/* harmony export */   flattenExtensions: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.flattenExtensions),\n/* harmony export */   fromString: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.fromString),\n/* harmony export */   generateHTML: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.generateHTML),\n/* harmony export */   generateJSON: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.generateJSON),\n/* harmony export */   generateText: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.generateText),\n/* harmony export */   getAttributes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getAttributes),\n/* harmony export */   getAttributesFromExtensions: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getAttributesFromExtensions),\n/* harmony export */   getChangedRanges: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getChangedRanges),\n/* harmony export */   getDebugJSON: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getDebugJSON),\n/* harmony export */   getExtensionField: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getExtensionField),\n/* harmony export */   getHTMLFromFragment: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getHTMLFromFragment),\n/* harmony export */   getMarkAttributes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getMarkAttributes),\n/* harmony export */   getMarkRange: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getMarkRange),\n/* harmony export */   getMarkType: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getMarkType),\n/* harmony export */   getMarksBetween: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getMarksBetween),\n/* harmony export */   getNodeAtPosition: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getNodeAtPosition),\n/* harmony export */   getNodeAttributes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getNodeAttributes),\n/* harmony export */   getNodeType: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getNodeType),\n/* harmony export */   getRenderedAttributes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getRenderedAttributes),\n/* harmony export */   getSchema: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getSchema),\n/* harmony export */   getSchemaByResolvedExtensions: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getSchemaByResolvedExtensions),\n/* harmony export */   getSchemaTypeByName: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getSchemaTypeByName),\n/* harmony export */   getSchemaTypeNameByName: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getSchemaTypeNameByName),\n/* harmony export */   getSplittedAttributes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getSplittedAttributes),\n/* harmony export */   getText: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getText),\n/* harmony export */   getTextBetween: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getTextBetween),\n/* harmony export */   getTextContentFromNodes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getTextContentFromNodes),\n/* harmony export */   getTextSerializersFromSchema: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getTextSerializersFromSchema),\n/* harmony export */   getUpdatedPosition: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getUpdatedPosition),\n/* harmony export */   h: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.h),\n/* harmony export */   injectExtensionAttributesToParseRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.injectExtensionAttributesToParseRule),\n/* harmony export */   inputRulesPlugin: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.inputRulesPlugin),\n/* harmony export */   isActive: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isActive),\n/* harmony export */   isAndroid: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isAndroid),\n/* harmony export */   isAtEndOfNode: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isAtEndOfNode),\n/* harmony export */   isAtStartOfNode: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isAtStartOfNode),\n/* harmony export */   isEmptyObject: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isEmptyObject),\n/* harmony export */   isExtensionRulesEnabled: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isExtensionRulesEnabled),\n/* harmony export */   isFunction: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isFunction),\n/* harmony export */   isList: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isList),\n/* harmony export */   isMacOS: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isMacOS),\n/* harmony export */   isMarkActive: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isMarkActive),\n/* harmony export */   isNodeActive: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isNodeActive),\n/* harmony export */   isNodeEmpty: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isNodeEmpty),\n/* harmony export */   isNodeSelection: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isNodeSelection),\n/* harmony export */   isNumber: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isNumber),\n/* harmony export */   isPlainObject: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isPlainObject),\n/* harmony export */   isRegExp: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isRegExp),\n/* harmony export */   isString: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isString),\n/* harmony export */   isTextSelection: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isTextSelection),\n/* harmony export */   isiOS: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isiOS),\n/* harmony export */   markInputRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.markInputRule),\n/* harmony export */   markPasteRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.markPasteRule),\n/* harmony export */   markdown: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.markdown),\n/* harmony export */   mergeAttributes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.mergeAttributes),\n/* harmony export */   mergeDeep: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.mergeDeep),\n/* harmony export */   minMax: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.minMax),\n/* harmony export */   nodeInputRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.nodeInputRule),\n/* harmony export */   nodePasteRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.nodePasteRule),\n/* harmony export */   objectIncludes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.objectIncludes),\n/* harmony export */   parseAttributes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.parseAttributes),\n/* harmony export */   parseIndentedBlocks: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.parseIndentedBlocks),\n/* harmony export */   pasteRulesPlugin: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.pasteRulesPlugin),\n/* harmony export */   posToDOMRect: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.posToDOMRect),\n/* harmony export */   removeDuplicates: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.removeDuplicates),\n/* harmony export */   renderNestedMarkdownContent: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.renderNestedMarkdownContent),\n/* harmony export */   resolveExtensions: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.resolveExtensions),\n/* harmony export */   resolveFocusPosition: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.resolveFocusPosition),\n/* harmony export */   rewriteUnknownContent: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.rewriteUnknownContent),\n/* harmony export */   selectionToInsertionEnd: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.selectionToInsertionEnd),\n/* harmony export */   serializeAttributes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.serializeAttributes),\n/* harmony export */   sortExtensions: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.sortExtensions),\n/* harmony export */   splitExtensions: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.splitExtensions),\n/* harmony export */   textInputRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.textInputRule),\n/* harmony export */   textPasteRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.textPasteRule),\n/* harmony export */   textblockTypeInputRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.textblockTypeInputRule),\n/* harmony export */   updateMarkViewAttributes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.updateMarkViewAttributes),\n/* harmony export */   useCurrentEditor: () => (/* binding */ useCurrentEditor),\n/* harmony export */   useEditor: () => (/* binding */ useEditor),\n/* harmony export */   useEditorState: () => (/* binding */ useEditorState),\n/* harmony export */   useReactNodeView: () => (/* binding */ useReactNodeView),\n/* harmony export */   wrappingInputRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.wrappingInputRule)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! use-sync-external-store/shim/index.js */ \"(ssr)/./node_modules/use-sync-external-store/shim/index.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var fast_equals__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! fast-equals */ \"(ssr)/./node_modules/fast-equals/dist/es/index.mjs\");\n/* harmony import */ var use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! use-sync-external-store/shim/with-selector.js */ \"(ssr)/./node_modules/use-sync-external-store/shim/with-selector.js\");\n// src/Context.tsx\n\n// src/EditorContent.tsx\n\n\n\n\nvar mergeRefs = (...refs)=>{\n    return (node)=>{\n        refs.forEach((ref)=>{\n            if (typeof ref === \"function\") {\n                ref(node);\n            } else if (ref) {\n                ;\n                ref.current = node;\n            }\n        });\n    };\n};\nvar Portals = ({ contentComponent })=>{\n    const renderers = (0,use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStore)(contentComponent.subscribe, contentComponent.getSnapshot, contentComponent.getServerSnapshot);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.Fragment, {\n        children: Object.values(renderers)\n    });\n};\nfunction getInstance() {\n    const subscribers = /* @__PURE__ */ new Set();\n    let renderers = {};\n    return {\n        /**\n     * Subscribe to the editor instance's changes.\n     */ subscribe (callback) {\n            subscribers.add(callback);\n            return ()=>{\n                subscribers.delete(callback);\n            };\n        },\n        getSnapshot () {\n            return renderers;\n        },\n        getServerSnapshot () {\n            return renderers;\n        },\n        /**\n     * Adds a new NodeView Renderer to the editor.\n     */ setRenderer (id, renderer) {\n            renderers = {\n                ...renderers,\n                [id]: /*#__PURE__*/ react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal(renderer.reactElement, renderer.element, id)\n            };\n            subscribers.forEach((subscriber)=>subscriber());\n        },\n        /**\n     * Removes a NodeView Renderer from the editor.\n     */ removeRenderer (id) {\n            const nextRenderers = {\n                ...renderers\n            };\n            delete nextRenderers[id];\n            renderers = nextRenderers;\n            subscribers.forEach((subscriber)=>subscriber());\n        }\n    };\n}\nvar PureEditorContent = class extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n    constructor(props){\n        var _a;\n        super(props);\n        this.editorContentRef = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createRef();\n        this.initialized = false;\n        this.state = {\n            hasContentComponentInitialized: Boolean((_a = props.editor) == null ? void 0 : _a.contentComponent)\n        };\n    }\n    componentDidMount() {\n        this.init();\n    }\n    componentDidUpdate() {\n        this.init();\n    }\n    init() {\n        const editor = this.props.editor;\n        if (editor && !editor.isDestroyed && editor.options.element) {\n            if (editor.contentComponent) {\n                return;\n            }\n            const element = this.editorContentRef.current;\n            element.append(editor.view.dom);\n            editor.setOptions({\n                element\n            });\n            editor.contentComponent = getInstance();\n            if (!this.state.hasContentComponentInitialized) {\n                this.unsubscribeToContentComponent = editor.contentComponent.subscribe(()=>{\n                    this.setState((prevState)=>{\n                        if (!prevState.hasContentComponentInitialized) {\n                            return {\n                                hasContentComponentInitialized: true\n                            };\n                        }\n                        return prevState;\n                    });\n                    if (this.unsubscribeToContentComponent) {\n                        this.unsubscribeToContentComponent();\n                    }\n                });\n            }\n            editor.createNodeViews();\n            this.initialized = true;\n        }\n    }\n    componentWillUnmount() {\n        var _a;\n        const editor = this.props.editor;\n        if (!editor) {\n            return;\n        }\n        this.initialized = false;\n        if (!editor.isDestroyed) {\n            editor.view.setProps({\n                nodeViews: {}\n            });\n        }\n        if (this.unsubscribeToContentComponent) {\n            this.unsubscribeToContentComponent();\n        }\n        editor.contentComponent = null;\n        try {\n            if (!((_a = editor.view.dom) == null ? void 0 : _a.firstChild)) {\n                return;\n            }\n            const newElement = document.createElement(\"div\");\n            newElement.append(editor.view.dom);\n            editor.setOptions({\n                element: newElement\n            });\n        } catch  {}\n    }\n    render() {\n        const { editor, innerRef, ...rest } = this.props;\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.Fragment, {\n            children: [\n                /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"div\", {\n                    ref: mergeRefs(innerRef, this.editorContentRef),\n                    ...rest\n                }),\n                (editor == null ? void 0 : editor.contentComponent) && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(Portals, {\n                    contentComponent: editor.contentComponent\n                })\n            ]\n        });\n    }\n};\nvar EditorContentWithKey = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((props, ref)=>{\n    const key = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        return Math.floor(Math.random() * 4294967295).toString();\n    }, [\n        props.editor\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(PureEditorContent, {\n        key,\n        innerRef: ref,\n        ...props\n    });\n});\nvar EditorContent = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.memo(EditorContentWithKey);\n// src/useEditor.ts\n\n\n\n// src/useEditorState.ts\n\n\n\nvar useIsomorphicLayoutEffect =  false ? 0 : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nvar EditorStateManager = class {\n    constructor(initialEditor){\n        this.transactionNumber = 0;\n        this.lastTransactionNumber = 0;\n        this.subscribers = /* @__PURE__ */ new Set();\n        this.editor = initialEditor;\n        this.lastSnapshot = {\n            editor: initialEditor,\n            transactionNumber: 0\n        };\n        this.getSnapshot = this.getSnapshot.bind(this);\n        this.getServerSnapshot = this.getServerSnapshot.bind(this);\n        this.watch = this.watch.bind(this);\n        this.subscribe = this.subscribe.bind(this);\n    }\n    /**\n   * Get the current editor instance.\n   */ getSnapshot() {\n        if (this.transactionNumber === this.lastTransactionNumber) {\n            return this.lastSnapshot;\n        }\n        this.lastTransactionNumber = this.transactionNumber;\n        this.lastSnapshot = {\n            editor: this.editor,\n            transactionNumber: this.transactionNumber\n        };\n        return this.lastSnapshot;\n    }\n    /**\n   * Always disable the editor on the server-side.\n   */ getServerSnapshot() {\n        return {\n            editor: null,\n            transactionNumber: 0\n        };\n    }\n    /**\n   * Subscribe to the editor instance's changes.\n   */ subscribe(callback) {\n        this.subscribers.add(callback);\n        return ()=>{\n            this.subscribers.delete(callback);\n        };\n    }\n    /**\n   * Watch the editor instance for changes.\n   */ watch(nextEditor) {\n        this.editor = nextEditor;\n        if (this.editor) {\n            const fn = ()=>{\n                this.transactionNumber += 1;\n                this.subscribers.forEach((callback)=>callback());\n            };\n            const currentEditor = this.editor;\n            currentEditor.on(\"transaction\", fn);\n            return ()=>{\n                currentEditor.off(\"transaction\", fn);\n            };\n        }\n        return void 0;\n    }\n};\nfunction useEditorState(options) {\n    var _a;\n    const [editorStateManager] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>new EditorStateManager(options.editor));\n    const selectedState = (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_4__.useSyncExternalStoreWithSelector)(editorStateManager.subscribe, editorStateManager.getSnapshot, editorStateManager.getServerSnapshot, options.selector, (_a = options.equalityFn) != null ? _a : fast_equals__WEBPACK_IMPORTED_MODULE_5__.deepEqual);\n    useIsomorphicLayoutEffect(()=>{\n        return editorStateManager.watch(options.editor);\n    }, [\n        options.editor,\n        editorStateManager\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)(selectedState);\n    return selectedState;\n}\n// src/useEditor.ts\nvar isDev = \"development\" !== \"production\";\nvar isSSR = \"undefined\" === \"undefined\";\nvar isNext = isSSR || Boolean( false && 0);\nvar EditorInstanceManager = class _EditorInstanceManager {\n    constructor(options){\n        /**\n     * The current editor instance.\n     */ this.editor = null;\n        /**\n     * The subscriptions to notify when the editor instance\n     * has been created or destroyed.\n     */ this.subscriptions = /* @__PURE__ */ new Set();\n        /**\n     * Whether the editor has been mounted.\n     */ this.isComponentMounted = false;\n        /**\n     * The most recent dependencies array.\n     */ this.previousDeps = null;\n        /**\n     * The unique instance ID. This is used to identify the editor instance. And will be re-generated for each new instance.\n     */ this.instanceId = \"\";\n        this.options = options;\n        this.subscriptions = /* @__PURE__ */ new Set();\n        this.setEditor(this.getInitialEditor());\n        this.scheduleDestroy();\n        this.getEditor = this.getEditor.bind(this);\n        this.getServerSnapshot = this.getServerSnapshot.bind(this);\n        this.subscribe = this.subscribe.bind(this);\n        this.refreshEditorInstance = this.refreshEditorInstance.bind(this);\n        this.scheduleDestroy = this.scheduleDestroy.bind(this);\n        this.onRender = this.onRender.bind(this);\n        this.createEditor = this.createEditor.bind(this);\n    }\n    setEditor(editor) {\n        this.editor = editor;\n        this.instanceId = Math.random().toString(36).slice(2, 9);\n        this.subscriptions.forEach((cb)=>cb());\n    }\n    getInitialEditor() {\n        if (this.options.current.immediatelyRender === void 0) {\n            if (isSSR || isNext) {\n                if (isDev) {\n                    throw new Error(\"Tiptap Error: SSR has been detected, please set `immediatelyRender` explicitly to `false` to avoid hydration mismatches.\");\n                }\n                return null;\n            }\n            return this.createEditor();\n        }\n        if (this.options.current.immediatelyRender && isSSR && isDev) {\n            throw new Error(\"Tiptap Error: SSR has been detected, and `immediatelyRender` has been set to `true` this is an unsupported configuration that may result in errors, explicitly set `immediatelyRender` to `false` to avoid hydration mismatches.\");\n        }\n        if (this.options.current.immediatelyRender) {\n            return this.createEditor();\n        }\n        return null;\n    }\n    /**\n   * Create a new editor instance. And attach event listeners.\n   */ createEditor() {\n        const optionsToApply = {\n            ...this.options.current,\n            // Always call the most recent version of the callback function by default\n            onBeforeCreate: (...args)=>{\n                var _a, _b;\n                return (_b = (_a = this.options.current).onBeforeCreate) == null ? void 0 : _b.call(_a, ...args);\n            },\n            onBlur: (...args)=>{\n                var _a, _b;\n                return (_b = (_a = this.options.current).onBlur) == null ? void 0 : _b.call(_a, ...args);\n            },\n            onCreate: (...args)=>{\n                var _a, _b;\n                return (_b = (_a = this.options.current).onCreate) == null ? void 0 : _b.call(_a, ...args);\n            },\n            onDestroy: (...args)=>{\n                var _a, _b;\n                return (_b = (_a = this.options.current).onDestroy) == null ? void 0 : _b.call(_a, ...args);\n            },\n            onFocus: (...args)=>{\n                var _a, _b;\n                return (_b = (_a = this.options.current).onFocus) == null ? void 0 : _b.call(_a, ...args);\n            },\n            onSelectionUpdate: (...args)=>{\n                var _a, _b;\n                return (_b = (_a = this.options.current).onSelectionUpdate) == null ? void 0 : _b.call(_a, ...args);\n            },\n            onTransaction: (...args)=>{\n                var _a, _b;\n                return (_b = (_a = this.options.current).onTransaction) == null ? void 0 : _b.call(_a, ...args);\n            },\n            onUpdate: (...args)=>{\n                var _a, _b;\n                return (_b = (_a = this.options.current).onUpdate) == null ? void 0 : _b.call(_a, ...args);\n            },\n            onContentError: (...args)=>{\n                var _a, _b;\n                return (_b = (_a = this.options.current).onContentError) == null ? void 0 : _b.call(_a, ...args);\n            },\n            onDrop: (...args)=>{\n                var _a, _b;\n                return (_b = (_a = this.options.current).onDrop) == null ? void 0 : _b.call(_a, ...args);\n            },\n            onPaste: (...args)=>{\n                var _a, _b;\n                return (_b = (_a = this.options.current).onPaste) == null ? void 0 : _b.call(_a, ...args);\n            },\n            onDelete: (...args)=>{\n                var _a, _b;\n                return (_b = (_a = this.options.current).onDelete) == null ? void 0 : _b.call(_a, ...args);\n            }\n        };\n        const editor = new _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.Editor(optionsToApply);\n        return editor;\n    }\n    /**\n   * Get the current editor instance.\n   */ getEditor() {\n        return this.editor;\n    }\n    /**\n   * Always disable the editor on the server-side.\n   */ getServerSnapshot() {\n        return null;\n    }\n    /**\n   * Subscribe to the editor instance's changes.\n   */ subscribe(onStoreChange) {\n        this.subscriptions.add(onStoreChange);\n        return ()=>{\n            this.subscriptions.delete(onStoreChange);\n        };\n    }\n    static compareOptions(a, b) {\n        return Object.keys(a).every((key)=>{\n            if ([\n                \"onCreate\",\n                \"onBeforeCreate\",\n                \"onDestroy\",\n                \"onUpdate\",\n                \"onTransaction\",\n                \"onFocus\",\n                \"onBlur\",\n                \"onSelectionUpdate\",\n                \"onContentError\",\n                \"onDrop\",\n                \"onPaste\"\n            ].includes(key)) {\n                return true;\n            }\n            if (key === \"extensions\" && a.extensions && b.extensions) {\n                if (a.extensions.length !== b.extensions.length) {\n                    return false;\n                }\n                return a.extensions.every((extension, index)=>{\n                    var _a;\n                    if (extension !== ((_a = b.extensions) == null ? void 0 : _a[index])) {\n                        return false;\n                    }\n                    return true;\n                });\n            }\n            if (a[key] !== b[key]) {\n                return false;\n            }\n            return true;\n        });\n    }\n    /**\n   * On each render, we will create, update, or destroy the editor instance.\n   * @param deps The dependencies to watch for changes\n   * @returns A cleanup function\n   */ onRender(deps) {\n        return ()=>{\n            this.isComponentMounted = true;\n            clearTimeout(this.scheduledDestructionTimeout);\n            if (this.editor && !this.editor.isDestroyed && deps.length === 0) {\n                if (!_EditorInstanceManager.compareOptions(this.options.current, this.editor.options)) {\n                    this.editor.setOptions({\n                        ...this.options.current,\n                        editable: this.editor.isEditable\n                    });\n                }\n            } else {\n                this.refreshEditorInstance(deps);\n            }\n            return ()=>{\n                this.isComponentMounted = false;\n                this.scheduleDestroy();\n            };\n        };\n    }\n    /**\n   * Recreate the editor instance if the dependencies have changed.\n   */ refreshEditorInstance(deps) {\n        if (this.editor && !this.editor.isDestroyed) {\n            if (this.previousDeps === null) {\n                this.previousDeps = deps;\n                return;\n            }\n            const depsAreEqual = this.previousDeps.length === deps.length && this.previousDeps.every((dep, index)=>dep === deps[index]);\n            if (depsAreEqual) {\n                return;\n            }\n        }\n        if (this.editor && !this.editor.isDestroyed) {\n            this.editor.destroy();\n        }\n        this.setEditor(this.createEditor());\n        this.previousDeps = deps;\n    }\n    /**\n   * Schedule the destruction of the editor instance.\n   * This will only destroy the editor if it was not mounted on the next tick.\n   * This is to avoid destroying the editor instance when it's actually still mounted.\n   */ scheduleDestroy() {\n        const currentInstanceId = this.instanceId;\n        const currentEditor = this.editor;\n        this.scheduledDestructionTimeout = setTimeout(()=>{\n            if (this.isComponentMounted && this.instanceId === currentInstanceId) {\n                if (currentEditor) {\n                    currentEditor.setOptions(this.options.current);\n                }\n                return;\n            }\n            if (currentEditor && !currentEditor.isDestroyed) {\n                currentEditor.destroy();\n                if (this.instanceId === currentInstanceId) {\n                    this.setEditor(null);\n                }\n            }\n        }, 1);\n    }\n};\nfunction useEditor(options = {}, deps = []) {\n    const mostRecentOptions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(options);\n    mostRecentOptions.current = options;\n    const [instanceManager] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>new EditorInstanceManager(mostRecentOptions));\n    const editor = (0,use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStore)(instanceManager.subscribe, instanceManager.getEditor, instanceManager.getServerSnapshot);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)(editor);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(instanceManager.onRender(deps));\n    useEditorState({\n        editor,\n        selector: ({ transactionNumber })=>{\n            if (options.shouldRerenderOnTransaction === false || options.shouldRerenderOnTransaction === void 0) {\n                return null;\n            }\n            if (options.immediatelyRender && transactionNumber === 0) {\n                return 0;\n            }\n            return transactionNumber + 1;\n        }\n    });\n    return editor;\n}\n// src/Context.tsx\n\nvar EditorContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    editor: null\n});\nvar EditorConsumer = EditorContext.Consumer;\nvar useCurrentEditor = ()=>(0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(EditorContext);\nfunction EditorProvider({ children, slotAfter, slotBefore, editorContainerProps = {}, ...editorOptions }) {\n    const editor = useEditor(editorOptions);\n    const contextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            editor\n        }), [\n        editor\n    ]);\n    if (!editor) {\n        return null;\n    }\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxs)(EditorContext.Provider, {\n        value: contextValue,\n        children: [\n            slotBefore,\n            /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(EditorConsumer, {\n                children: ({ editor: currentEditor })=>/* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(EditorContent, {\n                        editor: currentEditor,\n                        ...editorContainerProps\n                    })\n            }),\n            children,\n            slotAfter\n        ]\n    });\n}\n// src/useReactNodeView.ts\n\nvar ReactNodeViewContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    onDragStart: ()=>{},\n    nodeViewContentChildren: void 0,\n    nodeViewContentRef: ()=>{}\n});\nvar ReactNodeViewContentProvider = ({ children, content })=>{\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(ReactNodeViewContext.Provider, {\n        value: {\n            nodeViewContentChildren: content\n        }\n    }, children);\n};\nvar useReactNodeView = ()=>(0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ReactNodeViewContext);\n// src/NodeViewContent.tsx\n\nfunction NodeViewContent({ as: Tag = \"div\", ...props }) {\n    const { nodeViewContentRef, nodeViewContentChildren } = useReactNodeView();\n    return(// @ts-ignore\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(Tag, {\n        ...props,\n        ref: nodeViewContentRef,\n        \"data-node-view-content\": \"\",\n        style: {\n            whiteSpace: \"pre-wrap\",\n            ...props.style\n        },\n        children: nodeViewContentChildren\n    }));\n}\n// src/NodeViewWrapper.tsx\n\n\nvar NodeViewWrapper = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((props, ref)=>{\n    const { onDragStart } = useReactNodeView();\n    const Tag = props.as || \"div\";\n    return(// @ts-ignore\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(Tag, {\n        ...props,\n        ref,\n        \"data-node-view-wrapper\": \"\",\n        onDragStart,\n        style: {\n            whiteSpace: \"normal\",\n            ...props.style\n        }\n    }));\n});\n// src/ReactMarkViewRenderer.tsx\n\n\n// src/ReactRenderer.tsx\n\n\n\nfunction isClassComponent(Component) {\n    return !!(typeof Component === \"function\" && Component.prototype && Component.prototype.isReactComponent);\n}\nfunction isForwardRefComponent(Component) {\n    return !!(typeof Component === \"object\" && Component.$$typeof && (Component.$$typeof.toString() === \"Symbol(react.forward_ref)\" || Component.$$typeof.description === \"react.forward_ref\"));\n}\nfunction isMemoComponent(Component) {\n    return !!(typeof Component === \"object\" && Component.$$typeof && (Component.$$typeof.toString() === \"Symbol(react.memo)\" || Component.$$typeof.description === \"react.memo\"));\n}\nfunction canReceiveRef(Component) {\n    if (isClassComponent(Component)) {\n        return true;\n    }\n    if (isForwardRefComponent(Component)) {\n        return true;\n    }\n    if (isMemoComponent(Component)) {\n        const wrappedComponent = Component.type;\n        if (wrappedComponent) {\n            return isClassComponent(wrappedComponent) || isForwardRefComponent(wrappedComponent);\n        }\n    }\n    return false;\n}\nfunction isReact19Plus() {\n    try {\n        if (react__WEBPACK_IMPORTED_MODULE_0__.version) {\n            const majorVersion = parseInt(react__WEBPACK_IMPORTED_MODULE_0__.version.split(\".\")[0], 10);\n            return majorVersion >= 19;\n        }\n    } catch  {}\n    return false;\n}\nvar ReactRenderer = class {\n    /**\n   * Immediately creates element and renders the provided React component.\n   */ constructor(component, { editor, props = {}, as = \"div\", className = \"\" }){\n        this.ref = null;\n        this.id = Math.floor(Math.random() * 4294967295).toString();\n        this.component = component;\n        this.editor = editor;\n        this.props = props;\n        this.element = document.createElement(as);\n        this.element.classList.add(\"react-renderer\");\n        if (className) {\n            this.element.classList.add(...className.split(\" \"));\n        }\n        if (this.editor.isInitialized) {\n            (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync)(()=>{\n                this.render();\n            });\n        } else {\n            queueMicrotask(()=>{\n                this.render();\n            });\n        }\n    }\n    /**\n   * Render the React component.\n   */ render() {\n        var _a;\n        const Component = this.component;\n        const props = this.props;\n        const editor = this.editor;\n        const isReact19 = isReact19Plus();\n        const componentCanReceiveRef = canReceiveRef(Component);\n        const elementProps = {\n            ...props\n        };\n        if (elementProps.ref && !(isReact19 || componentCanReceiveRef)) {\n            delete elementProps.ref;\n        }\n        if (!elementProps.ref && (isReact19 || componentCanReceiveRef)) {\n            elementProps.ref = (ref)=>{\n                this.ref = ref;\n            };\n        }\n        this.reactElement = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(Component, {\n            ...elementProps\n        });\n        (_a = editor == null ? void 0 : editor.contentComponent) == null ? void 0 : _a.setRenderer(this.id, this);\n    }\n    /**\n   * Re-renders the React component with new props.\n   */ updateProps(props = {}) {\n        this.props = {\n            ...this.props,\n            ...props\n        };\n        this.render();\n    }\n    /**\n   * Destroy the React component.\n   */ destroy() {\n        var _a;\n        const editor = this.editor;\n        (_a = editor == null ? void 0 : editor.contentComponent) == null ? void 0 : _a.removeRenderer(this.id);\n        try {\n            if (this.element && this.element.parentNode) {\n                this.element.parentNode.removeChild(this.element);\n            }\n        } catch  {}\n    }\n    /**\n   * Update the attributes of the element that holds the React component.\n   */ updateAttributes(attributes) {\n        Object.keys(attributes).forEach((key)=>{\n            this.element.setAttribute(key, attributes[key]);\n        });\n    }\n};\n// src/ReactMarkViewRenderer.tsx\n\nvar ReactMarkViewContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n    markViewContentRef: ()=>{}\n});\nvar MarkViewContent = (props)=>{\n    const { as: Tag = \"span\", ...rest } = props;\n    const { markViewContentRef } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(ReactMarkViewContext);\n    return(// @ts-ignore\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(Tag, {\n        ...rest,\n        ref: markViewContentRef,\n        \"data-mark-view-content\": \"\"\n    }));\n};\nvar ReactMarkView = class extends _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.MarkView {\n    constructor(component, props, options){\n        super(component, props, options);\n        const { as = \"span\", attrs, className = \"\" } = options || {};\n        const componentProps = {\n            ...props,\n            updateAttributes: this.updateAttributes.bind(this)\n        };\n        this.contentDOMElement = document.createElement(\"span\");\n        const markViewContentRef = (el)=>{\n            if (el && !el.contains(this.contentDOMElement)) {\n                el.appendChild(this.contentDOMElement);\n            }\n        };\n        const context = {\n            markViewContentRef\n        };\n        const ReactMarkViewProvider = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.memo((componentProps2)=>{\n            return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(ReactMarkViewContext.Provider, {\n                value: context,\n                children: /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(component, componentProps2)\n            });\n        });\n        ReactMarkViewProvider.displayName = \"ReactMarkView\";\n        this.renderer = new ReactRenderer(ReactMarkViewProvider, {\n            editor: props.editor,\n            props: componentProps,\n            as,\n            className: `mark-${props.mark.type.name} ${className}`.trim()\n        });\n        if (attrs) {\n            this.renderer.updateAttributes(attrs);\n        }\n    }\n    get dom() {\n        return this.renderer.element;\n    }\n    get contentDOM() {\n        return this.contentDOMElement;\n    }\n};\nfunction ReactMarkViewRenderer(component, options = {}) {\n    return (props)=>new ReactMarkView(component, props, options);\n}\n// src/ReactNodeViewRenderer.tsx\n\n\n\nvar ReactNodeView = class extends _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.NodeView {\n    constructor(component, props, options){\n        super(component, props, options);\n        /**\n     * The requestAnimationFrame ID used for selection updates.\n     */ this.selectionRafId = null;\n        if (!this.node.isLeaf) {\n            if (this.options.contentDOMElementTag) {\n                this.contentDOMElement = document.createElement(this.options.contentDOMElementTag);\n            } else {\n                this.contentDOMElement = document.createElement(this.node.isInline ? \"span\" : \"div\");\n            }\n            this.contentDOMElement.dataset.nodeViewContentReact = \"\";\n            this.contentDOMElement.dataset.nodeViewWrapper = \"\";\n            this.contentDOMElement.style.whiteSpace = \"inherit\";\n            const contentTarget = this.dom.querySelector(\"[data-node-view-content]\");\n            if (!contentTarget) {\n                return;\n            }\n            contentTarget.appendChild(this.contentDOMElement);\n        }\n    }\n    /**\n   * Setup the React component.\n   * Called on initialization.\n   */ mount() {\n        const props = {\n            editor: this.editor,\n            node: this.node,\n            decorations: this.decorations,\n            innerDecorations: this.innerDecorations,\n            view: this.view,\n            selected: false,\n            extension: this.extension,\n            HTMLAttributes: this.HTMLAttributes,\n            getPos: ()=>this.getPos(),\n            updateAttributes: (attributes = {})=>this.updateAttributes(attributes),\n            deleteNode: ()=>this.deleteNode(),\n            ref: /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createRef)()\n        };\n        if (!this.component.displayName) {\n            const capitalizeFirstChar = (string)=>{\n                return string.charAt(0).toUpperCase() + string.substring(1);\n            };\n            this.component.displayName = capitalizeFirstChar(this.extension.name);\n        }\n        const onDragStart = this.onDragStart.bind(this);\n        const nodeViewContentRef = (element)=>{\n            if (element && this.contentDOMElement && element.firstChild !== this.contentDOMElement) {\n                if (element.hasAttribute(\"data-node-view-wrapper\")) {\n                    element.removeAttribute(\"data-node-view-wrapper\");\n                }\n                element.appendChild(this.contentDOMElement);\n            }\n        };\n        const context = {\n            onDragStart,\n            nodeViewContentRef\n        };\n        const Component = this.component;\n        const ReactNodeViewProvider = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)((componentProps)=>{\n            return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(ReactNodeViewContext.Provider, {\n                value: context,\n                children: /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Component, componentProps)\n            });\n        });\n        ReactNodeViewProvider.displayName = \"ReactNodeView\";\n        let as = this.node.isInline ? \"span\" : \"div\";\n        if (this.options.as) {\n            as = this.options.as;\n        }\n        const { className = \"\" } = this.options;\n        this.handleSelectionUpdate = this.handleSelectionUpdate.bind(this);\n        this.renderer = new ReactRenderer(ReactNodeViewProvider, {\n            editor: this.editor,\n            props,\n            as,\n            className: `node-${this.node.type.name} ${className}`.trim()\n        });\n        this.editor.on(\"selectionUpdate\", this.handleSelectionUpdate);\n        this.updateElementAttributes();\n    }\n    /**\n   * Return the DOM element.\n   * This is the element that will be used to display the node view.\n   */ get dom() {\n        var _a;\n        if (this.renderer.element.firstElementChild && !((_a = this.renderer.element.firstElementChild) == null ? void 0 : _a.hasAttribute(\"data-node-view-wrapper\"))) {\n            throw Error(\"Please use the NodeViewWrapper component for your node view.\");\n        }\n        return this.renderer.element;\n    }\n    /**\n   * Return the content DOM element.\n   * This is the element that will be used to display the rich-text content of the node.\n   */ get contentDOM() {\n        if (this.node.isLeaf) {\n            return null;\n        }\n        return this.contentDOMElement;\n    }\n    /**\n   * On editor selection update, check if the node is selected.\n   * If it is, call `selectNode`, otherwise call `deselectNode`.\n   */ handleSelectionUpdate() {\n        if (this.selectionRafId) {\n            cancelAnimationFrame(this.selectionRafId);\n            this.selectionRafId = null;\n        }\n        this.selectionRafId = requestAnimationFrame(()=>{\n            this.selectionRafId = null;\n            const { from, to } = this.editor.state.selection;\n            const pos = this.getPos();\n            if (typeof pos !== \"number\") {\n                return;\n            }\n            if (from <= pos && to >= pos + this.node.nodeSize) {\n                if (this.renderer.props.selected) {\n                    return;\n                }\n                this.selectNode();\n            } else {\n                if (!this.renderer.props.selected) {\n                    return;\n                }\n                this.deselectNode();\n            }\n        });\n    }\n    /**\n   * On update, update the React component.\n   * To prevent unnecessary updates, the `update` option can be used.\n   */ update(node, decorations, innerDecorations) {\n        const rerenderComponent = (props)=>{\n            this.renderer.updateProps(props);\n            if (typeof this.options.attrs === \"function\") {\n                this.updateElementAttributes();\n            }\n        };\n        if (node.type !== this.node.type) {\n            return false;\n        }\n        if (typeof this.options.update === \"function\") {\n            const oldNode = this.node;\n            const oldDecorations = this.decorations;\n            const oldInnerDecorations = this.innerDecorations;\n            this.node = node;\n            this.decorations = decorations;\n            this.innerDecorations = innerDecorations;\n            return this.options.update({\n                oldNode,\n                oldDecorations,\n                newNode: node,\n                newDecorations: decorations,\n                oldInnerDecorations,\n                innerDecorations,\n                updateProps: ()=>rerenderComponent({\n                        node,\n                        decorations,\n                        innerDecorations\n                    })\n            });\n        }\n        if (node === this.node && this.decorations === decorations && this.innerDecorations === innerDecorations) {\n            return true;\n        }\n        this.node = node;\n        this.decorations = decorations;\n        this.innerDecorations = innerDecorations;\n        rerenderComponent({\n            node,\n            decorations,\n            innerDecorations\n        });\n        return true;\n    }\n    /**\n   * Select the node.\n   * Add the `selected` prop and the `ProseMirror-selectednode` class.\n   */ selectNode() {\n        this.renderer.updateProps({\n            selected: true\n        });\n        this.renderer.element.classList.add(\"ProseMirror-selectednode\");\n    }\n    /**\n   * Deselect the node.\n   * Remove the `selected` prop and the `ProseMirror-selectednode` class.\n   */ deselectNode() {\n        this.renderer.updateProps({\n            selected: false\n        });\n        this.renderer.element.classList.remove(\"ProseMirror-selectednode\");\n    }\n    /**\n   * Destroy the React component instance.\n   */ destroy() {\n        this.renderer.destroy();\n        this.editor.off(\"selectionUpdate\", this.handleSelectionUpdate);\n        this.contentDOMElement = null;\n        if (this.selectionRafId) {\n            cancelAnimationFrame(this.selectionRafId);\n            this.selectionRafId = null;\n        }\n    }\n    /**\n   * Update the attributes of the top-level element that holds the React component.\n   * Applying the attributes defined in the `attrs` option.\n   */ updateElementAttributes() {\n        if (this.options.attrs) {\n            let attrsObj = {};\n            if (typeof this.options.attrs === \"function\") {\n                const extensionAttributes = this.editor.extensionManager.attributes;\n                const HTMLAttributes = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getRenderedAttributes)(this.node, extensionAttributes);\n                attrsObj = this.options.attrs({\n                    node: this.node,\n                    HTMLAttributes\n                });\n            } else {\n                attrsObj = this.options.attrs;\n            }\n            this.renderer.updateAttributes(attrsObj);\n        }\n    }\n};\nfunction ReactNodeViewRenderer(component, options) {\n    return (props)=>{\n        if (!props.editor.contentComponent) {\n            return {};\n        }\n        return new ReactNodeView(component, props, options);\n    };\n}\n// src/index.ts\n\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9yZWFjdC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLGtCQUFrQjtBQUN5QztBQUUzRCx3QkFBd0I7QUFDa0I7QUFDVDtBQUM0QztBQUNyQjtBQUN4RCxJQUFJVSxZQUFZLENBQUMsR0FBR0M7SUFDbEIsT0FBTyxDQUFDQztRQUNORCxLQUFLRSxPQUFPLENBQUMsQ0FBQ0M7WUFDWixJQUFJLE9BQU9BLFFBQVEsWUFBWTtnQkFDN0JBLElBQUlGO1lBQ04sT0FBTyxJQUFJRSxLQUFLOztnQkFFZEEsSUFBSUMsT0FBTyxHQUFHSDtZQUNoQjtRQUNGO0lBQ0Y7QUFDRjtBQUNBLElBQUlJLFVBQVUsQ0FBQyxFQUFFQyxnQkFBZ0IsRUFBRTtJQUNqQyxNQUFNQyxZQUFZWiwyRkFBb0JBLENBQ3BDVyxpQkFBaUJFLFNBQVMsRUFDMUJGLGlCQUFpQkcsV0FBVyxFQUM1QkgsaUJBQWlCSSxpQkFBaUI7SUFFcEMsT0FBTyxhQUFhLEdBQUdiLHNEQUFHQSxDQUFDRCx1REFBUUEsRUFBRTtRQUFFZSxVQUFVQyxPQUFPQyxNQUFNLENBQUNOO0lBQVc7QUFDNUU7QUFDQSxTQUFTTztJQUNQLE1BQU1DLGNBQWMsYUFBYSxHQUFHLElBQUlDO0lBQ3hDLElBQUlULFlBQVksQ0FBQztJQUNqQixPQUFPO1FBQ0w7O0tBRUMsR0FDREMsV0FBVVMsUUFBUTtZQUNoQkYsWUFBWUcsR0FBRyxDQUFDRDtZQUNoQixPQUFPO2dCQUNMRixZQUFZSSxNQUFNLENBQUNGO1lBQ3JCO1FBQ0Y7UUFDQVI7WUFDRSxPQUFPRjtRQUNUO1FBQ0FHO1lBQ0UsT0FBT0g7UUFDVDtRQUNB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QUN6RSxVQUFVO2dCQUNuRSxNQUFNd0MsaUJBQWlCbEIsbUVBQXFCQSxDQUFDLElBQUksQ0FBQzVQLElBQUksRUFBRThTO2dCQUN4REQsV0FBVyxJQUFJLENBQUNqUSxPQUFPLENBQUNpTSxLQUFLLENBQUM7b0JBQUU3TyxNQUFNLElBQUksQ0FBQ0EsSUFBSTtvQkFBRThRO2dCQUFlO1lBQ2xFLE9BQU87Z0JBQ0wrQixXQUFXLElBQUksQ0FBQ2pRLE9BQU8sQ0FBQ2lNLEtBQUs7WUFDL0I7WUFDQSxJQUFJLENBQUN4TixRQUFRLENBQUNnTixnQkFBZ0IsQ0FBQ3dFO1FBQ2pDO0lBQ0Y7QUFDRjtBQUNBLFNBQVNHLHNCQUFzQnRGLFNBQVMsRUFBRTlLLE9BQU87SUFDL0MsT0FBTyxDQUFDYjtRQUNOLElBQUksQ0FBQ0EsTUFBTVEsTUFBTSxDQUFDbEMsZ0JBQWdCLEVBQUU7WUFDbEMsT0FBTyxDQUFDO1FBQ1Y7UUFDQSxPQUFPLElBQUkyUCxjQUFjdEMsV0FBVzNMLE9BQU9hO0lBQzdDO0FBQ0Y7QUFFQSxlQUFlO0FBQ2M7QUFzQjNCLENBQ0YsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJhc29icGFpLXdlYi8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL3JlYWN0L2Rpc3QvaW5kZXguanM/YWJiZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvQ29udGV4dC50c3hcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIHVzZU1lbW8gfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL0VkaXRvckNvbnRlbnQudHN4XG5pbXBvcnQgUmVhY3QsIHsgZm9yd2FyZFJlZiB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gXCJyZWFjdC1kb21cIjtcbmltcG9ydCB7IHVzZVN5bmNFeHRlcm5hbFN0b3JlIH0gZnJvbSBcInVzZS1zeW5jLWV4dGVybmFsLXN0b3JlL3NoaW0vaW5kZXguanNcIjtcbmltcG9ydCB7IEZyYWdtZW50LCBqc3gsIGpzeHMgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBtZXJnZVJlZnMgPSAoLi4ucmVmcykgPT4ge1xuICByZXR1cm4gKG5vZGUpID0+IHtcbiAgICByZWZzLmZvckVhY2goKHJlZikgPT4ge1xuICAgICAgaWYgKHR5cGVvZiByZWYgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZWYobm9kZSk7XG4gICAgICB9IGVsc2UgaWYgKHJlZikge1xuICAgICAgICA7XG4gICAgICAgIHJlZi5jdXJyZW50ID0gbm9kZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn07XG52YXIgUG9ydGFscyA9ICh7IGNvbnRlbnRDb21wb25lbnQgfSkgPT4ge1xuICBjb25zdCByZW5kZXJlcnMgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZShcbiAgICBjb250ZW50Q29tcG9uZW50LnN1YnNjcmliZSxcbiAgICBjb250ZW50Q29tcG9uZW50LmdldFNuYXBzaG90LFxuICAgIGNvbnRlbnRDb21wb25lbnQuZ2V0U2VydmVyU25hcHNob3RcbiAgKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goRnJhZ21lbnQsIHsgY2hpbGRyZW46IE9iamVjdC52YWx1ZXMocmVuZGVyZXJzKSB9KTtcbn07XG5mdW5jdGlvbiBnZXRJbnN0YW5jZSgpIHtcbiAgY29uc3Qgc3Vic2NyaWJlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBsZXQgcmVuZGVyZXJzID0ge307XG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlIHRvIHRoZSBlZGl0b3IgaW5zdGFuY2UncyBjaGFuZ2VzLlxuICAgICAqL1xuICAgIHN1YnNjcmliZShjYWxsYmFjaykge1xuICAgICAgc3Vic2NyaWJlcnMuYWRkKGNhbGxiYWNrKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHN1YnNjcmliZXJzLmRlbGV0ZShjYWxsYmFjayk7XG4gICAgICB9O1xuICAgIH0sXG4gICAgZ2V0U25hcHNob3QoKSB7XG4gICAgICByZXR1cm4gcmVuZGVyZXJzO1xuICAgIH0sXG4gICAgZ2V0U2VydmVyU25hcHNob3QoKSB7XG4gICAgICByZXR1cm4gcmVuZGVyZXJzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQWRkcyBhIG5ldyBOb2RlVmlldyBSZW5kZXJlciB0byB0aGUgZWRpdG9yLlxuICAgICAqL1xuICAgIHNldFJlbmRlcmVyKGlkLCByZW5kZXJlcikge1xuICAgICAgcmVuZGVyZXJzID0ge1xuICAgICAgICAuLi5yZW5kZXJlcnMsXG4gICAgICAgIFtpZF06IFJlYWN0RE9NLmNyZWF0ZVBvcnRhbChyZW5kZXJlci5yZWFjdEVsZW1lbnQsIHJlbmRlcmVyLmVsZW1lbnQsIGlkKVxuICAgICAgfTtcbiAgICAgIHN1YnNjcmliZXJzLmZvckVhY2goKHN1YnNjcmliZXIpID0+IHN1YnNjcmliZXIoKSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgTm9kZVZpZXcgUmVuZGVyZXIgZnJvbSB0aGUgZWRpdG9yLlxuICAgICAqL1xuICAgIHJlbW92ZVJlbmRlcmVyKGlkKSB7XG4gICAgICBjb25zdCBuZXh0UmVuZGVyZXJzID0geyAuLi5yZW5kZXJlcnMgfTtcbiAgICAgIGRlbGV0ZSBuZXh0UmVuZGVyZXJzW2lkXTtcbiAgICAgIHJlbmRlcmVycyA9IG5leHRSZW5kZXJlcnM7XG4gICAgICBzdWJzY3JpYmVycy5mb3JFYWNoKChzdWJzY3JpYmVyKSA9PiBzdWJzY3JpYmVyKCkpO1xuICAgIH1cbiAgfTtcbn1cbnZhciBQdXJlRWRpdG9yQ29udGVudCA9IGNsYXNzIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICB2YXIgX2E7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIHRoaXMuZWRpdG9yQ29udGVudFJlZiA9IFJlYWN0LmNyZWF0ZVJlZigpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgaGFzQ29udGVudENvbXBvbmVudEluaXRpYWxpemVkOiBCb29sZWFuKChfYSA9IHByb3BzLmVkaXRvcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNvbnRlbnRDb21wb25lbnQpXG4gICAgfTtcbiAgfVxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB0aGlzLmluaXQoKTtcbiAgfVxuICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgdGhpcy5pbml0KCk7XG4gIH1cbiAgaW5pdCgpIHtcbiAgICBjb25zdCBlZGl0b3IgPSB0aGlzLnByb3BzLmVkaXRvcjtcbiAgICBpZiAoZWRpdG9yICYmICFlZGl0b3IuaXNEZXN0cm95ZWQgJiYgZWRpdG9yLm9wdGlvbnMuZWxlbWVudCkge1xuICAgICAgaWYgKGVkaXRvci5jb250ZW50Q29tcG9uZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmVkaXRvckNvbnRlbnRSZWYuY3VycmVudDtcbiAgICAgIGVsZW1lbnQuYXBwZW5kKGVkaXRvci52aWV3LmRvbSk7XG4gICAgICBlZGl0b3Iuc2V0T3B0aW9ucyh7XG4gICAgICAgIGVsZW1lbnRcbiAgICAgIH0pO1xuICAgICAgZWRpdG9yLmNvbnRlbnRDb21wb25lbnQgPSBnZXRJbnN0YW5jZSgpO1xuICAgICAgaWYgKCF0aGlzLnN0YXRlLmhhc0NvbnRlbnRDb21wb25lbnRJbml0aWFsaXplZCkge1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlVG9Db250ZW50Q29tcG9uZW50ID0gZWRpdG9yLmNvbnRlbnRDb21wb25lbnQuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICB0aGlzLnNldFN0YXRlKChwcmV2U3RhdGUpID0+IHtcbiAgICAgICAgICAgIGlmICghcHJldlN0YXRlLmhhc0NvbnRlbnRDb21wb25lbnRJbml0aWFsaXplZCkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGhhc0NvbnRlbnRDb21wb25lbnRJbml0aWFsaXplZDogdHJ1ZVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHByZXZTdGF0ZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAodGhpcy51bnN1YnNjcmliZVRvQ29udGVudENvbXBvbmVudCkge1xuICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZVRvQ29udGVudENvbXBvbmVudCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBlZGl0b3IuY3JlYXRlTm9kZVZpZXdzKCk7XG4gICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGVkaXRvciA9IHRoaXMucHJvcHMuZWRpdG9yO1xuICAgIGlmICghZWRpdG9yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICBpZiAoIWVkaXRvci5pc0Rlc3Ryb3llZCkge1xuICAgICAgZWRpdG9yLnZpZXcuc2V0UHJvcHMoe1xuICAgICAgICBub2RlVmlld3M6IHt9XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHRoaXMudW5zdWJzY3JpYmVUb0NvbnRlbnRDb21wb25lbnQpIHtcbiAgICAgIHRoaXMudW5zdWJzY3JpYmVUb0NvbnRlbnRDb21wb25lbnQoKTtcbiAgICB9XG4gICAgZWRpdG9yLmNvbnRlbnRDb21wb25lbnQgPSBudWxsO1xuICAgIHRyeSB7XG4gICAgICBpZiAoISgoX2EgPSBlZGl0b3Iudmlldy5kb20pID09IG51bGwgPyB2b2lkIDAgOiBfYS5maXJzdENoaWxkKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBuZXdFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIG5ld0VsZW1lbnQuYXBwZW5kKGVkaXRvci52aWV3LmRvbSk7XG4gICAgICBlZGl0b3Iuc2V0T3B0aW9ucyh7XG4gICAgICAgIGVsZW1lbnQ6IG5ld0VsZW1lbnRcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2gge1xuICAgIH1cbiAgfVxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBlZGl0b3IsIGlubmVyUmVmLCAuLi5yZXN0IH0gPSB0aGlzLnByb3BzO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4cyhGcmFnbWVudCwgeyBjaGlsZHJlbjogW1xuICAgICAgLyogQF9fUFVSRV9fICovIGpzeChcImRpdlwiLCB7IHJlZjogbWVyZ2VSZWZzKGlubmVyUmVmLCB0aGlzLmVkaXRvckNvbnRlbnRSZWYpLCAuLi5yZXN0IH0pLFxuICAgICAgKGVkaXRvciA9PSBudWxsID8gdm9pZCAwIDogZWRpdG9yLmNvbnRlbnRDb21wb25lbnQpICYmIC8qIEBfX1BVUkVfXyAqLyBqc3goUG9ydGFscywgeyBjb250ZW50Q29tcG9uZW50OiBlZGl0b3IuY29udGVudENvbXBvbmVudCB9KVxuICAgIF0gfSk7XG4gIH1cbn07XG52YXIgRWRpdG9yQ29udGVudFdpdGhLZXkgPSBmb3J3YXJkUmVmKFxuICAocHJvcHMsIHJlZikgPT4ge1xuICAgIGNvbnN0IGtleSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDQyOTQ5NjcyOTUpLnRvU3RyaW5nKCk7XG4gICAgfSwgW3Byb3BzLmVkaXRvcl0pO1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFB1cmVFZGl0b3JDb250ZW50LCB7XG4gICAgICBrZXksXG4gICAgICBpbm5lclJlZjogcmVmLFxuICAgICAgLi4ucHJvcHNcbiAgICB9KTtcbiAgfVxuKTtcbnZhciBFZGl0b3JDb250ZW50ID0gUmVhY3QubWVtbyhFZGl0b3JDb250ZW50V2l0aEtleSk7XG5cbi8vIHNyYy91c2VFZGl0b3IudHNcbmltcG9ydCB7IEVkaXRvciB9IGZyb20gXCJAdGlwdGFwL2NvcmVcIjtcbmltcG9ydCB7IHVzZURlYnVnVmFsdWUgYXMgdXNlRGVidWdWYWx1ZTIsIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QyLCB1c2VSZWYsIHVzZVN0YXRlIGFzIHVzZVN0YXRlMiB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgdXNlU3luY0V4dGVybmFsU3RvcmUgYXMgdXNlU3luY0V4dGVybmFsU3RvcmUyIH0gZnJvbSBcInVzZS1zeW5jLWV4dGVybmFsLXN0b3JlL3NoaW0vaW5kZXguanNcIjtcblxuLy8gc3JjL3VzZUVkaXRvclN0YXRlLnRzXG5pbXBvcnQgeyBkZWVwRXF1YWwgfSBmcm9tIFwiZmFzdC1lcXVhbHNcIjtcbmltcG9ydCB7IHVzZURlYnVnVmFsdWUsIHVzZUVmZmVjdCwgdXNlTGF5b3V0RWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IgfSBmcm9tIFwidXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUvc2hpbS93aXRoLXNlbGVjdG9yLmpzXCI7XG52YXIgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB1c2VMYXlvdXRFZmZlY3QgOiB1c2VFZmZlY3Q7XG52YXIgRWRpdG9yU3RhdGVNYW5hZ2VyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihpbml0aWFsRWRpdG9yKSB7XG4gICAgdGhpcy50cmFuc2FjdGlvbk51bWJlciA9IDA7XG4gICAgdGhpcy5sYXN0VHJhbnNhY3Rpb25OdW1iZXIgPSAwO1xuICAgIHRoaXMuc3Vic2NyaWJlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMuZWRpdG9yID0gaW5pdGlhbEVkaXRvcjtcbiAgICB0aGlzLmxhc3RTbmFwc2hvdCA9IHsgZWRpdG9yOiBpbml0aWFsRWRpdG9yLCB0cmFuc2FjdGlvbk51bWJlcjogMCB9O1xuICAgIHRoaXMuZ2V0U25hcHNob3QgPSB0aGlzLmdldFNuYXBzaG90LmJpbmQodGhpcyk7XG4gICAgdGhpcy5nZXRTZXJ2ZXJTbmFwc2hvdCA9IHRoaXMuZ2V0U2VydmVyU25hcHNob3QuYmluZCh0aGlzKTtcbiAgICB0aGlzLndhdGNoID0gdGhpcy53YXRjaC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuc3Vic2NyaWJlID0gdGhpcy5zdWJzY3JpYmUuYmluZCh0aGlzKTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IGVkaXRvciBpbnN0YW5jZS5cbiAgICovXG4gIGdldFNuYXBzaG90KCkge1xuICAgIGlmICh0aGlzLnRyYW5zYWN0aW9uTnVtYmVyID09PSB0aGlzLmxhc3RUcmFuc2FjdGlvbk51bWJlcikge1xuICAgICAgcmV0dXJuIHRoaXMubGFzdFNuYXBzaG90O1xuICAgIH1cbiAgICB0aGlzLmxhc3RUcmFuc2FjdGlvbk51bWJlciA9IHRoaXMudHJhbnNhY3Rpb25OdW1iZXI7XG4gICAgdGhpcy5sYXN0U25hcHNob3QgPSB7IGVkaXRvcjogdGhpcy5lZGl0b3IsIHRyYW5zYWN0aW9uTnVtYmVyOiB0aGlzLnRyYW5zYWN0aW9uTnVtYmVyIH07XG4gICAgcmV0dXJuIHRoaXMubGFzdFNuYXBzaG90O1xuICB9XG4gIC8qKlxuICAgKiBBbHdheXMgZGlzYWJsZSB0aGUgZWRpdG9yIG9uIHRoZSBzZXJ2ZXItc2lkZS5cbiAgICovXG4gIGdldFNlcnZlclNuYXBzaG90KCkge1xuICAgIHJldHVybiB7IGVkaXRvcjogbnVsbCwgdHJhbnNhY3Rpb25OdW1iZXI6IDAgfTtcbiAgfVxuICAvKipcbiAgICogU3Vic2NyaWJlIHRvIHRoZSBlZGl0b3IgaW5zdGFuY2UncyBjaGFuZ2VzLlxuICAgKi9cbiAgc3Vic2NyaWJlKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5zdWJzY3JpYmVycy5hZGQoY2FsbGJhY2spO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB0aGlzLnN1YnNjcmliZXJzLmRlbGV0ZShjYWxsYmFjayk7XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogV2F0Y2ggdGhlIGVkaXRvciBpbnN0YW5jZSBmb3IgY2hhbmdlcy5cbiAgICovXG4gIHdhdGNoKG5leHRFZGl0b3IpIHtcbiAgICB0aGlzLmVkaXRvciA9IG5leHRFZGl0b3I7XG4gICAgaWYgKHRoaXMuZWRpdG9yKSB7XG4gICAgICBjb25zdCBmbiA9ICgpID0+IHtcbiAgICAgICAgdGhpcy50cmFuc2FjdGlvbk51bWJlciArPSAxO1xuICAgICAgICB0aGlzLnN1YnNjcmliZXJzLmZvckVhY2goKGNhbGxiYWNrKSA9PiBjYWxsYmFjaygpKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBjdXJyZW50RWRpdG9yID0gdGhpcy5lZGl0b3I7XG4gICAgICBjdXJyZW50RWRpdG9yLm9uKFwidHJhbnNhY3Rpb25cIiwgZm4pO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgY3VycmVudEVkaXRvci5vZmYoXCJ0cmFuc2FjdGlvblwiLCBmbik7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG59O1xuZnVuY3Rpb24gdXNlRWRpdG9yU3RhdGUob3B0aW9ucykge1xuICB2YXIgX2E7XG4gIGNvbnN0IFtlZGl0b3JTdGF0ZU1hbmFnZXJdID0gdXNlU3RhdGUoKCkgPT4gbmV3IEVkaXRvclN0YXRlTWFuYWdlcihvcHRpb25zLmVkaXRvcikpO1xuICBjb25zdCBzZWxlY3RlZFN0YXRlID0gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IoXG4gICAgZWRpdG9yU3RhdGVNYW5hZ2VyLnN1YnNjcmliZSxcbiAgICBlZGl0b3JTdGF0ZU1hbmFnZXIuZ2V0U25hcHNob3QsXG4gICAgZWRpdG9yU3RhdGVNYW5hZ2VyLmdldFNlcnZlclNuYXBzaG90LFxuICAgIG9wdGlvbnMuc2VsZWN0b3IsXG4gICAgKF9hID0gb3B0aW9ucy5lcXVhbGl0eUZuKSAhPSBudWxsID8gX2EgOiBkZWVwRXF1YWxcbiAgKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuIGVkaXRvclN0YXRlTWFuYWdlci53YXRjaChvcHRpb25zLmVkaXRvcik7XG4gIH0sIFtvcHRpb25zLmVkaXRvciwgZWRpdG9yU3RhdGVNYW5hZ2VyXSk7XG4gIHVzZURlYnVnVmFsdWUoc2VsZWN0ZWRTdGF0ZSk7XG4gIHJldHVybiBzZWxlY3RlZFN0YXRlO1xufVxuXG4vLyBzcmMvdXNlRWRpdG9yLnRzXG52YXIgaXNEZXYgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCI7XG52YXIgaXNTU1IgPSB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiO1xudmFyIGlzTmV4dCA9IGlzU1NSIHx8IEJvb2xlYW4odHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cubmV4dCk7XG52YXIgRWRpdG9ySW5zdGFuY2VNYW5hZ2VyID0gY2xhc3MgX0VkaXRvckluc3RhbmNlTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCBlZGl0b3IgaW5zdGFuY2UuXG4gICAgICovXG4gICAgdGhpcy5lZGl0b3IgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIFRoZSBzdWJzY3JpcHRpb25zIHRvIG5vdGlmeSB3aGVuIHRoZSBlZGl0b3IgaW5zdGFuY2VcbiAgICAgKiBoYXMgYmVlbiBjcmVhdGVkIG9yIGRlc3Ryb3llZC5cbiAgICAgKi9cbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIGVkaXRvciBoYXMgYmVlbiBtb3VudGVkLlxuICAgICAqL1xuICAgIHRoaXMuaXNDb21wb25lbnRNb3VudGVkID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogVGhlIG1vc3QgcmVjZW50IGRlcGVuZGVuY2llcyBhcnJheS5cbiAgICAgKi9cbiAgICB0aGlzLnByZXZpb3VzRGVwcyA9IG51bGw7XG4gICAgLyoqXG4gICAgICogVGhlIHVuaXF1ZSBpbnN0YW5jZSBJRC4gVGhpcyBpcyB1c2VkIHRvIGlkZW50aWZ5IHRoZSBlZGl0b3IgaW5zdGFuY2UuIEFuZCB3aWxsIGJlIHJlLWdlbmVyYXRlZCBmb3IgZWFjaCBuZXcgaW5zdGFuY2UuXG4gICAgICovXG4gICAgdGhpcy5pbnN0YW5jZUlkID0gXCJcIjtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgdGhpcy5zZXRFZGl0b3IodGhpcy5nZXRJbml0aWFsRWRpdG9yKCkpO1xuICAgIHRoaXMuc2NoZWR1bGVEZXN0cm95KCk7XG4gICAgdGhpcy5nZXRFZGl0b3IgPSB0aGlzLmdldEVkaXRvci5iaW5kKHRoaXMpO1xuICAgIHRoaXMuZ2V0U2VydmVyU25hcHNob3QgPSB0aGlzLmdldFNlcnZlclNuYXBzaG90LmJpbmQodGhpcyk7XG4gICAgdGhpcy5zdWJzY3JpYmUgPSB0aGlzLnN1YnNjcmliZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMucmVmcmVzaEVkaXRvckluc3RhbmNlID0gdGhpcy5yZWZyZXNoRWRpdG9ySW5zdGFuY2UuYmluZCh0aGlzKTtcbiAgICB0aGlzLnNjaGVkdWxlRGVzdHJveSA9IHRoaXMuc2NoZWR1bGVEZXN0cm95LmJpbmQodGhpcyk7XG4gICAgdGhpcy5vblJlbmRlciA9IHRoaXMub25SZW5kZXIuYmluZCh0aGlzKTtcbiAgICB0aGlzLmNyZWF0ZUVkaXRvciA9IHRoaXMuY3JlYXRlRWRpdG9yLmJpbmQodGhpcyk7XG4gIH1cbiAgc2V0RWRpdG9yKGVkaXRvcikge1xuICAgIHRoaXMuZWRpdG9yID0gZWRpdG9yO1xuICAgIHRoaXMuaW5zdGFuY2VJZCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIsIDkpO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5mb3JFYWNoKChjYikgPT4gY2IoKSk7XG4gIH1cbiAgZ2V0SW5pdGlhbEVkaXRvcigpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmN1cnJlbnQuaW1tZWRpYXRlbHlSZW5kZXIgPT09IHZvaWQgMCkge1xuICAgICAgaWYgKGlzU1NSIHx8IGlzTmV4dCkge1xuICAgICAgICBpZiAoaXNEZXYpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBcIlRpcHRhcCBFcnJvcjogU1NSIGhhcyBiZWVuIGRldGVjdGVkLCBwbGVhc2Ugc2V0IGBpbW1lZGlhdGVseVJlbmRlcmAgZXhwbGljaXRseSB0byBgZmFsc2VgIHRvIGF2b2lkIGh5ZHJhdGlvbiBtaXNtYXRjaGVzLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVkaXRvcigpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmN1cnJlbnQuaW1tZWRpYXRlbHlSZW5kZXIgJiYgaXNTU1IgJiYgaXNEZXYpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJUaXB0YXAgRXJyb3I6IFNTUiBoYXMgYmVlbiBkZXRlY3RlZCwgYW5kIGBpbW1lZGlhdGVseVJlbmRlcmAgaGFzIGJlZW4gc2V0IHRvIGB0cnVlYCB0aGlzIGlzIGFuIHVuc3VwcG9ydGVkIGNvbmZpZ3VyYXRpb24gdGhhdCBtYXkgcmVzdWx0IGluIGVycm9ycywgZXhwbGljaXRseSBzZXQgYGltbWVkaWF0ZWx5UmVuZGVyYCB0byBgZmFsc2VgIHRvIGF2b2lkIGh5ZHJhdGlvbiBtaXNtYXRjaGVzLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmN1cnJlbnQuaW1tZWRpYXRlbHlSZW5kZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVkaXRvcigpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGVkaXRvciBpbnN0YW5jZS4gQW5kIGF0dGFjaCBldmVudCBsaXN0ZW5lcnMuXG4gICAqL1xuICBjcmVhdGVFZGl0b3IoKSB7XG4gICAgY29uc3Qgb3B0aW9uc1RvQXBwbHkgPSB7XG4gICAgICAuLi50aGlzLm9wdGlvbnMuY3VycmVudCxcbiAgICAgIC8vIEFsd2F5cyBjYWxsIHRoZSBtb3N0IHJlY2VudCB2ZXJzaW9uIG9mIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBieSBkZWZhdWx0XG4gICAgICBvbkJlZm9yZUNyZWF0ZTogKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMub3B0aW9ucy5jdXJyZW50KS5vbkJlZm9yZUNyZWF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIC4uLmFyZ3MpO1xuICAgICAgfSxcbiAgICAgIG9uQmx1cjogKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMub3B0aW9ucy5jdXJyZW50KS5vbkJsdXIpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCAuLi5hcmdzKTtcbiAgICAgIH0sXG4gICAgICBvbkNyZWF0ZTogKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMub3B0aW9ucy5jdXJyZW50KS5vbkNyZWF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIC4uLmFyZ3MpO1xuICAgICAgfSxcbiAgICAgIG9uRGVzdHJveTogKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMub3B0aW9ucy5jdXJyZW50KS5vbkRlc3Ryb3kpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCAuLi5hcmdzKTtcbiAgICAgIH0sXG4gICAgICBvbkZvY3VzOiAoLi4uYXJncykgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5vcHRpb25zLmN1cnJlbnQpLm9uRm9jdXMpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCAuLi5hcmdzKTtcbiAgICAgIH0sXG4gICAgICBvblNlbGVjdGlvblVwZGF0ZTogKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMub3B0aW9ucy5jdXJyZW50KS5vblNlbGVjdGlvblVwZGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIC4uLmFyZ3MpO1xuICAgICAgfSxcbiAgICAgIG9uVHJhbnNhY3Rpb246ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLm9wdGlvbnMuY3VycmVudCkub25UcmFuc2FjdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIC4uLmFyZ3MpO1xuICAgICAgfSxcbiAgICAgIG9uVXBkYXRlOiAoLi4uYXJncykgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5vcHRpb25zLmN1cnJlbnQpLm9uVXBkYXRlKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYSwgLi4uYXJncyk7XG4gICAgICB9LFxuICAgICAgb25Db250ZW50RXJyb3I6ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLm9wdGlvbnMuY3VycmVudCkub25Db250ZW50RXJyb3IpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCAuLi5hcmdzKTtcbiAgICAgIH0sXG4gICAgICBvbkRyb3A6ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLm9wdGlvbnMuY3VycmVudCkub25Ecm9wKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYSwgLi4uYXJncyk7XG4gICAgICB9LFxuICAgICAgb25QYXN0ZTogKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMub3B0aW9ucy5jdXJyZW50KS5vblBhc3RlKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYSwgLi4uYXJncyk7XG4gICAgICB9LFxuICAgICAgb25EZWxldGU6ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLm9wdGlvbnMuY3VycmVudCkub25EZWxldGUpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCAuLi5hcmdzKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGVkaXRvciA9IG5ldyBFZGl0b3Iob3B0aW9uc1RvQXBwbHkpO1xuICAgIHJldHVybiBlZGl0b3I7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCBlZGl0b3IgaW5zdGFuY2UuXG4gICAqL1xuICBnZXRFZGl0b3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWRpdG9yO1xuICB9XG4gIC8qKlxuICAgKiBBbHdheXMgZGlzYWJsZSB0aGUgZWRpdG9yIG9uIHRoZSBzZXJ2ZXItc2lkZS5cbiAgICovXG4gIGdldFNlcnZlclNuYXBzaG90KCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBTdWJzY3JpYmUgdG8gdGhlIGVkaXRvciBpbnN0YW5jZSdzIGNoYW5nZXMuXG4gICAqL1xuICBzdWJzY3JpYmUob25TdG9yZUNoYW5nZSkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQob25TdG9yZUNoYW5nZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5kZWxldGUob25TdG9yZUNoYW5nZSk7XG4gICAgfTtcbiAgfVxuICBzdGF0aWMgY29tcGFyZU9wdGlvbnMoYSwgYikge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhhKS5ldmVyeSgoa2V5KSA9PiB7XG4gICAgICBpZiAoW1xuICAgICAgICBcIm9uQ3JlYXRlXCIsXG4gICAgICAgIFwib25CZWZvcmVDcmVhdGVcIixcbiAgICAgICAgXCJvbkRlc3Ryb3lcIixcbiAgICAgICAgXCJvblVwZGF0ZVwiLFxuICAgICAgICBcIm9uVHJhbnNhY3Rpb25cIixcbiAgICAgICAgXCJvbkZvY3VzXCIsXG4gICAgICAgIFwib25CbHVyXCIsXG4gICAgICAgIFwib25TZWxlY3Rpb25VcGRhdGVcIixcbiAgICAgICAgXCJvbkNvbnRlbnRFcnJvclwiLFxuICAgICAgICBcIm9uRHJvcFwiLFxuICAgICAgICBcIm9uUGFzdGVcIlxuICAgICAgXS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGtleSA9PT0gXCJleHRlbnNpb25zXCIgJiYgYS5leHRlbnNpb25zICYmIGIuZXh0ZW5zaW9ucykge1xuICAgICAgICBpZiAoYS5leHRlbnNpb25zLmxlbmd0aCAhPT0gYi5leHRlbnNpb25zLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYS5leHRlbnNpb25zLmV2ZXJ5KChleHRlbnNpb24sIGluZGV4KSA9PiB7XG4gICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgIGlmIChleHRlbnNpb24gIT09ICgoX2EgPSBiLmV4dGVuc2lvbnMpID09IG51bGwgPyB2b2lkIDAgOiBfYVtpbmRleF0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChhW2tleV0gIT09IGJba2V5XSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogT24gZWFjaCByZW5kZXIsIHdlIHdpbGwgY3JlYXRlLCB1cGRhdGUsIG9yIGRlc3Ryb3kgdGhlIGVkaXRvciBpbnN0YW5jZS5cbiAgICogQHBhcmFtIGRlcHMgVGhlIGRlcGVuZGVuY2llcyB0byB3YXRjaCBmb3IgY2hhbmdlc1xuICAgKiBAcmV0dXJucyBBIGNsZWFudXAgZnVuY3Rpb25cbiAgICovXG4gIG9uUmVuZGVyKGRlcHMpIHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgdGhpcy5pc0NvbXBvbmVudE1vdW50ZWQgPSB0cnVlO1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuc2NoZWR1bGVkRGVzdHJ1Y3Rpb25UaW1lb3V0KTtcbiAgICAgIGlmICh0aGlzLmVkaXRvciAmJiAhdGhpcy5lZGl0b3IuaXNEZXN0cm95ZWQgJiYgZGVwcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaWYgKCFfRWRpdG9ySW5zdGFuY2VNYW5hZ2VyLmNvbXBhcmVPcHRpb25zKHRoaXMub3B0aW9ucy5jdXJyZW50LCB0aGlzLmVkaXRvci5vcHRpb25zKSkge1xuICAgICAgICAgIHRoaXMuZWRpdG9yLnNldE9wdGlvbnMoe1xuICAgICAgICAgICAgLi4udGhpcy5vcHRpb25zLmN1cnJlbnQsXG4gICAgICAgICAgICBlZGl0YWJsZTogdGhpcy5lZGl0b3IuaXNFZGl0YWJsZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlZnJlc2hFZGl0b3JJbnN0YW5jZShkZXBzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHRoaXMuaXNDb21wb25lbnRNb3VudGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVEZXN0cm95KCk7XG4gICAgICB9O1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFJlY3JlYXRlIHRoZSBlZGl0b3IgaW5zdGFuY2UgaWYgdGhlIGRlcGVuZGVuY2llcyBoYXZlIGNoYW5nZWQuXG4gICAqL1xuICByZWZyZXNoRWRpdG9ySW5zdGFuY2UoZGVwcykge1xuICAgIGlmICh0aGlzLmVkaXRvciAmJiAhdGhpcy5lZGl0b3IuaXNEZXN0cm95ZWQpIHtcbiAgICAgIGlmICh0aGlzLnByZXZpb3VzRGVwcyA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLnByZXZpb3VzRGVwcyA9IGRlcHM7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRlcHNBcmVFcXVhbCA9IHRoaXMucHJldmlvdXNEZXBzLmxlbmd0aCA9PT0gZGVwcy5sZW5ndGggJiYgdGhpcy5wcmV2aW91c0RlcHMuZXZlcnkoKGRlcCwgaW5kZXgpID0+IGRlcCA9PT0gZGVwc1tpbmRleF0pO1xuICAgICAgaWYgKGRlcHNBcmVFcXVhbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLmVkaXRvciAmJiAhdGhpcy5lZGl0b3IuaXNEZXN0cm95ZWQpIHtcbiAgICAgIHRoaXMuZWRpdG9yLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdGhpcy5zZXRFZGl0b3IodGhpcy5jcmVhdGVFZGl0b3IoKSk7XG4gICAgdGhpcy5wcmV2aW91c0RlcHMgPSBkZXBzO1xuICB9XG4gIC8qKlxuICAgKiBTY2hlZHVsZSB0aGUgZGVzdHJ1Y3Rpb24gb2YgdGhlIGVkaXRvciBpbnN0YW5jZS5cbiAgICogVGhpcyB3aWxsIG9ubHkgZGVzdHJveSB0aGUgZWRpdG9yIGlmIGl0IHdhcyBub3QgbW91bnRlZCBvbiB0aGUgbmV4dCB0aWNrLlxuICAgKiBUaGlzIGlzIHRvIGF2b2lkIGRlc3Ryb3lpbmcgdGhlIGVkaXRvciBpbnN0YW5jZSB3aGVuIGl0J3MgYWN0dWFsbHkgc3RpbGwgbW91bnRlZC5cbiAgICovXG4gIHNjaGVkdWxlRGVzdHJveSgpIHtcbiAgICBjb25zdCBjdXJyZW50SW5zdGFuY2VJZCA9IHRoaXMuaW5zdGFuY2VJZDtcbiAgICBjb25zdCBjdXJyZW50RWRpdG9yID0gdGhpcy5lZGl0b3I7XG4gICAgdGhpcy5zY2hlZHVsZWREZXN0cnVjdGlvblRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICh0aGlzLmlzQ29tcG9uZW50TW91bnRlZCAmJiB0aGlzLmluc3RhbmNlSWQgPT09IGN1cnJlbnRJbnN0YW5jZUlkKSB7XG4gICAgICAgIGlmIChjdXJyZW50RWRpdG9yKSB7XG4gICAgICAgICAgY3VycmVudEVkaXRvci5zZXRPcHRpb25zKHRoaXMub3B0aW9ucy5jdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudEVkaXRvciAmJiAhY3VycmVudEVkaXRvci5pc0Rlc3Ryb3llZCkge1xuICAgICAgICBjdXJyZW50RWRpdG9yLmRlc3Ryb3koKTtcbiAgICAgICAgaWYgKHRoaXMuaW5zdGFuY2VJZCA9PT0gY3VycmVudEluc3RhbmNlSWQpIHtcbiAgICAgICAgICB0aGlzLnNldEVkaXRvcihudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIDEpO1xuICB9XG59O1xuZnVuY3Rpb24gdXNlRWRpdG9yKG9wdGlvbnMgPSB7fSwgZGVwcyA9IFtdKSB7XG4gIGNvbnN0IG1vc3RSZWNlbnRPcHRpb25zID0gdXNlUmVmKG9wdGlvbnMpO1xuICBtb3N0UmVjZW50T3B0aW9ucy5jdXJyZW50ID0gb3B0aW9ucztcbiAgY29uc3QgW2luc3RhbmNlTWFuYWdlcl0gPSB1c2VTdGF0ZTIoKCkgPT4gbmV3IEVkaXRvckluc3RhbmNlTWFuYWdlcihtb3N0UmVjZW50T3B0aW9ucykpO1xuICBjb25zdCBlZGl0b3IgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZTIoXG4gICAgaW5zdGFuY2VNYW5hZ2VyLnN1YnNjcmliZSxcbiAgICBpbnN0YW5jZU1hbmFnZXIuZ2V0RWRpdG9yLFxuICAgIGluc3RhbmNlTWFuYWdlci5nZXRTZXJ2ZXJTbmFwc2hvdFxuICApO1xuICB1c2VEZWJ1Z1ZhbHVlMihlZGl0b3IpO1xuICB1c2VFZmZlY3QyKGluc3RhbmNlTWFuYWdlci5vblJlbmRlcihkZXBzKSk7XG4gIHVzZUVkaXRvclN0YXRlKHtcbiAgICBlZGl0b3IsXG4gICAgc2VsZWN0b3I6ICh7IHRyYW5zYWN0aW9uTnVtYmVyIH0pID0+IHtcbiAgICAgIGlmIChvcHRpb25zLnNob3VsZFJlcmVuZGVyT25UcmFuc2FjdGlvbiA9PT0gZmFsc2UgfHwgb3B0aW9ucy5zaG91bGRSZXJlbmRlck9uVHJhbnNhY3Rpb24gPT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmltbWVkaWF0ZWx5UmVuZGVyICYmIHRyYW5zYWN0aW9uTnVtYmVyID09PSAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uTnVtYmVyICsgMTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZWRpdG9yO1xufVxuXG4vLyBzcmMvQ29udGV4dC50c3hcbmltcG9ydCB7IGpzeCBhcyBqc3gyLCBqc3hzIGFzIGpzeHMyIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgRWRpdG9yQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoe1xuICBlZGl0b3I6IG51bGxcbn0pO1xudmFyIEVkaXRvckNvbnN1bWVyID0gRWRpdG9yQ29udGV4dC5Db25zdW1lcjtcbnZhciB1c2VDdXJyZW50RWRpdG9yID0gKCkgPT4gdXNlQ29udGV4dChFZGl0b3JDb250ZXh0KTtcbmZ1bmN0aW9uIEVkaXRvclByb3ZpZGVyKHtcbiAgY2hpbGRyZW4sXG4gIHNsb3RBZnRlcixcbiAgc2xvdEJlZm9yZSxcbiAgZWRpdG9yQ29udGFpbmVyUHJvcHMgPSB7fSxcbiAgLi4uZWRpdG9yT3B0aW9uc1xufSkge1xuICBjb25zdCBlZGl0b3IgPSB1c2VFZGl0b3IoZWRpdG9yT3B0aW9ucyk7XG4gIGNvbnN0IGNvbnRleHRWYWx1ZSA9IHVzZU1lbW8oKCkgPT4gKHsgZWRpdG9yIH0pLCBbZWRpdG9yXSk7XG4gIGlmICghZWRpdG9yKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3hzMihFZGl0b3JDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBjb250ZXh0VmFsdWUsIGNoaWxkcmVuOiBbXG4gICAgc2xvdEJlZm9yZSxcbiAgICAvKiBAX19QVVJFX18gKi8ganN4MihFZGl0b3JDb25zdW1lciwgeyBjaGlsZHJlbjogKHsgZWRpdG9yOiBjdXJyZW50RWRpdG9yIH0pID0+IC8qIEBfX1BVUkVfXyAqLyBqc3gyKEVkaXRvckNvbnRlbnQsIHsgZWRpdG9yOiBjdXJyZW50RWRpdG9yLCAuLi5lZGl0b3JDb250YWluZXJQcm9wcyB9KSB9KSxcbiAgICBjaGlsZHJlbixcbiAgICBzbG90QWZ0ZXJcbiAgXSB9KTtcbn1cblxuLy8gc3JjL3VzZVJlYWN0Tm9kZVZpZXcudHNcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQgYXMgY3JlYXRlQ29udGV4dDIsIGNyZWF0ZUVsZW1lbnQsIHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDIgfSBmcm9tIFwicmVhY3RcIjtcbnZhciBSZWFjdE5vZGVWaWV3Q29udGV4dCA9IGNyZWF0ZUNvbnRleHQyKHtcbiAgb25EcmFnU3RhcnQ6ICgpID0+IHtcbiAgfSxcbiAgbm9kZVZpZXdDb250ZW50Q2hpbGRyZW46IHZvaWQgMCxcbiAgbm9kZVZpZXdDb250ZW50UmVmOiAoKSA9PiB7XG4gIH1cbn0pO1xudmFyIFJlYWN0Tm9kZVZpZXdDb250ZW50UHJvdmlkZXIgPSAoeyBjaGlsZHJlbiwgY29udGVudCB9KSA9PiB7XG4gIHJldHVybiBjcmVhdGVFbGVtZW50KFJlYWN0Tm9kZVZpZXdDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB7IG5vZGVWaWV3Q29udGVudENoaWxkcmVuOiBjb250ZW50IH0gfSwgY2hpbGRyZW4pO1xufTtcbnZhciB1c2VSZWFjdE5vZGVWaWV3ID0gKCkgPT4gdXNlQ29udGV4dDIoUmVhY3ROb2RlVmlld0NvbnRleHQpO1xuXG4vLyBzcmMvTm9kZVZpZXdDb250ZW50LnRzeFxuaW1wb3J0IHsganN4IGFzIGpzeDMgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmZ1bmN0aW9uIE5vZGVWaWV3Q29udGVudCh7XG4gIGFzOiBUYWcgPSBcImRpdlwiLFxuICAuLi5wcm9wc1xufSkge1xuICBjb25zdCB7IG5vZGVWaWV3Q29udGVudFJlZiwgbm9kZVZpZXdDb250ZW50Q2hpbGRyZW4gfSA9IHVzZVJlYWN0Tm9kZVZpZXcoKTtcbiAgcmV0dXJuIChcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgLyogQF9fUFVSRV9fICovIGpzeDMoXG4gICAgICBUYWcsXG4gICAgICB7XG4gICAgICAgIC4uLnByb3BzLFxuICAgICAgICByZWY6IG5vZGVWaWV3Q29udGVudFJlZixcbiAgICAgICAgXCJkYXRhLW5vZGUtdmlldy1jb250ZW50XCI6IFwiXCIsXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgd2hpdGVTcGFjZTogXCJwcmUtd3JhcFwiLFxuICAgICAgICAgIC4uLnByb3BzLnN0eWxlXG4gICAgICAgIH0sXG4gICAgICAgIGNoaWxkcmVuOiBub2RlVmlld0NvbnRlbnRDaGlsZHJlblxuICAgICAgfVxuICAgIClcbiAgKTtcbn1cblxuLy8gc3JjL05vZGVWaWV3V3JhcHBlci50c3hcbmltcG9ydCBSZWFjdDMgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBqc3ggYXMganN4NCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIE5vZGVWaWV3V3JhcHBlciA9IFJlYWN0My5mb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiB7XG4gIGNvbnN0IHsgb25EcmFnU3RhcnQgfSA9IHVzZVJlYWN0Tm9kZVZpZXcoKTtcbiAgY29uc3QgVGFnID0gcHJvcHMuYXMgfHwgXCJkaXZcIjtcbiAgcmV0dXJuIChcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgLyogQF9fUFVSRV9fICovIGpzeDQoXG4gICAgICBUYWcsXG4gICAgICB7XG4gICAgICAgIC4uLnByb3BzLFxuICAgICAgICByZWYsXG4gICAgICAgIFwiZGF0YS1ub2RlLXZpZXctd3JhcHBlclwiOiBcIlwiLFxuICAgICAgICBvbkRyYWdTdGFydCxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICB3aGl0ZVNwYWNlOiBcIm5vcm1hbFwiLFxuICAgICAgICAgIC4uLnByb3BzLnN0eWxlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApXG4gICk7XG59KTtcblxuLy8gc3JjL1JlYWN0TWFya1ZpZXdSZW5kZXJlci50c3hcbmltcG9ydCB7IE1hcmtWaWV3IH0gZnJvbSBcIkB0aXB0YXAvY29yZVwiO1xuaW1wb3J0IFJlYWN0NCBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL1JlYWN0UmVuZGVyZXIudHN4XG5pbXBvcnQgeyB2ZXJzaW9uIGFzIHJlYWN0VmVyc2lvbiB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgZmx1c2hTeW5jIH0gZnJvbSBcInJlYWN0LWRvbVwiO1xuaW1wb3J0IHsganN4IGFzIGpzeDUgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmZ1bmN0aW9uIGlzQ2xhc3NDb21wb25lbnQoQ29tcG9uZW50KSB7XG4gIHJldHVybiAhISh0eXBlb2YgQ29tcG9uZW50ID09PSBcImZ1bmN0aW9uXCIgJiYgQ29tcG9uZW50LnByb3RvdHlwZSAmJiBDb21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xufVxuZnVuY3Rpb24gaXNGb3J3YXJkUmVmQ29tcG9uZW50KENvbXBvbmVudCkge1xuICByZXR1cm4gISEodHlwZW9mIENvbXBvbmVudCA9PT0gXCJvYmplY3RcIiAmJiBDb21wb25lbnQuJCR0eXBlb2YgJiYgKENvbXBvbmVudC4kJHR5cGVvZi50b1N0cmluZygpID09PSBcIlN5bWJvbChyZWFjdC5mb3J3YXJkX3JlZilcIiB8fCBDb21wb25lbnQuJCR0eXBlb2YuZGVzY3JpcHRpb24gPT09IFwicmVhY3QuZm9yd2FyZF9yZWZcIikpO1xufVxuZnVuY3Rpb24gaXNNZW1vQ29tcG9uZW50KENvbXBvbmVudCkge1xuICByZXR1cm4gISEodHlwZW9mIENvbXBvbmVudCA9PT0gXCJvYmplY3RcIiAmJiBDb21wb25lbnQuJCR0eXBlb2YgJiYgKENvbXBvbmVudC4kJHR5cGVvZi50b1N0cmluZygpID09PSBcIlN5bWJvbChyZWFjdC5tZW1vKVwiIHx8IENvbXBvbmVudC4kJHR5cGVvZi5kZXNjcmlwdGlvbiA9PT0gXCJyZWFjdC5tZW1vXCIpKTtcbn1cbmZ1bmN0aW9uIGNhblJlY2VpdmVSZWYoQ29tcG9uZW50KSB7XG4gIGlmIChpc0NsYXNzQ29tcG9uZW50KENvbXBvbmVudCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoaXNGb3J3YXJkUmVmQ29tcG9uZW50KENvbXBvbmVudCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoaXNNZW1vQ29tcG9uZW50KENvbXBvbmVudCkpIHtcbiAgICBjb25zdCB3cmFwcGVkQ29tcG9uZW50ID0gQ29tcG9uZW50LnR5cGU7XG4gICAgaWYgKHdyYXBwZWRDb21wb25lbnQpIHtcbiAgICAgIHJldHVybiBpc0NsYXNzQ29tcG9uZW50KHdyYXBwZWRDb21wb25lbnQpIHx8IGlzRm9yd2FyZFJlZkNvbXBvbmVudCh3cmFwcGVkQ29tcG9uZW50KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNSZWFjdDE5UGx1cygpIHtcbiAgdHJ5IHtcbiAgICBpZiAocmVhY3RWZXJzaW9uKSB7XG4gICAgICBjb25zdCBtYWpvclZlcnNpb24gPSBwYXJzZUludChyZWFjdFZlcnNpb24uc3BsaXQoXCIuXCIpWzBdLCAxMCk7XG4gICAgICByZXR1cm4gbWFqb3JWZXJzaW9uID49IDE5O1xuICAgIH1cbiAgfSBjYXRjaCB7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxudmFyIFJlYWN0UmVuZGVyZXIgPSBjbGFzcyB7XG4gIC8qKlxuICAgKiBJbW1lZGlhdGVseSBjcmVhdGVzIGVsZW1lbnQgYW5kIHJlbmRlcnMgdGhlIHByb3ZpZGVkIFJlYWN0IGNvbXBvbmVudC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvbXBvbmVudCwgeyBlZGl0b3IsIHByb3BzID0ge30sIGFzID0gXCJkaXZcIiwgY2xhc3NOYW1lID0gXCJcIiB9KSB7XG4gICAgdGhpcy5yZWYgPSBudWxsO1xuICAgIHRoaXMuaWQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiA0Mjk0OTY3Mjk1KS50b1N0cmluZygpO1xuICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xuICAgIHRoaXMuZWRpdG9yID0gZWRpdG9yO1xuICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICB0aGlzLmVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGFzKTtcbiAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmFkZChcInJlYWN0LXJlbmRlcmVyXCIpO1xuICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKC4uLmNsYXNzTmFtZS5zcGxpdChcIiBcIikpO1xuICAgIH1cbiAgICBpZiAodGhpcy5lZGl0b3IuaXNJbml0aWFsaXplZCkge1xuICAgICAgZmx1c2hTeW5jKCgpID0+IHtcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlbmRlciB0aGUgUmVhY3QgY29tcG9uZW50LlxuICAgKi9cbiAgcmVuZGVyKCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBDb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudDtcbiAgICBjb25zdCBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgZWRpdG9yID0gdGhpcy5lZGl0b3I7XG4gICAgY29uc3QgaXNSZWFjdDE5ID0gaXNSZWFjdDE5UGx1cygpO1xuICAgIGNvbnN0IGNvbXBvbmVudENhblJlY2VpdmVSZWYgPSBjYW5SZWNlaXZlUmVmKENvbXBvbmVudCk7XG4gICAgY29uc3QgZWxlbWVudFByb3BzID0geyAuLi5wcm9wcyB9O1xuICAgIGlmIChlbGVtZW50UHJvcHMucmVmICYmICEoaXNSZWFjdDE5IHx8IGNvbXBvbmVudENhblJlY2VpdmVSZWYpKSB7XG4gICAgICBkZWxldGUgZWxlbWVudFByb3BzLnJlZjtcbiAgICB9XG4gICAgaWYgKCFlbGVtZW50UHJvcHMucmVmICYmIChpc1JlYWN0MTkgfHwgY29tcG9uZW50Q2FuUmVjZWl2ZVJlZikpIHtcbiAgICAgIGVsZW1lbnRQcm9wcy5yZWYgPSAocmVmKSA9PiB7XG4gICAgICAgIHRoaXMucmVmID0gcmVmO1xuICAgICAgfTtcbiAgICB9XG4gICAgdGhpcy5yZWFjdEVsZW1lbnQgPSAvKiBAX19QVVJFX18gKi8ganN4NShDb21wb25lbnQsIHsgLi4uZWxlbWVudFByb3BzIH0pO1xuICAgIChfYSA9IGVkaXRvciA9PSBudWxsID8gdm9pZCAwIDogZWRpdG9yLmNvbnRlbnRDb21wb25lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5zZXRSZW5kZXJlcih0aGlzLmlkLCB0aGlzKTtcbiAgfVxuICAvKipcbiAgICogUmUtcmVuZGVycyB0aGUgUmVhY3QgY29tcG9uZW50IHdpdGggbmV3IHByb3BzLlxuICAgKi9cbiAgdXBkYXRlUHJvcHMocHJvcHMgPSB7fSkge1xuICAgIHRoaXMucHJvcHMgPSB7XG4gICAgICAuLi50aGlzLnByb3BzLFxuICAgICAgLi4ucHJvcHNcbiAgICB9O1xuICAgIHRoaXMucmVuZGVyKCk7XG4gIH1cbiAgLyoqXG4gICAqIERlc3Ryb3kgdGhlIFJlYWN0IGNvbXBvbmVudC5cbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuZWRpdG9yO1xuICAgIChfYSA9IGVkaXRvciA9PSBudWxsID8gdm9pZCAwIDogZWRpdG9yLmNvbnRlbnRDb21wb25lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5yZW1vdmVSZW5kZXJlcih0aGlzLmlkKTtcbiAgICB0cnkge1xuICAgICAgaWYgKHRoaXMuZWxlbWVudCAmJiB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgICB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmVsZW1lbnQpO1xuICAgICAgfVxuICAgIH0gY2F0Y2gge1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVXBkYXRlIHRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBlbGVtZW50IHRoYXQgaG9sZHMgdGhlIFJlYWN0IGNvbXBvbmVudC5cbiAgICovXG4gIHVwZGF0ZUF0dHJpYnV0ZXMoYXR0cmlidXRlcykge1xuICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZShrZXksIGF0dHJpYnV0ZXNba2V5XSk7XG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIHNyYy9SZWFjdE1hcmtWaWV3UmVuZGVyZXIudHN4XG5pbXBvcnQgeyBqc3ggYXMganN4NiB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIFJlYWN0TWFya1ZpZXdDb250ZXh0ID0gUmVhY3Q0LmNyZWF0ZUNvbnRleHQoe1xuICBtYXJrVmlld0NvbnRlbnRSZWY6ICgpID0+IHtcbiAgfVxufSk7XG52YXIgTWFya1ZpZXdDb250ZW50ID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHsgYXM6IFRhZyA9IFwic3BhblwiLCAuLi5yZXN0IH0gPSBwcm9wcztcbiAgY29uc3QgeyBtYXJrVmlld0NvbnRlbnRSZWYgfSA9IFJlYWN0NC51c2VDb250ZXh0KFJlYWN0TWFya1ZpZXdDb250ZXh0KTtcbiAgcmV0dXJuIChcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgLyogQF9fUFVSRV9fICovIGpzeDYoVGFnLCB7IC4uLnJlc3QsIHJlZjogbWFya1ZpZXdDb250ZW50UmVmLCBcImRhdGEtbWFyay12aWV3LWNvbnRlbnRcIjogXCJcIiB9KVxuICApO1xufTtcbnZhciBSZWFjdE1hcmtWaWV3ID0gY2xhc3MgZXh0ZW5kcyBNYXJrVmlldyB7XG4gIGNvbnN0cnVjdG9yKGNvbXBvbmVudCwgcHJvcHMsIG9wdGlvbnMpIHtcbiAgICBzdXBlcihjb21wb25lbnQsIHByb3BzLCBvcHRpb25zKTtcbiAgICBjb25zdCB7IGFzID0gXCJzcGFuXCIsIGF0dHJzLCBjbGFzc05hbWUgPSBcIlwiIH0gPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IGNvbXBvbmVudFByb3BzID0geyAuLi5wcm9wcywgdXBkYXRlQXR0cmlidXRlczogdGhpcy51cGRhdGVBdHRyaWJ1dGVzLmJpbmQodGhpcykgfTtcbiAgICB0aGlzLmNvbnRlbnRET01FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgY29uc3QgbWFya1ZpZXdDb250ZW50UmVmID0gKGVsKSA9PiB7XG4gICAgICBpZiAoZWwgJiYgIWVsLmNvbnRhaW5zKHRoaXMuY29udGVudERPTUVsZW1lbnQpKSB7XG4gICAgICAgIGVsLmFwcGVuZENoaWxkKHRoaXMuY29udGVudERPTUVsZW1lbnQpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgIG1hcmtWaWV3Q29udGVudFJlZlxuICAgIH07XG4gICAgY29uc3QgUmVhY3RNYXJrVmlld1Byb3ZpZGVyID0gUmVhY3Q0Lm1lbW8oKGNvbXBvbmVudFByb3BzMikgPT4ge1xuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3g2KFJlYWN0TWFya1ZpZXdDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBjb250ZXh0LCBjaGlsZHJlbjogUmVhY3Q0LmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50LCBjb21wb25lbnRQcm9wczIpIH0pO1xuICAgIH0pO1xuICAgIFJlYWN0TWFya1ZpZXdQcm92aWRlci5kaXNwbGF5TmFtZSA9IFwiUmVhY3RNYXJrVmlld1wiO1xuICAgIHRoaXMucmVuZGVyZXIgPSBuZXcgUmVhY3RSZW5kZXJlcihSZWFjdE1hcmtWaWV3UHJvdmlkZXIsIHtcbiAgICAgIGVkaXRvcjogcHJvcHMuZWRpdG9yLFxuICAgICAgcHJvcHM6IGNvbXBvbmVudFByb3BzLFxuICAgICAgYXMsXG4gICAgICBjbGFzc05hbWU6IGBtYXJrLSR7cHJvcHMubWFyay50eXBlLm5hbWV9ICR7Y2xhc3NOYW1lfWAudHJpbSgpXG4gICAgfSk7XG4gICAgaWYgKGF0dHJzKSB7XG4gICAgICB0aGlzLnJlbmRlcmVyLnVwZGF0ZUF0dHJpYnV0ZXMoYXR0cnMpO1xuICAgIH1cbiAgfVxuICBnZXQgZG9tKCkge1xuICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmVsZW1lbnQ7XG4gIH1cbiAgZ2V0IGNvbnRlbnRET00oKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudERPTUVsZW1lbnQ7XG4gIH1cbn07XG5mdW5jdGlvbiBSZWFjdE1hcmtWaWV3UmVuZGVyZXIoY29tcG9uZW50LCBvcHRpb25zID0ge30pIHtcbiAgcmV0dXJuIChwcm9wcykgPT4gbmV3IFJlYWN0TWFya1ZpZXcoY29tcG9uZW50LCBwcm9wcywgb3B0aW9ucyk7XG59XG5cbi8vIHNyYy9SZWFjdE5vZGVWaWV3UmVuZGVyZXIudHN4XG5pbXBvcnQgeyBnZXRSZW5kZXJlZEF0dHJpYnV0ZXMsIE5vZGVWaWV3IH0gZnJvbSBcIkB0aXB0YXAvY29yZVwiO1xuaW1wb3J0IHsgY3JlYXRlRWxlbWVudCBhcyBjcmVhdGVFbGVtZW50MiwgY3JlYXRlUmVmLCBtZW1vIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBqc3ggYXMganN4NyB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIFJlYWN0Tm9kZVZpZXcgPSBjbGFzcyBleHRlbmRzIE5vZGVWaWV3IHtcbiAgY29uc3RydWN0b3IoY29tcG9uZW50LCBwcm9wcywgb3B0aW9ucykge1xuICAgIHN1cGVyKGNvbXBvbmVudCwgcHJvcHMsIG9wdGlvbnMpO1xuICAgIC8qKlxuICAgICAqIFRoZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgSUQgdXNlZCBmb3Igc2VsZWN0aW9uIHVwZGF0ZXMuXG4gICAgICovXG4gICAgdGhpcy5zZWxlY3Rpb25SYWZJZCA9IG51bGw7XG4gICAgaWYgKCF0aGlzLm5vZGUuaXNMZWFmKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmNvbnRlbnRET01FbGVtZW50VGFnKSB7XG4gICAgICAgIHRoaXMuY29udGVudERPTUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRoaXMub3B0aW9ucy5jb250ZW50RE9NRWxlbWVudFRhZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvbnRlbnRET01FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0aGlzLm5vZGUuaXNJbmxpbmUgPyBcInNwYW5cIiA6IFwiZGl2XCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5jb250ZW50RE9NRWxlbWVudC5kYXRhc2V0Lm5vZGVWaWV3Q29udGVudFJlYWN0ID0gXCJcIjtcbiAgICAgIHRoaXMuY29udGVudERPTUVsZW1lbnQuZGF0YXNldC5ub2RlVmlld1dyYXBwZXIgPSBcIlwiO1xuICAgICAgdGhpcy5jb250ZW50RE9NRWxlbWVudC5zdHlsZS53aGl0ZVNwYWNlID0gXCJpbmhlcml0XCI7XG4gICAgICBjb25zdCBjb250ZW50VGFyZ2V0ID0gdGhpcy5kb20ucXVlcnlTZWxlY3RvcihcIltkYXRhLW5vZGUtdmlldy1jb250ZW50XVwiKTtcbiAgICAgIGlmICghY29udGVudFRhcmdldCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb250ZW50VGFyZ2V0LmFwcGVuZENoaWxkKHRoaXMuY29udGVudERPTUVsZW1lbnQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogU2V0dXAgdGhlIFJlYWN0IGNvbXBvbmVudC5cbiAgICogQ2FsbGVkIG9uIGluaXRpYWxpemF0aW9uLlxuICAgKi9cbiAgbW91bnQoKSB7XG4gICAgY29uc3QgcHJvcHMgPSB7XG4gICAgICBlZGl0b3I6IHRoaXMuZWRpdG9yLFxuICAgICAgbm9kZTogdGhpcy5ub2RlLFxuICAgICAgZGVjb3JhdGlvbnM6IHRoaXMuZGVjb3JhdGlvbnMsXG4gICAgICBpbm5lckRlY29yYXRpb25zOiB0aGlzLmlubmVyRGVjb3JhdGlvbnMsXG4gICAgICB2aWV3OiB0aGlzLnZpZXcsXG4gICAgICBzZWxlY3RlZDogZmFsc2UsXG4gICAgICBleHRlbnNpb246IHRoaXMuZXh0ZW5zaW9uLFxuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHRoaXMuSFRNTEF0dHJpYnV0ZXMsXG4gICAgICBnZXRQb3M6ICgpID0+IHRoaXMuZ2V0UG9zKCksXG4gICAgICB1cGRhdGVBdHRyaWJ1dGVzOiAoYXR0cmlidXRlcyA9IHt9KSA9PiB0aGlzLnVwZGF0ZUF0dHJpYnV0ZXMoYXR0cmlidXRlcyksXG4gICAgICBkZWxldGVOb2RlOiAoKSA9PiB0aGlzLmRlbGV0ZU5vZGUoKSxcbiAgICAgIHJlZjogY3JlYXRlUmVmKClcbiAgICB9O1xuICAgIGlmICghdGhpcy5jb21wb25lbnQuZGlzcGxheU5hbWUpIHtcbiAgICAgIGNvbnN0IGNhcGl0YWxpemVGaXJzdENoYXIgPSAoc3RyaW5nKSA9PiB7XG4gICAgICAgIHJldHVybiBzdHJpbmcuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHJpbmcuc3Vic3RyaW5nKDEpO1xuICAgICAgfTtcbiAgICAgIHRoaXMuY29tcG9uZW50LmRpc3BsYXlOYW1lID0gY2FwaXRhbGl6ZUZpcnN0Q2hhcih0aGlzLmV4dGVuc2lvbi5uYW1lKTtcbiAgICB9XG4gICAgY29uc3Qgb25EcmFnU3RhcnQgPSB0aGlzLm9uRHJhZ1N0YXJ0LmJpbmQodGhpcyk7XG4gICAgY29uc3Qgbm9kZVZpZXdDb250ZW50UmVmID0gKGVsZW1lbnQpID0+IHtcbiAgICAgIGlmIChlbGVtZW50ICYmIHRoaXMuY29udGVudERPTUVsZW1lbnQgJiYgZWxlbWVudC5maXJzdENoaWxkICE9PSB0aGlzLmNvbnRlbnRET01FbGVtZW50KSB7XG4gICAgICAgIGlmIChlbGVtZW50Lmhhc0F0dHJpYnV0ZShcImRhdGEtbm9kZS12aWV3LXdyYXBwZXJcIikpIHtcbiAgICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtbm9kZS12aWV3LXdyYXBwZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLmNvbnRlbnRET01FbGVtZW50KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGNvbnRleHQgPSB7IG9uRHJhZ1N0YXJ0LCBub2RlVmlld0NvbnRlbnRSZWYgfTtcbiAgICBjb25zdCBDb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudDtcbiAgICBjb25zdCBSZWFjdE5vZGVWaWV3UHJvdmlkZXIgPSBtZW1vKChjb21wb25lbnRQcm9wcykgPT4ge1xuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3g3KFJlYWN0Tm9kZVZpZXdDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBjb250ZXh0LCBjaGlsZHJlbjogY3JlYXRlRWxlbWVudDIoQ29tcG9uZW50LCBjb21wb25lbnRQcm9wcykgfSk7XG4gICAgfSk7XG4gICAgUmVhY3ROb2RlVmlld1Byb3ZpZGVyLmRpc3BsYXlOYW1lID0gXCJSZWFjdE5vZGVWaWV3XCI7XG4gICAgbGV0IGFzID0gdGhpcy5ub2RlLmlzSW5saW5lID8gXCJzcGFuXCIgOiBcImRpdlwiO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuYXMpIHtcbiAgICAgIGFzID0gdGhpcy5vcHRpb25zLmFzO1xuICAgIH1cbiAgICBjb25zdCB7IGNsYXNzTmFtZSA9IFwiXCIgfSA9IHRoaXMub3B0aW9ucztcbiAgICB0aGlzLmhhbmRsZVNlbGVjdGlvblVwZGF0ZSA9IHRoaXMuaGFuZGxlU2VsZWN0aW9uVXBkYXRlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5yZW5kZXJlciA9IG5ldyBSZWFjdFJlbmRlcmVyKFJlYWN0Tm9kZVZpZXdQcm92aWRlciwge1xuICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcbiAgICAgIHByb3BzLFxuICAgICAgYXMsXG4gICAgICBjbGFzc05hbWU6IGBub2RlLSR7dGhpcy5ub2RlLnR5cGUubmFtZX0gJHtjbGFzc05hbWV9YC50cmltKClcbiAgICB9KTtcbiAgICB0aGlzLmVkaXRvci5vbihcInNlbGVjdGlvblVwZGF0ZVwiLCB0aGlzLmhhbmRsZVNlbGVjdGlvblVwZGF0ZSk7XG4gICAgdGhpcy51cGRhdGVFbGVtZW50QXR0cmlidXRlcygpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIERPTSBlbGVtZW50LlxuICAgKiBUaGlzIGlzIHRoZSBlbGVtZW50IHRoYXQgd2lsbCBiZSB1c2VkIHRvIGRpc3BsYXkgdGhlIG5vZGUgdmlldy5cbiAgICovXG4gIGdldCBkb20oKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICh0aGlzLnJlbmRlcmVyLmVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQgJiYgISgoX2EgPSB0aGlzLnJlbmRlcmVyLmVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5oYXNBdHRyaWJ1dGUoXCJkYXRhLW5vZGUtdmlldy13cmFwcGVyXCIpKSkge1xuICAgICAgdGhyb3cgRXJyb3IoXCJQbGVhc2UgdXNlIHRoZSBOb2RlVmlld1dyYXBwZXIgY29tcG9uZW50IGZvciB5b3VyIG5vZGUgdmlldy5cIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmVsZW1lbnQ7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgY29udGVudCBET00gZWxlbWVudC5cbiAgICogVGhpcyBpcyB0aGUgZWxlbWVudCB0aGF0IHdpbGwgYmUgdXNlZCB0byBkaXNwbGF5IHRoZSByaWNoLXRleHQgY29udGVudCBvZiB0aGUgbm9kZS5cbiAgICovXG4gIGdldCBjb250ZW50RE9NKCkge1xuICAgIGlmICh0aGlzLm5vZGUuaXNMZWFmKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29udGVudERPTUVsZW1lbnQ7XG4gIH1cbiAgLyoqXG4gICAqIE9uIGVkaXRvciBzZWxlY3Rpb24gdXBkYXRlLCBjaGVjayBpZiB0aGUgbm9kZSBpcyBzZWxlY3RlZC5cbiAgICogSWYgaXQgaXMsIGNhbGwgYHNlbGVjdE5vZGVgLCBvdGhlcndpc2UgY2FsbCBgZGVzZWxlY3ROb2RlYC5cbiAgICovXG4gIGhhbmRsZVNlbGVjdGlvblVwZGF0ZSgpIHtcbiAgICBpZiAodGhpcy5zZWxlY3Rpb25SYWZJZCkge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5zZWxlY3Rpb25SYWZJZCk7XG4gICAgICB0aGlzLnNlbGVjdGlvblJhZklkID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5zZWxlY3Rpb25SYWZJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICB0aGlzLnNlbGVjdGlvblJhZklkID0gbnVsbDtcbiAgICAgIGNvbnN0IHsgZnJvbSwgdG8gfSA9IHRoaXMuZWRpdG9yLnN0YXRlLnNlbGVjdGlvbjtcbiAgICAgIGNvbnN0IHBvcyA9IHRoaXMuZ2V0UG9zKCk7XG4gICAgICBpZiAodHlwZW9mIHBvcyAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZnJvbSA8PSBwb3MgJiYgdG8gPj0gcG9zICsgdGhpcy5ub2RlLm5vZGVTaXplKSB7XG4gICAgICAgIGlmICh0aGlzLnJlbmRlcmVyLnByb3BzLnNlbGVjdGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VsZWN0Tm9kZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCF0aGlzLnJlbmRlcmVyLnByb3BzLnNlbGVjdGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVzZWxlY3ROb2RlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIE9uIHVwZGF0ZSwgdXBkYXRlIHRoZSBSZWFjdCBjb21wb25lbnQuXG4gICAqIFRvIHByZXZlbnQgdW5uZWNlc3NhcnkgdXBkYXRlcywgdGhlIGB1cGRhdGVgIG9wdGlvbiBjYW4gYmUgdXNlZC5cbiAgICovXG4gIHVwZGF0ZShub2RlLCBkZWNvcmF0aW9ucywgaW5uZXJEZWNvcmF0aW9ucykge1xuICAgIGNvbnN0IHJlcmVuZGVyQ29tcG9uZW50ID0gKHByb3BzKSA9PiB7XG4gICAgICB0aGlzLnJlbmRlcmVyLnVwZGF0ZVByb3BzKHByb3BzKTtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLmF0dHJzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhpcy51cGRhdGVFbGVtZW50QXR0cmlidXRlcygpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKG5vZGUudHlwZSAhPT0gdGhpcy5ub2RlLnR5cGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMudXBkYXRlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGNvbnN0IG9sZE5vZGUgPSB0aGlzLm5vZGU7XG4gICAgICBjb25zdCBvbGREZWNvcmF0aW9ucyA9IHRoaXMuZGVjb3JhdGlvbnM7XG4gICAgICBjb25zdCBvbGRJbm5lckRlY29yYXRpb25zID0gdGhpcy5pbm5lckRlY29yYXRpb25zO1xuICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSBkZWNvcmF0aW9ucztcbiAgICAgIHRoaXMuaW5uZXJEZWNvcmF0aW9ucyA9IGlubmVyRGVjb3JhdGlvbnM7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnVwZGF0ZSh7XG4gICAgICAgIG9sZE5vZGUsXG4gICAgICAgIG9sZERlY29yYXRpb25zLFxuICAgICAgICBuZXdOb2RlOiBub2RlLFxuICAgICAgICBuZXdEZWNvcmF0aW9uczogZGVjb3JhdGlvbnMsXG4gICAgICAgIG9sZElubmVyRGVjb3JhdGlvbnMsXG4gICAgICAgIGlubmVyRGVjb3JhdGlvbnMsXG4gICAgICAgIHVwZGF0ZVByb3BzOiAoKSA9PiByZXJlbmRlckNvbXBvbmVudCh7IG5vZGUsIGRlY29yYXRpb25zLCBpbm5lckRlY29yYXRpb25zIH0pXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKG5vZGUgPT09IHRoaXMubm9kZSAmJiB0aGlzLmRlY29yYXRpb25zID09PSBkZWNvcmF0aW9ucyAmJiB0aGlzLmlubmVyRGVjb3JhdGlvbnMgPT09IGlubmVyRGVjb3JhdGlvbnMpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgIHRoaXMuZGVjb3JhdGlvbnMgPSBkZWNvcmF0aW9ucztcbiAgICB0aGlzLmlubmVyRGVjb3JhdGlvbnMgPSBpbm5lckRlY29yYXRpb25zO1xuICAgIHJlcmVuZGVyQ29tcG9uZW50KHsgbm9kZSwgZGVjb3JhdGlvbnMsIGlubmVyRGVjb3JhdGlvbnMgfSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFNlbGVjdCB0aGUgbm9kZS5cbiAgICogQWRkIHRoZSBgc2VsZWN0ZWRgIHByb3AgYW5kIHRoZSBgUHJvc2VNaXJyb3Itc2VsZWN0ZWRub2RlYCBjbGFzcy5cbiAgICovXG4gIHNlbGVjdE5vZGUoKSB7XG4gICAgdGhpcy5yZW5kZXJlci51cGRhdGVQcm9wcyh7XG4gICAgICBzZWxlY3RlZDogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMucmVuZGVyZXIuZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwiUHJvc2VNaXJyb3Itc2VsZWN0ZWRub2RlXCIpO1xuICB9XG4gIC8qKlxuICAgKiBEZXNlbGVjdCB0aGUgbm9kZS5cbiAgICogUmVtb3ZlIHRoZSBgc2VsZWN0ZWRgIHByb3AgYW5kIHRoZSBgUHJvc2VNaXJyb3Itc2VsZWN0ZWRub2RlYCBjbGFzcy5cbiAgICovXG4gIGRlc2VsZWN0Tm9kZSgpIHtcbiAgICB0aGlzLnJlbmRlcmVyLnVwZGF0ZVByb3BzKHtcbiAgICAgIHNlbGVjdGVkOiBmYWxzZVxuICAgIH0pO1xuICAgIHRoaXMucmVuZGVyZXIuZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKFwiUHJvc2VNaXJyb3Itc2VsZWN0ZWRub2RlXCIpO1xuICB9XG4gIC8qKlxuICAgKiBEZXN0cm95IHRoZSBSZWFjdCBjb21wb25lbnQgaW5zdGFuY2UuXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMucmVuZGVyZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuZWRpdG9yLm9mZihcInNlbGVjdGlvblVwZGF0ZVwiLCB0aGlzLmhhbmRsZVNlbGVjdGlvblVwZGF0ZSk7XG4gICAgdGhpcy5jb250ZW50RE9NRWxlbWVudCA9IG51bGw7XG4gICAgaWYgKHRoaXMuc2VsZWN0aW9uUmFmSWQpIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuc2VsZWN0aW9uUmFmSWQpO1xuICAgICAgdGhpcy5zZWxlY3Rpb25SYWZJZCA9IG51bGw7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGF0dHJpYnV0ZXMgb2YgdGhlIHRvcC1sZXZlbCBlbGVtZW50IHRoYXQgaG9sZHMgdGhlIFJlYWN0IGNvbXBvbmVudC5cbiAgICogQXBwbHlpbmcgdGhlIGF0dHJpYnV0ZXMgZGVmaW5lZCBpbiB0aGUgYGF0dHJzYCBvcHRpb24uXG4gICAqL1xuICB1cGRhdGVFbGVtZW50QXR0cmlidXRlcygpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmF0dHJzKSB7XG4gICAgICBsZXQgYXR0cnNPYmogPSB7fTtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLmF0dHJzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY29uc3QgZXh0ZW5zaW9uQXR0cmlidXRlcyA9IHRoaXMuZWRpdG9yLmV4dGVuc2lvbk1hbmFnZXIuYXR0cmlidXRlcztcbiAgICAgICAgY29uc3QgSFRNTEF0dHJpYnV0ZXMgPSBnZXRSZW5kZXJlZEF0dHJpYnV0ZXModGhpcy5ub2RlLCBleHRlbnNpb25BdHRyaWJ1dGVzKTtcbiAgICAgICAgYXR0cnNPYmogPSB0aGlzLm9wdGlvbnMuYXR0cnMoeyBub2RlOiB0aGlzLm5vZGUsIEhUTUxBdHRyaWJ1dGVzIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXR0cnNPYmogPSB0aGlzLm9wdGlvbnMuYXR0cnM7XG4gICAgICB9XG4gICAgICB0aGlzLnJlbmRlcmVyLnVwZGF0ZUF0dHJpYnV0ZXMoYXR0cnNPYmopO1xuICAgIH1cbiAgfVxufTtcbmZ1bmN0aW9uIFJlYWN0Tm9kZVZpZXdSZW5kZXJlcihjb21wb25lbnQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIChwcm9wcykgPT4ge1xuICAgIGlmICghcHJvcHMuZWRpdG9yLmNvbnRlbnRDb21wb25lbnQpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBSZWFjdE5vZGVWaWV3KGNvbXBvbmVudCwgcHJvcHMsIG9wdGlvbnMpO1xuICB9O1xufVxuXG4vLyBzcmMvaW5kZXgudHNcbmV4cG9ydCAqIGZyb20gXCJAdGlwdGFwL2NvcmVcIjtcbmV4cG9ydCB7XG4gIEVkaXRvckNvbnN1bWVyLFxuICBFZGl0b3JDb250ZW50LFxuICBFZGl0b3JDb250ZXh0LFxuICBFZGl0b3JQcm92aWRlcixcbiAgTWFya1ZpZXdDb250ZW50LFxuICBOb2RlVmlld0NvbnRlbnQsXG4gIE5vZGVWaWV3V3JhcHBlcixcbiAgUHVyZUVkaXRvckNvbnRlbnQsXG4gIFJlYWN0TWFya1ZpZXcsXG4gIFJlYWN0TWFya1ZpZXdDb250ZXh0LFxuICBSZWFjdE1hcmtWaWV3UmVuZGVyZXIsXG4gIFJlYWN0Tm9kZVZpZXcsXG4gIFJlYWN0Tm9kZVZpZXdDb250ZW50UHJvdmlkZXIsXG4gIFJlYWN0Tm9kZVZpZXdDb250ZXh0LFxuICBSZWFjdE5vZGVWaWV3UmVuZGVyZXIsXG4gIFJlYWN0UmVuZGVyZXIsXG4gIHVzZUN1cnJlbnRFZGl0b3IsXG4gIHVzZUVkaXRvcixcbiAgdXNlRWRpdG9yU3RhdGUsXG4gIHVzZVJlYWN0Tm9kZVZpZXdcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsiY3JlYXRlQ29udGV4dCIsInVzZUNvbnRleHQiLCJ1c2VNZW1vIiwiUmVhY3QiLCJmb3J3YXJkUmVmIiwiUmVhY3RET00iLCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZSIsIkZyYWdtZW50IiwianN4IiwianN4cyIsIm1lcmdlUmVmcyIsInJlZnMiLCJub2RlIiwiZm9yRWFjaCIsInJlZiIsImN1cnJlbnQiLCJQb3J0YWxzIiwiY29udGVudENvbXBvbmVudCIsInJlbmRlcmVycyIsInN1YnNjcmliZSIsImdldFNuYXBzaG90IiwiZ2V0U2VydmVyU25hcHNob3QiLCJjaGlsZHJlbiIsIk9iamVjdCIsInZhbHVlcyIsImdldEluc3RhbmNlIiwic3Vic2NyaWJlcnMiLCJTZXQiLCJjYWxsYmFjayIsImFkZCIsImRlbGV0ZSIsInNldFJlbmRlcmVyIiwiaWQiLCJyZW5kZXJlciIsImNyZWF0ZVBvcnRhbCIsInJlYWN0RWxlbWVudCIsImVsZW1lbnQiLCJzdWJzY3JpYmVyIiwicmVtb3ZlUmVuZGVyZXIiLCJuZXh0UmVuZGVyZXJzIiwiUHVyZUVkaXRvckNvbnRlbnQiLCJDb21wb25lbnQiLCJjb25zdHJ1Y3RvciIsInByb3BzIiwiX2EiLCJlZGl0b3JDb250ZW50UmVmIiwiY3JlYXRlUmVmIiwiaW5pdGlhbGl6ZWQiLCJzdGF0ZSIsImhhc0NvbnRlbnRDb21wb25lbnRJbml0aWFsaXplZCIsIkJvb2xlYW4iLCJlZGl0b3IiLCJjb21wb25lbnREaWRNb3VudCIsImluaXQiLCJjb21wb25lbnREaWRVcGRhdGUiLCJpc0Rlc3Ryb3llZCIsIm9wdGlvbnMiLCJhcHBlbmQiLCJ2aWV3IiwiZG9tIiwic2V0T3B0aW9ucyIsInVuc3Vic2NyaWJlVG9Db250ZW50Q29tcG9uZW50Iiwic2V0U3RhdGUiLCJwcmV2U3RhdGUiLCJjcmVhdGVOb2RlVmlld3MiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsInNldFByb3BzIiwibm9kZVZpZXdzIiwiZmlyc3RDaGlsZCIsIm5ld0VsZW1lbnQiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJyZW5kZXIiLCJpbm5lclJlZiIsInJlc3QiLCJFZGl0b3JDb250ZW50V2l0aEtleSIsImtleSIsIk1hdGgiLCJmbG9vciIsInJhbmRvbSIsInRvU3RyaW5nIiwiRWRpdG9yQ29udGVudCIsIm1lbW8iLCJFZGl0b3IiLCJ1c2VEZWJ1Z1ZhbHVlIiwidXNlRGVidWdWYWx1ZTIiLCJ1c2VFZmZlY3QiLCJ1c2VFZmZlY3QyIiwidXNlUmVmIiwidXNlU3RhdGUiLCJ1c2VTdGF0ZTIiLCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZTIiLCJkZWVwRXF1YWwiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvciIsInVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QiLCJFZGl0b3JTdGF0ZU1hbmFnZXIiLCJpbml0aWFsRWRpdG9yIiwidHJhbnNhY3Rpb25OdW1iZXIiLCJsYXN0VHJhbnNhY3Rpb25OdW1iZXIiLCJsYXN0U25hcHNob3QiLCJiaW5kIiwid2F0Y2giLCJuZXh0RWRpdG9yIiwiZm4iLCJjdXJyZW50RWRpdG9yIiwib24iLCJvZmYiLCJ1c2VFZGl0b3JTdGF0ZSIsImVkaXRvclN0YXRlTWFuYWdlciIsInNlbGVjdGVkU3RhdGUiLCJzZWxlY3RvciIsImVxdWFsaXR5Rm4iLCJpc0RldiIsInByb2Nlc3MiLCJpc1NTUiIsImlzTmV4dCIsIndpbmRvdyIsIm5leHQiLCJFZGl0b3JJbnN0YW5jZU1hbmFnZXIiLCJfRWRpdG9ySW5zdGFuY2VNYW5hZ2VyIiwic3Vic2NyaXB0aW9ucyIsImlzQ29tcG9uZW50TW91bnRlZCIsInByZXZpb3VzRGVwcyIsImluc3RhbmNlSWQiLCJzZXRFZGl0b3IiLCJnZXRJbml0aWFsRWRpdG9yIiwic2NoZWR1bGVEZXN0cm95IiwiZ2V0RWRpdG9yIiwicmVmcmVzaEVkaXRvckluc3RhbmNlIiwib25SZW5kZXIiLCJjcmVhdGVFZGl0b3IiLCJzbGljZSIsImNiIiwiaW1tZWRpYXRlbHlSZW5kZXIiLCJFcnJvciIsIm9wdGlvbnNUb0FwcGx5Iiwib25CZWZvcmVDcmVhdGUiLCJhcmdzIiwiX2IiLCJjYWxsIiwib25CbHVyIiwib25DcmVhdGUiLCJvbkRlc3Ryb3kiLCJvbkZvY3VzIiwib25TZWxlY3Rpb25VcGRhdGUiLCJvblRyYW5zYWN0aW9uIiwib25VcGRhdGUiLCJvbkNvbnRlbnRFcnJvciIsIm9uRHJvcCIsIm9uUGFzdGUiLCJvbkRlbGV0ZSIsIm9uU3RvcmVDaGFuZ2UiLCJjb21wYXJlT3B0aW9ucyIsImEiLCJiIiwia2V5cyIsImV2ZXJ5IiwiaW5jbHVkZXMiLCJleHRlbnNpb25zIiwibGVuZ3RoIiwiZXh0ZW5zaW9uIiwiaW5kZXgiLCJkZXBzIiwiY2xlYXJUaW1lb3V0Iiwic2NoZWR1bGVkRGVzdHJ1Y3Rpb25UaW1lb3V0IiwiZWRpdGFibGUiLCJpc0VkaXRhYmxlIiwiZGVwc0FyZUVxdWFsIiwiZGVwIiwiZGVzdHJveSIsImN1cnJlbnRJbnN0YW5jZUlkIiwic2V0VGltZW91dCIsInVzZUVkaXRvciIsIm1vc3RSZWNlbnRPcHRpb25zIiwiaW5zdGFuY2VNYW5hZ2VyIiwic2hvdWxkUmVyZW5kZXJPblRyYW5zYWN0aW9uIiwianN4MiIsImpzeHMyIiwiRWRpdG9yQ29udGV4dCIsIkVkaXRvckNvbnN1bWVyIiwiQ29uc3VtZXIiLCJ1c2VDdXJyZW50RWRpdG9yIiwiRWRpdG9yUHJvdmlkZXIiLCJzbG90QWZ0ZXIiLCJzbG90QmVmb3JlIiwiZWRpdG9yQ29udGFpbmVyUHJvcHMiLCJlZGl0b3JPcHRpb25zIiwiY29udGV4dFZhbHVlIiwiUHJvdmlkZXIiLCJ2YWx1ZSIsImNyZWF0ZUNvbnRleHQyIiwidXNlQ29udGV4dDIiLCJSZWFjdE5vZGVWaWV3Q29udGV4dCIsIm9uRHJhZ1N0YXJ0Iiwibm9kZVZpZXdDb250ZW50Q2hpbGRyZW4iLCJub2RlVmlld0NvbnRlbnRSZWYiLCJSZWFjdE5vZGVWaWV3Q29udGVudFByb3ZpZGVyIiwiY29udGVudCIsInVzZVJlYWN0Tm9kZVZpZXciLCJqc3gzIiwiTm9kZVZpZXdDb250ZW50IiwiYXMiLCJUYWciLCJzdHlsZSIsIndoaXRlU3BhY2UiLCJSZWFjdDMiLCJqc3g0IiwiTm9kZVZpZXdXcmFwcGVyIiwiTWFya1ZpZXciLCJSZWFjdDQiLCJ2ZXJzaW9uIiwicmVhY3RWZXJzaW9uIiwiZmx1c2hTeW5jIiwianN4NSIsImlzQ2xhc3NDb21wb25lbnQiLCJwcm90b3R5cGUiLCJpc1JlYWN0Q29tcG9uZW50IiwiaXNGb3J3YXJkUmVmQ29tcG9uZW50IiwiJCR0eXBlb2YiLCJkZXNjcmlwdGlvbiIsImlzTWVtb0NvbXBvbmVudCIsImNhblJlY2VpdmVSZWYiLCJ3cmFwcGVkQ29tcG9uZW50IiwidHlwZSIsImlzUmVhY3QxOVBsdXMiLCJtYWpvclZlcnNpb24iLCJwYXJzZUludCIsInNwbGl0IiwiUmVhY3RSZW5kZXJlciIsImNvbXBvbmVudCIsImNsYXNzTmFtZSIsImNsYXNzTGlzdCIsImlzSW5pdGlhbGl6ZWQiLCJxdWV1ZU1pY3JvdGFzayIsImlzUmVhY3QxOSIsImNvbXBvbmVudENhblJlY2VpdmVSZWYiLCJlbGVtZW50UHJvcHMiLCJ1cGRhdGVQcm9wcyIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsInVwZGF0ZUF0dHJpYnV0ZXMiLCJhdHRyaWJ1dGVzIiwic2V0QXR0cmlidXRlIiwianN4NiIsIlJlYWN0TWFya1ZpZXdDb250ZXh0IiwibWFya1ZpZXdDb250ZW50UmVmIiwiTWFya1ZpZXdDb250ZW50IiwiUmVhY3RNYXJrVmlldyIsImF0dHJzIiwiY29tcG9uZW50UHJvcHMiLCJjb250ZW50RE9NRWxlbWVudCIsImVsIiwiY29udGFpbnMiLCJhcHBlbmRDaGlsZCIsImNvbnRleHQiLCJSZWFjdE1hcmtWaWV3UHJvdmlkZXIiLCJjb21wb25lbnRQcm9wczIiLCJkaXNwbGF5TmFtZSIsIm1hcmsiLCJuYW1lIiwidHJpbSIsImNvbnRlbnRET00iLCJSZWFjdE1hcmtWaWV3UmVuZGVyZXIiLCJnZXRSZW5kZXJlZEF0dHJpYnV0ZXMiLCJOb2RlVmlldyIsImNyZWF0ZUVsZW1lbnQyIiwianN4NyIsIlJlYWN0Tm9kZVZpZXciLCJzZWxlY3Rpb25SYWZJZCIsImlzTGVhZiIsImNvbnRlbnRET01FbGVtZW50VGFnIiwiaXNJbmxpbmUiLCJkYXRhc2V0Iiwibm9kZVZpZXdDb250ZW50UmVhY3QiLCJub2RlVmlld1dyYXBwZXIiLCJjb250ZW50VGFyZ2V0IiwicXVlcnlTZWxlY3RvciIsIm1vdW50IiwiZGVjb3JhdGlvbnMiLCJpbm5lckRlY29yYXRpb25zIiwic2VsZWN0ZWQiLCJIVE1MQXR0cmlidXRlcyIsImdldFBvcyIsImRlbGV0ZU5vZGUiLCJjYXBpdGFsaXplRmlyc3RDaGFyIiwic3RyaW5nIiwiY2hhckF0IiwidG9VcHBlckNhc2UiLCJzdWJzdHJpbmciLCJoYXNBdHRyaWJ1dGUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJSZWFjdE5vZGVWaWV3UHJvdmlkZXIiLCJoYW5kbGVTZWxlY3Rpb25VcGRhdGUiLCJ1cGRhdGVFbGVtZW50QXR0cmlidXRlcyIsImZpcnN0RWxlbWVudENoaWxkIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJmcm9tIiwidG8iLCJzZWxlY3Rpb24iLCJwb3MiLCJub2RlU2l6ZSIsInNlbGVjdE5vZGUiLCJkZXNlbGVjdE5vZGUiLCJ1cGRhdGUiLCJyZXJlbmRlckNvbXBvbmVudCIsIm9sZE5vZGUiLCJvbGREZWNvcmF0aW9ucyIsIm9sZElubmVyRGVjb3JhdGlvbnMiLCJuZXdOb2RlIiwibmV3RGVjb3JhdGlvbnMiLCJyZW1vdmUiLCJhdHRyc09iaiIsImV4dGVuc2lvbkF0dHJpYnV0ZXMiLCJleHRlbnNpb25NYW5hZ2VyIiwiUmVhY3ROb2RlVmlld1JlbmRlcmVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/react/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/starter-kit/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@tiptap/starter-kit/dist/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StarterKit: () => (/* binding */ StarterKit),\n/* harmony export */   \"default\": () => (/* binding */ index_default)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_extension_blockquote__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/extension-blockquote */ \"(ssr)/./node_modules/@tiptap/extension-blockquote/dist/index.js\");\n/* harmony import */ var _tiptap_extension_bold__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/extension-bold */ \"(ssr)/./node_modules/@tiptap/extension-bold/dist/index.js\");\n/* harmony import */ var _tiptap_extension_code__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tiptap/extension-code */ \"(ssr)/./node_modules/@tiptap/extension-code/dist/index.js\");\n/* harmony import */ var _tiptap_extension_code_block__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tiptap/extension-code-block */ \"(ssr)/./node_modules/@tiptap/extension-code-block/dist/index.js\");\n/* harmony import */ var _tiptap_extension_document__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tiptap/extension-document */ \"(ssr)/./node_modules/@tiptap/extension-document/dist/index.js\");\n/* harmony import */ var _tiptap_extension_hard_break__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @tiptap/extension-hard-break */ \"(ssr)/./node_modules/@tiptap/extension-hard-break/dist/index.js\");\n/* harmony import */ var _tiptap_extension_heading__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @tiptap/extension-heading */ \"(ssr)/./node_modules/@tiptap/extension-heading/dist/index.js\");\n/* harmony import */ var _tiptap_extension_horizontal_rule__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @tiptap/extension-horizontal-rule */ \"(ssr)/./node_modules/@tiptap/extension-horizontal-rule/dist/index.js\");\n/* harmony import */ var _tiptap_extension_italic__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @tiptap/extension-italic */ \"(ssr)/./node_modules/@tiptap/extension-italic/dist/index.js\");\n/* harmony import */ var _tiptap_extension_link__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @tiptap/extension-link */ \"(ssr)/./node_modules/@tiptap/extension-link/dist/index.js\");\n/* harmony import */ var _tiptap_extension_list__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @tiptap/extension-list */ \"(ssr)/./node_modules/@tiptap/extension-list/dist/index.js\");\n/* harmony import */ var _tiptap_extension_paragraph__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @tiptap/extension-paragraph */ \"(ssr)/./node_modules/@tiptap/extension-paragraph/dist/index.js\");\n/* harmony import */ var _tiptap_extension_strike__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @tiptap/extension-strike */ \"(ssr)/./node_modules/@tiptap/extension-strike/dist/index.js\");\n/* harmony import */ var _tiptap_extension_text__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @tiptap/extension-text */ \"(ssr)/./node_modules/@tiptap/extension-text/dist/index.js\");\n/* harmony import */ var _tiptap_extension_underline__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @tiptap/extension-underline */ \"(ssr)/./node_modules/@tiptap/extension-underline/dist/index.js\");\n/* harmony import */ var _tiptap_extensions__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @tiptap/extensions */ \"(ssr)/./node_modules/@tiptap/extensions/dist/index.js\");\n// src/starter-kit.ts\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar StarterKit = _tiptap_core__WEBPACK_IMPORTED_MODULE_16__.Extension.create({\n    name: \"starterKit\",\n    addExtensions () {\n        var _a, _b, _c, _d;\n        const extensions = [];\n        if (this.options.bold !== false) {\n            extensions.push(_tiptap_extension_bold__WEBPACK_IMPORTED_MODULE_1__.Bold.configure(this.options.bold));\n        }\n        if (this.options.blockquote !== false) {\n            extensions.push(_tiptap_extension_blockquote__WEBPACK_IMPORTED_MODULE_0__.Blockquote.configure(this.options.blockquote));\n        }\n        if (this.options.bulletList !== false) {\n            extensions.push(_tiptap_extension_list__WEBPACK_IMPORTED_MODULE_10__.BulletList.configure(this.options.bulletList));\n        }\n        if (this.options.code !== false) {\n            extensions.push(_tiptap_extension_code__WEBPACK_IMPORTED_MODULE_2__.Code.configure(this.options.code));\n        }\n        if (this.options.codeBlock !== false) {\n            extensions.push(_tiptap_extension_code_block__WEBPACK_IMPORTED_MODULE_3__.CodeBlock.configure(this.options.codeBlock));\n        }\n        if (this.options.document !== false) {\n            extensions.push(_tiptap_extension_document__WEBPACK_IMPORTED_MODULE_4__.Document.configure(this.options.document));\n        }\n        if (this.options.dropcursor !== false) {\n            extensions.push(_tiptap_extensions__WEBPACK_IMPORTED_MODULE_15__.Dropcursor.configure(this.options.dropcursor));\n        }\n        if (this.options.gapcursor !== false) {\n            extensions.push(_tiptap_extensions__WEBPACK_IMPORTED_MODULE_15__.Gapcursor.configure(this.options.gapcursor));\n        }\n        if (this.options.hardBreak !== false) {\n            extensions.push(_tiptap_extension_hard_break__WEBPACK_IMPORTED_MODULE_5__.HardBreak.configure(this.options.hardBreak));\n        }\n        if (this.options.heading !== false) {\n            extensions.push(_tiptap_extension_heading__WEBPACK_IMPORTED_MODULE_6__.Heading.configure(this.options.heading));\n        }\n        if (this.options.undoRedo !== false) {\n            extensions.push(_tiptap_extensions__WEBPACK_IMPORTED_MODULE_15__.UndoRedo.configure(this.options.undoRedo));\n        }\n        if (this.options.horizontalRule !== false) {\n            extensions.push(_tiptap_extension_horizontal_rule__WEBPACK_IMPORTED_MODULE_7__.HorizontalRule.configure(this.options.horizontalRule));\n        }\n        if (this.options.italic !== false) {\n            extensions.push(_tiptap_extension_italic__WEBPACK_IMPORTED_MODULE_8__.Italic.configure(this.options.italic));\n        }\n        if (this.options.listItem !== false) {\n            extensions.push(_tiptap_extension_list__WEBPACK_IMPORTED_MODULE_10__.ListItem.configure(this.options.listItem));\n        }\n        if (this.options.listKeymap !== false) {\n            extensions.push(_tiptap_extension_list__WEBPACK_IMPORTED_MODULE_10__.ListKeymap.configure((_a = this.options) == null ? void 0 : _a.listKeymap));\n        }\n        if (this.options.link !== false) {\n            extensions.push(_tiptap_extension_link__WEBPACK_IMPORTED_MODULE_9__.Link.configure((_b = this.options) == null ? void 0 : _b.link));\n        }\n        if (this.options.orderedList !== false) {\n            extensions.push(_tiptap_extension_list__WEBPACK_IMPORTED_MODULE_10__.OrderedList.configure(this.options.orderedList));\n        }\n        if (this.options.paragraph !== false) {\n            extensions.push(_tiptap_extension_paragraph__WEBPACK_IMPORTED_MODULE_11__.Paragraph.configure(this.options.paragraph));\n        }\n        if (this.options.strike !== false) {\n            extensions.push(_tiptap_extension_strike__WEBPACK_IMPORTED_MODULE_12__.Strike.configure(this.options.strike));\n        }\n        if (this.options.text !== false) {\n            extensions.push(_tiptap_extension_text__WEBPACK_IMPORTED_MODULE_13__.Text.configure(this.options.text));\n        }\n        if (this.options.underline !== false) {\n            extensions.push(_tiptap_extension_underline__WEBPACK_IMPORTED_MODULE_14__.Underline.configure((_c = this.options) == null ? void 0 : _c.underline));\n        }\n        if (this.options.trailingNode !== false) {\n            extensions.push(_tiptap_extensions__WEBPACK_IMPORTED_MODULE_15__.TrailingNode.configure((_d = this.options) == null ? void 0 : _d.trailingNode));\n        }\n        return extensions;\n    }\n});\n// src/index.ts\nvar index_default = StarterKit;\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9zdGFydGVyLWtpdC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxxQkFBcUI7QUFDb0I7QUFDaUI7QUFDWjtBQUNBO0FBQ1c7QUFDSDtBQUNHO0FBQ0w7QUFDZTtBQUNqQjtBQUNKO0FBQ3lDO0FBQy9CO0FBQ047QUFDSjtBQUNVO0FBQzJCO0FBQ25GLElBQUl1QixhQUFhdkIsb0RBQVNBLENBQUN3QixNQUFNLENBQUM7SUFDaENDLE1BQU07SUFDTkM7UUFDRSxJQUFJQyxJQUFJQyxJQUFJQyxJQUFJQztRQUNoQixNQUFNQyxhQUFhLEVBQUU7UUFDckIsSUFBSSxJQUFJLENBQUNDLE9BQU8sQ0FBQ0MsSUFBSSxLQUFLLE9BQU87WUFDL0JGLFdBQVdHLElBQUksQ0FBQ2hDLHdEQUFJQSxDQUFDaUMsU0FBUyxDQUFDLElBQUksQ0FBQ0gsT0FBTyxDQUFDQyxJQUFJO1FBQ2xEO1FBQ0EsSUFBSSxJQUFJLENBQUNELE9BQU8sQ0FBQ0ksVUFBVSxLQUFLLE9BQU87WUFDckNMLFdBQVdHLElBQUksQ0FBQ2pDLG9FQUFVQSxDQUFDa0MsU0FBUyxDQUFDLElBQUksQ0FBQ0gsT0FBTyxDQUFDSSxVQUFVO1FBQzlEO1FBQ0EsSUFBSSxJQUFJLENBQUNKLE9BQU8sQ0FBQ0ssVUFBVSxLQUFLLE9BQU87WUFDckNOLFdBQVdHLElBQUksQ0FBQ3ZCLCtEQUFVQSxDQUFDd0IsU0FBUyxDQUFDLElBQUksQ0FBQ0gsT0FBTyxDQUFDSyxVQUFVO1FBQzlEO1FBQ0EsSUFBSSxJQUFJLENBQUNMLE9BQU8sQ0FBQ00sSUFBSSxLQUFLLE9BQU87WUFDL0JQLFdBQVdHLElBQUksQ0FBQy9CLHdEQUFJQSxDQUFDZ0MsU0FBUyxDQUFDLElBQUksQ0FBQ0gsT0FBTyxDQUFDTSxJQUFJO1FBQ2xEO1FBQ0EsSUFBSSxJQUFJLENBQUNOLE9BQU8sQ0FBQ08sU0FBUyxLQUFLLE9BQU87WUFDcENSLFdB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Q0FBQ0gsT0FBTyxDQUFDb0IsU0FBUztRQUM1RDtRQUNBLElBQUksSUFBSSxDQUFDcEIsT0FBTyxDQUFDcUIsTUFBTSxLQUFLLE9BQU87WUFDakN0QixXQUFXRyxJQUFJLENBQUNsQiw2REFBTUEsQ0FBQ21CLFNBQVMsQ0FBQyxJQUFJLENBQUNILE9BQU8sQ0FBQ3FCLE1BQU07UUFDdEQ7UUFDQSxJQUFJLElBQUksQ0FBQ3JCLE9BQU8sQ0FBQ3NCLElBQUksS0FBSyxPQUFPO1lBQy9CdkIsV0FBV0csSUFBSSxDQUFDakIseURBQUlBLENBQUNrQixTQUFTLENBQUMsSUFBSSxDQUFDSCxPQUFPLENBQUNzQixJQUFJO1FBQ2xEO1FBQ0EsSUFBSSxJQUFJLENBQUN0QixPQUFPLENBQUN1QixTQUFTLEtBQUssT0FBTztZQUNwQ3hCLFdBQVdHLElBQUksQ0FBQ2hCLG1FQUFTQSxDQUFDaUIsU0FBUyxDQUFDLENBQUNOLEtBQUssSUFBSSxDQUFDRyxPQUFPLEtBQUssT0FBTyxLQUFLLElBQUlILEdBQUcwQixTQUFTO1FBQ3pGO1FBQ0EsSUFBSSxJQUFJLENBQUN2QixPQUFPLENBQUN3QixZQUFZLEtBQUssT0FBTztZQUN2Q3pCLFdBQVdHLElBQUksQ0FBQ2IsNkRBQVlBLENBQUNjLFNBQVMsQ0FBQyxDQUFDTCxLQUFLLElBQUksQ0FBQ0UsT0FBTyxLQUFLLE9BQU8sS0FBSyxJQUFJRixHQUFHMEIsWUFBWTtRQUMvRjtRQUNBLE9BQU96QjtJQUNUO0FBQ0Y7QUFFQSxlQUFlO0FBQ2YsSUFBSTBCLGdCQUFnQmxDO0FBSWxCLENBQ0YsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJhc29icGFpLXdlYi8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL3N0YXJ0ZXIta2l0L2Rpc3QvaW5kZXguanM/OWRiZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvc3RhcnRlci1raXQudHNcbmltcG9ydCB7IEV4dGVuc2lvbiB9IGZyb20gXCJAdGlwdGFwL2NvcmVcIjtcbmltcG9ydCB7IEJsb2NrcXVvdGUgfSBmcm9tIFwiQHRpcHRhcC9leHRlbnNpb24tYmxvY2txdW90ZVwiO1xuaW1wb3J0IHsgQm9sZCB9IGZyb20gXCJAdGlwdGFwL2V4dGVuc2lvbi1ib2xkXCI7XG5pbXBvcnQgeyBDb2RlIH0gZnJvbSBcIkB0aXB0YXAvZXh0ZW5zaW9uLWNvZGVcIjtcbmltcG9ydCB7IENvZGVCbG9jayB9IGZyb20gXCJAdGlwdGFwL2V4dGVuc2lvbi1jb2RlLWJsb2NrXCI7XG5pbXBvcnQgeyBEb2N1bWVudCB9IGZyb20gXCJAdGlwdGFwL2V4dGVuc2lvbi1kb2N1bWVudFwiO1xuaW1wb3J0IHsgSGFyZEJyZWFrIH0gZnJvbSBcIkB0aXB0YXAvZXh0ZW5zaW9uLWhhcmQtYnJlYWtcIjtcbmltcG9ydCB7IEhlYWRpbmcgfSBmcm9tIFwiQHRpcHRhcC9leHRlbnNpb24taGVhZGluZ1wiO1xuaW1wb3J0IHsgSG9yaXpvbnRhbFJ1bGUgfSBmcm9tIFwiQHRpcHRhcC9leHRlbnNpb24taG9yaXpvbnRhbC1ydWxlXCI7XG5pbXBvcnQgeyBJdGFsaWMgfSBmcm9tIFwiQHRpcHRhcC9leHRlbnNpb24taXRhbGljXCI7XG5pbXBvcnQgeyBMaW5rIH0gZnJvbSBcIkB0aXB0YXAvZXh0ZW5zaW9uLWxpbmtcIjtcbmltcG9ydCB7IEJ1bGxldExpc3QsIExpc3RJdGVtLCBMaXN0S2V5bWFwLCBPcmRlcmVkTGlzdCB9IGZyb20gXCJAdGlwdGFwL2V4dGVuc2lvbi1saXN0XCI7XG5pbXBvcnQgeyBQYXJhZ3JhcGggfSBmcm9tIFwiQHRpcHRhcC9leHRlbnNpb24tcGFyYWdyYXBoXCI7XG5pbXBvcnQgeyBTdHJpa2UgfSBmcm9tIFwiQHRpcHRhcC9leHRlbnNpb24tc3RyaWtlXCI7XG5pbXBvcnQgeyBUZXh0IH0gZnJvbSBcIkB0aXB0YXAvZXh0ZW5zaW9uLXRleHRcIjtcbmltcG9ydCB7IFVuZGVybGluZSB9IGZyb20gXCJAdGlwdGFwL2V4dGVuc2lvbi11bmRlcmxpbmVcIjtcbmltcG9ydCB7IERyb3BjdXJzb3IsIEdhcGN1cnNvciwgVHJhaWxpbmdOb2RlLCBVbmRvUmVkbyB9IGZyb20gXCJAdGlwdGFwL2V4dGVuc2lvbnNcIjtcbnZhciBTdGFydGVyS2l0ID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gIG5hbWU6IFwic3RhcnRlcktpdFwiLFxuICBhZGRFeHRlbnNpb25zKCkge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICBjb25zdCBleHRlbnNpb25zID0gW107XG4gICAgaWYgKHRoaXMub3B0aW9ucy5ib2xkICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKEJvbGQuY29uZmlndXJlKHRoaXMub3B0aW9ucy5ib2xkKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuYmxvY2txdW90ZSAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuc2lvbnMucHVzaChCbG9ja3F1b3RlLmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnMuYmxvY2txdW90ZSkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmJ1bGxldExpc3QgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goQnVsbGV0TGlzdC5jb25maWd1cmUodGhpcy5vcHRpb25zLmJ1bGxldExpc3QpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5jb2RlICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKENvZGUuY29uZmlndXJlKHRoaXMub3B0aW9ucy5jb2RlKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuY29kZUJsb2NrICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKENvZGVCbG9jay5jb25maWd1cmUodGhpcy5vcHRpb25zLmNvZGVCbG9jaykpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmRvY3VtZW50ICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKERvY3VtZW50LmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnMuZG9jdW1lbnQpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5kcm9wY3Vyc29yICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKERyb3BjdXJzb3IuY29uZmlndXJlKHRoaXMub3B0aW9ucy5kcm9wY3Vyc29yKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuZ2FwY3Vyc29yICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKEdhcGN1cnNvci5jb25maWd1cmUodGhpcy5vcHRpb25zLmdhcGN1cnNvcikpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmhhcmRCcmVhayAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuc2lvbnMucHVzaChIYXJkQnJlYWsuY29uZmlndXJlKHRoaXMub3B0aW9ucy5oYXJkQnJlYWspKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5oZWFkaW5nICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKEhlYWRpbmcuY29uZmlndXJlKHRoaXMub3B0aW9ucy5oZWFkaW5nKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMudW5kb1JlZG8gIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goVW5kb1JlZG8uY29uZmlndXJlKHRoaXMub3B0aW9ucy51bmRvUmVkbykpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmhvcml6b250YWxSdWxlICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKEhvcml6b250YWxSdWxlLmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnMuaG9yaXpvbnRhbFJ1bGUpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5pdGFsaWMgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goSXRhbGljLmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnMuaXRhbGljKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMubGlzdEl0ZW0gIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goTGlzdEl0ZW0uY29uZmlndXJlKHRoaXMub3B0aW9ucy5saXN0SXRlbSkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmxpc3RLZXltYXAgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goTGlzdEtleW1hcC5jb25maWd1cmUoKF9hID0gdGhpcy5vcHRpb25zKSA9PSBudWxsID8gdm9pZCAwIDogX2EubGlzdEtleW1hcCkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmxpbmsgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goTGluay5jb25maWd1cmUoKF9iID0gdGhpcy5vcHRpb25zKSA9PSBudWxsID8gdm9pZCAwIDogX2IubGluaykpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLm9yZGVyZWRMaXN0ICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKE9yZGVyZWRMaXN0LmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnMub3JkZXJlZExpc3QpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5wYXJhZ3JhcGggIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goUGFyYWdyYXBoLmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnMucGFyYWdyYXBoKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuc3RyaWtlICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKFN0cmlrZS5jb25maWd1cmUodGhpcy5vcHRpb25zLnN0cmlrZSkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLnRleHQgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goVGV4dC5jb25maWd1cmUodGhpcy5vcHRpb25zLnRleHQpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy51bmRlcmxpbmUgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goVW5kZXJsaW5lLmNvbmZpZ3VyZSgoX2MgPSB0aGlzLm9wdGlvbnMpID09IG51bGwgPyB2b2lkIDAgOiBfYy51bmRlcmxpbmUpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy50cmFpbGluZ05vZGUgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goVHJhaWxpbmdOb2RlLmNvbmZpZ3VyZSgoX2QgPSB0aGlzLm9wdGlvbnMpID09IG51bGwgPyB2b2lkIDAgOiBfZC50cmFpbGluZ05vZGUpKTtcbiAgICB9XG4gICAgcmV0dXJuIGV4dGVuc2lvbnM7XG4gIH1cbn0pO1xuXG4vLyBzcmMvaW5kZXgudHNcbnZhciBpbmRleF9kZWZhdWx0ID0gU3RhcnRlcktpdDtcbmV4cG9ydCB7XG4gIFN0YXJ0ZXJLaXQsXG4gIGluZGV4X2RlZmF1bHQgYXMgZGVmYXVsdFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJFeHRlbnNpb24iLCJCbG9ja3F1b3RlIiwiQm9sZCIsIkNvZGUiLCJDb2RlQmxvY2siLCJEb2N1bWVudCIsIkhhcmRCcmVhayIsIkhlYWRpbmciLCJIb3Jpem9udGFsUnVsZSIsIkl0YWxpYyIsIkxpbmsiLCJCdWxsZXRMaXN0IiwiTGlzdEl0ZW0iLCJMaXN0S2V5bWFwIiwiT3JkZXJlZExpc3QiLCJQYXJhZ3JhcGgiLCJTdHJpa2UiLCJUZXh0IiwiVW5kZXJsaW5lIiwiRHJvcGN1cnNvciIsIkdhcGN1cnNvciIsIlRyYWlsaW5nTm9kZSIsIlVuZG9SZWRvIiwiU3RhcnRlcktpdCIsImNyZWF0ZSIsIm5hbWUiLCJhZGRFeHRlbnNpb25zIiwiX2EiLCJfYiIsIl9jIiwiX2QiLCJleHRlbnNpb25zIiwib3B0aW9ucyIsImJvbGQiLCJwdXNoIiwiY29uZmlndXJlIiwiYmxvY2txdW90ZSIsImJ1bGxldExpc3QiLCJjb2RlIiwiY29kZUJsb2NrIiwiZG9jdW1lbnQiLCJkcm9wY3Vyc29yIiwiZ2FwY3Vyc29yIiwiaGFyZEJyZWFrIiwiaGVhZGluZyIsInVuZG9SZWRvIiwiaG9yaXpvbnRhbFJ1bGUiLCJpdGFsaWMiLCJsaXN0SXRlbSIsImxpc3RLZXltYXAiLCJsaW5rIiwib3JkZXJlZExpc3QiLCJwYXJhZ3JhcGgiLCJzdHJpa2UiLCJ0ZXh0IiwidW5kZXJsaW5lIiwidHJhaWxpbmdOb2RlIiwiaW5kZXhfZGVmYXVsdCIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/starter-kit/dist/index.js\n");

/***/ })

};
;